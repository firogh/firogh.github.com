<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Cs on f(x) </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://firoyang.org/cs/</link>
    <language>en-us</language>
    <author>Firo Yang</author>
    
    <updated>Sat, 05 Dec 2015 14:06:29 CST</updated>
    
    <item>
      <title>Console and TTY</title>
      <link>http://firoyang.org/cs/console/</link>
      <pubDate>Sat, 05 Dec 2015 14:06:29 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/console/</guid>
      <description>

&lt;p&gt;343 line&lt;br /&gt;
1. /dev/console 指向正在运行的tty 和tty0 一样ttyN not pts, console 佬变.&lt;br /&gt;
2. /dev/tty 一直指向所在的那个不变.&lt;/p&gt;

&lt;h1 id=&#34;about-the-design&#34;&gt;About the design&lt;/h1&gt;

&lt;p&gt;Why dose we use /dev/xxx to represent the &amp;ldquo;tty&amp;rdquo; device?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The whole point with &amp;ldquo;everything is a file&amp;rdquo; is not that you have some random filename (indeed, sockets and pipes show that &amp;ldquo;file&amp;rdquo; and &amp;ldquo;filename&amp;rdquo;&amp;gt; have nothing to do with each other), but the fact that you can use common tools to operate on different things. &amp;ndash; Linus&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So we got the key point!&lt;br /&gt;
In order to use the common tools, file ops and vfs layer, the tty device is &amp;ldquo;abstructed&amp;rdquo; to&lt;br /&gt;
files by us. Addnationaly, we must assurance that is the files is &lt;em&gt;different&lt;/em&gt;. What does&lt;br /&gt;
the word &amp;ldquo;dirrerent&amp;rdquo; means is not that you have some random different filename, but the&lt;br /&gt;
fact that you can access the real device through the different.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Wikipedia:&lt;br /&gt;
In mathematics, injections, surjections and bijections are classes of functions distinguished by the manner in which arguments (input expression&amp;gt; s from the domain) and images (output expressions from the codomain) are related or mapped to each other.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I got an insight that abstruction is a non-injective, right?&lt;br /&gt;
But non-injective may not be a anstruction.&lt;br /&gt;
An asbstruction should come from manipulating different objects.&lt;br /&gt;
Non-injective, 多对一; Multiplex, 一对多.&lt;br /&gt;
So we can use mathematical language to describe the linux subsystem.&lt;br /&gt;
From real life device to a filesystem file.&lt;br /&gt;
* Abstruction: Non-injective, Multiplex(not partial function).&lt;br /&gt;
* Jection num: injective, or non-jective, or multiplex; Jection level: domain set and codoain set!&lt;br /&gt;
Abstruction -&amp;gt; Control abstruction and data abstruction -&amp;gt; Abstruction layer&lt;/p&gt;

&lt;p&gt;软件设计的两个主要目的.&lt;br /&gt;
1. 简化, 易用,易操作, 如computer architecture, tty subsystem. 抽象.&lt;br /&gt;
2. Separation of concerns, modular(abstruciton in layer), 笛卡尔划分的思想&lt;/p&gt;

&lt;h1 id=&#34;tty-struct-disc-data&#34;&gt;tty_struct-&amp;gt;disc_data&lt;/h1&gt;

&lt;p&gt;tty_init_dev-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    initialize_tty_struct-&amp;gt;tty_ldisc_init&lt;br /&gt;
    tty_ldisc_setup-&amp;gt;tty_ldisc_open-&amp;gt;n_tty_open-&amp;gt; tty-&amp;gt;disc_data = ldata;&lt;br /&gt;
}&lt;br /&gt;
sys_vhangup-&amp;gt;tty_vhangup_self-&amp;gt;__tty_hangup-&amp;gt;tty_ldisc_hangup-&amp;gt;tty_ldisc_reinit&lt;br /&gt;
vfs_write-&amp;gt;redirected_tty_write-&amp;gt;tty_write-&amp;gt;n_tty_write-&amp;gt;process_output&lt;/p&gt;

&lt;h1 id=&#34;early-con&#34;&gt;early_con&lt;/h1&gt;

&lt;p&gt;EARLYCON_DECLARE(uart8250, early_serial8250_setup); EARLYCON_DECLARE(uart, early_serial8250_setup);&lt;br /&gt;
setup_earlycon-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    parse_options-&amp;gt;&lt;br /&gt;
    {&lt;br /&gt;
        parse earlycon_device-&amp;gt;port-&amp;gt;uartclk and&lt;br /&gt;
        earlycon_device-&amp;gt;baud&lt;br /&gt;
    }&lt;br /&gt;
    setup = early_serial8250_setup-&amp;gt; init_port(device);&lt;br /&gt;
    register_console(early_console_dev.con)&lt;br /&gt;
}&lt;/p&gt;

&lt;h1 id=&#34;earlyprintk&#34;&gt;earlyprintk&lt;/h1&gt;

&lt;p&gt;early_param(&amp;ldquo;earlyprintk&amp;rdquo;, setup_early_printk)-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    early_serial_init-&amp;gt;&lt;br /&gt;
    {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;}
early_console_register(&amp;amp;early_serial_console, keep);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;h1 id=&#34;cpu-hotplug&#34;&gt;cpu hotplug&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;onset&lt;br /&gt;
static struct smp_hotplug_thread softirq_threads {&lt;br /&gt;
.thread_fn              = run_ksoftirqd&lt;br /&gt;
};&lt;br /&gt;
early_initcall(spawn_ksoftirqd)-&amp;gt;mpboot_register_percpu_thread(&amp;amp;softirq_threads)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;nucles onset&lt;br /&gt;
suspend_enter-&amp;gt;enable_nonboot_cpus-&amp;gt;_cpu_up-&amp;gt;smpboot_create_threads-&amp;gt;&lt;strong&gt;smpboot_create_thread(&amp;amp;hotplug_threads)-&amp;gt;&lt;br /&gt;
kthread_create_on_cpu(smpboot_thread_fn-&amp;gt; ht-&amp;gt;thread_fn(td-&amp;gt;cpu)= run_ksoftirqd-&amp;gt;&lt;/strong&gt;do_softirq-&amp;gt;h-&amp;gt;action(h) = run_timer_softirq-&amp;gt;&lt;br /&gt;
__run_timers-&amp;gt;call_timer_fn)&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;vt 就是个tty也有tty_driver 叫console_driver.&lt;/p&gt;

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;h1 id=&#34;contents&#34;&gt;Contents&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://superuser.com/questions/144666/what-is-the-difference-between-shell-console-and-terminal&#34;&gt;What is the difference between shell, console, and terminal?&lt;/a&gt;&lt;br /&gt;
What does console do in kernel or u-boot?&lt;br /&gt;
Linux console?&lt;br /&gt;
Computer terminal: keyboard + dispaly&lt;br /&gt;
Terminal emulator:&lt;/p&gt;

&lt;h1 id=&#34;get-a-glance-on-u-boot&#34;&gt;get a glance on u-boot&lt;/h1&gt;

&lt;p&gt;start.S:board_init_r&lt;br /&gt;
init_sequence_f: -&amp;gt;init_baud_rate; serial_init; console_init_f&lt;br /&gt;
serial_init -&amp;gt;&amp;amp;eserial1_device-&amp;gt;start=eserial##port##_init-&amp;gt;NS16550_init: UART divisor init.&lt;br /&gt;
Firstly, the struct of serial define some input and output funtion.&lt;br /&gt;
It&amp;rsquo;s basic function of serial, put or get!&lt;br /&gt;
console_init_f: just gd-&amp;gt;have_console = 1;&lt;br /&gt;
init_sequence_r: stdio_init_tables,initr_serial, stdio_add_devices, console_init_r,&lt;br /&gt;
initr_serial: just register &amp;amp;eserial1_device to serial_devices&lt;br /&gt;
stdio_add_devices: drv_system_init, serial_stdio_init&lt;br /&gt;
drv_system_init: register default serial dev to devs.list.&lt;br /&gt;
serial_stdio_init: register &amp;amp;eserial1_device to devs.list. Duplicate, but serial dev &amp;ldquo;eserial0&amp;rdquo;  and system &amp;ldquo;serial&amp;rdquo;.&lt;br /&gt;
console_init_r: console_doenv -&amp;gt;console_setfile:stdio_devices[file(0/1/2)] = dev; actually, dev is &amp;ldquo;serial&amp;rdquo;, but they may be KBD!&lt;br /&gt;
看来console的真正作用就是在serial和kbd中选择一个, 可能多选iomux?&lt;br /&gt;
main_loop:cli_loop: getc!&lt;/p&gt;

&lt;h1 id=&#34;what-is-platform-device-or-driver&#34;&gt;what is platform device or driver?&lt;/h1&gt;

&lt;h1 id=&#34;a-reallife-serial8250&#34;&gt;A reallife serial8250&lt;/h1&gt;

&lt;p&gt;drivers/tty/serial/8250/8250_boca.c:plat_serial8250_port&lt;br /&gt;
module_init-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    serial8250_init-&amp;gt;serial8250_isa_init_ports-&amp;gt;serial8250_ports[i].port.ops = &amp;amp;serial8250_pops; //insidious&lt;br /&gt;
    boca_init-&amp;gt;platform_device_register(&amp;amp;boca_device); //register platform device and data.&lt;br /&gt;
}&lt;br /&gt;
* uart_port-&amp;gt;tty_port&lt;/p&gt;

&lt;p&gt;serial8250_probe(plat_serial8250_port)-&amp;gt;serial8250_register_8250_port(uart_8250_port)-&amp;gt;&lt;br /&gt;
uart_add_one_port(&amp;amp;serial8250_reg, &amp;amp;uart-&amp;gt;port=uart_port)-&amp;gt;&lt;br /&gt;
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uart_configure_port-&amp;gt;
{
    port-&amp;gt;ops-&amp;gt;config_port(port, flags)=serial8250_config_port
    if post is console and not registered; register!
    we know that uport-&amp;gt;cons = drv-&amp;gt;cons; what is the relation to registering about up-&amp;gt;cons.
    why we register it? where does drv-&amp;gt;cons come from?
    //这个uart_driver drv就是serial8250_reg, 我们也就知道了
    // console是设备的一种天生能力. 能否使用, 只关乎你是否想用, 就是配置相关的config SERIAL8250_CONSOLE
    // con_driver is the backends, vga, dummy/serial?, fb. 
}
tty_port_register_device_attr-&amp;gt;
{
    //tty_driver  tty_port
    tty_port_link_device
    tty_register_device_attr
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;h1 id=&#34;simple-conceptions&#34;&gt;Simple conceptions&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.linusakesson.net/programming/tty/&#34;&gt;You must read this -&amp;gt; The TTY demystified&lt;/a&gt;&lt;br /&gt;
System consoles are generalized to computer terminals, which are abstracted respectively by virtual consoles and terminal emulators.&lt;br /&gt;
        UART&lt;br /&gt;
        Line displine + TTY(pts, dummy/serial, kbd+vga/fb)&lt;br /&gt;
* System console&lt;br /&gt;
Virtual termial, Terminal emulator/telnet/ssh -&amp;gt; pts ,Physical terminal&lt;br /&gt;
You need at least one virtual terminal device in order to make use of your keyboard and monitor.&lt;br /&gt;
VT combine keyboard and display see con_init&lt;br /&gt;
con_init init a virtual terminal like gnome-terminal but in kernel.&lt;br /&gt;
con_init mainly init display.&lt;br /&gt;
vty_init mainly init kbd&lt;br /&gt;
They all can be system console.(Exception pts??), if you enable it.&lt;br /&gt;
Console is the entry of linux system.&lt;br /&gt;
* Console driver &amp;ndash; banckends of  console&lt;br /&gt;
struct console 指定了console的结构.&lt;br /&gt;
* Console config&lt;br /&gt;
If I disable CONFIG_SERIAL8250_CONSOLE(enable vt console), then no booting log and I can not login system.&lt;br /&gt;
If I disable CONFIG_VT_CONSOLE(enable serail console, /dev/console point to ttyS0 see show_cons_active), no booting log but I can lgin system.&lt;br /&gt;
How to explain this phenomena?&lt;br /&gt;
From show_cons_active, we know /dev/console should come from console_drivers.&lt;br /&gt;
/dev/console is really the pointer.&lt;br /&gt;
Now, let&amp;rsquo;s inspect open /dev/console.&lt;br /&gt;
* Open /dev/console&lt;br /&gt;
Fisrt, it&amp;rsquo;s the very last place of booting kernel.&lt;br /&gt;
start_kernel-&amp;gt;rest_init-&amp;gt;kernel_init-&amp;gt;kernel_init_freeable-&amp;gt;sys_open((const char __user *) &amp;ldquo;/dev/console&amp;rdquo;, O_RDWR, 0)-&amp;gt;&amp;hellip;-&amp;gt;&lt;br /&gt;
console_fops-&amp;gt;tty_open-&amp;gt;&lt;br /&gt;
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Sitiuations: disbale VT CONSOLE byt enable SERIAL8250_CONSOLE.
// This function work only for /dev/tty
// ls -l /dev/tty
// crw-rw-rw- 1 root tty 5, 0 Dec 10 10:24 /dev/tty
tty_open_current_tty-&amp;gt;
{
    /dev/console is 5:1, just return NULL
}
//This index should be Ctrl + Alt + Fn??
// tty_struct is corresponding virtual console, or just console??
// lookup tty_driver. It looks like lookup a inode, right?
tty_lookup_driver-&amp;gt;
{
    // Find a tty_driver by device() in console_drivers.
    // So we know, got a console, then got a tty_driver, right?
    // Where do the components of console_drivers come form?
    // At present, we should have only serial8250_console because 
    // console vt_console_driver is disabled by us! But tty_driver console_driver
    // still do exist!So console and tty is really separated!
    // When we init vt, we get the tty_driver console_driver with con_ops type of tty_operations.
    // tty_drivers have the same major with /dev/tty0!
    // char_dev -&amp;gt; tty_driver int vty_init, not disable.
    // vt console---^
    console_device-&amp;gt;c-&amp;gt;device(c, index)
    // What about serial8250_console?
    // Where is the tty_driver of serial8250_console?
    // console-&amp;gt;data = uart_driver-&amp;gt;tty_driver.
    // We got another scene : uart-&amp;gt;tty
    // serial8250 console-&amp;gt;data-^
    // serial&#39;s tty_driver alloced in serial8250_init with uart_ops.
    // vt&#39;s tty_driver alloced in vty_init.
    // We summarize these:
    // uart_driver serial8250_reg &amp;lt;-&amp;gt;  vc dev or /dev/tty*
    // serial tty driver &amp;lt;-&amp;gt; vt tty driver 
    // fs:vty_init &amp;lt;-&amp;gt; module:serial8250_init
    // tty driver ops con_ops &amp;lt;-&amp;gt; uart_ops
    // vt use major to connect tty and  vc dev
    // serial use major and -&amp;gt; to connect tty and uart_driver
    // It seems that uart and tty has a strong relationship, yet vt.
    // Ok... we got tty driver.
    // If we disable vt console, then here is the serial8250 tty_driver.
}
// Lookup for tty_struct
tty_driver_lookup_tty -&amp;gt;
{
    //tty_struct is alloced in init function alloc_tty_driver.
    // ttys, termios, ports, cdevs.
    // ttys was used by tty_standard_install then tty_driver_install_tty 
    // then tty_init_dev then ok we return to tty open. So this is the start place.

    So we know tty_driver-&amp;gt;ttys[*] must be NULL.
}
tty_init_dev-&amp;gt;
{
    // tty_driver likes a process, ttys like the files, tty_struct like a file!
    // So we know a tty_struct is a tty file.
    // tty_driver much like a inode
    //So tty_struct-&amp;gt;ops = tty_driver-&amp;gt;ops = &amp;amp; uart_ops
    alloc_tty_struct-&amp;gt;tty-&amp;gt;ops = driver-&amp;gt;ops;
    tty_driver_install_tty(driver, tty_struct)-&amp;gt; tty_standard_install-&amp;gt;driver-&amp;gt;ttys[tty-&amp;gt;index] = tty;
}
// Ok... We got a tty_struct.
// Add /dev/console to tty_struct-&amp;gt;tty_files
tty_add_file
// At present, what have we done?
// open(/dev/console)-&amp;gt;console_drivers-&amp;gt;console-&amp;gt;tty_driver-&amp;gt;tty_struct, right?

tty-&amp;gt;ops-&amp;gt;open(tty, filp)-&amp;gt;//ops = &amp;amp;uart_ops
{
    uart_ops-&amp;gt;open = uart_open-&amp;gt;
    {
        uart-&amp;gt; tty struct
        struct uart_driver *drv = (struct uart_driver *)tty-&amp;gt;driver-&amp;gt;driver_state;
        struct uart_state *state = drv-&amp;gt;state + line; //uart_state
        tty-&amp;gt;driver_data = state;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
// At present, we understand the flow of open /dev/console to serial console&lt;/p&gt;

&lt;h1 id=&#34;what-about-opening-dev-console-to-vt-console&#34;&gt;What about opening /dev/console to vt console&lt;/h1&gt;

&lt;p&gt;sys_open(/dev/console)-&amp;gt; &amp;hellip; tty_open -&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    tty_lookup_driver-&amp;gt; get tty_driver=console_driver,&lt;br /&gt;
    Through the name console_driver, we know, vt tty_driver is the defaut driver of console!&lt;br /&gt;
    // 同时, 我们也应该知道所谓的kernel的system console 是你只要enable了先关的config CONFIG_VT_CONSOLE and CONFIG_SERIAL_8250_CONSOLE.&lt;br /&gt;
    // system console就有了, printk也就有了归处. In other words, you registered, you got printed&lt;br /&gt;
    // In theory, you should be able to input something, like sysrq, I maybe test tomorrow.&lt;br /&gt;
    // 那么在kernel_init中sys_open又是什么鬼呢?&lt;br /&gt;
    // dev/tty 是专门真对进程的, 就是进程之前打开了一个tty就存在singnal里, 这个dev/tty就是取出来的.&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;h1 id=&#34;总结下-打开-dev-console-会从console-drivers-最终到达tty-driver&#34;&gt;总结下, 打开/dev/console, 会从console_drivers, 最终到达tty_driver.&lt;/h1&gt;

&lt;h1 id=&#34;这和-dev-tty-dev-ttys-从tty-drivers-差不多&#34;&gt;这和/dev/tty* /dev/ttyS* 从tty_drivers, 差不多.&lt;/h1&gt;

&lt;p&gt;// 这么输出为什么不会打窜了?&lt;br /&gt;
// How ctrl alt Fn work?&lt;br /&gt;
// echo xxx /dev/tty in serial tty_lookup_driver&lt;br /&gt;
// 另一个问题, serial 的terminal?&lt;/p&gt;

&lt;h1 id=&#34;the-perspective&#34;&gt;The perspective&lt;/h1&gt;

&lt;p&gt;/dev/*&lt;br /&gt;
vfs&lt;br /&gt;
chrdev&lt;br /&gt;
tty_fops&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;gt;tty core&lt;br /&gt;
    ld_ops &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;&amp;gt; tty line discipline(for read, write)&lt;br /&gt;
tty_driver con_ops/uart_ops&amp;mdash;&amp;mdash;&amp;ndash;&amp;gt; tty driver and tty_operations&lt;br /&gt;
HW&lt;br /&gt;
There are three different types of tty drivers: console, serial port, and pty.&lt;br /&gt;
serial8250_default_handle_irq&lt;br /&gt;
UART console&lt;br /&gt;
              |&amp;mdash;- Virtual terminal &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; VT console&lt;br /&gt;
              |                 | &amp;ndash; VT console&lt;br /&gt;
              |&amp;mdash;-&lt;br /&gt;
        Terminal&amp;ndash;|&lt;br /&gt;
              |&amp;mdash;-&lt;/p&gt;

&lt;h1 id=&#34;what-about-console&#34;&gt;What about console?&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;early_con&lt;br /&gt;
start_kernel or setup_arch(arm)-&amp;gt;parse_early_param-&amp;gt;do_early_param-&amp;gt;p-&amp;gt;setup_func()= setup_early_printk-&amp;gt;register_console&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;vga_con&lt;br /&gt;
start_kerenl-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
// All about vga console&lt;br /&gt;
set_arch-&amp;gt; conswitchp = &amp;amp;vga_con; or conswitchp = &amp;amp;dummy_con;&lt;br /&gt;
console_init-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
        tty_ldisc_begin-&amp;gt;tty_register_ldisc(N_TTY, &amp;amp;tty_ldisc_N_TTY);&lt;br /&gt;
    console_initcall(con_init);&lt;br /&gt;
console_initcall(serial8250_console_init)&lt;br /&gt;
    con_init-&amp;gt;&lt;br /&gt;
    {&lt;br /&gt;
        // vc-&amp;gt;vc_sw-&amp;gt;con_putcs is DUMMY&lt;br /&gt;
        //内存映射64KB or 32KB的VGA区域. 启动VGA&lt;br /&gt;
        conswitchp-&amp;gt;con_startup = vgacon_startup -&amp;gt;vga_vram_base = VGA_MAP_MEM(vga_vram_base, vga_vram_size);&lt;br /&gt;
        con_driver_map[0~MAX_NR_CONSOLES] = conswitchp; //空间换时间&lt;br /&gt;
        // 核心内容!&lt;br /&gt;
        for (currcons = 0; currcons &amp;lt; MIN_NR_CONSOLES; currcons++) {&lt;br /&gt;
            // 给vc_cons[currcons].d分配内存&lt;br /&gt;
            vc_cons[currcons].d = vc = kzalloc(sizeof(struct vc_data), GFP_NOWAIT);&lt;br /&gt;
            INIT_WORK(&amp;amp;vc_cons[currcons].SAK_work, vc_SAK);&lt;br /&gt;
            //初始化vc_cons[currcons].d&lt;br /&gt;
            tty_port_init(&amp;amp;vc-&amp;gt;port);&lt;br /&gt;
            // 继续初始化, 主要是确定screenbuf size&lt;br /&gt;
            visual_init(vc, currcons, 1);&lt;br /&gt;
            // 给vc_screenbuf分配内存&lt;br /&gt;
            vc-&amp;gt;vc_screenbuf = kzalloc(vc-&amp;gt;vc_screenbuf_size, GFP_NOWAIT);&lt;br /&gt;
            vc_init(vc, vc-&amp;gt;vc_rows, vc-&amp;gt;vc_cols,&lt;br /&gt;
                currcons || !vc-&amp;gt;vc_sw-&amp;gt;con_save_screen);&lt;br /&gt;
        }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    [    0.000000] Console: colour VGA+ 80x25
    register_console(&amp;amp;vt_console_driver);//vt_console can use vgacon writing.
}
serial8250_console_init-&amp;gt;register_console(&amp;amp;serial8250_console) to console_drivers; exclusive_console.
[    0.000000] console [tty0] enabled
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
module_init(serial8250_init);??&lt;br /&gt;
}&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;fbcon&lt;br /&gt;
register_framebuffer-&amp;gt; do_take_over_console -&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
do_register_con_driver-&amp;gt;csw-&amp;gt;con_startup();registered_con_driver&lt;br /&gt;
do_bind_con_driver -&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    [    3.882220] Console: switching to colour dummy device 80x25&lt;br /&gt;
    [    4.720732] Console: switching to colour frame buffer device 170x48&lt;br /&gt;
}&lt;br /&gt;
}&lt;/p&gt;

&lt;h2 id=&#34;vga-text-console-printk-write&#34;&gt;VGA text console printk &amp;amp; write&lt;/h2&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;kernel space&lt;br /&gt;
printk-&amp;gt; &amp;hellip;-&amp;gt;log_buf&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;userspace for ttyN&lt;br /&gt;
tty_fops-&amp;gt;write=tty_write-&amp;gt; tty_ldisc_N_TTY-&amp;gt;write=n_tty_write-&amp;gt; tty_driver-&amp;gt;ops=con_ops-&amp;gt;write=con_write-&amp;gt;do_con_write&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;agent&lt;br /&gt;
console_drivers-&amp;gt;vt_console_driver-&amp;gt;serial8250_console-&amp;gt;NULL&lt;br /&gt;
console_unlock-&amp;gt;..-&amp;gt;__call_console_drivers-&amp;gt; console_drivers-&amp;gt;write = vt_console_print&lt;br /&gt;
{&lt;br /&gt;
//保存到screen buf, vga_con也什么不做啊.&lt;br /&gt;
scr_writew((vc-&amp;gt;vc_attr &amp;lt;&amp;lt; 8) + c, (unsigned short *)vc-&amp;gt;vc_pos);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;h1 id=&#34;what-about-tty&#34;&gt;What about tty&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;onset&lt;br /&gt;
console_init-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
tty_ldisc_begin-&amp;gt;tty_register_ldisc(N_TTY, &amp;amp;tty_ldisc_N_TTY);&lt;br /&gt;
console_initcall(con_init);&lt;br /&gt;
console_initcall(serial8250_console_init)&lt;br /&gt;
}&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;N_TTY:&lt;a href=&#34;http://www.linux.it/~rubini/docs/serial/serial.html&#34;&gt;Serial Drivers by Alessandro Rubini&lt;/a&gt;&lt;br /&gt;
fs_initcall:chr_dev_init-&amp;gt;drivers/tty/tty_io.c: tty_init-&amp;gt;&lt;br /&gt;
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* /dev/tty0 = /dev/console console_ops */
/* /dev/tty = the /dev/ttyN whererun echo /dev/tty tty_ops */

//&amp;quot;/dev/tty&amp;quot;,
cdev_init(&amp;amp;tty_cdev, &amp;amp;tty_fops);
&amp;quot;/dev/console&amp;quot;
cdev_init(&amp;amp;console_cdev, &amp;amp;console_fops);
vty_init-&amp;gt;
{
    //&amp;quot;dev/tty0&amp;quot;    
    cdev_init(&amp;amp;vc0_cdev, console_fops); 
    //&amp;quot;/dev/ttyN&amp;quot;
    tty_register_driver-&amp;gt;
    {
        // What does tty_register_driver do ?
        // Alloc and register chr dev region.
        // Add cdev with tty_ops and above region.
        // Register tty device
        // Why do we register tty devices?
        // These devices must be used in some place.
        // After registering itself, the driver registers the devices it controls through the tty_register_device function. 
        // 原来是把major 和minor做成dev_t放到driver-&amp;gt;cdevs[index].dev里面了.
        // 也就是说driver-&amp;gt;cdevs[index]就是tty driver控制的device啊, 怪不得cdev_init(&amp;amp;driver-&amp;gt;cdevs[index], &amp;amp;tty_fops);
        // 那么看来用到的时候就是open了, 竟然没有不过有个tty_get_device用了tty_class
        // tty_register_device_attr-&amp;gt;device_register-&amp;gt;device_add-&amp;gt;klist_add_tail(&amp;amp;dev-&amp;gt;knode_class,&amp;amp;dev-&amp;gt;class-&amp;gt;p-&amp;gt;klist_devices)
        // 果然是在open tty-&amp;gt;dev = tty_get_device(tty);在alloc_tty_struct
        // 不知道这个tty-&amp;gt;dev在哪里用, 不管他了.
        tty_register_device(_attr) -&amp;gt;tty_cdev_add-&amp;gt; cdev_init(&amp;amp;driver-&amp;gt;cdevs[index], &amp;amp;tty_fops);
    }
    kbd_init
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
device_init:serial8250_init-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    // In this function we decide &amp;ldquo;/dev/ttyS*&amp;rdquo;&lt;br /&gt;
    // dmesg |grep Serial&lt;br /&gt;
    // [    0.696341] Serial: &lt;sup&gt;8250&lt;/sup&gt;&amp;frasl;&lt;sub&gt;16550&lt;/sub&gt; driver, 32 ports, IRQ sharing enabled&lt;br /&gt;
    // serial8250.c -&amp;gt; tty_io.c&lt;br /&gt;
    serial8250_reg.nr = UART_NR;&lt;br /&gt;
    ret = uart_register_driver(&amp;amp;serial8250_reg);&lt;br /&gt;
    tty_driver set to uart_driver by uart_register_driver -&amp;gt;&lt;br /&gt;
    {&lt;br /&gt;
        drv-&amp;gt;state = kzalloc        //uart_state&lt;br /&gt;
        normal-&amp;gt;driver_state    = drv; //args struct uart_driver *drv = &amp;amp;serial8250_reg&lt;br /&gt;
        tty_set_operations(normal, &amp;amp;uart_ops);&lt;br /&gt;
        struct tty_port &lt;em&gt;port = &amp;amp;state-&amp;gt;port&lt;br /&gt;
        tty_port_init(port);&lt;br /&gt;
        port-&amp;gt;ops = &amp;amp;uart_port_ops; //tty_port&lt;br /&gt;
        // We register &amp;ldquo;/dev/ttyS&lt;/em&gt;&amp;rdquo; files here.&lt;br /&gt;
        static struct uart_driver serial8250_reg = {&lt;br /&gt;
            .owner                  = THIS_MODULE,&lt;br /&gt;
            .driver_name            = &amp;ldquo;serial&amp;rdquo;,&lt;br /&gt;
            .dev_name               = &amp;ldquo;ttyS&amp;rdquo;,&lt;br /&gt;
            .major                  = TTY_MAJOR,&lt;br /&gt;
            .minor                  = 64,&lt;br /&gt;
            .cons                   = SERIAL8250_CONSOLE,&lt;br /&gt;
        };&lt;br /&gt;
        retval = tty_register_driver(normal); -&amp;gt; register_chrdev_region(dev, driver-&amp;gt;num, driver-&amp;gt;name) //32, ttyS?*? should be tty_ops&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;}
serial8250_register_ports(&amp;amp;serial8250_reg, &amp;amp;serial8250_isa_devs-&amp;gt;dev);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
* nucleus&lt;br /&gt;
tty_write-&amp;gt;ld-&amp;gt;ops-&amp;gt;write=n_tty_write-&amp;gt;(tty_struct tty-&amp;gt;ops-&amp;gt;write)=uart_write-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    struct uart_state *state = tty-&amp;gt;driver_data;&lt;br /&gt;
    port = state-&amp;gt;uart_port;&lt;br /&gt;
    circ = &amp;amp;state-&amp;gt;xmit;&lt;br /&gt;
    memcpy(circ-&amp;gt;buf + circ-&amp;gt;head, buf, c);&lt;br /&gt;
    uart_start-&amp;gt;__uart_start-&amp;gt;(uart_port-&amp;gt;ops-&amp;gt;start_tx(port)); //&amp;amp;uart_port_ops ?? uart_ops??&lt;br /&gt;
}&lt;/p&gt;

&lt;h1 id=&#34;what-about-pseudoterminal&#34;&gt;What about Pseudoterminal&lt;/h1&gt;

&lt;p&gt;/dev/ptmx is the &amp;ldquo;pseudo-terminal master multiplexer&amp;rdquo;. from wikipedia&lt;br /&gt;
static struct tty_driver *ptm_driver;&lt;br /&gt;
static struct tty_driver *pts_driver;&lt;br /&gt;
module_init(pty_init)-&amp;gt;unix98_pty_init-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    tty_set_operations(ptm_driver, &amp;amp;ptm_unix98_ops);&lt;br /&gt;
    tty_register_driver(ptm_driver)&lt;br /&gt;
    tty_set_operations(pts_driver, &amp;amp;pty_unix98_ops);&lt;br /&gt;
    tty_register_driver(pts_driver)&lt;br /&gt;
    ptmx_fops = tty_fops;&lt;br /&gt;
    ptmx_fops.open = ptmx_open;&lt;br /&gt;
    cdev_init(&amp;amp;ptmx_cdev, &amp;amp;ptmx_fops);&lt;br /&gt;
}&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;How to use ptmx?&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;tty-drivers&#34;&gt;tty drivers&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;cat /proc/tty/drivers&lt;br /&gt;
/dev/tty             /dev/tty        5       0 system:/dev/tty&lt;br /&gt;
/dev/console         /dev/console    5       1 system:console&lt;br /&gt;
/dev/ptmx            /dev/ptmx       5       2 system&lt;br /&gt;
/dev/vc/0            /dev/vc/0       4       0 system:vtmaster&lt;br /&gt;
usbserial            /dev/ttyUSB   188 0-511 serial&lt;br /&gt;
serial               /dev/ttyS       4 64-95 serial&lt;br /&gt;
pty_slave            /dev/pts      136 0-1048575 pty:slave&lt;br /&gt;
pty_master           /dev/ptm      128 0-1048575 pty:master&lt;br /&gt;
unknown              /dev/tty        4 1-63 console&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;question&#34;&gt;Question?&lt;/h1&gt;

&lt;p&gt;what is /dev/vcs?&lt;/p&gt;

&lt;h1 id=&#34;backup&#34;&gt;Backup&lt;/h1&gt;

&lt;p&gt;./drivers//tty/vt/vt.c:3042:        register_chrdev_region(MKDEV(TTY_MAJOR, 0), 1, &amp;ldquo;/dev/vc/0&amp;rdquo;) &amp;lt; 0)&lt;br /&gt;
./drivers//tty/vt/vc_screen.c:644:  if (register_chrdev(VCS_MAJOR, &amp;ldquo;vcs&amp;rdquo;, &amp;amp;vcs_fops))&lt;br /&gt;
./drivers//tty/tty_io.c:3377:       error = register_chrdev_region(dev, driver-&amp;gt;num, driver-&amp;gt;name);&lt;br /&gt;
./drivers//tty/tty_io.c:3414:   unregister_chrdev_region(dev, driver-&amp;gt;num);&lt;br /&gt;
./drivers//tty/tty_io.c:3430:   unregister_chrdev_region(MKDEV(driver-&amp;gt;major, driver-&amp;gt;minor_start),&lt;br /&gt;
./drivers//tty/tty_io.c:3607:       register_chrdev_region(MKDEV(TTYAUX_MAJOR, 0), 1, &amp;ldquo;/dev/tty&amp;rdquo;) &amp;lt; 0)&lt;br /&gt;
./drivers//tty/tty_io.c:3613:       register_chrdev_region(MKDEV(TTYAUX_MAJOR, 1), 1, &amp;ldquo;/dev/console&amp;rdquo;) &amp;lt; 0)&lt;br /&gt;
./drivers//tty/pty.c:841:       register_chrdev_region(MKDEV(TTYAUX_MAJOR, 2), 1, &amp;ldquo;/dev/ptmx&amp;rdquo;) &amp;lt; 0)&lt;/p&gt;

&lt;h1 id=&#34;hugh-in-n-tty-write&#34;&gt;hugh in n_tty_write&lt;/h1&gt;

&lt;p&gt;uart_flush_buffer-&amp;gt; tty_wakeup&lt;br /&gt;
serial8250_handle_port-&amp;gt; transmit_chars&lt;br /&gt;
n_tty_read/poll-&amp;gt;input_available_p-&amp;gt;flush_to_ldisc-&amp;gt;n_tty_receive_buf-&amp;gt;uart_flush_chars&lt;br /&gt;
n_tty_write-&amp;gt;uart_flush_chars-&amp;gt;uart_start&lt;br /&gt;
n_tty_write-&amp;gt;uart_write-&amp;gt; uart_start-&amp;gt;start_tx -&amp;gt; serial8250_start_tx -&amp;gt; transmit_chars-&amp;gt;uart_write_wakeup -&amp;gt;uart_tasklet_action-&amp;gt;tty_wakeup&lt;/p&gt;

&lt;h1 id=&#34;echo-char&#34;&gt;Echo char&lt;/h1&gt;

&lt;p&gt;===serial chipset&lt;br /&gt;
serial8250_interrupt&lt;br /&gt;
seirial8250_handle_port&lt;br /&gt;
receive_chars&lt;/p&gt;

&lt;p&gt;===serial abstruction&lt;br /&gt;
uart_insert_char&lt;/p&gt;

&lt;p&gt;===terminal device&lt;br /&gt;
tty_insert_flip_char&lt;/p&gt;

&lt;p&gt;receive_chars-&amp;gt;tty_flip_buffer_push -&amp;gt;flush_to_ldisc-&amp;gt;&lt;br /&gt;
=== Line discipline&lt;br /&gt;
disc-&amp;gt;receive_buf=n_tty_receive_buf-&amp;gt;n_tty_receive_char-&amp;gt;echo_char&lt;/p&gt;

&lt;h1 id=&#34;uart-port&#34;&gt;uart_port&lt;/h1&gt;

&lt;p&gt;serial8250_register_ports&lt;br /&gt;
struct uart_8250_port *up = &amp;amp;serial8250_ports[i];&lt;br /&gt;
uart_add_one_port(drv, &amp;amp;up-&amp;gt;port);&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>System booting</title>
      <link>http://firoyang.org/cs/boot/</link>
      <pubDate>Thu, 12 Nov 2015 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/boot/</guid>
      <description>

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;h1 id=&#34;contents&#34;&gt;Contents&lt;/h1&gt;

&lt;p&gt;What basic initializations should be perfomed when power on?&lt;br /&gt;
How do we load the kernel to memory?&lt;br /&gt;
What does kernel do when kernel boot.&lt;br /&gt;
MBR vs BIOS?&lt;br /&gt;
PC vs embedded&lt;br /&gt;
Kernel init&lt;br /&gt;
before start_kernel&lt;br /&gt;
start_kernel&lt;br /&gt;
reset_init &amp;amp; kernel_init&lt;/p&gt;

&lt;h1 id=&#34;p4080-board&#34;&gt;p4080 Board&lt;/h1&gt;

&lt;p&gt;PBL&lt;br /&gt;
1. initialize I2C, SPI, eLBC, eSDHC.&lt;br /&gt;
2. Load RCW and boot init commands from above.&lt;br /&gt;
3. write date to conf register and memory&lt;/p&gt;

&lt;h1 id=&#34;config&#34;&gt;config&lt;/h1&gt;

&lt;p&gt;CCSRBAR -&amp;gt; CCSR&lt;br /&gt;
default is 0x0_FE00_0000&lt;br /&gt;
CCSRBAR is in CCSR memory. odd. stored in 0(CCSRBAR).&lt;br /&gt;
CCSRBAR always points to itself.&lt;br /&gt;
holdoff&lt;/p&gt;

&lt;h1 id=&#34;u-boot&#34;&gt;u-boot&lt;/h1&gt;

&lt;p&gt;ft_fixup_cpu -&amp;gt; determine_mp_bootpg(NULL) &amp;amp; fdt_add_mem_rsv&lt;/p&gt;

&lt;p&gt;main_loop-&amp;gt; &amp;hellip;-&amp;gt;./common/bootm_os.c:410:&amp;hellip; do_bootm_states-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
bootm_find_other-&amp;gt;bootm_find_ramdisk_fdt-&amp;gt;bootm_find_fdt-&amp;gt;boot_get_fdt&amp;amp;set_working_fdt_addr(0x0200000)-&amp;gt;IMAGE_FORMAT_FIT-&amp;gt;&lt;br /&gt;
&amp;amp;&lt;br /&gt;
boot_fn = bootm_os_get_boot_func(images-&amp;gt;os.os)=[IH_OS_LINUX] =&lt;br /&gt;
&amp;amp;&lt;br /&gt;
boot_selected_os-&amp;gt;boot_fn=do_bootm_linux-&amp;gt;boot_body_linux-&amp;gt;image_setup_linux-&amp;gt;image_setup_libfdt-&amp;gt;&lt;br /&gt;
board/freescale/corenet_ds/corenet_ds.c ft_board_setup-&amp;gt; ft_cpu_setup-&amp;gt;&lt;br /&gt;
}&lt;/p&gt;

&lt;h1 id=&#34;ppc-multicore-booting&#34;&gt;PPC multicore booting&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;There are two possibilites to make secondary cores booting failed.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;There is a bug in the code executed by Secondary cores&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;The spin table address, passed to croe0, is not correct, so we did not really kick the secondary cores.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CCSRBAR&lt;br /&gt;
MPC86xx_MCM_OFFSET&lt;br /&gt;
srio_boot_master_release_slave&lt;/p&gt;

&lt;p&gt;uboot-&amp;gt;&lt;br /&gt;
set the cpu-release-addr at funciton ft_fixup_cpu(), I am not sure.&lt;/p&gt;

&lt;p&gt;core0 run, 2nd cores holdoff&lt;br /&gt;
core0 set BPTR and kick(BRR) 2nd cores, 2nd cores spintable loop in uboot function setup_mp&lt;br /&gt;
core0 -&amp;gt; arch/powerpc/cpu/mpc85xx/start.S-&amp;gt;_start_e500&lt;br /&gt;
board_init_r-&amp;gt;cpu_init_r-&amp;gt; setup_mp-&amp;gt; {&lt;br /&gt;
&lt;strong&gt;bootpg_addr = (u32)virt_to_phys(&amp;amp;&lt;/strong&gt;second_half_boot_page); //Assembly code for put core to spin tablea. Used by __secondary_start_page&lt;br /&gt;
__spin_table_addr = (u32)get_spin_phys_addr();// used by __second_half_boot_page&lt;br /&gt;
bootpg = BPTR = __secondary_start_page&lt;br /&gt;
plat_mp_up-&amp;gt;kick BRR &amp;amp; Boot Space Translation&lt;br /&gt;
}&lt;br /&gt;
2nd cores holdoff -&amp;gt; &lt;strong&gt;secondary_start_page&lt;br /&gt;
kernel-&amp;gt;&lt;br /&gt;
core0 boot kernel, core0 kickoff 2nd cores spintable, triger 2nd core&amp;rsquo;s spin table by writing  the spin table field with the desired address&lt;br /&gt;
2nd cores ePAPR-&amp;gt;spintable-&amp;gt;addr_l=&lt;/strong&gt;early_start-&amp;gt;__secondary_start-&amp;gt;smp_ops-&amp;gt;setup_cpu-&amp;gt;cpu_idle&lt;br /&gt;
arch/powerpc/kernel/head_fsl_booke.S&lt;br /&gt;
U-boot logs:&lt;br /&gt;
Reserving MP boot page to 7ffff000^M^M - &amp;ndash;   -   MP spin table&lt;br /&gt;
address.&lt;br /&gt;
SPAG : fdt_fixup_fman_firmware, 567^M^M&lt;br /&gt;
^M^M&lt;br /&gt;
..r.^M^M&lt;br /&gt;
VDBG : ft_cpu_setup, 737, comment fdt_fixup_memory ^M^M&lt;br /&gt;
VDBG: Secondary cores are not held in reset.^M^M&lt;br /&gt;
Kernel Logs:&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 1 to ack^M^M&lt;br /&gt;
smp: failed starting cpu 1 (rc -2)^M^M&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 2 to ack^M^M&lt;br /&gt;
smp: failed starting cpu 2 (rc -2)^M^M&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 3 to ack^M^M&lt;br /&gt;
smp: failed starting cpu 3 (rc -2)^M^M&lt;br /&gt;
Brought up 1 CPUs^M^M&lt;br /&gt;
devtmpfs: initialized^M^M&lt;/p&gt;

&lt;p&gt;Note that u-boot can&amp;rsquo;t detect  memory above 2G and we need to check&lt;br /&gt;
if kernel is accessing at high mem of 2G or 4G.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Light camera action - compile link load</title>
      <link>http://firoyang.org/cs/cll/</link>
      <pubDate>Sun, 25 Oct 2015 01:46:28 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/cll/</guid>
      <description>

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.tenouk.com/ModuleW.html&#34;&gt;compiler, assembler, linker and loader: a brief story&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://a3f.at/lists/linkers&#34;&gt;Linkers 20 parts by Gold author Ian Lance Taylor&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://rickgray.me/2015/08/07/use-gdb-to-study-got-and-plt.html&#34;&gt;通过 GDB 调试理解 GOT/PLT&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html&#34;&gt;PLT and GOT - the key to code sharing and dynamic libraries&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;elf&#34;&gt;ELF&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.sco.com/developers/gabi/latest/contents.html&#34;&gt;System V Application Binary Interface ELF&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.sco.com/developers/devspecs/&#34;&gt;SCO Developer Specifications&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;function-call&#34;&gt;Function call&lt;/h1&gt;

&lt;p&gt;x86: stack and caller but kernel maybe regpara(3)&lt;/p&gt;

&lt;p&gt;create_elf_tables&lt;br /&gt;
sysdeps/x86_64/dl-machine.h: -&amp;gt; _start -&amp;gt;_dl_start-&amp;gt;/elf/dl-sysdep.c:83:_dl_sysdep_start-&amp;gt;dl_main&lt;br /&gt;
Relocation&lt;br /&gt;
PIC&lt;/p&gt;

&lt;h1 id=&#34;contents&#34;&gt;Contents&lt;/h1&gt;

&lt;p&gt;Why complier can manipulate the address of vriables?&lt;br /&gt;
What is the address in lds(??) file?&lt;/p&gt;

&lt;h2 id=&#34;kbuild&#34;&gt;kbuild&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;if no .config, every config tools make a .config from scrach!&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;oldconfig just for new moduels patch merged in trunk. This no any relations to .config.old and /boot/config.x.y.z&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;make localmodconfig will reduce many unused kernel config.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;make bzImage  #kmods will not build that configured with M!&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;make modules_install INSTALL_MOD_PATH=/home/firo/kmods&lt;br /&gt;
##build signle kernel module&lt;br /&gt;
make menuconfig&lt;br /&gt;
make oldconfig &amp;amp;&amp;amp; make prepare&lt;br /&gt;
make -C $(pwd) M=/home/firo/linux/fs/ext3 modules V=1&lt;br /&gt;
make ARCH=arm CROSS_COMPILE=/usr/bin/arm-linux-gnu- drivers/pcmcia/sa11xx_base.o&lt;/p&gt;

&lt;h1 id=&#34;compile-construction&#34;&gt;Compile construction&lt;/h1&gt;

&lt;p&gt;##&lt;a href=&#34;http://www.stlinux.com/devel/debug/jtag/build?q=node/82&#34;&gt;Generating optimized code&lt;/a&gt;&lt;br /&gt;
##Symbol table&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;System.map less&lt;br /&gt;
When you compile the kernel&lt;br /&gt;
nm vmlinux&lt;br /&gt;
readelf -s&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;/proc/kallsyms&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Computer architecture</title>
      <link>http://firoyang.org/cs/arch/</link>
      <pubDate>Tue, 13 Oct 2015 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/arch/</guid>
      <description>

&lt;p&gt;##Reference&lt;br /&gt;
&lt;a href=&#34;https://youtu.be/cNN_tTXABUA&#34;&gt;How a CPU Works&lt;/a&gt;&lt;br /&gt;
Legacy 常用寄存器，常见指令 实模式和保护模式 分段和分页机制 TSS和任务管理 中断机制 时钟机制 高速缓存&lt;br /&gt;
《模拟电子技术基础 童诗白 第四版》第一章前半部分&lt;br /&gt;
Structured Computer Organization 6th Edition&lt;br /&gt;
Digital Design and Computer Architecture 2nd Edition&lt;br /&gt;
Computer Organization and Design 5th Edition&lt;br /&gt;
Write Great Code: Volume 1: Understanding the Machine&lt;br /&gt;
See MIPS run&lt;br /&gt;
Intel 64 and IA-32 architectures software developers manual combined volumes 3A, 3B, and 3C: System programming guide&lt;br /&gt;
Microelectronics&lt;/p&gt;

&lt;h2 id=&#34;isa&#34;&gt;ISA&lt;/h2&gt;

&lt;p&gt;model: 1570s, &amp;ldquo;likeness made to scale; architect&amp;rsquo;s set of designs,&amp;rdquo; from Middle French modelle&lt;br /&gt;
Semantics in computer science: In programming language theory, semantics is the field concerned&lt;br /&gt;
with the rigorous mathematical study of the meaning of programming languages.&lt;br /&gt;
Language primitive&lt;br /&gt;
ISA: memory model, registers, data types, instructions, word size(?).&lt;br /&gt;
Memory model: unit of address resolution, word, aligment, address space, addressing mode, memory barrier/memory order primitive&amp;rsquo;s semantics.&lt;br /&gt;
#x86 Interrupt&lt;br /&gt;
If interrupt occured in user mode, then cpu will context swith for potential reschedule.&lt;br /&gt;
The Interrupt Descriptor Table (IDT) is a data structure used by the x86 architecture to implement an interrupt vector table.&lt;br /&gt;
##Hardware interrupts&lt;br /&gt;
are used by devices to communicate that they require attention from the operating system.&lt;br /&gt;
asynchronus&lt;br /&gt;
more details in init_IRQ() or set_irq() in driver.&lt;br /&gt;
##software interrupt&lt;br /&gt;
synchronus&lt;br /&gt;
more details in trap_init().&lt;br /&gt;
* exception or trap&lt;br /&gt;
is caused either by an exceptional condition in the processor itself,&lt;br /&gt;
divide zero painc?&lt;br /&gt;
* special instruction, for example INT 0x80&lt;br /&gt;
or a special instruction in the instruction set which causes an interrupt when it is executed.&lt;/p&gt;

&lt;h1 id=&#34;i-o-ic&#34;&gt;I/O IC&lt;/h1&gt;

&lt;p&gt;serial communication: UART(16550) + RS-232&lt;br /&gt;
parallel communication: SCSI, ISA, ATA, PCI, FSB&lt;/p&gt;

&lt;h1 id=&#34;data-struct-aligment&#34;&gt;Data struct aligment&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.catb.org/esr/structure-packing/&#34;&gt;The Lost Art of C Structure Packing&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://en.wikipedia.org/wiki/Data_structure_alignment#Typical_alignment_of_C_structs_on_x86&#34;&gt;Typical alignment of C structs on x86&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;为什么需要结构体对齐&#34;&gt;为什么需要结构体对齐?&lt;/h2&gt;

&lt;p&gt;struct foo {&lt;br /&gt;
char c;&lt;br /&gt;
int i;};&lt;br /&gt;
如果是32位, cpu 一次取4byte a word 数据.&lt;br /&gt;
如果我们把i的前3byte和c存到一起, 剩下1byte of i自己单独存.&lt;br /&gt;
那么我们访问i这个数据就要读两个4byte a word. 对cpu来说性能损耗.&lt;br /&gt;
如果我们把i单独放到4byte 对齐的地址, 那么我们只需要一次cpu读取.fast!&lt;/p&gt;

&lt;h2 id=&#34;产生非对齐访问的场景&#34;&gt;产生非对齐访问的场景&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Casting variables to types of different lengths, 比如char * 到int *&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Pointer arithmetic followed by access to at least 2 bytes of data , 不太理解.&lt;/p&gt;

&lt;h2 id=&#34;我们做什么&#34;&gt;我们做什么?&lt;/h2&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;什么也不干, 按默认对齐来Natural alignment&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为了不影响性能, 同时减少内存使用, 编程时最好显示reorder.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;get/put_unaligned  to avoid analigned access.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通过attribute aligned指定对齐要求.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;数据要在不同体系, 32/64之间使用, 比如网络,写到disk, 我们必须要attribute packed&lt;br /&gt;
也就是说不对齐, 不同平台对齐可能不同, 我们不能让数据corruption.&lt;/p&gt;

&lt;h2 id=&#34;如果数据不对齐有什么-cpu怎么办&#34;&gt;如果数据不对齐有什么, cpu怎么办?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kernel.org/doc/Documentation/unaligned-memory-access.txt&#34;&gt;必读UNALIGNED MEMORY ACCESSES&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果用了packed, 编译器会生成extra代码阻止非对齐访问, performance loss.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cpu呢? 可能正确处理raise a exception to fix it with performance loss.&lt;/p&gt;

&lt;h2 id=&#34;calculate-the-sizeof-of-aligned-c-struct&#34;&gt;Calculate the sizeof of aligned c struct&lt;/h2&gt;

&lt;p&gt;Data alignment means putting the data at a memory address equal to some multiple of the word size,&lt;br /&gt;
which increases the system&amp;rsquo;s performance due to the way the CPU handles memory.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;find the widest scalar member and attribute( aligned(x)) to determin alignment.&lt;br /&gt;
找到结构体内scalar和attribute最大的对齐要求.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;fill the member to alignement without wrap&lt;br /&gt;
把结构的成员一次填满对齐宽度, 不够的填到下个对齐宽度, 空出来留着padding&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Pading to alignment&lt;br /&gt;
填上所有空.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;endianess&#34;&gt;Endianess&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.yolinux.com/TUTORIALS/Endian-Byte-Order.html&#34;&gt;Endianness: Big and Little Endian Byte Order&lt;/a&gt;&lt;br /&gt;
应该说bit endianess 实际存储只有MSB &amp;hellip; LSB这一种二进制表达形式! 在上面的文章的representtion, 辅证这一点.&lt;br /&gt;
这篇文章&lt;a href=&#34;http://tonybai.com/2013/05/21/talk-about-bitfield-in-c-again/&#34;&gt;再谈C语言位域&lt;/a&gt;,&lt;br /&gt;
之所以输出逆序, 是因为错误里理解了, bit 序. bit 序是cpu 读取的方式, 不是存储的方式!&lt;br /&gt;
* &lt;a href=&#34;https://en.wikipedia.org/wiki/Bit_numbering&#34;&gt;bit endianness&lt;/a&gt;&lt;br /&gt;
这样就可以更好的理解iphdr:&lt;br /&gt;
#if defined(__LITTLE_ENDIAN_BITFIELD)&lt;br /&gt;
    &lt;strong&gt;u8    ihl:4,&lt;br /&gt;
        version:4;&lt;br /&gt;
#elif defined (&lt;/strong&gt;BIG_ENDIAN_BITFIELD)&lt;br /&gt;
    __u8    version:4,&lt;br /&gt;
        ihl:4;&lt;br /&gt;
#else&lt;br /&gt;
#error  &amp;ldquo;Please fix &lt;asm/byteorder.h&gt;&amp;ldquo;&lt;br /&gt;
#endif&lt;br /&gt;
ipv4 header的拓扑&lt;br /&gt;
version ihl&lt;br /&gt;
0100 0101&lt;br /&gt;
因为le的cpu是 lsb first, 也就是从最左面的1开始读, 所以第一个是ihl&lt;br /&gt;
而be的cpu是 msb first, 从最右开始所以version开头.&lt;br /&gt;
而使用unsigned char ver_ihl&lt;br /&gt;
(ver_ihl &amp;amp; 0xf0)&amp;gt;&amp;gt; 4 = version&lt;br /&gt;
ver_ihl &amp;amp; 0x0f = ihl&lt;br /&gt;
是无关cpu读取顺序的.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux time subsystem</title>
      <link>http://firoyang.org/cs/time/</link>
      <pubDate>Tue, 22 Sep 2015 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/time/</guid>
      <description>

&lt;p&gt;我写作的主要目的是理清基本概念与原理, 而非实现,细节这一类.&lt;/p&gt;

&lt;p&gt;时间是人类发明出来的概念, Kant也认为时间是心智概念.&lt;br /&gt;
一百年前的世界和现在有什么不同呢?这个提问揭示生活中时间最重要的用途,&lt;br /&gt;
*标记*某中状态下的世界. 所谓的过去世界不过是世界的一个个连续状态&lt;br /&gt;
那么时空穿越, 就变成了保住项少龙这个肉身不变, 世界的其他部分完全&lt;br /&gt;
转变到过去的某一个状态. 而所谓现在世界就被抹杀了.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The future is already here – it&#39;s just not evenly distributed.
                        — William Gibson
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;人想回到&amp;rdquo;过去&amp;rdquo;多半源于情感因素, 而想去&amp;rdquo;未来&amp;rdquo;则是因为&amp;rdquo;物质&amp;rdquo;的缘故.&lt;br /&gt;
想象下中国的未来50年, 很可能是现在美国or西欧现在的样子.虽然中西虽然处在&lt;br /&gt;
时间概念上相同的现在, 而物质世界确实&amp;rdquo;过去&amp;rdquo;和&amp;rdquo;未来&amp;rdquo;之差.&lt;/p&gt;

&lt;p&gt;比如我们下周而要开会, 那么此时下周二就是有意识的规划未来, 时间依然是标记.&lt;br /&gt;
UTC/GMT&lt;br /&gt;
Based on caesium microwave atomic clock&lt;br /&gt;
Leap second&lt;/p&gt;

&lt;h2 id=&#34;genus-differentia-definition&#34;&gt;Genus-differentia definition&lt;/h2&gt;

&lt;p&gt;interrupt, clock event,  clock source, tick, timer, timekeeping, gettimeofday.&lt;/p&gt;

&lt;h2 id=&#34;unites&#34;&gt;unites&lt;/h2&gt;

&lt;p&gt;cputime = jiffies under HZ (FIXME)&lt;br /&gt;
sum_exec_runtime nanoseconds&lt;br /&gt;
clockt = jiffies but under USER_HZ&lt;/p&gt;

&lt;h2 id=&#34;功用定义&#34;&gt;功用定义&lt;/h2&gt;

&lt;p&gt;获取时间&lt;br /&gt;
timer&lt;br /&gt;
sleep ?&lt;br /&gt;
update sched info&lt;/p&gt;

&lt;h2 id=&#34;发生定义-设计-etymology-history-operational-definition&#34;&gt;发生定义/设计   etymology, history Operational definition&lt;/h2&gt;

&lt;p&gt;timekeeping/计时:时刻．&lt;br /&gt;
clock source: 时间之源, 表针之力.&lt;br /&gt;
clock event: 闹铃之力, 经过tick展现能力.&lt;br /&gt;
tick: timer的中断事件叫tick, tick device产生tick, 可以说tick决定了clock_event event_handler进而决定了, clock_event行为.&lt;br /&gt;
tickless:&lt;br /&gt;
for timer: use HW timer one shot, set next.&lt;br /&gt;
for update time: in above HW timer, not good&lt;br /&gt;
for sched: for priority distributed in time slice, use timer.&lt;br /&gt;
dynamic tick/no HZ:&lt;br /&gt;
No HZ in idle&lt;br /&gt;
No HZ while only 1 process running for HPC.&lt;br /&gt;
tick devies 就是clock event包了层虎皮.&lt;br /&gt;
tick broadcast framework:  based on tick device&lt;br /&gt;
clock: 可记录时间, 表盘.利用timekeeping&lt;br /&gt;
timer: use clock. what about timer_list?&lt;br /&gt;
timer_list: do in softirq&lt;br /&gt;
* timekeeping aspect&lt;br /&gt;
onset: start_kernel -&amp;gt; timekeeping_init &amp;amp; time_init &amp;amp;(rest_init-&amp;gt; kernel_init-&amp;gt; &lt;br /&gt;
kernel_init_freeable-&amp;gt;do_basic_setup-&amp;gt;do_initcalls&amp;ndash;device_initcall(init_clocksource_sysfs))&lt;br /&gt;
nucleus:used by clock see init_posix_timers and update_wall_time and sys_time&lt;br /&gt;
coda:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;clock source aspect&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;tick device layer aspect&lt;br /&gt;
per_cpu(tick_cpu_device, cpu)&lt;br /&gt;
onset: time_init-&amp;gt;mach-&amp;gt;init_time-&amp;gt;&amp;hellip;clockevents_register_device-&amp;gt;tick_check_new_device&lt;br /&gt;
nucleus: a38x_timer_interrupt-&amp;gt;a38x_clkevt.event_handler&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;tick broadcast framework&lt;br /&gt;
onset:&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;clock aspect&lt;br /&gt;
k_clock&lt;br /&gt;
onset:init_posix_timers &amp;amp; init_posix_cpu_timers&lt;br /&gt;
nucleus: 用户-&amp;gt; posix_clock-&amp;gt;timepkeeping-&amp;gt;clock_socurce&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;timer aspect&lt;br /&gt;
onset: open_softirq(HRTIMER_SOFTIRQ, run_hrtimer_softirq);&lt;br /&gt;
nucleus: common_timer_set&lt;br /&gt;
hrtimer_interrupt | (tick_handle_periodic-&amp;gt; tick_periodic-&amp;gt; update_process_times-&amp;gt;run_local_timers-&amp;gt;hrtimer_run_queues)-&amp;gt;__run_hrtimer-&amp;gt;timer.function = posix_timer_fn;(set in common_timer_set)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;计算机概念&lt;br /&gt;
system clock CLOCK_REALTIME CLOCK_MONOTONIC&lt;br /&gt;
time.h time_t=tm=timeval=timespec calendar time  clock_t&lt;/p&gt;

&lt;p&gt;clock event -&amp;gt; tick device-&amp;gt; handle function&lt;br /&gt;
clock event 相较于timer更为抽象, timer 是一种用途,timer 通过clock event来实现功能,&lt;br /&gt;
clock event 通过timer来体现自己, timer面向使用者的onset,&lt;br /&gt;
而clock event 则是偏向于nucleus and coda.&lt;br /&gt;
timer: 标记不能立即执行的变化.&lt;br /&gt;
clock source: 用一些整型抽象一个过程, 对于时间来说, 简直是完美的抽象.&lt;br /&gt;
* kernel requirement&lt;br /&gt;
linux的时间子系统要求硬件timer提供下面两种能力：&lt;br /&gt;
一是free running的counter，此外需要能够在指定的counter值上产生中断的能力。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux virtualization</title>
      <link>http://firoyang.org/cs/virt/</link>
      <pubDate>Wed, 17 Jun 2015 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/virt/</guid>
      <description>

&lt;p&gt;本文着重探讨下kvm的实现, 11年在snia的实习的时候, 接触过一点.&lt;br /&gt;
已经过去将近4年了,  当初看到qemu的代码, 被吓到了, 我靠, 这代码量赶上内核了!&lt;br /&gt;
现在kvm核心就1069行当前kernel 4.1 rc7, qemu虽然赶不上kernel但是也不少1144756.&lt;br /&gt;
看过指环王的, 都知道神奇中土大陆是托尔金虚构的魔幻世界,那里活着阿拉贡和&lt;br /&gt;
他的朋友们, 以及他们精彩的历程.人的想象力, 如此神奇, 他能使人超越时间与&lt;br /&gt;
空间去体验到不同生命历程.&lt;br /&gt;
今天, 我们来探索一下&lt;a href=&#34;https://en.wikipedia.org/wiki/Virtualization&#34;&gt;虚拟化&lt;/a&gt;&lt;br /&gt;
如wikipedia所说, 虚拟化始于上个世纪60年代, 这是指的计算机领域内的.&lt;br /&gt;
显然, 我们要把眼光放得更远, 因为我们想洞见一些深层次的内容.&lt;br /&gt;
法国哲学家福柯一生都在从事&amp;rdquo;知识考古学&amp;rdquo;, 而我也喜欢在研究问题时, 从语言学特别是&lt;br /&gt;
词源角度开始. virtual这个词, 最早来自于中世纪拉丁文virtualis, 涵义是&lt;br /&gt;
influencing by physical virtues or capabilities,&lt;br /&gt;
effective with respect to inherent natural qualities&lt;br /&gt;
受某种实在的长处能力影响, 源自本质的效用.&lt;br /&gt;
这里从两种角度理解virtual, 受影响者, 影响者本身.&lt;br /&gt;
所以这里virtual的真实涵义应该是延续某种内在的本质并施加于外物.&lt;br /&gt;
这个英文单词的汉语翻译是很有趣的, 摘自金山词霸:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;virtual 音节划分：vir▪tual
英 [ˈvɜ:tʃuəl] 美 [ˈvɜ:rtʃuəl]
adj.实质上的，事实上的；（计算机）虚拟的；&amp;lt;物&amp;gt;有效的，虚像的；（粒子）实际存在的
虚；虚拟艺术；虚拟的；模拟帐户
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个词汇简直是英语翻译界的笑话, 一会实一会虚, 非常让人困惑!&lt;br /&gt;
话说回来, 这个词的翻译确实有难度.我翻译的话会叫质延.&lt;br /&gt;
很多事情, 在我们出生前就决定了, 我是89年9月出生的.&lt;br /&gt;
我们搞懂了所谓&amp;rdquo;虚拟化&amp;rdquo;的实质, 之后就可以继续探索了.&lt;br /&gt;
如wikipedia, 所说计算机领域的虚拟化更多的是指hardware virtualization.&lt;br /&gt;
没错就是延伸硬件的特质, 准确说是在软件层继续延伸硬件的特质.&lt;br /&gt;
好, 首先, 我们要搞懂硬件都有那些特质? 硬件有很多, 在计算机领域指什么呢?&lt;br /&gt;
没错, CPU, 硬盘, 电路板, 内存, 鼠标键盘等等. 那么他们有什么特质呢?&lt;br /&gt;
所谓的特质就是特别的性质, 一种属性, 哲学上, 称之为事物对外物的作用的一种表现.&lt;br /&gt;
那么CPU的最大特质就是指令处理, 我想这也是虚拟化的核心吧!&lt;br /&gt;
我们硬件虚拟化延伸的终点是让另一个操作系统运行于当前操作系统提供的硬件特质延伸之上.&lt;br /&gt;
终于进入正文了. 现在我们自己来设计一套虚拟化基础架构, 让一个简单的kernel运行在当前的fedora&lt;br /&gt;
之上.&lt;/p&gt;

&lt;h2 id=&#34;fkvm&#34;&gt;FKVM&lt;/h2&gt;

&lt;p&gt;没错我的虚拟化技术就叫这个FucK VM, 好吧, 其实简写于Firo&amp;rsquo;s KVM!&lt;br /&gt;
首先, 我们必须明确一点, 即便我 or 我们不能最终实现一个虚拟化架构让另一个kernel&lt;br /&gt;
运行起来, 今天在这里做得事情的意义, 依然深远且几乎无可替代!&lt;br /&gt;
因为, 至少你是在想象力,或者更为正式表述是在概念层次上让他运行起来了, 而且跑得飞快!&lt;br /&gt;
你在虚拟化一个虚拟化, 这就是智力劳动的乐趣.&lt;br /&gt;
怎么才能让一个kernel 运行起来呢? 能想到的就是从用户态起一个进程, 之后这个进程fork下去执行&lt;br /&gt;
start_kernel的代码.有点眉目了. 问题也来了, 内核启动的时候会各种初始化, 这会扰乱了现在正在运行的&lt;br /&gt;
cpu, 我能想到的这个新的内核的内存管理不能和之前运行的fedora的冲突, 两个都玩完, 首先要隔离内存.&lt;br /&gt;
也就是要虚拟化一块内存. 怎么解决, 最简单的直接malloc一块空间给他吧. 怎么给? 为了简单.&lt;br /&gt;
在内核初始化的时候, 会用调用bios的中断来获取内存信息.&lt;br /&gt;
也就是说我们要先弄一个虚拟bios出来啊. 先假设bios, 我们弄出来了.&lt;br /&gt;
开机先执行这段bios代码, 把之前申请的内存告诉bios, 之后我们在内核内核初始化的时候, 就用这块.&lt;br /&gt;
现在问题用来了. 内核要访问这块内存就必须为他建页表, 申请的这块内存可能是不连续的而且还可能是&lt;br /&gt;
高端内存, 内核初始化的代码可没考虑这么复杂. 要么该内核, 要么改FKVM, 显然不能改内核啊.&lt;br /&gt;
只能去尝试, 虚拟一个CPU, cpu指令那么复杂, 怎么能搞定. 是否有必要, 搞那么复杂呢?&lt;br /&gt;
我们的一个cpu就是一个进程.这个cpu执行内初始化的代码, 需要想办法, 让内核感知不到底层的变化.&lt;br /&gt;
就好比, 他访问了一块高端内存, 但这个内核, 里面的页表却标明他是低端, 随意访问.&lt;br /&gt;
也就是说, 我们要截获cpu访存的指令, 并且要把他再次重定向到真正的物理内存.&lt;br /&gt;
如何截获?我们不能有太多假设.而且现在的工作, 实际已经被usermode linux 完成了.&lt;br /&gt;
这里需要很多底层的知识. 先看点资料再回来.&lt;br /&gt;
看了下基本实现, 这里我们的思路没有问题, 只不过指令和优先级的问题没有考虑.&lt;br /&gt;
访问特权指令确实是被截获的. intel引入了vt-x来解决这个问题.&lt;br /&gt;
探索这种复杂的系统, 就行探索一座深山一样, 如果不加思索就突入进去, 最终会迷路.&lt;br /&gt;
无论别人说的多么好, 我们必须要有自己的思路.&lt;br /&gt;
总结下所得:&lt;br /&gt;
控制虚拟机对全局资源的访问, 通过截获虚拟的某些指令.&lt;br /&gt;
虚拟化一块内存.&lt;br /&gt;
我们知道想中断啊, IO这些都得良好的处理掉, 否这会影响到我们早已运行的fedora.&lt;br /&gt;
由于缺少太多硬件知识, 在这样思考下去, 就会变成满篇假设了, 这和我们的目的背道而驰了.&lt;br /&gt;
同时乐趣也会减少.&lt;/p&gt;

&lt;h1 id=&#34;kvm-qemu&#34;&gt;KVM QEMU&lt;/h1&gt;

&lt;p&gt;现在我们来了解KVM, 在经过前面不成熟的思考好, 结果有点令人沮丧. 似乎我们什么都没完成&amp;hellip;&lt;br /&gt;
探索的方式, 依然是以自我思考为主, 通过提问的形式完成思考过程.&lt;br /&gt;
千万不可成了, 靠一点一滴积累别人的思想感悟来成长. 万万不可.对于问题的洞见主力依然&lt;br /&gt;
是我们自己, 别人的知识只是辅助. 那好我们开始.&lt;br /&gt;
首先, 我们是为了了解KVM是如何运作的, 晚上的paper 帖子, 都说比较概括, 而分析的又不太通俗.&lt;br /&gt;
往往初学者, 很容易被绕进去.&lt;br /&gt;
从宏观上看KVM虚拟化, 由KVM和QEMU两个组件完成的, 一个内核模块, 一个用户态程序.&lt;br /&gt;
为什么这么设计? 还有别的虚拟化架构吗? 维基给出了, 硬件虚拟化的几种实现策略.&lt;br /&gt;
Full virtualization,  VMware Workstation 和 QEMU就是这种, 全虚拟化定义上是说, 为虚拟机提供&lt;br /&gt;
全部的硬件特性的延伸支持. 这个技术上个世界70年代就由IBM推行. 在人们看来这门高深的学问在计算机的&lt;br /&gt;
洪荒时代, 便已出现. 那个时代一切都是新的, 人们强烈的渴望伸展四肢, 天不怕地不怕的.&lt;br /&gt;
Partial virtualization, 维基上给出半虚拟化的介绍, 他是全虚拟化的先驱, 现在很少本人提起.&lt;br /&gt;
至少, 现在都是全虚拟化和类虚拟化的天下.文中提及, 虚拟地址空间便是半虚拟化.&lt;br /&gt;
从虚拟化的定义角度来看, 操作系统本身, 便是一种原生且原始的虚拟化, 这无可否认.&lt;br /&gt;
这是一种高度抽象的虚拟化, 就好比进程是cpu的虚拟化, 虚拟地址空间是对内存的一种虚拟化.&lt;br /&gt;
Paravirtualization, para是在什么旁边的意思, 中文翻译成类虚拟化, 也算贴切.&lt;br /&gt;
类虚拟化修改guest 系统, 而不是通过虚拟化硬件.Xen(也支持全虚拟化)和UML是这一类.&lt;br /&gt;
Operating-system-level virtualization&lt;br /&gt;
这种虚拟化,概念上不同于上面三种, 是对操作系统的虚拟化, 虽然追根到底, 还是对硬件的虚拟化.&lt;br /&gt;
但是, 这里强调的是操作系统的资源的虚拟化. 属于操作系统的很多高级抽象, 底层硬件是不具备的.&lt;br /&gt;
比如协议栈这个概念, 他本身是对信息传递的抽象而非硬件, 硬件只是其中一环而已.&lt;br /&gt;
这里若是简单的翻译成系统级虚拟化, 就就比如LXC这个技术而言, 这里面我们并没有虚拟化任何东西.&lt;br /&gt;
比如我们使用socket 发包, 还是这样; 使用malloc分配内存还是这样, 并没有也不需要所谓虚拟化,&lt;br /&gt;
他们都是原生的original.  所以在这里我们就看到了, 不合适的翻译造成的理解差异.&lt;br /&gt;
这里还是直接说容器技术,比较合适, 因为他本来就强调对资源的管理.&lt;br /&gt;
在了解了虚拟化的概念后, 问题又回到了KVM QEMU本身, 此时, 我们依然对他们的实现没有头绪,&lt;br /&gt;
网上也没有找到, 说理清晰的入门文档. 我们还是要搞懂 kvm和qemu的原理.&lt;br /&gt;
我们从小的概念开始, 力求集合小的概念最终, 完成的对kvm 和 qemu的认知.&lt;br /&gt;
首先是qemu是什么? 为什么要有他, 单独一个kvm不行吗?&lt;br /&gt;
官网的解释:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;QEMU is a generic and open source machine emulator and virtualizer.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;qemu可以做emulator, 就像android的开发环境中的那个模拟器差不多.&lt;br /&gt;
qemu可以作为虚拟化的工具和kvm,xen联动, 重点看这个.&lt;br /&gt;
我们在FKVM中已经知道, cpu的虚拟化是同vtx, 截获特殊指令完成的.&lt;br /&gt;
那么内存虚拟化呢, 显然不应是malloc一块空间能解决的.&lt;br /&gt;
毫无疑问, 肯定要有一个机制把host的内存映射到一个guest的物理地址空间, 同时guest的&lt;br /&gt;
虚拟地址解析出来的物理地址在转到宿主机的地址, 最后转成真正的物理地址. 有三次转换.&lt;br /&gt;
据我所指, x86的页表转换是自动的.如何让他这么转来转去的.这个应该就是kvm orvtx干的事情&lt;br /&gt;
补货到访存指令, 之后进行地址转换. 看了下真正的实现, 和我们思路差不多.&lt;br /&gt;
不同点, guest的物理地址是用pfn加数量标志的. 不用想每次访存kvm都要参与, 而且地址转换确实复杂&lt;br /&gt;
肯定有优化空间. 我现在想说, vtx这个截获访存指令确实是个BUG级的存在.&lt;br /&gt;
内存虚拟化就到这里了, 优化去看IBM的讲解帖子吧.&lt;br /&gt;
下面继续看cpu的虚拟化. 这个主要就是, 如何捕获, 那些vm运行比较敏感的指令.&lt;br /&gt;
我们的FKVM支持一个进程跑, 能想到的就是建几个线程来模拟SMP.&lt;/p&gt;

&lt;p&gt;下面是设备的虚拟化, 这个还是看书去吧.&lt;/p&gt;

&lt;h1 id=&#34;代码实现&#34;&gt;代码实现&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;KVM architecture&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Kernel running flow&lt;br /&gt;
svm.ko -&amp;gt; svm_init(svm.c) -&amp;gt; kvm_init(kvm_main.c) -&amp;gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;File&lt;br /&gt;
svm.c vmx.c kvm_main.c kvm_svm.h&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Function&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Struct&lt;br /&gt;
kvm_x86_ops x86.h&lt;br /&gt;
vcpu_svm    kvm_svm.h&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;qemu-system-ppc&#34;&gt;qemu-system-ppc&lt;/h1&gt;

&lt;p&gt;-mem-path:&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Algorithms and data structues</title>
      <link>http://firoyang.org/cs/algorithm/</link>
      <pubDate>Wed, 27 May 2015 12:42:12 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/algorithm/</guid>
      <description>

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://cstheory.stackexchange.com/questions/19759/core-algorithms-deployed#&#34;&gt;Core algorithms deployed&lt;/a&gt;&lt;br /&gt;
Algorithms: Design Techniques and Analysis&lt;br /&gt;
The Algorithm Design Manual 2nd Edition&lt;/p&gt;

&lt;h1 id=&#34;世界本源-the-origin-of-the-world-l-origine-du-monde&#34;&gt;世界本源, the origin of the world, L&amp;rsquo;Origine du monde&lt;/h1&gt;

&lt;p&gt;being(4), abyss(0)&lt;br /&gt;
material(1) change, quality, quantity, relation, space, time&lt;br /&gt;
process(2), tansfer, truth, signifier(3), bijection, Causality, structure&lt;br /&gt;
connectivity&lt;/p&gt;

&lt;h1 id=&#34;排序算法的分析&#34;&gt;排序算法的分析&lt;/h1&gt;

&lt;p&gt;排序的结果全序.&lt;br /&gt;
在确定排序的思想/算法后, 排序的过程是从无序to 有序的过程.&lt;br /&gt;
我们排序的过程等价成一次算术运算.&lt;br /&gt;
每一次, 在特定的算法下, 数据有序度增加or不增加, 但不减少.&lt;br /&gt;
我们把有序度看成一个quantity.那么此时排序的过程等价于有序度增加的过程.&lt;br /&gt;
怎么定义有序度set内元素构成=&amp;lt;就是一度粗有序度. 严谨的连续元素构成=&amp;lt;关系.&lt;br /&gt;
比如1 2 3 4 5 , bold order:4 + 3+ 2 +1; 严谨有序度:４&lt;/p&gt;

&lt;p&gt;也就是一个算法, 对如3 2 5 4 1. bo:2 + 2 ; 严谨有序度:0&lt;br /&gt;
bo: 2+2 to 10&lt;br /&gt;
严谨: 0 to 4&lt;br /&gt;
就算完成.此时我们没做一次排序, 都在做加法运算.只是每一步转换成一个变量了.&lt;br /&gt;
这似乎对我们理解sorting起不了多大的帮助.&lt;br /&gt;
直觉应该没错.确实不应该关心过程, 而应该关系变化本身, process不等于变化本身.&lt;br /&gt;
只是process是变化的动力, 却不是原因.变化的因果并不是恒定不变的.process成了变化的&lt;br /&gt;
结果了, 因为要这样所以才有了process, 不是这个process才怎么怎么了.&lt;br /&gt;
这样我们知道从raw set to ordered set, 这个过程, 一定可以有多个sort algorithms来完成.&lt;br /&gt;
那么选取哪个sort algorithm就是有改变的形式决定的.&lt;br /&gt;
所以我们依然在探讨结构上的变化. 而不是纯粹的process过程.&lt;br /&gt;
比如先确定边界元素的有序度, 从一边向另一边逐渐演化. 这就是selection sort.&lt;br /&gt;
注意!我们通过等价变换causlity, 原来近乎process主导的问题变为了, quantity structure渐变的问题了.&lt;br /&gt;
原来是伸手不见五指的变, 现在是看的见有形的变.&lt;br /&gt;
再看其他的算法, 比如我们想确定由中间quantity发起向两侧的有序变化, 就是快排.快排为什么快?&lt;br /&gt;
但是我们发现, 这种有中间发起的有序度变多的过程, 有两个疑点.&lt;br /&gt;
1. 这个所谓中间值是我们随机指定的, 几乎不可能是真正意义上的&amp;rdquo;中间值&amp;rdquo;.&lt;br /&gt;
2. 也是疑惑最大, 这种中起的有序度变化, 严格有序度不像边沿变化那样连续, 但是关于所谓中间值的bold order&lt;br /&gt;
确是丝毫没有耗损的! 也就是bold order是非常细腻的, 而Strict order, 是非常粗野的.&lt;br /&gt;
我们可以武断地下个定论, 满足严格有序的算法效率差!后面会给出严谨的证明.&lt;br /&gt;
我们继续, 另外务必注意, 我们这里没有任何关于已知算法的信息.&lt;br /&gt;
已知的各种算法是就是符号系统里面的signifier, 在我们分析的过程中纯粹的就是个名字而已.&lt;br /&gt;
更可怜的是, 这个名字是我们从signified推出来的.&lt;br /&gt;
我们现在已经推出了冒泡, 选择, 快排 三种算法了.&lt;br /&gt;
另外还有merge sort, heap sort, insertion sort, shell sort.&lt;br /&gt;
我只是看了merge sort之后的名字了, 具体的算法, 内容我都忘了(刻意不去想).&lt;br /&gt;
现在看了quick sort确认的是任意一点为为核心的orderness的增多过程. 增加的形式由中间开启.topdown.可以强调中间的含义.&lt;br /&gt;
insertion sort是select的一个generalize的版本, 他不强求strict order的满足. 也是有一边向另一边的orderness增多过程.&lt;br /&gt;
merge sort: 从全部的个体单元开始的开始有序度增多, bottomup过程.不强加中间的含义.&lt;br /&gt;
构成了以raw 元素为开始的, 从东南西北开始的四面埋伏是的有序度增多过程.&lt;br /&gt;
看来我的感觉没错.&lt;br /&gt;
算法的分析就结束了, 意外的收获颇多.本以为行不通的.&lt;/p&gt;

&lt;h1 id=&#34;查找算法的分析-searching-algorithm&#34;&gt;查找算法的分析 searching algorithm&lt;/h1&gt;

&lt;p&gt;搜索的效率完全在于搜索路径的长短.&lt;br /&gt;
查找是在a set of objects, 找到特定的目标. the structure of the set of objects可能是任意的.&lt;br /&gt;
计算机中如线性的linked list, array, tree, graph. structure并不只是量之间的quality, relation.&lt;br /&gt;
还包括了, change, 即operation, access/get也是一种change, 效果是没有change.&lt;br /&gt;
那么What is the form causality of searching?上面分析sorting的时候, 我们没有分析sorting算法的效率.&lt;br /&gt;
因为排序的form是orderness, 不是效率. 当然效率也很重要.&lt;br /&gt;
而查找算法,直观上要比sorting要简单, 他只关心特定的目标, 找到or not found.&lt;br /&gt;
但是有一点, 我们是万分确信的. 那就是类似sorting, searching的目的也是确定的, 也就是目的因的存在.&lt;br /&gt;
我们通过类似蒙太奇的手法, 去从差异中需找这种量. 寻找一些差异来自于我们找到target的最终结果和每步尝试之间.&lt;br /&gt;
每一步, 我们都比上一步离target更近了. 我想这是searching的form之一.&lt;br /&gt;
我定义为reachness(我瞎起的). 我们知道在特定的算法确定的情况下, 在特定的数据结构下(也就是搜寻的具体空间),&lt;br /&gt;
reachness这个quantity用来刻画我们searching的process, 因为算法确定, 数据结构确定, 没有数据的update.&lt;br /&gt;
那么我们前后两次searching到同一个target的reachness是一样的!没有差异, 我们不能仅仅用他来区分不同的searching process.&lt;br /&gt;
那么我们如何用这个reachness刻画不同searching algorithm呢?在说一次,&lt;br /&gt;
 我们分析过程不关心算法的效率(这种马后炮式的分析,很无聊, 但巨大现实意义), 不属于本次的topic!&lt;br /&gt;
我们的目的是为了理解区分而刻画不同的searching algorithm.实际上在上面分析排序算法的过程中我们隐式的分析对象就是数据结构,&lt;br /&gt;
不过我们忽视了他的存在. 我们分析的内容是确定的:&lt;br /&gt;
数据有序, 能显著减少搜索的空间? 为什么有序order的数据, 就能减少搜索的次数呢?&lt;br /&gt;
a) 查找本身就是做order判断.&lt;br /&gt;
b)  而有序的数据潜在做完了判断.&lt;br /&gt;
也就是还有一个判断读的问题 or orderness. 那么final reachness的最大值就是描述在不同的数据结构中, 得到target经历的quantity.&lt;br /&gt;
if orderness = 0. every structure&amp;rsquo;s final reachness = max space.&lt;br /&gt;
else final reachness &amp;lt; max space; // maybe half of max space&lt;br /&gt;
那么树形结构和linear 结构有什么区别呢? 结构上的已经清楚了.实际上, 我们知道计算机中树就是用linear实现的.&lt;br /&gt;
无序的链表和无序的tree是一样的.可以说无序的树是无意义的.&lt;br /&gt;
树是链表的超集. 有什么事树可以, 链表不可以.二分查找和二叉树查找是一样的.&lt;br /&gt;
但是二分只能应用到array上. 主要是因为没办法找到中间点.如果我们加个指针指向有序链表中间向他变成了什么?&lt;br /&gt;
没错树, 这应该就是树的重要本质了, accessable &amp;ldquo;中间&amp;rdquo;的quantity.除了叶节点职位的quantity都是内部&amp;rdquo;中间&amp;rdquo;quantity.&lt;br /&gt;
tree的两个后继则是边缘的一种展示.相比链表, 我们能第一时间知道正set of quantities的中间quantities.&lt;br /&gt;
实际上, 顺着middle pointer我们能够找到所有的interior middle quantities; 意外吧. 但是我们想知道其他的&lt;br /&gt;
中间节点时间耗费就是增多了.比如2049个节点. dfs只要最多8次就能找到任意&amp;rdquo;interior middle pointer&amp;rdquo;可是link list&lt;br /&gt;
全是512次啊tree有效的控制了reachness. 当然树是完全平衡的二叉树.&lt;br /&gt;
我现在到底在说什么呢? 我们试图用reachness和orderness描述tree, 我们辨析了tree和链表在reachness上的差异, 前提full order.&lt;br /&gt;
tree毫无疑问有link list来的.也就是说我们现在把searching 等价成了tree的结构.&lt;br /&gt;
那么维持reachness在较低值就是算法优劣关键. 那么如何保持reachness最小, 也就是orderness最大.&lt;br /&gt;
是什么让tree在reachness比link list优势这么大? 是存在于tree中隐式的判断.链式是一点点线性的变化, 而tree中的隐式判断确实二分的.&lt;br /&gt;
orderness小于1的tree没有意义.&lt;br /&gt;
记下来看看:avl tree, redblack tree, treap, splay tree, Size Balanced Tree, B-tree, B+ tree. but Trie or 霍夫曼树.&lt;br /&gt;
也就是说我们现在要考察这些tree structure. 基本考察完, 我的算法就同了. 后面还有DP, 贪婪, 数值, PNP之类都是思想了.&lt;br /&gt;
所以基本上本周5能把algorithm, 完事, 周6 设计模式. 周日开始sicp.&lt;br /&gt;
开始, 树结构的分析, 因为尽管是有形的visible structure, 我们依然无法给霍夫曼树和red black一个合理分析视角,&lt;br /&gt;
根本原因就是他们的form causality or 目的因不同.由上面可知orderness和reachness是我门刻画binary balance tree的quantities.&lt;br /&gt;
我们前面也分析了如何从link list到链表. 确定小, 中, 大,即 left, root, right这种模式下所有set of quantities的构成tree有多种可能.&lt;br /&gt;
如 1 2 3 4 5; left subtree 可以是 NULL, 1, 2, 还可以是1, 2, NULL.常见的旋转可以打到前者的情况. or不旋转:&lt;br /&gt;
5是root. 之后3是left 也是subtree的root, 1是left, 4是right,  1是root 2是right.&lt;br /&gt;
有序的link list和二叉树在插入删除是都做order判断调整, 由此一点我们不能判断出书有效的. 那什么是树比link list有效的呢?当然前提是&lt;br /&gt;
整个set 是order的.对1 2 3 4 5, reachness可能是5也可能是3. 对与1024个数据可能是1024, 可能是9.&lt;br /&gt;
树的高度height能有效衡量reachness.现在我们知道了, avl, red black, trap, splay这些tree的目标都是height的最小化.&lt;br /&gt;
但同时, 我们也知道height是一个描述最终结果.并不是process quantity. 我们找到与process动态同步的quantity.&lt;br /&gt;
这个process准确说就是构建balance tree的过程. 那么这个量就是描述balance tree.如 1 2 3 4 5 6 7 8 9, 5做root,&lt;br /&gt;
1 2 3 4 全是left child, 6 7 8 9全是right child. 二叉树的最raw的形态应该是link list那种.也就是说除了leaf node, 每个node至少&lt;br /&gt;
和两个node相连.也就是天然的形态. 那么我们把同时连着两个的node的connectivity作为1. 反之为0.链表起始是right side tree,&lt;br /&gt;
我的天, 这样链表的connectivity就是0啊.比如1,2,3,4,5,6,7的connectivity在0~3, 这是strict connectivity.那么bold connectivity就是&lt;br /&gt;
只要有连着就行link list对于1 to 7 这种情况是6.和二叉树没差. 比如 1 2 3 4 5. connectivity是1 or 2对search是没有影响的.&lt;br /&gt;
饶了一圈发现还是height最好用.那如何保证height最小. 看来还差树的form是保证height=(logN+1向上取整)&lt;br /&gt;
现在searching问题就转换成了二叉树构造的问题了.成了一个动态的过程了.&lt;br /&gt;
我们现在完全不考虑算法实现. 只是单纯的考虑一个过程前后两个state的差异, 类似蒙太奇手法.&lt;br /&gt;
重点是确认前后的两个state是什么? 前一个状态是raw, 我们不关心具体什么, 因为他可以是二叉树可能存在的各种状态.那么后一个状态呢?&lt;br /&gt;
我们期望的是什么. 我们可以为binary tree的各种形态用数值量化表示. 我们不用complete binary tree来表示理性的便于搜索的二叉树.&lt;br /&gt;
因为在最右在层, leaf node是否连续, 对searching的worst-case time O(log n) 没影响.所以我们叫piled tree.&lt;/p&gt;

&lt;p&gt;如果存在3个点向来的情况就认为 connectivity is 1。整个树的connectivity 是每个点的加和结果。&lt;br /&gt;
比如1到7的set那么max connectivity&lt;br /&gt;
4&lt;br /&gt;
&lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;5&lt;/sub&gt;&lt;br /&gt;
&lt;sup&gt;13&lt;/sup&gt;&amp;frasl;&lt;sub&gt;67&lt;/sub&gt;&lt;br /&gt;
所以是3这种情况也就是最有利于searching的。&lt;br /&gt;
同样1到7。&lt;br /&gt;
4&lt;br /&gt;
&lt;sup&gt;3&lt;/sup&gt;&amp;frasl;&lt;sub&gt;5&lt;/sub&gt;&lt;br /&gt;
&lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;67&lt;/sub&gt;&lt;br /&gt;
2&lt;br /&gt;
这种情况connectivity不是max，是2。也对应不是对searching最优的结构。&lt;br /&gt;
how to prove the consistency between connectivity and searching effiency？&lt;br /&gt;
Delay this job to future。&lt;br /&gt;
So oncemore we transfer our hunting target to how to build a  binary tree that with max connectivity.&lt;br /&gt;
In other words, all the popular self banlancing tree inherit this intrsic.&lt;br /&gt;
what we can do to modify the structure of  binary searching tree.&lt;br /&gt;
1 link  or unlink&lt;br /&gt;
2 counterclockwise weight inreasing&lt;br /&gt;
3 right shift(left roation); left shift(right roation)&lt;br /&gt;
4 只有insert和delete会影响.&lt;br /&gt;
尝试这却理解redblack tree.&lt;br /&gt;
逐一分析性质:&lt;br /&gt;
分出red black, 根叶都是黑.&lt;br /&gt;
red node不联通.&lt;br /&gt;
每个路径上黑node个数相同.&lt;br /&gt;
如果对于特定数量的nodes, 我们确认他能构成一定数量对应height在log(N+1), 也就是最优的searching.&lt;br /&gt;
所以说specific number nodes可以组成很多种binary searching tree.按照node的height在log(N+1)的数量.&lt;br /&gt;
avl 要严格rb-tree.这就是bst的form. 我们来总结下.&lt;br /&gt;
numbers of node &amp;lt; log(N +1) 取上.&lt;br /&gt;
那么rb是如何保证logN呢?&lt;br /&gt;
一个潜在的性质是插入是红.红永远小于黑,&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://gregfjohnson.com/cgi-bin/redblackbuilder&#34;&gt;http://gregfjohnson.com/cgi-bin/redblackbuilder&lt;/a&gt; 生成1 2 3 4 5 6逐一插入的算法.&lt;br /&gt;
                                                                             2  (b)&lt;br /&gt;
                                                                               |&lt;br /&gt;
                                                                   +&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&amp;mdash;&amp;mdash;&amp;mdash;-+&lt;br /&gt;
                                                                   |                      |&lt;br /&gt;
                                                                 1  (b)                 4  &amp;reg;&lt;br /&gt;
                                                                                          |&lt;br /&gt;
                                                                                  +&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;-+&lt;br /&gt;
                                                                                  |               |&lt;br /&gt;
                                                                                3  (b)          5  (b)&lt;br /&gt;
                                                                                                  |&lt;br /&gt;
                                                                                                  +&amp;mdash;-+&lt;br /&gt;
                                                                                                       |&lt;br /&gt;
                                                                                                     6  &amp;reg;&lt;br /&gt;
insert 7:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                                                                         2  (b)                                 
                                                                           |                                    
                                                              +------------+------------+                       
                                                              |                         |                       
                                                            1  (b)                    4  (r)                    
                                                                                        |                       
                                                                             +----------+----------+            
                                                                             |                     |            
                                                                           3  (b)                6  (b)         
                                                                                                   |            
                                                                                            +------+------+     
                                                                                            |             |     
                                                                                          5  (r)        7  (r) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;insert 8:&lt;br /&gt;
                                                                             4  (b)&lt;br /&gt;
                                                                               |&lt;br /&gt;
                                                                 +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&lt;br /&gt;
                                                                 |                            |&lt;br /&gt;
                                                               2  &amp;reg;                       6  &amp;reg;&lt;br /&gt;
                                                                 |                            |&lt;br /&gt;
                                                          +&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;+             +&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;-+&lt;br /&gt;
                                                          |             |             |               |&lt;br /&gt;
                                                        1  (b)        3  (b)        5  (b)          7  (b)&lt;br /&gt;
                                                                                                      |&lt;br /&gt;
                                                                                                      +&amp;mdash;-+&lt;br /&gt;
                                                                                                           |&lt;br /&gt;
                                                                                                         8  &amp;reg;&lt;br /&gt;
从6和7我们能看出来rb tree不是严格小于log(N+1) 分别有1和2个node height超过(logN+1), 第一个插入的是4那么就能保证complete了.&lt;br /&gt;
那么rb tree是如何保证每条路径上黑node相同呢?貌似是个副产品.可是非常重要.&lt;br /&gt;
如果父和叔都是r, 都变b, 祖父r.&lt;br /&gt;
如果叔是黑, 父黑, 祖父r. 父变root.&lt;br /&gt;
删除:&lt;br /&gt;
要复杂很多.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The Journey to RCU</title>
      <link>http://firoyang.org/cs/rcu/</link>
      <pubDate>Sun, 24 May 2015 09:52:12 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/rcu/</guid>
      <description>

&lt;h1 id=&#34;rcu-stalls&#34;&gt;RCU stalls&lt;/h1&gt;

&lt;p&gt;update_process_times-&amp;gt;rcu_check_callbacks-&amp;gt;rcu_pending-&amp;gt;__rcu_pending-&amp;gt;check_cpu_stall-&amp;gt;print_other_cpu_stall&lt;/p&gt;

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;iframe frameborder=&#34;no&#34; border=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; width=330 height=86 src=&#34;http://music.163.com/outchain/player?type=2&amp;id=444737&amp;auto=1&amp;height=66&#34;&gt;&lt;/iframe&gt;&lt;br /&gt;
&lt;a href=&#34;http://lse.sourceforge.net/locking/rcupdate.html&#34;&gt;官网Read-Copy Update Mutual Exclusion&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://lse.sourceforge.net/locking/rcu/HOWTO/index.html&#34;&gt;Read Copy Update HOWTO&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://lse.sourceforge.net/locking/rcu/rcupdate_doc.html&#34;&gt;Read-Copy Update Mutual-Exclusion in Linux&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://pages.cs.wisc.edu/~thanhdo/qual-notes/sync/sync2-rcu.txt&#34;&gt;Thanh Do&amp;rsquo;s notes Read-copy update. In Ottawa Linux Symposium, July 2001&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;why-do-need-rcu&#34;&gt;Why do need RCU&lt;/h1&gt;

&lt;p&gt;For &lt;a href=&#34;http://en.wikipedia.org/wiki/Scalability&#34;&gt;scalable&lt;/a&gt; mutual exclusion.&lt;br /&gt;
scale有两个词源涵义Proto-Germanic原始日耳曼, 酒杯, 盘子, 称重的盘子, 后来演化成标量的意思.&lt;br /&gt;
scalar在数学上是标量, 在c语言指int float, Scalar processor标量计算机也是来源于此.&lt;br /&gt;
另一个出处是Latin拉丁文scandere, 有攀爬之意, 进而衍生出扩展之意.&lt;br /&gt;
From wikipedia,  A system whose performance improves after adding hardware,&lt;br /&gt;
proportionally to the capacity added, is said to be a scalable system.&lt;br /&gt;
&lt;a href=&#34;https://www.ibm.com/developerworks/cn/linux/l-rcu/&#34;&gt;因为rwlock, brlock在多核性能下降.需要个高性能的锁&lt;/a&gt;&lt;br /&gt;
言下之意, 就是其他的mutual exclusion 机制不能很好的扩展, 需要RCU.&lt;br /&gt;
Read Copy Update HOWTO介绍了当初RCU开发的动机:&lt;br /&gt;
* Increase in cost of conventional locks&lt;br /&gt;
第一个原因也是最重要的, 最根本原因.&lt;br /&gt;
传统的锁the contended lock如spinlock实现上不断访问内存轮询锁当前状态, cpu和内存速度的*越来越*巨大差异;&lt;br /&gt;
一种新的锁机制减少访问内存,就成了强烈的需求.&lt;br /&gt;
* Cache benefits of lock-free reads&lt;br /&gt;
传统锁/tried-and-true 如spinlock一类的实现在多核下, 在出现锁竞争时会导致&lt;a href=&#34;http://www.quora.com/What-is-cache-line-bouncing-How-spinlock-may-trigger-this-frequently&#34;&gt;cache line bouncing&lt;/a&gt;.&lt;br /&gt;
3个cpu, A占有spinlock, 另外两个轮询尝试获取在test and set版本的&lt;br /&gt;
spinlock, 如果Bcpu 修改lock那么C cpu的d cache line 就会强制无效,&lt;br /&gt;
之后c 也修改lock, B的d cache line就无效了.之后B又来了, 就这样.&lt;br /&gt;
在不同cpu之间同步数据, 会耗费很多cpu 指令周期.&lt;br /&gt;
像&lt;a href=&#34;https://www.ibm.com/developerworks/cn/linux/l-cn-spinlock/&#34;&gt;x86的spinlock的实现用lock指令前缀锁住总线&lt;/a&gt;,&lt;br /&gt;
其他cpu or dma就不能访问内存, 降低系统的性能, ibm这篇文章说P6之后的处理器减少这种危害.&lt;br /&gt;
* Avoiding complicated races&lt;br /&gt;
No deadlock, 减少了开发维护.&lt;/p&gt;

&lt;h1 id=&#34;how-to-use-rcu&#34;&gt;How to use RCU&lt;/h1&gt;

&lt;p&gt;list rcu&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/263130/&#34;&gt;What is RCU? Part 2: Usage&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www2.rdrop.com/users/paulmck/techreports/RCUUsage.2013.02.24a.pdf&#34;&gt;RCU Usage In the Linux Kernel: One Decade Later&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;what-is-rcu&#34;&gt;What is RCU&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.rdrop.com/~paulmck/RCU/whatisRCU.html&#34;&gt;What is RCU, Really?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/262464/&#34;&gt;What is RCU, Fundamentally?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://lwn.net/Articles/264090/&#34;&gt;RCU part 3: the RCU API&lt;/a&gt;&lt;br /&gt;
RCU supports concurrency between a single updater and multiple readers!&lt;/p&gt;

&lt;h2 id=&#34;design-pattern&#34;&gt;Design pattern&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Publish-Subscribe&lt;br /&gt;
For updater before synchnization_rcu(); similar to softirq rcu&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Observer&lt;br /&gt;
For updater to wait For Pre-Existing RCU Readers to Complete&lt;br /&gt;
Maintain Multiple Versions of Recently Updated Objects&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;positivism-implementions&#34;&gt;Positivism Implementions&lt;/h1&gt;

&lt;h2 id=&#34;classic-rcu&#34;&gt;Classic RCU&lt;/h2&gt;

&lt;p&gt;Classic RCU requires that read-side critical sections obey the same rules&lt;br /&gt;
obeyed by the critical sections of pure spinlocks:&lt;br /&gt;
blocking or sleeping of any sort is strictly prohibited.&lt;/p&gt;

&lt;h2 id=&#34;preemtible-rcu&#34;&gt;Preemtible RCU&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://lwn.net/Articles/253651/&#34;&gt;The design of preemptible read-copy-update&lt;/a&gt;&lt;br /&gt;
stage 的切换是由rcu_read_unlock 推动的!&lt;/p&gt;

&lt;h2 id=&#34;tree-rcu&#34;&gt;Tree RCU&lt;/h2&gt;

&lt;p&gt;For hundreds and thounds CPU cores&lt;/p&gt;

&lt;p&gt;#FAQ&lt;br /&gt;
* Difference with primitive and atomic&lt;br /&gt;
* Grace period is synchroinze_rcu or a softirq justment&lt;br /&gt;
* __rcu sparse will warn you if you access that pointer without the services of one of the variants of rcu_dereference().&lt;/p&gt;

&lt;h1 id=&#34;below-is-how-to-use-rcu&#34;&gt;Below is how to use RCU!&lt;/h1&gt;

&lt;h1 id=&#34;reference-1&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www2.rdrop.com/users/paulmck/techreports/RCUUsage.2013.02.24a.pdf&#34;&gt;RCU Usage In the Linux Kernel: One Decade Later&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;本文内容并非我原创, 实际上是翻译加上个人理解Paul E. McKenney的paper.Credit to Paul and others.&lt;br /&gt;
本文不关心RCU的实现.&lt;br /&gt;
本文的核心目标就是了解如何使用RCU.&lt;br /&gt;
所有使用RCU代码, 都可以分为4部分:&lt;br /&gt;
RCU read critical section: 就是rcu_read_lock()和rcu_read_unlock()之间的代码.&lt;br /&gt;
update: 这部分代码在synchronize_rcu/call_rcu之前执行. 比如给pointer = new_data;&lt;br /&gt;
synchronize: 这部分代码是等待调用synchronize/call_rcu时的所有Rcu read critical section 执行完.&lt;br /&gt;
free: 这部分是在上面synchronize/call_rcu确认所有对就数据引用的RCU read critical section都执行完了, 安全释放内存.&lt;br /&gt;
Paul的paper总结了5种用法, 并且附上了代码, 便于理解.&lt;br /&gt;
理解的过程实质上是用RCU的外衣再次理解这个5种方法!&lt;/p&gt;

&lt;h1 id=&#34;wait-for-completion&#34;&gt;Wait for Completion&lt;/h1&gt;

&lt;p&gt;内核中有&lt;a href=&#34;https://lwn.net/Articles/23993/&#34;&gt;完成量completion&lt;/a&gt;的基础设施&lt;br /&gt;
上面的RCU read critical section和synchronize可以构成completion的语义.&lt;br /&gt;
为什么要用RCU而不是内核自身提供的completion函数呢?&lt;br /&gt;
Paul的文中举的例子实在NMI中要作这样的事情, 显然基于waitqueue的completion是毫无用处的.&lt;br /&gt;
所以这里的RCU, 应该叫做Completion RCU-version.&lt;/p&gt;

&lt;h1 id=&#34;reference-counting&#34;&gt;Reference Counting&lt;/h1&gt;

&lt;p&gt;传统的引用计数就是往结构体里面内嵌一个atomic,加加减减.&lt;br /&gt;
但RCU实现的引用计数把实际工作转移到softirq-rcu部分去了.&lt;br /&gt;
Paul给了一个例子, 我认为是及其不合适的.因为他忽略了softirq部分随着smp的核数增多&lt;br /&gt;
同样也会带来性能的损耗,而不是almost zero in his paper.&lt;br /&gt;
引用计数和完成量的区别, 除了语义上的差异, 看起来没有太大的区分.FIXME.&lt;/p&gt;

&lt;h1 id=&#34;type-safe-memory&#34;&gt;Type Safe Memory&lt;/h1&gt;

&lt;h1 id=&#34;publish-subscribe&#34;&gt;Publish-Subscribe&lt;/h1&gt;

&lt;h1 id=&#34;read-write-lock-alternative&#34;&gt;Read-Write Lock Alternative&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>Kernel hacking</title>
      <link>http://firoyang.org/cs/hacking/</link>
      <pubDate>Sat, 25 Apr 2015 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/hacking/</guid>
      <description>

&lt;h1 id=&#34;kernel-hacking&#34;&gt;kernel hacking&lt;/h1&gt;

&lt;p&gt;The cxgb3_*_send() functions return NET&lt;em&gt;XMIT&lt;/em&gt; values, which are&lt;br /&gt;
positive integers values. So don&amp;rsquo;t treat positive return values&lt;br /&gt;
as an error.&lt;br /&gt;
67f1aee6f45059fd6b0f5b0ecb2c97ad0451f6b3&lt;/p&gt;

&lt;h1 id=&#34;old-questions&#34;&gt;old questions&lt;/h1&gt;

&lt;p&gt;What is platform driver?&lt;br /&gt;
find source code of config&lt;br /&gt;
How to print backtrace by kernel oops, and why it&amp;rsquo;s not exact?&lt;br /&gt;
What is abi&lt;br /&gt;
why get_unaligned_be16?&lt;br /&gt;
 _THIS&lt;em&gt;IP&lt;/em&gt; vs &lt;strong&gt;FUNCTIONS&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&#34;kernel-data-type&#34;&gt;kernel data type&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://yarchive.net/comp/linux/kernel_headers.html&#34;&gt;__u32&lt;/a&gt; and &lt;a href=&#34;http://www.linuxjournal.com/article/5783&#34;&gt;this&lt;/a&gt; and dd3e chapter 10.&lt;/p&gt;

&lt;h1 id=&#34;the-principle-of-kernel-driver-backport&#34;&gt;The principle of kernel &amp;amp; driver backport&lt;/h1&gt;

&lt;p&gt;将高本版kernel的feature移植到低版本的kernel的过程就是backport.&lt;br /&gt;
1. 尽量保持与mainline的代码一致&lt;br /&gt;
2. 做好取舍不要引入太多patch.&lt;/p&gt;

&lt;h2 id=&#34;开发流程&#34;&gt;开发流程&lt;/h2&gt;

&lt;p&gt;理清所引入feature的代码. 主要数据结构以及功能流程.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://wangcong.org/2007/03/09/-e8-b5-b0-e8-bf-91linux-e5-86-85-e6-a0-b8/&#34;&gt;走近Linux内核&amp;ndash; 王聪&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;kernel-hacker之路&#34;&gt;kernel hacker之路&lt;/h1&gt;

&lt;p&gt;我实在太想聊这个话题 &amp;ndash; 内核hacker的成长之路!&lt;br /&gt;
不是教你写第一个kernel module, 就灭火了. 而是持续的一步步成长为&lt;br /&gt;
内核的中坚力量, 甚至是maintainer.&lt;br /&gt;
作为一个内核爱好者, 从接触到现在已经3年半了. 然而, 我对自己是非常失望的.&lt;br /&gt;
因为我看了3年多的书, 从今年(15)5月才开始, 给社区提补丁.&lt;br /&gt;
起始我在12年的11月份曾经给社区, 提过几次补丁. 后来有那么两三次, 想帮着修复&lt;br /&gt;
kernel panic 和oops的问题, 基本上个人感觉难度非常太大就无极而终了.&lt;br /&gt;
5月份这次, 我是因为实在不想在看书籍了, 市面上稍微有点名的书籍, 我都看过.&lt;br /&gt;
实在太厌烦再看书了, 我把自己和另外一个内核hacker 王聪做了对比, 得出结论:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;赶快滚去给社区提patch! 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我挨个看了王聪给社区提的前50个patch. 都是很简单的修改.&lt;br /&gt;
我几次挫败都是, 因为没能找到合适内核事情去做, 最终没有下文了.&lt;br /&gt;
今天, 我在给社区提了20个左右的patch 10几个被接收了. 我现在找到了一条成长路.&lt;/p&gt;

&lt;h2 id=&#34;内核我现在认为可以给新人做得事&#34;&gt;内核我现在认为可以给新人做得事&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/284099/&#34;&gt;https://lwn.net/Articles/284099/&lt;/a&gt;  这个帖子, 提供了新手可以做得事情, 我觉得非常好.&lt;br /&gt;
smatch coccinelle的分析结果.&lt;br /&gt;
源码中标注的FIXME和TODO, 简单的提过去很难被接受, 难的这些开发者自己都没搞定, 新人更难.&lt;br /&gt;
这也不是一条好路.&lt;br /&gt;
内核bugzilla kerneloops上问题, 这个很难.&lt;br /&gt;
找一个和内核相关的工作驱动啊, 网络开发, 虚拟化, 存储都非常赞.&lt;br /&gt;
自己搞个feature, 感觉更难, 这个需要需求驱动.&lt;br /&gt;
没有一条轻松的路让你走, 但你却不应该光着脚走在上面!!!&lt;br /&gt;
内核之外有很多值得珍惜的. 尽力做好, 你能做的, 开始点滴积累.&lt;br /&gt;
终有一天会聚成沧海, 前提是你等得到那天, 不要亏待自己.&lt;br /&gt;
内核之路始终时不那么清晰, 但是反思过后, 你便知道, 该去做什么了.&lt;br /&gt;
这也许是最难受的情况了.&lt;br /&gt;
Linus 之前说过, 搞得内核你得用起来. uml 是个不错的开端.&lt;br /&gt;
用起来才是王道!&lt;/p&gt;

&lt;p&gt;#git&lt;br /&gt;
&lt;a href=&#34;http://git-scm.com/docs/gittutorial&#34;&gt;gittutorial - A tutorial introduction to Git&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;linux-source-code&#34;&gt;linux source code&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kernel.org/doc/man-pages/linux-next.html&#34;&gt;Working with linux-next&lt;/a&gt;&lt;br /&gt;
要add git://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git不是https.&lt;br /&gt;
我之前改了好多bug基于linus的分支, 提交后被告知别人已改. 后来Julia告诉我要基于linux-next开发.&lt;br /&gt;
我的linux next remote 就叫next, 基于其创建开发分支.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git branch now next/master
git pull next master:now
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;你提patch-社区的困惑是什么&#34;&gt;你提patch, 社区的困惑是什么?&lt;/h1&gt;

&lt;p&gt;每个kernel newbie 都应该完整看完这个mail list&lt;br /&gt;
&lt;a href=&#34;http://thread.gmane.org/gmane.linux.kernel/683798/focus=684297&#34;&gt;http://thread.gmane.org/gmane.linux.kernel/683798/focus=684297&lt;/a&gt;&lt;br /&gt;
你能看到鹰派的Al还有温和派Andrew Morton.&lt;br /&gt;
为什么&lt;a href=&#34;http://kernelnewbies.org/这么重要网站&#34;&gt;http://kernelnewbies.org/这么重要网站&lt;/a&gt;, 不做的好一点, 至少界面友好点.&lt;br /&gt;
应该找个机会, 整一下.&lt;/p&gt;

&lt;h1 id=&#34;fix-kernel-mistakes&#34;&gt;Fix kernel mistakes&lt;/h1&gt;

&lt;p&gt;内核至今如此优秀就是因为, 成千上万前赴后继的开发者笔耕不缀的结果.&lt;br /&gt;
别当豆包不当干粮, 虽然, 你不能设计出很牛的算法, or 什么子系统,&lt;br /&gt;
但是内核还有很多问题有待解决, 正所谓老虎也要打, 苍蝇也要拍; 千里之堤毁于蚁穴.&lt;br /&gt;
我提过好些这种patch Dan Carpenter都告诉我Linus已经改了.&lt;/p&gt;

&lt;h2 id=&#34;kernel-newbie上有个list&#34;&gt;kernel newbie上有个list&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://kernelnewbies.org/KernelJanitors/Todo&#34;&gt;KernelJanitors/Todo&lt;/a&gt;&lt;br /&gt;
* Style fix&lt;br /&gt;
如:&lt;br /&gt;
remove_wait_queue(entry-&amp;gt;wait_address,&amp;amp;entry-&amp;gt;wait);&lt;br /&gt;
remove_wait_queue(entry-&amp;gt;wait_address, &amp;amp;entry-&amp;gt;wait);&lt;/p&gt;

&lt;h2 id=&#34;smatch&#34;&gt;Smatch&lt;/h2&gt;

&lt;p&gt;smatch这个工具是Dan写的主要就是为了找到内核的小问题, 基本用法:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    make CHECK=&amp;quot;~/path/to/smatch/smatch -p=kernel&amp;quot; C=1 \
            bzImage modules | tee warns.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;smatch 会产生好多可疑的问题, 细心寻找吧.&lt;br /&gt;
你找到了, 那么就是修改了.&lt;br /&gt;
记住在smatch之前一点要git pull next master:now一下, 保证checkout到了now的分支.&lt;/p&gt;

&lt;h2 id=&#34;coccinelle&#34;&gt;Coccinelle&lt;/h2&gt;

&lt;p&gt;Coccinelle是 Julia Lawall 写的静态检测工具.very nice.&lt;br /&gt;
自己研究吧&lt;br /&gt;
Documentation/coccinelle.txt&lt;br /&gt;
&lt;a href=&#34;http://pagesperso-systeme.lip6.fr/Julia.Lawall/tutorial.pdf&#34;&gt;http://pagesperso-systeme.lip6.fr/Julia.Lawall/tutorial.pdf&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;生成patch&#34;&gt;生成patch&lt;/h2&gt;

&lt;p&gt;先修改.&lt;br /&gt;
之后git add&lt;br /&gt;
在commit 之前你要 git log &amp;ndash;online path/to/modification/file&lt;br /&gt;
看下提交的titile:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git log  --oneline drivers/base/firmware_class.c
5455c8c firmware: Fix memory leak in error path
e0fd9b1 firmware: use const for remaining firmware names
f9692b2 firmware: fix possible use after free on name on a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主义冒号:后一定要有一个空格!&lt;br /&gt;
你会还是看下Document下的submitting的文档.&lt;br /&gt;
之后commit:&lt;br /&gt;
先是类似上面的一行oneline 简要说明&lt;br /&gt;
空一行.&lt;br /&gt;
之后具体描述下.&lt;br /&gt;
commit后, 生成patch&lt;br /&gt;
如果你只提交了一次:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git format-patch HEAD^..HEAD
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个命令就ok了.&lt;br /&gt;
如果commit多次, 自己斟酌两次diff的commit id了, HEAD^ 和HEAD都是commit id.&lt;br /&gt;
这样就生成了patch, 一般叫做0001-xxx-ooo.patch之类的&lt;br /&gt;
如我这个, 已被接收:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0001-firmware-Fix-memory-leak-in-error-path.patch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;commit id 是5455c8c3284a63e2673d1be7f040fb245cbf9be9&lt;/p&gt;

&lt;h2 id=&#34;测试patch&#34;&gt;测试patch&lt;/h2&gt;

&lt;p&gt;复杂的patch要编译内核, 安装的机器上跑一下.&lt;/p&gt;

&lt;h2 id=&#34;发送patch&#34;&gt;发送patch&lt;/h2&gt;

&lt;p&gt;天朝用户自己打梯子吧proxychains shadowsocks.&lt;br /&gt;
基本步骤是&lt;br /&gt;
先编译一下:&lt;br /&gt;
make path/to/modification/file.o&lt;br /&gt;
之后&lt;br /&gt;
./scripts/checkpatch.pl&lt;br /&gt;
之后 get maintainer&lt;br /&gt;
./scripts/get_maintainer.pl&lt;/p&gt;

&lt;p&gt;发送的时候, 发给维护者 &amp;ndash;cc其他人, 还有cc 一个mailist, 如果没有合适的list的话,&lt;br /&gt;
就cc到linux-kernel@vger.kernel.org, 这是个开放的list, 有合适的list了, 就不要cc它了.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;proxychains git send-email --to ming.lei@canonical.com --cc gregkh@linuxfoundation.org --cc kernel-janitors@vger.kernel.org 0001-firmware-Fix-memory-leak-in-error-path.patch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;免不了你要返工重新修改.这时候, 新生成的patch这样:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git format-patch --subject-prefix=&amp;quot;PATCH v2&amp;quot; HEAD^..HEAD
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改几次就v几.&lt;br /&gt;
和社区交流的时候, 要注意礼貌, 而且要感谢别人对你的patch做出的建议,&lt;br /&gt;
没有人的时间是被猪拱来的.&lt;/p&gt;

&lt;p&gt;这些都是比较简单(代码量上)的patch, 要想提交深度的还需要对某方面的深度.&lt;br /&gt;
基本上这就完了, 你的真正的patch就给社区了.&lt;/p&gt;

&lt;h1 id=&#34;进阶decent&#34;&gt;进阶decent&lt;/h1&gt;

&lt;p&gt;这个是昨天晚上改drivers代码时候, 看到TODO的注释猛然想到的.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grep -nr &#39;FIXME&#39; --include=&amp;quot;*.c&amp;quot;  ./ | tee fixmek.log
grep -nr &#39;TODO&#39; --include=&amp;quot;*.c&amp;quot; ./ | tee todok.log
wc -l fixmek.log 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有6000多个.&lt;/p&gt;

&lt;h1 id=&#34;deeply-involved&#34;&gt;Deeply involved&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://vger.kernel.org/~davem/net_todo.html&#34;&gt;http://vger.kernel.org/~davem/net_todo.html&lt;/a&gt;&lt;br /&gt;
这个列表上的基本都过期了&amp;hellip;.哎&lt;br /&gt;
往深了走不是难事, 主要是意识到内核, 不是什么神秘的东西, 选好一个方向&lt;br /&gt;
简单看看概念见我的&amp;lt;如何学习&amp;gt; 就可以实践.&lt;br /&gt;
必须要意识到, 动手比看再多概念管用, 我就是之前看了太多, 还发展出一个哲学&lt;br /&gt;
体系出来:-) 确实随着现代信息科学给社会带来的巨大变化, 哲学也必须要更新.&lt;br /&gt;
才能更好的服务于人.&lt;br /&gt;
这几天就在, 找内核哪里还不完善, 自己能补上, 今天6号了.&lt;br /&gt;
#patch formate advices&lt;br /&gt;
* Julia Lawall Sorry to be picky,&lt;br /&gt;
but normally people put a space after the colon.  Also,&lt;br /&gt;
the subject line could be shorter: Remove unneeded cast.&lt;br /&gt;
The description part of the subject doesnt have to be unique,&lt;br /&gt;
just the whole thing, asfter the [PATCH] part.&lt;br /&gt;
* Dan Carpenter&lt;br /&gt;
Otherwise your patch was fine, btw.  Other improvements.&lt;br /&gt;
Don&amp;rsquo;t put &amp;ldquo;Drivers:&amp;rdquo; in the subject.&lt;br /&gt;
On Wed, Apr 22, 2015 at 09:10:50PM +0800, Firo Yang wrote:&lt;br /&gt;
&amp;gt; From: Firo Yang &lt;a href=&#34;mailto:firogm@gmail.com&#34;&gt;firogm@gmail.com&lt;/a&gt;&lt;br /&gt;
Don&amp;rsquo;t include this line.  We can get it from you email address.&lt;/p&gt;

&lt;p&gt;Include everyone from the ./scripts/get_maintainer.pl output except&lt;br /&gt;
don&amp;rsquo;t include linux-kernel@vger.kernel.org if there is another mailing&lt;br /&gt;
list there already.&lt;br /&gt;
* To find  patch prefix&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git log --oneline  path/to/file.c
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;更新patch 要加v几&lt;/p&gt;

&lt;p&gt;git format-patch &amp;ndash;subject-prefix=&amp;ldquo;PATCH v2&amp;rdquo; xxx..ooo&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;提交多个patch 要手动生成一个[PATCH 0/N], 这个0就是要写简要描述的.&lt;/p&gt;

&lt;p&gt;proxychains git send-email &amp;ndash;subject &amp;ldquo;[PATCH v2 0/15] Remove unneeded casts of memory-alloc function return values&amp;rdquo; &amp;ndash;thread &amp;ndash;compose &amp;ndash;confirm=compose &amp;ndash;to firogm@gmail.com *.patch&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Dave Miller偏好&lt;br /&gt;
@@ -325,13 +325,15 @@ static inline void empty_child_dec(struct key_vector *n)&lt;br /&gt;
static struct key_vector *leaf_new(t_key key, struct fib_alias *fa)&lt;br /&gt;
{&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;struct tnode *kv = kmem_cache_alloc(trie_leaf_kmem, GFP_KERNEL);&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;struct key_vector *l = kv-&amp;gt;kv;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;struct tnode *kv;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;struct key_vector *l;&lt;br /&gt;
Dave Miller usually prefers it if variables are ordered from longest to shortest.&lt;br /&gt;
So you should probably have l defined first, and then kv.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Computer science a kernel programmer&#39;s perspective</title>
      <link>http://firoyang.org/cs/cs/</link>
      <pubDate>Fri, 27 Feb 2015 15:46:14 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/cs/</guid>
      <description>

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.bravegnu.org/gnu-eprog/&#34;&gt;Vijay Kumar B&amp;rsquo;s Embedded Programming with the GNU Toolchain&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;arch-of-cs&#34;&gt;arch of cs&lt;/h1&gt;

&lt;p&gt;design(pattern) and algorithm, programming(debugging, hacking)&lt;br /&gt;
pl,assembly, compile(gcc), link, load(cll)&lt;br /&gt;
process, quantaties, order(synchronization)&lt;br /&gt;
turing, arch, os(boot, console, fedora, fs, process, mm, pm, time, virt, synchronization)&lt;br /&gt;
math, logic, electronics&lt;/p&gt;

&lt;h1 id=&#34;the-architecture-of-computer-science&#34;&gt;The Architecture of Computer science&lt;/h1&gt;

&lt;p&gt;SICP states that cs focuses on process.&lt;br /&gt;
What process is is the set of changes and quantaties.而这些changes 和 quantaties live in model of computation.&lt;br /&gt;
我们可以说一个process就是一个从属于model of computation的changes和quantaties的一次排列和集合.&lt;br /&gt;
所以model of computation至少是change的集合 和 quantaty的集合的集合.processess 本身就是暗含着data/quantaties的.&lt;br /&gt;
Why can  processes being? It&amp;rsquo;s model of computation.&lt;br /&gt;
这就是cs的form, process和model of computation. What is the material of cs?&lt;br /&gt;
cs 的material 是symbolic.&lt;br /&gt;
For now, we have noticed that the form of cs is changes and quantities.&lt;br /&gt;
And the material of cs is symbolic(or, symbolic system).&lt;br /&gt;
Both form and material are properties of being/abyss.&lt;br /&gt;
人类的思维使用多种materials(vision, animation, graphics,or, feelings)去express a concept。&lt;br /&gt;
可以说程序设计语言就是标准描述 process的Semiotic system。&lt;br /&gt;
所以， pl对process的elements or origins做了合适的描述。&lt;br /&gt;
sicp研究的符号规则层面的process 和 data。 design pattern研究的是语义层面的。&lt;br /&gt;
PL 给了我们一种视角, 从process的元素的角度去描述process.&lt;br /&gt;
form language(BNF-&amp;gt;syntax, regex-&amp;gt;lexical)藐视pl的语法.&lt;br /&gt;
form language可以通过automata鉴别.automata等价于form system lambda calculus.&lt;br /&gt;
自动机被相应的form grammar分类.&lt;br /&gt;
我们的目的是规范化人类思维的表达形式.以此来达到交流, 具现化.&lt;br /&gt;
我们要明白, pl的所有内容都是围绕the set of changes and quantaties建立的,&lt;br /&gt;
也就是说pl是能指, 而所指便是the set of changes and quantaties.&lt;br /&gt;
syntax句法不是我们关注的, 我们关注的是semantic.从semantic角度去尽可能的描述changes和quantaty.&lt;br /&gt;
quantaties and changes: type system&lt;br /&gt;
我们给quantaties附上特定的类型, 表达特定的含义,&lt;br /&gt;
primitive expression: 数学量, 符号学字符, function&lt;br /&gt;
combination: compound elements&lt;br /&gt;
abstraction: name an elements&lt;br /&gt;
relation: inference, relaton of changes, Flow Diagrams, Turing Machines And Languages With Only Two Formation Rules;&lt;br /&gt;
也就是Jhone Locke的binary relation.&lt;br /&gt;
process 可以看成人的意志力展示.origins加入interence不关注changes. logic就是研究过程/changes和过程/changes之间的关系.&lt;br /&gt;
control flow描述设定的就是这种order/relation.核心不在于有没有if else, 而是是否有足够的表达能力.&lt;br /&gt;
表达changes之间的relation/order.可能是一种图的感觉, 就比如if else引起了tree这种order的产生.&lt;br /&gt;
也就是说语言的表达力. changes要类似automata的四通八达的感觉.&lt;br /&gt;
process由 changes, inference/relation, quantaties组成.因为这是由人的意志will 参与的process.&lt;br /&gt;
inference 强调的是order of changes/computation,也就是control flow.&lt;br /&gt;
Why does the order of execution matter?&lt;br /&gt;
Then we need programming:sicp c3(c2/c1)&lt;br /&gt;
then interpreter: sicp c4&lt;br /&gt;
compile link load&lt;br /&gt;
computation model: sicp c5&lt;br /&gt;
if else: 表示的是relation(changes之间的关系, order, causality, inference)&lt;br /&gt;
也就是说pl包含:&lt;br /&gt;
changes, quantaties, relation. 这几种表述.&lt;br /&gt;
pl和machine/model of computation近乎等价, progrm是machin的超集. program 是process.而pl不是.&lt;br /&gt;
所以pl和machine都对process有表达的能力.pl和machine的form一致, 但material不同. 他们都是process元素的集合.&lt;br /&gt;
programming是排列组合这些process elements的craft.可以说这些元素是data, 可以转变为process.&lt;br /&gt;
这里面我们就定义programmer的skills, crafts, 是一种排力组合的能力, 不严禁的通俗的理解.&lt;br /&gt;
design pattern 更注重宏观process. 他们排布process. 单这些process是处理别的process.high-order process(procedure?)&lt;br /&gt;
而algorithm, 可以认为是关注的是primitive/ process.&lt;br /&gt;
图灵机加入的&amp;rdquo;感知&amp;rdquo;,正是laking of causal.&lt;br /&gt;
之于表述computational process, 认为(hypothesis?)自然语言和pl是具有相同能力的.&lt;br /&gt;
programming的目的之一是把思维结果转为pl形式表达出来.&lt;br /&gt;
另外, 我们现在能总结出, cs的两大主题就是:the form of process and how to express more better.&lt;br /&gt;
process的内在, 以及如何表达process.cs剩下的问题都是programmer 码农的问题.&lt;br /&gt;
现在我们来研究纯粹的process.继承sicp的定义.&lt;br /&gt;
procedure是process的体现. process &amp;gt;= procedure. 所谓的local evolution, 等价于c,lisp的function.&lt;br /&gt;
procedure 是一changes(quantaties, relation)有限的集合.&lt;br /&gt;
一个process可以包含多个procedure, 也可以只有一个procedure(如, 递归, 迭代).&lt;br /&gt;
还有另外一个就是data.process和data唇亡齿寒.&lt;br /&gt;
process: procedure, computation/changes.&lt;br /&gt;
data-&amp;gt;: compound data, quantaty.&lt;br /&gt;
我们研究的重点似乎时relation吧?&lt;br /&gt;
process和data既像一物两面, 又像唇亡齿寒.&lt;br /&gt;
下面开始,&lt;br /&gt;
从combination, abstraction, relation这三个方面属性的process.&lt;br /&gt;
从简单到复杂, 先关注process.&lt;br /&gt;
如果process只有一个procedure.  elementary process.&lt;br /&gt;
似乎我们可以得到一个关于process的坐标系: procedure 的种类和数量.&lt;br /&gt;
这里, 我们不关注algorithm.&lt;br /&gt;
这里, 关注design pattern, GoF, elemental design pattern, POSA.&lt;br /&gt;
从坐标系角度只考虑process和process之间的关系:&lt;br /&gt;
1 只有一种quality的procedure, 完成的process.&lt;br /&gt;
那么数量上如果构成大于1, 也就是procedure call procedure.&lt;br /&gt;
可以是iteration or recursion; 我门的坐标系反应不出来.&lt;br /&gt;
需要另外一个属性, procedure 自身是否是运算的参数.&lt;br /&gt;
坐标系改下, procedure的数量换成procedure是否参与运算. 如果参与computation就是递归.&lt;br /&gt;
默认procedure 数量&amp;gt;=2.&lt;br /&gt;
我们再一次发现, procedures之间可能并不是直接调用的.&lt;br /&gt;
所以一个小坐标系, 能表达的太有限, 要废弃掉.从属性角度看.但可以明确procedures出现次数是2个以上.&lt;br /&gt;
当然, 我们是从process角度分析问题的.&lt;br /&gt;
只有一种procedure,&lt;br /&gt;
* call/order relation&lt;br /&gt;
参与 computaton 是 recursive, otherwise, iteration.&lt;br /&gt;
iter(a,i, n)&lt;br /&gt;
if (i&lt;n)
 a = a * (a +1)
 i++;
 return iter(a, i, n)//tail call&gt;&lt;br /&gt;
看来这个问题的实质是process是否作为计算的对象.而recursive和iteration是某个general的特例.&lt;br /&gt;
loose relation: sequence(特例iteration), 是computation之间的关系.&lt;br /&gt;
strict relation: computation是内在的关系. computation被抽象data&lt;br /&gt;
primitive computation可以调function, function可以调primitive computation.&lt;br /&gt;
computation function 经过抽象变成data.data反过来又可构成computation.&lt;br /&gt;
可以说没有data, 全是computation!?那这么说(所谓的&amp;rdquo;recursive&amp;rdquo;, 就司空见惯了.)&lt;br /&gt;
function反应的是computation 序列集合.自身调用自身, 首先满足这种 order sequence的关系.&lt;br /&gt;
似乎称之为recursive是没问题的. 但一个只能反应sequence, or和sequence等价的&amp;rdquo;recursive&amp;rdquo;.&lt;br /&gt;
又有多大价值呢?recursive意义又有多大呢? 究竟, process的核心是什么呢? 是computation.&lt;br /&gt;
回答显示世界的recursive, 一个画面不断重复自身的画面!&lt;br /&gt;
&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/6/62/Droste.jpg&#34; alt=&#34;recursion&#34; /&gt;&lt;br /&gt;
我们发现, 他们总是在表达一个完整的个体.&lt;br /&gt;
画面的recursion, 依然在一个画面下.&lt;br /&gt;
function的recursion, 确实表现在一个function内.&lt;br /&gt;
但是从computation角度, recursive的function表述的是computation的连续sequence.&lt;br /&gt;
也就是说recursion是有对象的,对于process是computation是对象.&lt;br /&gt;
对于recursion process, 只有一个computation, 而iteration的process是多个computation的order/sequence集合.&lt;br /&gt;
所以要区分computation和procedure/function. function是computation和sequence集合.他反应的是computation之间的关系.&lt;br /&gt;
并不能反应computation自身内在关系.这也是我们混淆了recursion procedure的原因.&lt;br /&gt;
想想, 集合的复合还是computation sequence. 而computation自身的复合却是一个computation,自身的演变.&lt;br /&gt;
让我们体悟到了function和computation的区别.不同对象的交互operation差异.&lt;br /&gt;
对函数的讨论研究等价与, 讨论computation之间的关系.也就是把function全部替换成了computation.&lt;br /&gt;
所以recursive function就成了不断内嵌sequence computation了, 递归全无.&lt;br /&gt;
computation 内在的组合, 我们讨论了, 相似对象/function的情况.&lt;br /&gt;
如果一个computation内部,是由不同computation组成的.就是非递归的情况,edp叫Conglomeration.合理&lt;br /&gt;
computation内在讨论先停下.&lt;br /&gt;
我们关注computations之间的关系.&lt;br /&gt;
无论是computation的内部还是,computation之间data都成了纽带.&lt;br /&gt;
我们只讨论具有relation的process/computation.&lt;br /&gt;
如果通过共同的操作的data,&lt;br /&gt;
这就是并发的问题, 也就是changes.&lt;br /&gt;
如果共同的data, 不是作为操作的对象知识表达一个relation.&lt;br /&gt;
这是能想到的通过data的processes/computations之间的交互.&lt;br /&gt;
似乎量changes/computation/process 之间的relation, 只能是&lt;br /&gt;
causality and synchronization?(FIXME).&lt;br /&gt;
Causality: Observer(发起者主动, 结果者被动), polling(结果者主动)&lt;br /&gt;
state pattern(发起者的状态), Strategy Pattern(根据对象的选择行为)&lt;br /&gt;
Command Pattern(?decoupling, 貌似就是个Observer不过把状态给了接收者处理),&lt;br /&gt;
Mediator Pattern(decoupling),&lt;br /&gt;
design pattern 关注的是form, syntax.&lt;br /&gt;
研究process/procedure/function/computation 到 data&lt;br /&gt;
 Simple Factory Pattern类似strategy pattern, 根据(接收者类型产生对象)&lt;br /&gt;
Factory Method Pattern类似(Mediator pattern, 将对象生成放给子类)&lt;br /&gt;
没有relation(or relationless)的process联系到一起.&lt;br /&gt;
adapter pattern&lt;br /&gt;
还有一种两个procedure concurrent, 要分开 order sequence化.&lt;br /&gt;
concurrent是design pattern等价的.&lt;br /&gt;
这样design pattern也融合进来了.&lt;br /&gt;
下面应该是SICP的chapter 3. chapter 3依然是对process的form的阐释和补全, 结合pl的语义进行挖掘.&lt;br /&gt;
另一方面结合具体的实现开始kernel相关的(可能涉及到hard ware), 分布式系统理解.&lt;br /&gt;
还有一个link load interpreter这方面的工作.&lt;/p&gt;

&lt;h1 id=&#34;programming&#34;&gt;programming&lt;/h1&gt;

&lt;p&gt;Abstraction is vital in helping us to cope with the complexity of&lt;br /&gt;
large systems.&lt;br /&gt;
Effective program synthesis also requires organizational principles that&lt;br /&gt;
can guide us in formulating the overall design of a program.&lt;br /&gt;
orgnizational principles应该是architecture pattern.&lt;br /&gt;
我理解的programming的核心应该是modeling, modeling最直接的体现就是architecture pattern.&lt;br /&gt;
相较于design pattern, ap更注重整体?&lt;br /&gt;
不对, 这块不能把ap直接加进来, 逻辑不严密, 不完整.就先叫op吧.&lt;br /&gt;
why modular,we are not creating something.&lt;br /&gt;
It&amp;rsquo;s just about the being.&lt;br /&gt;
abstraction is vital in helping us to cope with the complexity of&lt;br /&gt;
large systems. 通过抽象构造的material层级, 逐级清晰.&lt;br /&gt;
世界以我们所认为的那样方式运行着.&lt;br /&gt;
modular , that is, so that they can be divided “naturally” into co-&lt;br /&gt;
herent parts that can be separately developed and maintained.&lt;br /&gt;
I think it&amp;rsquo;s because of the form.&lt;br /&gt;
model as modeled, action in local.&lt;br /&gt;
object-based approach and the stream-processing approach&lt;br /&gt;
objec is the form of this world. what about stream?&lt;/p&gt;

&lt;p&gt;The difficulties of dealing with objects, change, and identity are a fundamental&lt;br /&gt;
consequence of the need to grapple with time in our computational models.&lt;br /&gt;
Concurrent 增加了更多的难度, 但只是double的关系不是quality上的.&lt;/p&gt;

&lt;p&gt;The stream approach can be most&lt;br /&gt;
fully exploited when we decouple simulated time in our model from the&lt;br /&gt;
order of the events that take place in the computer during evaluation.&lt;br /&gt;
We will accomplish this using a technique known as delayed evaluation .&lt;br /&gt;
stream 解耦了我模拟的时间和event的order.event有orderbut no time.&lt;br /&gt;
We don&amp;rsquo;t care time. 隐约中我们引入了另一个origin of world, time.&lt;br /&gt;
我想还是需要关心时间的只是在stream的form里面不存在时间了.&lt;br /&gt;
leak of causal is abstraction.&lt;br /&gt;
second origin, state, An object is said to “have&lt;br /&gt;
state” if its behavior is influenced by its history.&lt;br /&gt;
We can characterize an object’s state by one or more state vari-&lt;br /&gt;
ables.&lt;br /&gt;
有很多objects, 一些objects可能影响others&amp;rsquo;s state, couple the state variables.&lt;br /&gt;
modular 需要decomposed into computational objects modeling actual objects.&lt;br /&gt;
model指整体如substitution 和environment.&lt;br /&gt;
Each computational object must have its own lo-&lt;br /&gt;
cal state variables describing the actual object’s state.&lt;br /&gt;
我们用computational object model actual, 每个 computational object must have its own local state variales.&lt;br /&gt;
local state variables 描述actual object&amp;rsquo;s state. why local?&lt;/p&gt;

&lt;p&gt;If we choose to model the flow of time in the system by the elapsed time&lt;br /&gt;
in the computer, then we must have a way to construct computational&lt;br /&gt;
objects whose behaviors change as our programs run. In particular, if&lt;br /&gt;
we wish to model state variables by ordinary symbolic names in the&lt;br /&gt;
programming language, then the language must provide an assignment&lt;br /&gt;
operator to enable us to change the value associated with a name.&lt;br /&gt;
从state variables 扯到 assignment operator.&lt;br /&gt;
因为state variables是记录actual objects的state的, state可能随时间改变.&lt;br /&gt;
我们必须改变state variables, 就需要assignment operator.表述一个关系, change.&lt;br /&gt;
一个对象自己的state variables 被称为 local?&lt;br /&gt;
形参?&lt;br /&gt;
massage passing 类似strategy pattern&lt;/p&gt;

&lt;p&gt;From the point of view of one part of a complex process, the other&lt;br /&gt;
parts appear to change with time. They have hidden time-varying local&lt;br /&gt;
state. If we wish to write computer programs whose structure reflects&lt;br /&gt;
this decomposition, we make computational objects (such as bank ac-&lt;br /&gt;
counts and random-number generators) whose behavior changes with&lt;br /&gt;
time. We model state with local state variables, and we model the changes&lt;br /&gt;
of state with assignments to those variables.&lt;br /&gt;
整体上, a process, one part 看另外一面是&lt;br /&gt;
A process hide time-varying local state in modular, but with a changes behavior. encapuslation.&lt;br /&gt;
= changes, variable states&lt;/p&gt;

&lt;p&gt;In general, programming with assignment forces us to carefully consider the relative orders&lt;br /&gt;
of the assignments to make sure that each statement is using the correct&lt;br /&gt;
version of the variables that have been changed. is issue simply does&lt;br /&gt;
not arise in functional programs.&lt;/p&gt;

&lt;p&gt;函数调用对应的是substitution model&lt;br /&gt;
model of evaluation&lt;br /&gt;
environments&lt;br /&gt;
An environment is a sequence of frames . Each frame is a table (pos-&lt;br /&gt;
sibly empty) of bindings , which associate variable names with their cor-&lt;br /&gt;
responding values. (A single frame may contain at most one binding&lt;br /&gt;
for any variable.) Each frame also has a pointer to its enclosing environ-&lt;br /&gt;
ment , unless, for the purposes of discussion, the frame is considered to&lt;br /&gt;
be global . e value of a variable with respect to an environment is the&lt;br /&gt;
value given by the binding of the variable in the first frame in the en-&lt;br /&gt;
vironment that contains a binding for that variable. If no frame in the&lt;br /&gt;
sequence specifies a binding for the variable, then the variable is said to&lt;br /&gt;
be unbound in the environment.&lt;br /&gt;
所以programming实际讨论的是意义的问题.不是某种形式&lt;br /&gt;
3.4&lt;br /&gt;
e central issue lurking beneath the complexity of state, sameness,&lt;br /&gt;
and change is that by introducing assignment we are forced to admit&lt;br /&gt;
time into our computational models. Before we introduced assignment,&lt;br /&gt;
all our programs were timeless, in the sense that any expression that&lt;br /&gt;
has a value always has the same value.&lt;br /&gt;
so time is changing.&lt;br /&gt;
the execution of assignment&lt;br /&gt;
statements delineates&lt;br /&gt;
moments in time when values change. e result of evaluating an ex-&lt;br /&gt;
pression depends not only on the expression itself, but also on whether&lt;br /&gt;
the evaluation occurs before or aer these moments. Building models&lt;br /&gt;
in terms of computational objects with local state forces us to confront&lt;br /&gt;
time as an essential concept in programming.&lt;br /&gt;
we use assignmnet to record state/history.&lt;br /&gt;
We implemented the time variation of the states of the model objects in the computer&lt;br /&gt;
with assignments to the local variables of the model objects.&lt;br /&gt;
必须意识到change被modeled 到assignment.&lt;br /&gt;
model change in terms of sequences&lt;br /&gt;
list sequence is inefficient than the standard iterative style.&lt;br /&gt;
Streams are a clever idea that allows one to use sequence manipu-&lt;br /&gt;
lations without incurring the costs of manipulating sequences as lists.&lt;br /&gt;
With streams we can achieve the best of both worlds: We can formu-&lt;br /&gt;
late programs elegantly as sequence manipulations, while aaining the&lt;br /&gt;
efficiency of incremental computation.&lt;br /&gt;
stream 比list好,elegantly as sequence manipulation, efficiency as incremental computation.&lt;br /&gt;
(delay ⟨ exp ⟩ ) delayed object很有趣, 类似Brandon的enhanced greensight.连接是空, 穿越时空.&lt;/p&gt;

&lt;h1 id=&#34;chapter-4-metalinguistic-abstraction&#34;&gt;Chapter 4 Metalinguistic abstraction&lt;/h1&gt;

&lt;p&gt;It is no exaggeration to regard this as the most fundamental idea in&lt;br /&gt;
programming:&lt;br /&gt;
e evaluator, which determines the meaning of expres-&lt;br /&gt;
sions in a programming language, is just another program.&lt;/p&gt;

&lt;p&gt;SICP, 暂时看到这里.&lt;br /&gt;
programming 是modeling. 看了sicp差不多了.&lt;br /&gt;
interpreter:&lt;br /&gt;
EOPL&lt;br /&gt;
PLAI&lt;br /&gt;
&lt;a href=&#34;http://papl.cs.brown.edu/2016/&#34;&gt;http://papl.cs.brown.edu/2016/&lt;/a&gt;&lt;br /&gt;
另外PL也到这里吧.&lt;br /&gt;
source code写出来如何让run?&lt;br /&gt;
&lt;a href=&#34;https://www.zhihu.com/question/19918532&#34;&gt;弱类型、强类型、动态类型、静态类型语言的区别是什么？&lt;/a&gt;&lt;br /&gt;
c语言是弱类型语言的意思是：它的类型是给编译器看的，让编译器在初次分配内存的时候好分配一个指定大小的空间。在实际操作中你可以随意更改变量的类型（强制或自动）。&lt;br /&gt;
c语言实际是对内存直接操作的一门语言。也就是说如果给你四个字节的内存，你喜欢把它当成int来操作也行，当成四个char操作也行，随你喜欢。&lt;br /&gt;
&lt;a href=&#34;http://stackoverflow.com/questions/430182/is-c-strongly-typed&#34;&gt;Is C strongly typed?&lt;/a&gt;&lt;br /&gt;
I spent a few weeks, about a year ago, trying to sort out the terminology of &amp;ldquo;strongly typed,&amp;rdquo; &amp;ldquo;statically typed,&amp;rdquo; &amp;ldquo;safe,&amp;rdquo; etc., and found it amazingly difficult. As your message points out, the usage of these terms is so various as to render them almost useless. &amp;ndash;Benjamin C. Pierce&lt;/p&gt;

&lt;h1 id=&#34;program-execution&#34;&gt;program execution&lt;/h1&gt;

&lt;p&gt;run的目的是source code 对应到ISA.&lt;br /&gt;
最容易想到的就是compilation.&lt;br /&gt;
我们把compilation和interpreter当成从source code 到runnable program之间的某种form的变化.&lt;br /&gt;
先略过compilation, 也就是我们现在编译出了最简单形式的一个程序foo 输出hello world用到了一个新lib.&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/631631/&#34;&gt;How programs get run: ELF binaries&lt;/a&gt;&lt;br /&gt;
我们知道了个大概, 那么我们最关心的事, 现在lib和foo都进入内存了, 那么foo是如何调用到lib的函数.&lt;br /&gt;
原来是直接利用address_space 最memory map private就共享了.&lt;br /&gt;
不需要显示维护library的list列表的.&lt;br /&gt;
这样程序就运行起来了.&lt;br /&gt;
硬件可以理解为programs的的interpreter. 理解为model of computations, 由set of changs and state/quantaties and relations 组成.&lt;br /&gt;
所以硬件也可以看成是抽象的! 只不过不能自动.&lt;br /&gt;
研究memory的是时候我们会区分到RAM和SRAM到电容和logic gates.也就是最终的实现.&lt;br /&gt;
这个时候, 我们发现material成了我们理解问题的所必须考虑的方面了.&lt;br /&gt;
也就是说理解到了电路这个层次, 我们就完成了standalone, Completeness的.&lt;br /&gt;
也就是hardware的material完成了我们的认知, 就是认知闭环了.&lt;br /&gt;
所以已经关注很多cpu的和process运行相关的指令, 对于理解lock锁(包括所谓的lockfree无锁)理解到硬件的material也是应该的.&lt;br /&gt;
为什么这么说? 如果不用关心到logic完整的material, 实际上我们不需要理解什么语言啊, computation model. 设计模式啊, 操作系统啊.&lt;br /&gt;
只要脑子想就够了.可是material也是being存在.也是有form的存在.&lt;br /&gt;
所以另外的, 很重要的就是, 我们不是理解hardware本身, 我们理解的是hardware背后的form!&lt;br /&gt;
form的内容就很少了.所以说学习要特别注意两点, form和completeness.&lt;br /&gt;
记住我们关心的不是hardware的material而是hardware的form.&lt;br /&gt;
所以说我们是为了完整complete form而不是material.&lt;br /&gt;
而实际上, 当我意识到所谓的form的存在的时候, hardware本身就成一种自然的延伸了.自然的被包括进学习的范围目标里面了(FIXME).&lt;/p&gt;

&lt;h1 id=&#34;os&#34;&gt;os&lt;/h1&gt;

&lt;p&gt;所以下面的os, 从一个整体的角度去看待computer, 实质善顺道把os相关, 有助于os理解的hardware的知识&lt;br /&gt;
也包含进来. 下面的思考包含常见的GNU Linux/Unix/Windows这些系统, 和distribute system.&lt;br /&gt;
在更general 的form下思考他们的form.&lt;br /&gt;
我们似乎根本就不在乎是否有hardware参与进来, 我们关注的只是form. 如果form本身是完整的. hardware是不需要的.&lt;br /&gt;
为什么hardware对我们是不需要的, 因为我们所构建的cs的真正基础是纯粹逻辑的(FIXME), 可能有部分内容依赖物理如晶振, 电路的delta时间.&lt;br /&gt;
所以说, 我几乎不需要hardware.&lt;br /&gt;
开始分析os, os包括userspace, application. 睡觉.&lt;br /&gt;
from this &lt;a href=&#34;https://www.bowdoin.edu/~sbarker/teaching/courses/spring14/slides/lec03.pdf&#34;&gt;ppt Last Class: OS and Computer Architecture&lt;/a&gt;&lt;br /&gt;
we know&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;OS Service&lt;/th&gt;
&lt;th&gt;Hardware Support&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Protection&lt;/td&gt;
&lt;td&gt;Kernel/user mode, protected instructions, base/limit registers&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Interrupts&lt;/td&gt;
&lt;td&gt;Interrupt vectors&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;System calls&lt;/td&gt;
&lt;td&gt;Trap instructions and trap vectors&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;I/O&lt;/td&gt;
&lt;td&gt;Interrupts and memory mapping&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Scheduling, error recovery,accounting&lt;/td&gt;
&lt;td&gt;Timer&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Synchronization&lt;/td&gt;
&lt;td&gt;Atomic instructions&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Virtual memory&lt;/td&gt;
&lt;td&gt;Translation look-aside buffers&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;特别是synchronization和atomic instructions这条, 貌似冥冥中, 体现出了我们想要的感觉.&lt;br /&gt;
就我所知道的&lt;a href=&#34;https://book.douban.com/people/firodb/all?sort=rating&amp;amp;start=0&amp;amp;tag=os&amp;amp;mode=grid&amp;amp;tags_sort=count&#34;&gt;几本OS的书&lt;/a&gt;, 基本都不符合我的思路. Operating Systems : Three Easy Pieces 这本还算可以吧.&lt;br /&gt;
有点心意, 但是达不到sicp的高度.&lt;br /&gt;
终于可以坐下来安心思考os了.上面的os书都是告诉你os有什么process, thread, memory management,&lt;br /&gt;
interrupt, IO等等, 而且讲的非常详细, 就好像他们真的是主角似得.&lt;br /&gt;
是的没错! os书里只关注这process, thread, scheduling, memory management, interrupt, IO之类的能干什么.&lt;br /&gt;
对, 尽量讲得很详细, 以为这样就好了. 可实际上呢? 学习者的思维, 全被那些符号填满, 同时思考的机会也&lt;br /&gt;
被剥夺了! 合理的os理解过程是什么样的呢? 我觉得还是从origins of world 往过来推导.&lt;br /&gt;
我们上来根本就不关心process 啊scheduling, memory management.IO, interrupt等等&lt;br /&gt;
我们最初有什么? 或者说, 我们正在做什么? 从origins 经过sicip.&lt;br /&gt;
只考虑最原始的情况, 为了完成computational process, 我们需要一个真实的model of computation.&lt;br /&gt;
我们有了他是relation(算术数学运算, order体现着结构上),  change(transfer, assignment), quantaties(state, memory)的集合.&lt;br /&gt;
我们为了, 完成一件事情编写了program开始运行. 似乎不太好想遇上了什么问题.&lt;br /&gt;
我们很容易想到让computer同时做量件事, 比如说两个人同时记日记.想当然, 我们也可以让一所学校的学生,&lt;br /&gt;
同时记日记.此时我们就意识到了, 要抽象下Process出来了, scheduling也来了. 同时我们也要统一管理set of states, memory了.&lt;br /&gt;
也有了IO, 我们要让内容输入进来, 显示出来.这都很好想.&lt;br /&gt;
我们要保证系统有序的运行动起来.我设计了datapath和control unit.&lt;br /&gt;
现在我们往回解释,也就是从interrupt之类到origins, 讨论the form.&lt;br /&gt;
interrupt对应的是什么?是relation, 准确说是建立order.&lt;br /&gt;
interrupt为什么不能运行长时间, 当然可以运行长时间.&lt;br /&gt;
我们把interrupt, 看成和Process是一类东西, 都是process, change的实例.&lt;br /&gt;
memory和fs对state set的管理.所以至少process要和memory 和fs关联&lt;br /&gt;
貌似就没了?这只是框架.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;form&lt;/th&gt;
&lt;th&gt;os&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;change, computation, transfer .&lt;/td&gt;
&lt;td&gt;instructions(memory,IO), Process, interrupt&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;relation, order&lt;/td&gt;
&lt;td&gt;synchronization/atomic, scheduling, interrupt&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;quantaties, state&lt;/td&gt;
&lt;td&gt;fs, memory, device, driver&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a href=&#34;http://web.cecs.pdx.edu/~walpole/class/cse513/slides/3.pdf&#34;&gt;test-and-set&lt;/a&gt;&lt;br /&gt;
test the lock, if false(nobody take it), then set the lock.&lt;br /&gt;
Test and test-and-set对TAS优化.&lt;br /&gt;
TAS bus lock, cache invalidation&lt;br /&gt;
TAS and TTAS is two different algorithms .&lt;br /&gt;
还需要面对contention, backoff and queue lock.&lt;br /&gt;
造成contention原因是什么, 就是cache.&lt;br /&gt;
因为lokc prefix的总线仲裁, 可以简单的按顺序来.&lt;br /&gt;
这样的话, concurrent, parallel涉及到的order就算是大概过了.&lt;br /&gt;
下面我们还是回到relation/order, change, quantaties上来.&lt;br /&gt;
这样我们用locality of reference and transfer/channel special/temporal.来解读了cache.&lt;br /&gt;
另外还有cache coherence.&lt;br /&gt;
我们把process, interrupt都看成computation.&lt;br /&gt;
而timeshareing 世界之源是作为process的基本属性, 解读了调度&lt;br /&gt;
memory subsystem 作为quantaties和state的管理比较直观.&lt;br /&gt;
fs和mm本质是一回事.&lt;br /&gt;
剩下一个IO, 就是transfer的实例化, 包括char, block, network device的驱动.&lt;br /&gt;
我们把peripheral device看成跟memory一样的东西也就是quantaties同时也涉及到了transfer&lt;br /&gt;
我们基本上把 整个os computer都包含进来了.&lt;br /&gt;
但还需要细节推理.&lt;br /&gt;
比如, fs:&lt;br /&gt;
我们要先有个文件file, 各种类型&lt;br /&gt;
mm 和fs都是quantaties的描述, 但根本却别在于fs是有人的参与的, 也就是说操作是要满足人的需求的.&lt;br /&gt;
这里fs包含了各种设备.mm是process和quantaties的关系. 而fs是人与quantaties的关系.&lt;br /&gt;
我们不考虑各种图形界面GUI, 只考虑最基础的linux console那种情况. 当然shell和linux console也要忽略掉.&lt;br /&gt;
从纯粹的使用场景出发, 我们是不关心什么具体的fs实现, 我们只关心具体的用户user如何操作几个or很多的文件.&lt;br /&gt;
最为真实的,实惠的, 基本的用户场景. 同样作为quantaties的mm是用数字标示quantaties的. 而且signifier根植&lt;br /&gt;
于电路版.而fs面对的对象是人, 而有自己的语言符号系统, 而且不能通过全部number记忆东西.&lt;br /&gt;
所以file要有个name, 文件多了, folder就有了, folder和folder之间就类似function之间调用.&lt;br /&gt;
也是体现的order.&lt;br /&gt;
我们发现folder和file这两个就能很好的描述用户使用了. 另外还有一个就是order, 不太被在意的.&lt;br /&gt;
现在fs就成了name的集合了并且那么之间都是线性的关系, 我们不考虑soft link.&lt;br /&gt;
我们来考虑下ln: a: hard link not allowed for directory. Why?&lt;br /&gt;
反证法如果我们允许hard link dir, 在不recursive情况下hard link ok. But 如果recursive怎么办?&lt;br /&gt;
soft link 也可能递归!所以recursive不是问题. 那么什么是&lt;br /&gt;
mkdir -p /tmp/a /tmp/a/b&lt;br /&gt;
如果&lt;br /&gt;
ln /tmp/a /tmp/la&lt;br /&gt;
怎么办, 就是递归.&lt;br /&gt;
ln /tmp/a/ /tmp/a/b/la1&lt;br /&gt;
toch /tmp/a/b/la1&lt;br /&gt;
貌似没理解到点子上.&lt;br /&gt;
现在用户哪里看到的就是多树.&lt;br /&gt;
开始fs.&lt;br /&gt;
有理由把dir和file看成一个东西.&lt;br /&gt;
下面file代表抽象了. file代表open, 就是用户面对的那个. 指向inode对应一个文件 inode连接address space backend.&lt;br /&gt;
那么问题来了, 就上面这个搓比的设计我们如何管理这些inode, file可以process弄个链表(大误, 数组)什么的好办.&lt;br /&gt;
如, struct file __rcu * fd-array[NR_OPEN_DEFAULT]; 这个可以理解. struct fdtable fdtab; 这个就不理解了.&lt;br /&gt;
不去管他. 我们如何组织inode, 比如我们打开是5本电子书, 7个文件, chrome, vim, 总之很多个文件, 那么这些inode怎么办?&lt;br /&gt;
最简单, 列个linked list就行.&lt;br /&gt;
in fs, namei stands for name interpreting,  the pathname lookup mechanisms (namei) by Feb-1997 T. Schoebel-Theuer&lt;br /&gt;
现在关于fs就make sense了.&lt;br /&gt;
关于open /dev, 参考dev&lt;em&gt;mount().&lt;/em&gt;. ramfs_mknod vfs_mknode&lt;br /&gt;
 drivers/base/devtmpfs.c &amp;lt;&lt;handle_create&gt;&amp;gt;&lt;br /&gt;
1. 从用户这个层面我们提供了dir 和 file, dir可以包含dir这三个concept涵盖住用户需求.&lt;/p&gt;

&lt;p&gt;内核一个file 对应一次open, 先walk link path 之后do_last(walk和last交互着来 in wile()) 先去dcache 找dentry,&lt;br /&gt;
(/dev 的dentry被pin住了, inode也建好了), 其他不在dcache找个empty dentry, 用父inode的iget之类操作&lt;br /&gt;
建个inode同时根据硬盘数据确定operation 类型.&lt;br /&gt;
我们发现:&lt;br /&gt;
2. file/ inode/ dentry是严格从属于fs的.&lt;br /&gt;
3. file -&amp;gt; dentry -&amp;gt; inode 这个顺序&lt;br /&gt;
4. inode决定了你的 fs之内的最高级别operations(如char ops). 进一步的(如tty 靠major minor)&lt;br /&gt;
5. special的inode不同于disk reglar 这种. 他们事先就created and pin dentry in core.&lt;br /&gt;
6. namei&lt;br /&gt;
7. lru&lt;br /&gt;
反观fs, sb和dentry是做骨架同inode是骨架的支撑, 不可缺少.&lt;br /&gt;
file是花拳绣腿. 有什么深刻的? 用户态松散的order和 transfer, quantaties 关系. dentry就是这种反应.&lt;br /&gt;
深刻1, 就是order 包含!&lt;br /&gt;
深刻2, 是什么, abstraction and function of everything(data, process)不同事物的抽象关系, 映射关系.&lt;br /&gt;
明天就是mm, 想对比fs关注与不同事物的组合, mm更纯粹, 也会涉及大quantaties的管理, 和disk之类应该有较大的相似性.&lt;br /&gt;
更能体现出quantaties.&lt;br /&gt;
cs 的fs的inode见 iput_final iput inode_add_lru list_lru_add(&amp;amp;inode-&amp;gt;i_sb-&amp;gt;s_inode_lru, &amp;amp;inode-&amp;gt;i&lt;em&gt;lru) .&lt;/em&gt;.&lt;br /&gt;
现在来看最后的mm.&lt;/p&gt;

&lt;h1 id=&#34;底层的transer&#34;&gt;底层的transer&lt;/h1&gt;

&lt;p&gt;io, polling, interrupting, network device的multi queue, 的性能提升.&lt;/p&gt;

&lt;h1 id=&#34;mm&#34;&gt;mm&lt;/h1&gt;

&lt;p&gt;首先, physical  memory 就是quantaties/states的集合, 没有什么好说的, DRAM的实现需要看下.&lt;br /&gt;
process要用到这些quantaties 如何分给他们, 分多少?&lt;br /&gt;
首先, 我们要统计下, 我们有多少内存, mem map, 内存 看page分块. 分配物理地址signifier. buddy system.&lt;br /&gt;
我们不知道process, 要多少, 不可能给他很多, 所以就是 Demand paging是被动的, 再有就是主动分配alloc的.&lt;br /&gt;
首先process是不应该关心物理的signifier, 他肯定是在写程序的时候有自己的一套, 标记quantaties的signifiers.&lt;br /&gt;
我们不关心, process自己如何组织他自己内部的signifiers, 但是我们知道他当然可能自己全权掌控, physicl signifiers,&lt;br /&gt;
所谓的real system.一单, 我们为了简单, 使用了internal的signifiers, 那么internal 到physical的转换必不可缺.&lt;br /&gt;
这里就要设计到relation的维护. 同时memory是作为disk的cache, 那么不可避免.&lt;br /&gt;
已知关于cache的问题:&lt;br /&gt;
1. 组织 如page cache radix tree.&lt;br /&gt;
2. cache coherence. 如page 和disk. pdflush&lt;br /&gt;
3. 还是lru&lt;br /&gt;
关于mm&lt;br /&gt;
1. relation, page table.&lt;br /&gt;
2. physical signifiers的管理, mem map buddy system.&lt;br /&gt;
3. 关于internal signifiers的管理, mem layout, vma之类的.&lt;br /&gt;
基本上os就差不多了. 另外, 还有碎角料, kernel mode切换, interface abi,api.&lt;br /&gt;
所以我们能从os遇到个种种问题中, 归纳出共性, 集中精力研究这些共性的, 重要的(性能角度)的问题, 得到他们的&lt;br /&gt;
本源origins of the world._.&lt;/p&gt;

&lt;p&gt;can we open a file in interrupt?&lt;/p&gt;

&lt;h1 id=&#34;the-advert-of-new-world-origin-performance&#34;&gt;the advert of new world origin - performance&lt;/h1&gt;

&lt;p&gt;cache: in order to improve performace, cache tries to reduce the access time of transfer of future.&lt;br /&gt;
buffer: What does buffer do? temporary(Not future) place for data,reducing access time of transfer and&lt;br /&gt;
maybe effiency of quantaties/times of transfer. 是确定的行为, 不同与cache的统计学原理.&lt;br /&gt;
time-sharing: multi-task from batch processing&lt;br /&gt;
prallel process: increas quantanties of process.&lt;/p&gt;

&lt;p&gt;现在我们以新的视角看待os演化过程， 即以process/change， quantaties/state， relation/order这些natural origin为wilds，&lt;br /&gt;
辅以will意志的origin:&lt;br /&gt;
performance/efficiency&lt;br /&gt;
Easy to use&lt;br /&gt;
Security/Protection/isolation&lt;br /&gt;
Reliability&lt;br /&gt;
Energy-efficiency&lt;/p&gt;

&lt;h1 id=&#34;memory-vm&#34;&gt;Memory VM&lt;/h1&gt;

&lt;p&gt;我们回头再看mm， vm的提出是为了解决。easy to use。&lt;br /&gt;
1. decoupling physical memory 符号集合。programmer 不需要关注底层细节。 任务转给操作系统。&lt;br /&gt;
2. VM相对物理内存增加了表达能力， 有了更多表达符号。着减少了swap or 不必要的页表抖动。&lt;br /&gt;
Not useful links, you may not read them:&lt;br /&gt;
&lt;a href=&#34;http://denninginstitute.com/pjd/PUBS/bvm.pdf&#34;&gt;BEFORE MEMORY WAS VIRTUAL&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://research.microsoft.com/en-us/um/people/gbell/CGB%20Files/Computer%20Structures%20Readings%20and%20Examples%201971.pdf&#34;&gt;Computer Structures: Readings and Examples &lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/contents.html&#34;&gt;Computer Structures: Readings and Examples html version&lt;/a&gt;&lt;br /&gt;
Chapter 10 One-level storage system is the first implemention of virtual memory mind.&lt;br /&gt;
VM address space 和physical memory address space， 本质上都是符号集合。 形象点说， 就是数字的集合。&lt;br /&gt;
32bit系统为例， 现在书上都是长条矩形标上0， 4GB， 容易让人产生狭隘的理解。 实际上， 所谓的0~4GB，只要你有这么多个标示，他们能被&lt;br /&gt;
computation这个符号系统理解。就可以， 比如0用香蕉图片， 1用汽车图片， 等等。显然数字最简洁了。&lt;br /&gt;
现在我们有了4GB的空间怎么用， 作为处理公共事务的kernel要占quantative states集合的一部分， ok。另外一部分给process。&lt;br /&gt;
1. kernel 和 user之间分。Linux TASK_SIZE. VM split, 同时copy between kernel and userspace.&lt;br /&gt;
2. 有了user VM space，开始布局memory layout。在load application时候。load_elf_binary&lt;br /&gt;
layout内每块区域都是个VMA。VMA a memory region如何组织&lt;br /&gt;
rb寻找可用的未分配的userspace VM地址空间.&lt;br /&gt;
list, for what? proc/self/maps show_tid_map-&amp;gt;show_map_vma  and core dump fill_files_note.&lt;br /&gt;
vm_pgoff, 文件内偏移不是VMA/Page内偏移, 0代表从文件开始处开始映射.&lt;br /&gt;
VMA in PAGE_SIZE unit&lt;br /&gt;
3. 现在vm space 已经划分出去了. 还没有和physical memory 还有disk 关联上。Demand paging,见page fault, filemap_fault.&lt;br /&gt;
4. 通过Demand paging 和page建立联系了. VM spaces/VMA, page, disk的关系, 何去何从?&lt;br /&gt;
我们得沿着自己的思路去思考. physial-pages-of-file/page-cache-entity/address_space.&lt;br /&gt;
首先一个file的pages的集合.address_space.page_tree + pagevec_lru 也就是 Page cache add_to_page_cache_lru.&lt;br /&gt;
page cache这个结构非常有意思. 众多的address_spaces 构成了分布式page_tree, 同时zone lruvec控制这个分布式page_trees里&lt;br /&gt;
那些page该evict.&lt;br /&gt;
我们先在总结下, load application到kernel, 建立各种VMA. access VMA出发demand paging.加入page cache可以正常用了.&lt;br /&gt;
根本不需要reverse mapping.&lt;br /&gt;
5. 如果page得到更新, pte也需要更新.比如page被evicted. pte必须invalid.&lt;br /&gt;
rerverse mapping建立都在__do_fault&lt;br /&gt;
For anon, check do_anonymous_page&lt;/p&gt;

&lt;p&gt;现在放眼在Physical memory.&lt;br /&gt;
performance: &lt;a href=&#34;https://lwn.net/Articles/254445/&#34;&gt;NUMA&lt;/a&gt;&lt;br /&gt;
PM自身符号集合管理.&lt;/p&gt;

&lt;p&gt;pg_data_t zone page&lt;br /&gt;
关于pte.pte尾端bit被复用, phys_pud_init prot.&lt;/p&gt;

&lt;h1 id=&#34;memory-initialization-onset&#34;&gt;Memory initialization onset:&lt;/h1&gt;

&lt;p&gt;先从bios 拿信息 main -&amp;gt; detect_memory save in boot_params.e820_map&lt;br /&gt;
之后real -&amp;gt; protected -&amp;gt; long mode&lt;br /&gt;
启动 protected? mode. &lt;a href=&#34;http://www.delorie.com/djgpp/doc/ug/basics/protected.html&#34;&gt;What does protected mode mean&lt;/a&gt;&lt;br /&gt;
setup_arch&lt;br /&gt;
setup_memory_map -&amp;gt; default_machine_specific_memory_setup // Save into struct e820map e820; from boot_params.e820_map. That&amp;rsquo;s all.&lt;br /&gt;
max_pfn = e820_end_of_ram_pfn(); // max_pfn  BIOS-e820: mem 0x0000000100000000-0x00000003227fffff usable and last_pfn = 0x322800(12840MB), so last_pfn is invalid address, use it with &amp;lt;.&lt;br /&gt;
mtrr update max_pfn, see &lt;a href=&#34;https://en.wikipedia.org/wiki/Processor_supplementary_capability&#34;&gt;Processor supplementary capability&lt;/a&gt;&lt;br /&gt;
trim_low_memory_range // reserve 64k&lt;br /&gt;
max_low_pfn = e820_end_of_low_ram_pfn(); //4GB以下的end of block&lt;br /&gt;
memblock_x86_fill// copy e820 to memblock, reconstructs direct memory mapping and setups the direct mapping of the physical memory at PAGE_OFFSET&lt;br /&gt;
early_trap_pf_init //  X86_TRAP_PF, page_fault) =&amp;gt; do_page_fault&lt;br /&gt;
init_mem_mapping //set page table and cr3.&lt;br /&gt;
initmem_init ; NUMA init&lt;br /&gt;
x86_init.paging.pagetable_init();= paging_init //x86_64 -&amp;gt;zone_sizes_init-&amp;gt;&amp;hellip;free_area_init_core&lt;br /&gt;
mm_init&lt;br /&gt;
memblock the &lt;a href=&#34;https://0xax.gitbooks.io/linux-insides/content/mm/linux-mm-1.html&#34;&gt;implementations&lt;/a&gt; of memblock is quite simple. static initialization with variable memblock.&lt;br /&gt;
bootmem is discarded by &lt;a href=&#34;https://lkml.org/lkml/2015/12/21/333&#34;&gt;ARM&lt;/a&gt; and x86&lt;br /&gt;
a little history e820_register_active_region replaced by lmb &lt;a href=&#34;https://lkml.org/lkml/2010/7/13/68&#34;&gt;replaced by&lt;/a&gt; memblock&lt;br /&gt;
reserve_initrd ; // RAMDISK&lt;br /&gt;
总结下, 内存初始化需要的基础.&lt;br /&gt;
1. e820 get memory region.&lt;br /&gt;
2. set PF trap do_page_fault.&lt;br /&gt;
3. set page table and cr3.&lt;br /&gt;
这就完了. 之后开始开始加工.&lt;br /&gt;
arch 相关的x86_init.paging.pagetable_init = native_pagetable_init = paging_init -&amp;gt;&lt;br /&gt;
sparse_init&lt;br /&gt;
{&lt;br /&gt;
    memblock_virt_alloc // sizeof(struct page *) * NR_MEM_SECTIONS;NR_MEM_SECTIONS = 1 &amp;lt;&amp;lt; 19, Is it big?&lt;br /&gt;
    // alloc memory region will be marked in memory_reserved.&lt;br /&gt;
}&lt;br /&gt;
zone_sizes_init.&lt;br /&gt;
{&lt;br /&gt;
    calculate_node_totalpages // 每个zone的page数.&lt;br /&gt;
    free_area_init_node-&amp;gt; alloc_node_mem_map // alloc mem_map for FLAT&lt;br /&gt;
    free_area_init_core&lt;br /&gt;
    {&lt;br /&gt;
        calc_memmap_size // 1/4k of spanned or present used for memmap. heuristic?&lt;br /&gt;
        zone_pcp_init // init percpu pageset with boot_pageset&lt;br /&gt;
        set_pageblock_migratetype(page, MIGRATE_MOVABLE);// 512 per zone&lt;br /&gt;
        memmap_init_zone-&amp;gt; __init_single_page // init every page in a zone.&lt;br /&gt;
    }&lt;br /&gt;
}&lt;br /&gt;
arch independent,&lt;br /&gt;
build_all_zonelists&lt;br /&gt;
page_alloc_init // drain percpu pageset when cpu dead or dead frozen for CPU hotplug&lt;br /&gt;
mm_init&lt;br /&gt;
Zone watermarks core_initcall(init_per_zone_wmark_min)&lt;br /&gt;
基本上内存初始化,就到这里了.&lt;/p&gt;

&lt;h1 id=&#34;memory-pagge-cache-and-buffer-cache&#34;&gt;Memory pagge cache and buffer cache.&lt;/h1&gt;

&lt;p&gt;page cache for memory, buffer cache for fs(block size is dependent on filesystem).&lt;br /&gt;
address_pace-&amp;gt;page_tree: why radix tree, read ahead,&lt;br /&gt;
do_page_fault-&amp;gt;read_page&lt;/p&gt;

&lt;p&gt;For buffer cache: buffer cache is only a wrapper of page for fs operations.&lt;br /&gt;
buffer_head is temporary data released in a deeper function than the function allocing the buffer_head.&lt;br /&gt;
__block_write_full_page&lt;br /&gt;
block_read_full_page&lt;/p&gt;

&lt;p&gt;I can not cover every corner of kernel, so If need, I will learn it.&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Kernel/Index/#Memory_management-Writeback&#34;&gt;The coherency problem, fs-writeback&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/326552/&#34;&gt;Flushing out pdflush&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Kernel/Index/#Memory_management-Swapping&#34;&gt;Swapping&lt;/a&gt;&lt;br /&gt;
User space process: anonymous mapping(stack,heap,mmap), IPC-share memory(anonymous?), private mapping&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Kernel/Index/#Memory_management-Shrinkers&#34;&gt;Shrink cache&lt;/a&gt;&lt;br /&gt;
LRU cache&lt;/p&gt;

&lt;h1 id=&#34;processes-of-os&#34;&gt;processes of os&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://wiki.osdev.org/Exceptions&#34;&gt;Exceptions&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;if you do lidt in userspace program, you will receive SIGSEGV with si_code 128(somewhere of kernel).&lt;br /&gt;
But with the dmesg traps: int0x80[15066] general protection ip:4000c7 sp:7ffc8706cdf0 error:0 in int0x80[400000+1000] form do_general_protection.&lt;br /&gt;
Privilege instructions in V3a chapter 5 Protection&lt;br /&gt;
.data&lt;br /&gt;
    .quad msg&lt;/p&gt;

&lt;p&gt;msg:&lt;br /&gt;
    .ascii &amp;ldquo;Hello, world!\n&amp;rdquo;&lt;br /&gt;
    len = . - msg&lt;br /&gt;
saved_idt:&lt;br /&gt;
        .long 0,0&lt;/p&gt;

&lt;p&gt;.text&lt;br /&gt;
    .global _start&lt;/p&gt;

&lt;p&gt;_start:&lt;br /&gt;
    movl  $4, %eax&lt;br /&gt;
    movl  $1, %ebx&lt;br /&gt;
    movl  $msg, %ecx&lt;br /&gt;
    sidt  saved_idt&lt;br /&gt;
    lidt  saved_idt  ;===============&amp;gt; crashed at here&lt;br /&gt;
    movl  $len, %edx&lt;br /&gt;
    int   $0x80&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;movl  $1, %eax
xorl  %ebx, %ebx 
int   $0x80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, we need to know the basic elements of process.&lt;br /&gt;
Privilege level. ring 0 ~ 3.&lt;br /&gt;
v1 6.4 and v3a 6 for interrupt and exceptions.&lt;br /&gt;
priority&lt;br /&gt;
status&lt;br /&gt;
PCB&lt;br /&gt;
Process create.&lt;br /&gt;
schedule&lt;/p&gt;

&lt;h1 id=&#34;boot-and-init&#34;&gt;Boot and init&lt;/h1&gt;

&lt;p&gt;Power button -&amp;gt; cpu reset -&amp;gt; BIOS -&amp;gt; hard drive -&amp;gt; Grub boot.S/MBR aa5a -&amp;gt; Grub diskboot.S -&amp;gt; &amp;hellip; -&amp;gt; The kernel real-mode setup code. _start of arch/x86/boot/header.S&lt;br /&gt;
Aligh register, Stack and BSS for C function to run. -&amp;gt; main-&amp;gt;startup_32-&amp;gt;startup_64-&amp;gt; __START_KERNEL_map-&amp;gt;&amp;hellip; start_kernel&lt;br /&gt;
&lt;a href=&#34;https://github.com/torvalds/linux/blob/master/Documentation/x86/boot.txt#L130&#34;&gt;Kernel legacy boot sector&lt;/a&gt; start form 4d5a of arch/x86/boot/header.S&lt;br /&gt;
is only used by something link &amp;lsquo;qemu-system-x86_64 vmlinuz-3.18-generic&amp;rsquo;. It&amp;rsquo;s obsoleted that is what legacy means.&lt;/p&gt;

&lt;h2 id=&#34;process-management&#34;&gt;Process management&lt;/h2&gt;

&lt;p&gt;进程的定义和PCB，进程和线程的区别，进程的三个基本状态及它们之间的转换关系，进程的同步，竞争和死锁，进程间通信&lt;br /&gt;
###Representation&lt;br /&gt;
* Program memory&lt;br /&gt;
Stack(User/Kernel)&lt;br /&gt;
Heap&lt;br /&gt;
Data segment(data/bss)&lt;br /&gt;
Code segment&lt;br /&gt;
* PCB&lt;br /&gt;
Resource&lt;br /&gt;
Processor Context&lt;br /&gt;
Process state&lt;br /&gt;
###daemonize&lt;br /&gt;
&lt;a href=&#34;http://fixunix.com/unix/84640-daemon-controlling-terminal.html&#34;&gt;http://fixunix.com/unix/84640-daemon-controlling-terminal.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;memory-managerment&#34;&gt;Memory managerment&lt;/h2&gt;

&lt;p&gt;分页式管理，分段式管理，虚拟内存的概念，页面置换算法，内存分配算法&lt;/p&gt;

&lt;h3 id=&#34;paging&#34;&gt;Paging&lt;/h3&gt;

&lt;p&gt;paging is one of the memory management schemes by which&lt;br /&gt;
a computer stores and retrieves data from the secondary storage for use in main memory.&lt;br /&gt;
* Page fault&lt;br /&gt;
###Page replacement algorithm&lt;br /&gt;
OPT&lt;br /&gt;
FIFO&lt;br /&gt;
Second-chance&lt;br /&gt;
LRU&lt;/p&gt;

&lt;h3 id=&#34;x86-memory-segmentation&#34;&gt;x86 memory segmentation&lt;/h3&gt;

&lt;p&gt;linux 基本不用&lt;br /&gt;
&lt;a href=&#34;http://oss.org.cn/kernel-book/ch02/2.3.7.htm&#34;&gt;Linux中的段&lt;/a&gt;&lt;br /&gt;
* GDT&lt;br /&gt;
* TSS&lt;br /&gt;
&lt;a href=&#34;https://en.wikipedia.org/wiki/Task_state_segment#Use_of_TSS_in_Linux&#34;&gt;Use of TSS in Linux&lt;/a&gt;&lt;br /&gt;
* Linear address&lt;/p&gt;

&lt;h3 id=&#34;virtual-memory-https-en-wikipedia-org-wiki-virtual-memory-paged-virtual-memory&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Virtual_memory#Paged_virtual_memory&#34;&gt;Virtual memory&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;It maps memory addresses used by a program, called virtual addresses, into physical addresses in computer memory.&lt;br /&gt;
* Logic/Virtual address&lt;br /&gt;
* Page table&lt;/p&gt;

&lt;h3 id=&#34;memory-allocation&#34;&gt;Memory allocation&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Buddy memory allocation.&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Slab allocation/Memory Pool&lt;/p&gt;

&lt;h2 id=&#34;device-management&#34;&gt;Device management&lt;/h2&gt;

&lt;p&gt;中断的概念，中断处理，I/O控制方式，缓冲区管理，设备驱动，磁盘调度和高速缓存&lt;/p&gt;

&lt;h2 id=&#34;network-stack&#34;&gt;Network stack&lt;/h2&gt;

&lt;p&gt;Protocol&lt;/p&gt;

&lt;h2 id=&#34;i-o&#34;&gt;I/O&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cs.uwm.edu/classes/cs458/Lecture/HTML/ch11s02.html&#34;&gt;Methods for designing a CPU&amp;rsquo;s I/O interface generally fall into one of the following categories:&lt;/a&gt;&lt;br /&gt;
Completely separate memory and I/O. buses DMA?&lt;br /&gt;
Common buses, separate control lines. Port-I/O&lt;br /&gt;
Common buses and control line. Memroy-maped I/O&lt;br /&gt;
###Higher level implemention of I/O&lt;br /&gt;
device or partion of device/memory -&amp;gt; file&lt;br /&gt;
io -&amp;gt; stream&lt;br /&gt;
####&lt;a href=&#34;https://en.wikipedia.org/wiki/Stream_(computing)&#34;&gt;stream&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Standard_streams&#34;&gt;Standard streams&lt;/a&gt;&lt;br /&gt;
interface is stdio library or the kernel version.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;codata&lt;/p&gt;

&lt;h3 id=&#34;low-i-o-type&#34;&gt;Low I/O type&lt;/h3&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Programmed I/O/Polling&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;DMA&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Interrupt I/O&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Channel I/O&lt;/p&gt;

&lt;h3 id=&#34;i-o-scheduling&#34;&gt;I/O scheduling&lt;/h3&gt;

&lt;p&gt;Elevator algorithm&lt;br /&gt;
###Asynchronous I/O NEED CLEAN&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;synchronous I/O multiplexing and I/O event notification facility&lt;br /&gt;
select/poll/epoll&lt;br /&gt;
For the ease of use, the select loop is implemented as an &lt;em&gt;event loop&lt;/em&gt; with callbacks.&lt;br /&gt;
libevent and libev is a well-designed &lt;em&gt;event loop&lt;/em&gt;.Check shadowsocks for using of libev.&lt;/p&gt;

&lt;h2 id=&#34;file-system&#34;&gt;File system&lt;/h2&gt;

&lt;p&gt;文件的概念，文件的管理，文件系统&lt;/p&gt;

&lt;h2 id=&#34;system-calls&#34;&gt;System calls&lt;/h2&gt;

&lt;p&gt;系统调用的概念，系统调用的处理，系统调用类型&lt;/p&gt;

&lt;h2 id=&#34;cpu-device-i-o&#34;&gt;CPU-device I/O&lt;/h2&gt;

&lt;h3 id=&#34;memory-mapped-i-o&#34;&gt;Memory-mapped I/O&lt;/h3&gt;

&lt;p&gt;ioremap: physical address-&amp;gt;logical address, simlar to vmalloc except we need not page.&lt;/p&gt;

&lt;h3 id=&#34;ported-mapped-i-o&#34;&gt;Ported-mapped I/O&lt;/h3&gt;

&lt;p&gt;##Non CPU-device I/O&lt;/p&gt;

&lt;h3 id=&#34;i-o-channels&#34;&gt;I/O channels&lt;/h3&gt;

&lt;h2 id=&#34;同步与异步io&#34;&gt;同步与异步IO&lt;/h2&gt;

&lt;p&gt;今天我们要辨析一下同步和异步IO. 我们先解释最基础的概念, 之后用生活化的例子&lt;br /&gt;
完成认知.&lt;br /&gt;
首先是blocking 和 non-blocking这两个概念. 这两个概念实质上是和IO没有关系.&lt;br /&gt;
他们是在说, 比如读数据, 如果没有数据我该怎么办. 也就是说, 他是在IO不存的时候,&lt;br /&gt;
在语义上才是有效, 如果你要读的数据始终存在, 那么你还会考虑阻塞与不阻塞的问题吗?&lt;br /&gt;
那你应该考虑什么? 同步还是异步IO, 倒地什么是同步或者异步呢?&lt;br /&gt;
英文synchronous, syn 和chronous构成, syn是在一起的意思而chronous是时间的意思.&lt;br /&gt;
也就是说在一个时间点上在一起, 那么是谁和谁在意一起呢?其中一个是IO可以肯定, 另外一个&lt;br /&gt;
就是执行IO的发起者, 通常也就是进程. 简单说来这个IO是由进程执行的.&lt;br /&gt;
那么异步IO呢, asynchronous是a + synchronous. a表否定, 我们知道在IO进行的过程中我们的&lt;br /&gt;
进程是始终存在的, 也就是说IO 和进程共享着相同的时间进度, 但是却不在一起.也就是说,&lt;br /&gt;
IO不是由我们的进程完成而是别的进程完成, 是谁呢,是内核线程.&lt;br /&gt;
那么我们就知道只有linux上的aio是符合异步IO的标准, 而多路复用, 如epoll返回是我们和IO是在&lt;br /&gt;
一起, 我们要调用read之类的完成他.&lt;/p&gt;

&lt;h1 id=&#34;physical-computation-phenomenon&#34;&gt;Physical computation phenomenon&lt;/h1&gt;

&lt;p&gt;A Symbolic Analysis of Relay and Switching Circuits&lt;br /&gt;
The Mathematical Theory of Communication&lt;br /&gt;
Given a symbol level, the architecture is the description of the system in&lt;br /&gt;
whatever system-description scheme exists next below the symbol level. - Newell, 1990, p. 81&lt;br /&gt;
&lt;a href=&#34;https://news.ycombinator.com/item?id=9844090&#34;&gt;Ask HN: How to learn about the history of computing?&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Control&lt;br /&gt;
Cogwheel control&lt;br /&gt;
electromechanical magnet plugging control&lt;br /&gt;
control sequence points&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;faq&#34;&gt;Faq&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;early_reserve_initrd&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;How does gcc attribute((aligned)) work?&lt;br /&gt;
struct S1 { short f; short f1; short f2;char a; char c;} &lt;strong&gt;attribute&lt;/strong&gt; ((aligned ));&lt;br /&gt;
sizeof S1 = 16 in 64-bit&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;In what situation can unaligned accesss make a kernel panic?&lt;br /&gt;
may be arch/mips/kernel/unaligned.c&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Is the address generated by compiler physical or virtual?&lt;br /&gt;
Graphviz + CodeViz&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Operating system</title>
      <link>http://firoyang.org/cs/os/</link>
      <pubDate>Fri, 27 Feb 2015 15:46:14 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/os/</guid>
      <description>

&lt;h1 id=&#34;signal&#34;&gt;Signal&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;struct signal_sturct:&lt;br /&gt;
The &amp;ldquo;struct signal_struct&amp;rdquo; is the random &lt;em&gt;leftovers&lt;/em&gt; from all the other stuff.&lt;br /&gt;
&lt;a href=&#34;http://thread.gmane.org/gmane.linux.kernel/512831/focus=513990&#34;&gt;http://thread.gmane.org/gmane.linux.kernel/512831/focus=513990&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;sigpending&lt;br /&gt;
Store blocked signal info&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Non-mask signal&lt;br /&gt;
SIGKILL, SIGSTOP&lt;br /&gt;
##Generate signal&lt;br /&gt;
__send_signal();&lt;br /&gt;
##Process siganl&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;SIGKILL (may be some other)&lt;br /&gt;
process in _send_signal()-&amp;gt; complete_signal() tsk-&amp;gt;state |= TASK_WAKEKILL&lt;br /&gt;
&lt;a href=&#34;http://lwn.net/Articles/288056/&#34;&gt;http://lwn.net/Articles/288056/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.ibm.com/developerworks/library/l-task-killable/&#34;&gt;http://www.ibm.com/developerworks/library/l-task-killable/&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;others&lt;br /&gt;
each time a switch is made from kernel mode to user mode,&lt;br /&gt;
arch-specific: entry.S -&amp;gt; do_siganl()&lt;br /&gt;
{&lt;br /&gt;
get_signal_deliver()&lt;br /&gt;
{&lt;br /&gt;
    if fatal -&amp;gt; do_greoup_exit()-&amp;gt;&amp;hellip;__cleanup_sighand()&lt;br /&gt;
}&lt;/p&gt;

&lt;p&gt;handle_signal() -&amp;gt; k-&amp;gt;u(hanle)-sigreturn-&amp;gt;k&lt;br /&gt;
}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;mm-fault-handler&#34;&gt;mm fault handler&lt;/h1&gt;

&lt;p&gt;arch/powerpc/mm/fault.c&lt;br /&gt;
deatils of trap is in bad_page_fault&lt;/p&gt;

&lt;p&gt;sigbus&lt;br /&gt;
__handle_mm_fault&lt;br /&gt;
{&lt;br /&gt;
    hugetlb_fault CONFIG_HUGETLB_PAGE&lt;br /&gt;
    handle_pte_fault-&amp;gt;&lt;br /&gt;
    {&lt;br /&gt;
        do_linear_fault -&amp;gt; __do_fault&lt;br /&gt;
        {&lt;br /&gt;
            vma-&amp;gt;vm_ops-&amp;gt;fault(vma, &amp;amp;vmf);&lt;br /&gt;
        }&lt;br /&gt;
        do_anonymous_page&lt;br /&gt;
        {&lt;br /&gt;
            check_stack_guard_page&lt;br /&gt;
        }&lt;br /&gt;
        do_nonlinear_fault&lt;br /&gt;
        do_swap_page&lt;br /&gt;
        do_wp_page&lt;br /&gt;
        {&lt;br /&gt;
            vma-&amp;gt;vm_ops-&amp;gt;page_mkwrite(vma, &amp;amp;vmf); //??&lt;br /&gt;
        }&lt;br /&gt;
}&lt;/p&gt;

&lt;h1 id=&#34;kernel-panic-3-10-62&#34;&gt;kernel panic 3.10.62&lt;/h1&gt;

&lt;p&gt;kernel/panic.c&lt;br /&gt;
general protection fault and page fault&lt;br /&gt;
1498 errorentry general_protection do_general_protection&lt;br /&gt;
1499 errorentry page_fault do_page_fault&lt;br /&gt;
static const struct stacktrace_ops print_trace_ops = {&lt;br /&gt;
        .stack                  = print_trace_stack,&lt;br /&gt;
        .address                = print_trace_address,&lt;br /&gt;
        .walk_stack             = print_context_stack,&lt;br /&gt;
};&lt;br /&gt;
no_context-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    show_fault_oops-&amp;gt;&lt;br /&gt;
    __die-&amp;gt;&lt;br /&gt;
    {&lt;br /&gt;
        print_modules&lt;br /&gt;
        show_regs&lt;br /&gt;
        {&lt;br /&gt;
            printk(KERN_DEFAULT &amp;ldquo;Stack:\n&amp;rdquo;);&lt;br /&gt;
            show_stack_log_lvl-&amp;gt;&lt;br /&gt;
            {&lt;br /&gt;
                show_trace_log_lvl-&amp;gt;&lt;br /&gt;
                {&lt;br /&gt;
                    printk(&amp;ldquo;%sCall Trace:\n&amp;rdquo;, log_lvl);&lt;br /&gt;
                    // arch/x86/kernel/dumpstack_64.c&lt;br /&gt;
                    dump_trace-&amp;gt;&amp;amp;print_trace_ops&lt;br /&gt;
                }&lt;br /&gt;
            }&lt;br /&gt;
            printk(KERN_DEFAULT &amp;ldquo;Code: &amp;ldquo;);&lt;br /&gt;
        }&lt;br /&gt;
    }&lt;br /&gt;
}&lt;/p&gt;

&lt;h1 id=&#34;process-and-thread&#34;&gt;Process and thread&lt;/h1&gt;

&lt;h1 id=&#34;kernel-mapping&#34;&gt;Kernel mapping&lt;/h1&gt;

&lt;p&gt;tgid_base_stuff show_map_vma&lt;/p&gt;

&lt;h1 id=&#34;gdb-mapping&#34;&gt;GDB mapping&lt;/h1&gt;

&lt;p&gt;t-&amp;gt;to_info_proc=procfs_info_proc&lt;br /&gt;
linux_info_proc not used in core dump&lt;br /&gt;
linux_core_info_proc_mappings this is correct&lt;/p&gt;

&lt;p&gt;in kernel&lt;br /&gt;
fill_files_note&lt;/p&gt;

&lt;p&gt;_IO_new_fopen&lt;br /&gt;
_IO_new_file_init&lt;br /&gt;
libio/fileops.c _IO_file_open&lt;br /&gt;
&amp;amp; _IO_file_jumps_maybe_mmap -&amp;gt; _IO_default_uflow -&amp;gt; _IO_file_underflow_maybe_mmap&lt;/p&gt;

&lt;p&gt;libio/fileops.c: decide_maybe_mmap&lt;br /&gt;
We use the file in read-only mode.  This could mean we can&lt;br /&gt;
     mmap the file and use it without any copying.  But not all&lt;br /&gt;
     file descriptors are for mmap-able objects and on 32-bit&lt;br /&gt;
     machines we don&amp;rsquo;t want to map files which are too large since&lt;br /&gt;
     this would require too much virtual memory.  */&lt;br /&gt;
 __mmap64 (NULL, st.st_size, PROT_READ, MAP_SHARED, fp-&amp;gt;_fileno, 0);&lt;/p&gt;

&lt;p&gt;_IO_file_jumps_maybe_mmap&lt;br /&gt;
  JUMP_INIT_DUMMY,&lt;br /&gt;
  JUMP_INIT(finish, _IO_file_finish),&lt;br /&gt;
  JUMP_INIT(overflow, _IO_file_overflow),&lt;br /&gt;
  JUMP_INIT(underflow, _IO_file_underflow_maybe_mmap),&lt;br /&gt;
  JUMP_INIT(uflow, _IO_default_uflow),&lt;br /&gt;
  JUMP_INIT(pbackfail, _IO_default_pbackfail),&lt;br /&gt;
  JUMP_INIT(xsputn, _IO_new_file_xsputn),&lt;br /&gt;
  JUMP_INIT(xsgetn, _IO_file_xsgetn_maybe_mmap),&lt;br /&gt;
  JUMP_INIT(seekoff, _IO_file_seekoff_maybe_mmap),&lt;br /&gt;
  JUMP_INIT(seekpos, _IO_default_seekpos),&lt;br /&gt;
  JUMP_INIT(setbuf, (_IO_setbuf_t) _IO_file_setbuf_mmap),&lt;br /&gt;
  JUMP_INIT(sync, _IO_new_file_sync),&lt;br /&gt;
  JUMP_INIT(doallocate, _IO_file_doallocate),&lt;br /&gt;
  JUMP_INIT(read, _IO_file_read),&lt;br /&gt;
  JUMP_INIT(write, _IO_new_file_write),&lt;br /&gt;
  JUMP_INIT(seek, _IO_file_seek),&lt;br /&gt;
  JUMP_INIT(close, _IO_file_close),&lt;br /&gt;
  JUMP_INIT(stat, _IO_file_stat),&lt;br /&gt;
  JUMP_INIT(showmanyc, _IO_default_showmanyc),&lt;br /&gt;
  JUMP_INIT(imbue, _IO_default_imbue)&lt;/p&gt;

&lt;p&gt;_IO_file_jumps_mmap&lt;/p&gt;

&lt;p&gt;_IO_file_jumps&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.yinwang.org/blog-cn/2016/03/31/no-longer-pl&#34;&gt;我为什么不再做PL人&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;ai&#34;&gt;AI&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/subconscious/p/4107357.html&#34;&gt;从机器学习谈起&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;resources-of-os-design&#34;&gt;Resources of OS design&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.brokenthorn.com/Resources/OSDevIndex.html&#34;&gt;BrokenThorn Entertainment Operating System Development Series&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://pages.cs.wisc.edu/~remzi/OSTEP/&#34;&gt;Operating Systems: Three Easy Pieces&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;unix-linux-programming&#34;&gt;Unix/Linux programming&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.catb.org/esr/writings/taoup/html/&#34;&gt;The Art of Unix Programming&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;quantaties&#34;&gt;Quantaties&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://people.eecs.berkeley.edu/~rcs/research/interactive_latency.html&#34;&gt;Latency Numbers Every Programmer Should Know&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;prof&#34;&gt;Prof&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.tuicool.com/articles/YRZvem&#34;&gt;Mort Yao 程序与证明&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;compile-and-link&#34;&gt;Compile and link&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://sourceforge.net/p/predef/wiki/Architectures/&#34;&gt;Pre-defined Compiler Macros&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://sourceware.org/binutils/docs/&#34;&gt;Gnu binutils docs&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://gcc.gnu.org/wiki/HomePage&#34;&gt;Welcome to GCC Wiki&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;distributed-system&#34;&gt;Distributed system&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.andrew.cmu.edu/course/15-440-s13/index/syllabus_index.html&#34;&gt;CMU 15-&lt;sup&gt;640&lt;/sup&gt;&amp;frasl;&lt;sub&gt;440&lt;/sub&gt;&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://dancres.github.io/Pages/&#34;&gt;A Distributed Systems Reading List&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://blog.incubaid.com/2012/03/28/the-game-of-distributed-systems-programming-which-level-are-you/&#34;&gt;The Game of Distributed Systems Programming. Which Level Are You?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://bravenewgeek.com/from-the-ground-up-reasoning-about-distributed-systems-in-the-real-world/&#34;&gt;From the Ground Up: Reasoning About Distributed Systems in the Real World&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://videlalvaro.github.io/2015/12/learning-about-distributed-systems.html&#34;&gt;WHAT WE TALK ABOUT WHEN WE TALK ABOUT DISTRIBUTED SYSTEMS&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;hack&#34;&gt;Hack&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://phrack.org/index.html&#34;&gt;Phrack&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.exploit-db.com/papers/13146/&#34;&gt;Obtain sys_call_table on amd64 &lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;cognition&#34;&gt;Cognition&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://jvns.ca/blog/2016/04/30/building-expertise-at-work/&#34;&gt;How does knowledge get locked up in people&amp;rsquo;s heads?&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;process&#34;&gt;Process&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.ccs.neu.edu/home/matthias/HtDP2e/index.html&#34;&gt;How to Design Programs, Second Edition&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;programming-language&#34;&gt;Programming language&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://jozefg.bitbucket.org/posts/2015-08-14-learn-tt.html&#34;&gt;Learn Type Theory&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;functional-language&#34;&gt;Functional language&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html&#34;&gt;Functors, Applicatives, And Monads In Pictures&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;programming&#34;&gt;Programming&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://sijinjoseph.com/programmer-competency-matrix/&#34;&gt;Programmer Competency Matrix&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.freebsd.org/cgi/man.cgi?query=style&amp;amp;sektion=9&#34;&gt;FB coding style&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.gnu.org/prep/standards/standards.html&#34;&gt;GNU Coding Standards&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://googletesting.blogspot.com/&#34;&gt;Google testing blog&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;network&#34;&gt;Network&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.securitywizardry.com/index.php/tools/packet-headers.html&#34;&gt;RAW PACKET FORMATS&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://wangcong.org/2012/10/15/-e4-bb-8e-ipv4-e5-88-b0-ipv6/&#34;&gt;从 IPv4 到 IPv6&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.tecmint.com/ipv4-and-ipv6-comparison/&#34;&gt;What’s wrong with IPv4 and Why we are moving to IPv6&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/629155/&#34;&gt;Improving Linux networking performance&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;concurrency&#34;&gt;Concurrency&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://queue.acm.org/detail.cfm?id=2698990&#34;&gt;Scalability Techniques for Practical Synchronization Primitives&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;english&#34;&gt;English&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.tudou.com/programs/view/S9cfVXLvThM/?bid=03&amp;amp;pid=02&amp;amp;resourceId=100311153_03_05_02&#34;&gt;英语口音纠正课程&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.douban.com/note/144818819/#!/i!/ckDefault&#34;&gt;英语思维漫谈&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://v.youku.com/v_show/id_XNDYyMjcyNDI0.html?from=y1.2-1-87.3.3-2.1-1-1-2-0&#34;&gt;Pronunciation workshop&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.tu-chemnitz.de/phil/english/sections/ling/course/Conceptualising/Annabell/Question_tags.htm&#34;&gt;Conceptualizing English Language Systems&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;memory&#34;&gt;Memory&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.memorymanagement.org/mmref/recycle.html&#34;&gt;Recycling techniques&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;kernel&#34;&gt;Kernel&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://wangcong.org/2007/03/09/-e8-b5-b0-e8-bf-91linux-e5-86-85-e6-a0-b8/&#34;&gt;走近Linux内核&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://wangcong.org/2012/06/01/-e4-b8-ba-e4-bb-80-e4-b9-88linux-e5-86-85-e6-a0-b8-e4-b8-8d-e5-85-81-e8-ae-b8-e5-9c-a8-e4-b8-ad-e6-96-ad-e4-b8-ad-e4-bc-91-e7-9c-a0-ef-bc-9f/&#34;&gt;为什么Linux内核不允许在中断中休眠&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.linux.org/threads/linux-kernel-reading-guide.5384/&#34;&gt;Linux Kernel Reading Guide&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.kernel.org/pub/linux/kernel/people/rusty/kernel-locking/index.html&#34;&gt;Unreliable Guide To Locking&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/660404/&#34;&gt;Speeding up kernel development with QEMU&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.usenix.org/legacy/event/usenix2000/freenix/full_papers/silvers/silvers_html/&#34;&gt;UBC: An Efficient Unified I/O and Memory Caching Subsystem for NetBSD&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.fieldses.org/~bfields/kernel/vfs.txt&#34;&gt;VFS notes&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;kvm&#34;&gt;KVM&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.oenhan.com/kvm-src-3-cpu&#34;&gt;KVM源代码分析3:CPU虚拟化&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;human-too-human&#34;&gt;Human, too human&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.flickr.com/photos/deathhell/8702618520/in/photostream/&#34;&gt;Iyo Yoshimi 吉見衣世&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The art of programming</title>
      <link>http://firoyang.org/cs/programming/</link>
      <pubDate>Fri, 27 Feb 2015 15:46:14 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/programming/</guid>
      <description>

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Category:Programming_principles&#34;&gt;Programming principles&lt;/a&gt;&lt;br /&gt;
programming principles&lt;br /&gt;
High cohesion low coupling&lt;/p&gt;

&lt;h1 id=&#34;computer-programming&#34;&gt;Computer programming&lt;/h1&gt;

&lt;p&gt;编程作为我重要的谋生手段, 有必要审慎的加以考察审视. 程序设计应该包含那些最少的, 必备的, 重要的能力呢?&lt;br /&gt;
&lt;a href=&#34;http://www.cs.princeton.edu/~bwk/tpop.webpage/&#34;&gt;The practice of programming&lt;/a&gt;给出了大概的框架, 但不完整.&lt;br /&gt;
我认为最重要的就是Abstraction and design.&lt;br /&gt;
&lt;a href=&#34;http://www.ccs.neu.edu/home/matthias/HtDP2e/&#34;&gt;How to design programs&lt;/a&gt;还有&lt;a href=&#34;http://sarabander.github.io/sicp/&#34;&gt;SICP&lt;/a&gt;以及Elements of programming.&lt;br /&gt;
其次我们要掌握几门Programming language.&lt;br /&gt;
养成好的Coding style,&lt;br /&gt;
Valid and verification&lt;br /&gt;
Testing&lt;br /&gt;
Debuging&lt;/p&gt;

&lt;h1 id=&#34;files-sytle&#34;&gt;Files sytle&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://lists.kernelnewbies.org/pipermail/kernelnewbies/2012-March/004986.html&#34;&gt;kernel asm/asm-generic&lt;/a&gt;&lt;br /&gt;
asm stands for arch specific macros(FIXME).&lt;/p&gt;

&lt;h1 id=&#34;coding-style&#34;&gt;Coding style&lt;/h1&gt;

&lt;p&gt;比如GNU coding standards, Linux kernel coding style, Shell coding standard&lt;br /&gt;
* Label&lt;br /&gt;
It is considered to be safer that the label reflect what happens at the&lt;br /&gt;
destination, and not the reason for reaching the label. &amp;ndash;Julia&lt;/p&gt;

&lt;h1 id=&#34;verification-and-validation&#34;&gt;Verification and validation&lt;/h1&gt;

&lt;p&gt;抽象的知识来自生活经验的总结, 所以学习抽象知识的重要方向是从实践不断总结抽象.&lt;br /&gt;
programming is a goal-oriented activity&lt;br /&gt;
14.4&lt;br /&gt;
Before attempting to solve a problem, make absolutely sure you  what the problem is.&lt;br /&gt;
14.5&lt;br /&gt;
Before developing a program, make precise and refine the pre/postcondition.&lt;br /&gt;
program -&amp;gt;&lt;br /&gt;
{Q} S {R}: predicte, formal notation&lt;br /&gt;
Q: input asseration&lt;br /&gt;
R: output asseration&lt;br /&gt;
predictes -&amp;gt; asseration&lt;br /&gt;
asseration: a predicate placed in a program is called an asseration.&lt;br /&gt;
Proof outline: a program together with an asseration between each pair of statements&lt;br /&gt;
Program specification ⊃ excution ∪ speed ∪ size&lt;br /&gt;
Instances: summation, squre root approximation, sorting&lt;br /&gt;
command-comment ⊃ all input ∪ output&lt;/p&gt;

&lt;h1 id=&#34;debugging&#34;&gt;Debugging&lt;/h1&gt;

&lt;p&gt;see debugging.md&lt;/p&gt;

&lt;h1 id=&#34;testing&#34;&gt;Testing&lt;/h1&gt;

&lt;p&gt;1.Black-box testing test software function.&lt;br /&gt;
2.White-box testing test software internal logic.&lt;br /&gt;
kvm &amp;amp; supermin&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The philosophy of debugging</title>
      <link>http://firoyang.org/cs/debugging/</link>
      <pubDate>Fri, 27 Feb 2015 15:46:14 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/debugging/</guid>
      <description>

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;Reverse engineering&lt;/p&gt;

&lt;h1 id=&#34;debugging-and-bug-types&#34;&gt;Debugging and Bug types&lt;/h1&gt;

&lt;p&gt;Does anyone can tell me what is debugging? Debugging is &lt;a href=&#34;https://en.wikipedia.org/wiki/Abductive_reasoning#Logic-based_abduction&#34;&gt;Abductive reasoning&lt;/a&gt;.&lt;br /&gt;
Theory + Observations =&amp;gt; Explanation&lt;/p&gt;

&lt;h1 id=&#34;bug-classifications&#34;&gt;Bug classifications&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.opensourceforu.com/2010/10/joy-of-programming-types-of-bugs&#34;&gt;BUG type of Jim Gray&lt;/a&gt;,除了Bohrbug,其他都不太好解.&lt;br /&gt;
The National Vulnerability Database是一个非常有用的网站, 国内鲜少有人提及.尤其是,&lt;br /&gt;
他的Bug分类方式惊艳无比, 逻辑上非常严密, 就好比数学系统, 由公理系统推导而得.&lt;br /&gt;
NVD的Bug分类也采用类似的构建方式.&lt;a href=&#34;https://nvd.nist.gov/cwe.cfm&#34;&gt;CWE Cross Section Mapped into by NVD&lt;/a&gt;&lt;br /&gt;
涵盖了所有常见的的Bug描述, 而且非常专业.大赞!wikipedia的条目就相形见绌了&lt;br /&gt;
&lt;a href=&#34;https://en.wikipedia.org/wiki/Software_bug#Common_types_of_computer_bugs&#34;&gt;Common types of computer bugs in wikipedia&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;use-after-free&#34;&gt;use after free&lt;/h1&gt;

&lt;p&gt;record the owner, who free.&lt;/p&gt;

&lt;h1 id=&#34;oops&#34;&gt;oops&lt;/h1&gt;

&lt;p&gt;Kernel oops relates to invalid memory access, including sigev and sigbus.&lt;br /&gt;
&lt;a href=&#34;https://www.kernel.org/doc/Documentation/oops-tracing.txt&#34;&gt;kernel oops tracing&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;lockup&#34;&gt;lockup&lt;/h1&gt;

&lt;p&gt;phenomenon: LOCKUP_DETECTOR&lt;br /&gt;
&lt;a href=&#34;https://www.kernel.org/doc/Documentation/lockup-watchdogs.txt&#34;&gt;kernle doc - Softlockup detector and hardlockup detector&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.av8n.com/computer/htm/kernel-lockup.htm&#34;&gt;Debugging Linux Kernel Lockup / Panic / Oops&lt;/a&gt;&lt;br /&gt;
Causes: deadlock, hardware, irqoff and loop&lt;/p&gt;

&lt;h1 id=&#34;hung-task&#34;&gt;hung task&lt;/h1&gt;

&lt;p&gt;phenomenon: DETECT_HUNG_TASK&lt;br /&gt;
Includes the interruptable task.&lt;br /&gt;
Causes: deadlock, race condition&lt;/p&gt;

&lt;h1 id=&#34;deadlock&#34;&gt;deadlock&lt;/h1&gt;

&lt;p&gt;Lockdep&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/185666/&#34;&gt;The kernel lock validator&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt&#34;&gt;Runtime locking correctness validator&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lkml.org/lkml/2013/2/4/4&#34;&gt;https://lkml.org/lkml/2013/2/4/4&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://bbs.chinaunix.net/thread-4183696-1-1.html&#34;&gt;http://bbs.chinaunix.net/thread-4183696-1-1.html&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;kasan&#34;&gt;kasan&lt;/h1&gt;

&lt;p&gt;setup_arch-&amp;gt;kasan_init&lt;br /&gt;
&lt;a href=&#34;http://events.linuxfoundation.org/sites/events/files/slides/LinuxCon%20North%20America%202015%20KernelAddressSanitizer.pdf&#34;&gt;KernelAddressSanitizer a fast memory error detector for the Linux kernel&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/zfsonlinux/zfs/pull/4708/commits/01709937be3c28a89eff83e0e657a72826947506&#34;&gt;kasan found stack out of bounds&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/612153/&#34;&gt;lwn The kernel address sanitizer&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lkml.org/lkml/2014/12/3/128&#34;&gt;out of bounds&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;config-debug-pagealloc&#34;&gt;CONFIG_DEBUG_PAGEALLOC&lt;/h1&gt;

&lt;p&gt;check_poison_mem in alloc_pages&lt;br /&gt;
free_pages_prepare posion&lt;/p&gt;

&lt;h1 id=&#34;general-debugging-steps&#34;&gt;General debugging steps&lt;/h1&gt;

&lt;p&gt;Debugging的逻辑过程是&lt;a href=&#34;https://en.wikipedia.org/wiki/Abductive_reasoning#Logic-based_abduction&#34;&gt;Abductive reasoning&lt;/a&gt;. 我们以此进行推导.&lt;br /&gt;
T: Theory 也就是我们的background, cs的知识技术, 出问题的程序与代码.&lt;br /&gt;
O: Observations 是Bug发生的现场以及相应的log, 现象.&lt;br /&gt;
E: Explanation 是最终定位的结论.&lt;br /&gt;
E ⊆ T; O ⊆ T; E ⊃ (E ∩ O);&lt;br /&gt;
if E = (E ∩ O); then debugging is done.&lt;br /&gt;
T, E 与 O理论上都是从∅开始,且O =&amp;gt; E;&lt;br /&gt;
E: ∅ -&amp;gt; Bug type(可能经过是多种Bug types的过渡状态) -&amp;gt; Explanation&lt;br /&gt;
很多时候O也会使T扩大.所以O成为debugging的关键.&lt;br /&gt;
下面严格区分T 和 O. 我们得到O就要不断地结合T进行理性分析.&lt;br /&gt;
&amp;gt; Another perespective,&lt;br /&gt;
&amp;gt; the process of debugging is use O to minimize T to E instance.&lt;br /&gt;
&amp;gt; T is solutions space, E &lt;a href=&#34;https://nvd.nist.gov/cwe.cfm#cweIdEntry-CWE-1&#34;&gt;locates&lt;/a&gt; in T. O is the address to find E.&lt;/p&gt;

&lt;p&gt;基于NVD的CWE我们可知, 收集observations 可能是development和deployment的各个节点.&lt;/p&gt;

&lt;h3 id=&#34;get-observations&#34;&gt;Get observations&lt;/h3&gt;

&lt;p&gt;首先我们要理清中间的各个流程, 以及相关的observations:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;coding&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;compilation&lt;br /&gt;
make kernel/sched.s V=1&lt;br /&gt;
readelf, objdump&lt;br /&gt;
c++filt&lt;br /&gt;
addr2line -f -C -a 0xxxx -e ooo.bin&lt;br /&gt;
./scripts/decodecode &amp;lt; Oops.txt&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;load software&lt;br /&gt;
LD_TRACE_LOADED_OBJECTS=1 git&lt;br /&gt;
ldd /usr/bin/git&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;software running&lt;br /&gt;
&amp;gt; #define debugme(fmt, args&amp;hellip;) do{FILE *fdebug=fopen(&amp;ldquo;/tmp/d.log&amp;rdquo;, &amp;ldquo;a+&amp;rdquo;); &lt;br /&gt;
&amp;gt; fprintf(fdebug,&amp;ldquo;%s,%s,%d:&amp;ldquo;fmt, &lt;strong&gt;TIME&lt;/strong&gt;, &lt;strong&gt;FUNCTION&lt;/strong&gt;, &lt;strong&gt;LINE&lt;/strong&gt;, ##args);fclose(fdebug);} while(0)&lt;br /&gt;
lsof, ltrace, strace, bash -x, coredump&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;kernel specific&lt;br /&gt;
putstr early_printk vs printk pr_debug vs dev_debug dump_stack&lt;br /&gt;
Linux serial-port driver is interrupt driven, if irq-off console will not work!&lt;br /&gt;
how to use serial-port addr&lt;br /&gt;
ioctl/netlink, SysRq, ftrace expect,kgtp, lockdep, kdump, kgdboc&lt;br /&gt;
CONFIG_DYNAMIC_DEBUG, &lt;debugfs&gt;/dynamic_debug/control&lt;br /&gt;
print signal This is just a hiwifi wonderful kernel patch #931&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;network specific&lt;br /&gt;
tcpdump netstat iptables wireshark&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;u-boot&lt;br /&gt;
print_tlb&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;make specific&lt;br /&gt;
-s, -n, -p, &amp;ndash;warn-undefined-variables&lt;br /&gt;
$(warning &amp;hellip;)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;有的类型的Bug会阻止我们收集observations&lt;br /&gt;
这时候就要增加observations,让我们能收集到. 比如use after free, buffer errors.&lt;br /&gt;
这时要扩大目标struct的大小, 把observations加进去.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;software imediately stop&lt;br /&gt;
Use atexit() register a stackdump or a wrapped print&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;inference&#34;&gt;Inference&lt;/h1&gt;

&lt;p&gt;From observatons to source code/mind&lt;br /&gt;
追BUG实际上就是, 找关联度最高的.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;tips&lt;br /&gt;
If an page oops close to zero, for example 0xfffffff4&lt;br /&gt;
It maybe ERR_PTR(-12);&lt;br /&gt;
&lt;a href=&#34;http://www.stlinux.com/devel/debug/jtag/build?q=node/82&#34;&gt;Tips on debugging optimized code&lt;/a&gt;&lt;br /&gt;
code reordering inlining Optimized-away variables Tailcall optimization&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;oops&lt;br /&gt;
From ASM to c language&lt;br /&gt;
&lt;a href=&#34;http://yarchive.net/comp/linux/oops_decoding.html&#34;&gt;lkml-Linus-Al-Viro-oops-debug&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;asm&lt;/strong&gt;(), 常量, loop codes format, char *, ip&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;一些比较通用的调试工具&#34;&gt;一些比较通用的调试工具&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;gdb&lt;br /&gt;
gdb vmlinux /proc/kcore&lt;br /&gt;
p jiffies_64&lt;br /&gt;
text_addr=/sys/module/char-read-write/sections/.text&lt;br /&gt;
add-symbol-file /home/nkhare/char-read-write.ko $text_addr&lt;br /&gt;
print &amp;amp;((struct kmem_cache *)0)-&amp;gt;offset&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;anti-debugging&#34;&gt;Anti-debugging&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Syntax checking&lt;br /&gt;
gcc -Wall&lt;br /&gt;
bash -n&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;static code analysis&lt;br /&gt;
smatch&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;bug-made-by-me&#34;&gt;BUG made by me&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;print_signal_info wrong pritk parameters position&lt;br /&gt;
    printk(KERN_NOTICE &amp;ldquo;K %d : %d -&amp;gt; %s %d %s %d\n&amp;rdquo;, sig, q-&amp;gt;info.si_code,&lt;br /&gt;
            ss&lt;a href=&#34;http://www.opensourceforu.com/2010/10/joy-of-programming-types-of-bugs&#34;&gt;2&lt;/a&gt;, ss&lt;a href=&#34;https://nvd.nist.gov/cwe.cfm&#34;&gt;3&lt;/a&gt;, task_tgid_vnr(r_t), task_tgid_vnr(r_p));&lt;br /&gt;
Watch compile warning info can be avoid of this bug.&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;spin_lock(sighand) invoke down_sem and cond_resched&amp;hellip;&lt;br /&gt;
__send_signal()&lt;/p&gt;

&lt;h1 id=&#34;examples&#34;&gt;Examples&lt;/h1&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;timer_list-&amp;gt;function = NULL&lt;br /&gt;
我前几天定位了一个Softirq中timer corruption的问题, 现象是timer func是个非法地址.&lt;br /&gt;
首先, 一下子不能确认是由那种Bug type导致的.可能是Improper Restriction of Operations&lt;br /&gt;
within the Bounds of a Memory Buffer 也可能是Use after free. 所以此时debug的关键所在&lt;br /&gt;
就是收集observations,也就是function的名字, 而我遇到的这个问题timer 被完全写坏了.&lt;br /&gt;
可以用ftrace收集所有timer 的地址和function, 再从oops里面得到timer地址,回头找ftrace&lt;br /&gt;
log中记录的function, 从而定位问题. 稍后介绍, 如何通过expect抓屏幕log.&lt;br /&gt;
这个方法没成功, 时候分析知道是因为panic的瞬间出问题的timer的地址和function没来得及&lt;br /&gt;
记录到ftrace.怎么办? 我直接说了, 我想到一个办法, 把timer的空间增大, 增大的空间用来&lt;br /&gt;
保存function,在oops把这块内存打出来. 此法非常有用, timer的function一下子就找到了, 进而&lt;br /&gt;
确认了问题是use after free. 非常开心:-)这里的解释了如何收集observations的技巧.对待use&lt;br /&gt;
after free的问题是够了, 以后用到这类问题基本可以妙解了.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;module text address&lt;br /&gt;
cat /sys/module/wmi/sections/.text&lt;br /&gt;
cat /proc/modules | grep wmi&lt;br /&gt;
int bss_var;&lt;br /&gt;
static int hello_init(void)&lt;br /&gt;
{printk(KERN_ALERT &amp;ldquo;Text location .text(Code Segment):%p\n&amp;rdquo;,hello_init);&lt;br /&gt;
static int data_var=0;&lt;br /&gt;
printk(KERN_ALERT &amp;ldquo;Data Location .data(Data Segment):%p\n&amp;rdquo;,&amp;amp;data_var);&lt;br /&gt;
printk(KERN_ALERT &amp;ldquo;BSS Location: .bss(BSS Segment):%p\n&amp;rdquo;,&amp;amp;bss_var);}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>The programming language</title>
      <link>http://firoyang.org/cs/pl/</link>
      <pubDate>Fri, 27 Feb 2015 15:46:14 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/pl/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://www.yinwang.org/blog-cn/2016/03/31/no-longer-pl&#34;&gt;我为什么不再做PL人&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;∅ ⊢ pl&lt;br /&gt;
scope: The set of expressions for which a binding defines a name is called the scope of that name.&lt;/p&gt;

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.zhihu.com/question/21843639&#34;&gt;http://www.zhihu.com/question/21843639&lt;/a&gt;&lt;br /&gt;
貌似正则是type 3, c是type2, 范式角度我现在不好理解, 缺乏语言学的知识.&lt;br /&gt;
Programming Language Pragmatics 3rd&lt;br /&gt;
C11&lt;br /&gt;
C Traps and Pitfalls&lt;br /&gt;
Expert C Programming&lt;/p&gt;

&lt;h1 id=&#34;contents&#34;&gt;Contents&lt;/h1&gt;

&lt;p&gt;Programming language theory&lt;br /&gt;
Programming language&lt;/p&gt;

&lt;h1 id=&#34;programming-language-theory&#34;&gt;Programming language theory&lt;/h1&gt;

&lt;p&gt;What is formal language and the relationg between fl and pl?&lt;br /&gt;
Language primitive&lt;/p&gt;

&lt;h2 id=&#34;semantics&#34;&gt;Semantics&lt;/h2&gt;

&lt;h1 id=&#34;c&#34;&gt;C&lt;/h1&gt;

&lt;p&gt;我们还是从使用的角度来看c 语言;&lt;br /&gt;
c语言自身重要基础性质, 我们需要了解.&lt;br /&gt;
除此之外, 我们还要了解一些重要的标准库函数.&lt;br /&gt;
知道这些, 我们就能用c语言.&lt;/p&gt;

&lt;h2 id=&#34;type&#34;&gt;Type&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Object type and function type&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Object &amp;ndash; void, scalar,aggregate types, composite&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Scalar type &amp;ndash; Arithmetic types and pointer types&lt;br /&gt;
&lt;a href=&#34;http://www.techopedia.com/definition/16441/scalar&#34;&gt;What does Scalar mean?&lt;/a&gt;&lt;br /&gt;
scalar 词源上由scale演化而来, scalar type来自scalar processor and vector processor.&lt;br /&gt;
超标量也是来自这里concurrent SISD =&amp;gt;MIMD 所谓的流水线.&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Arithmetic type &amp;ndash; Integer and floating types&lt;/p&gt;

&lt;h2 id=&#34;incomplete-and-complete&#34;&gt;Incomplete and complete&lt;/h2&gt;

&lt;p&gt;void; struct s; union u;&lt;/p&gt;

&lt;h2 id=&#34;conversion&#34;&gt;Conversion&lt;/h2&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;only effect to scalar type data&lt;br /&gt;
error: conversion to non-scalar type requested&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;无符号数 转换成upper rank的有符号数, 还是无符号数, 不管最初是-1!&lt;br /&gt;
unsigned int i = 1; long f = -10;if ( i &amp;gt; f ) printf(&amp;ldquo;ok\n&amp;rdquo;); true 证明确实usigned 向long转换了.&lt;br /&gt;
unsigned int i = -3; long f = -5u;if ( i &amp;gt; f ) printf(&amp;ldquo;ok\n&amp;rdquo;); true&lt;br /&gt;
c11上是ok的!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;做signed 和unsigned 貌似both convert to unsigned gcc才给警告, 否则不给即便是signed和unsigned比较.&lt;/p&gt;

&lt;h2 id=&#34;lvalue-rvalue-modfiable-rvalue&#34;&gt;lvalue rvalue modfiable rvalue&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c&#34;&gt;Understanding lvalues and rvalues in C and C++&lt;/a&gt;&lt;br /&gt;
If a variable/expression  has a address, it&amp;rsquo;s of lvalue.&lt;/p&gt;

&lt;h2 id=&#34;array-decay&#34;&gt;Array decay&lt;/h2&gt;

&lt;p&gt;数组退化的初衷, 可能是K&amp;amp;R当年计算资源紧缺, 导致不允许函数传值copy数组内容.&lt;br /&gt;
总之标准委员会介入之前就决定.&lt;br /&gt;
&lt;a href=&#34;http://bbs.chinaunix.net/thread-1031622-1-1.html&#34;&gt;[C] [原创]数组与指针&amp;mdash;都是&amp;rdquo;退化&amp;rdquo;惹的祸&lt;/a&gt;&lt;br /&gt;
关于char *s错误声明的讲解不错!&lt;br /&gt;
&lt;a href=&#34;http://stackoverflow.com/questions/17752978/exception-to-array-not-decaying-into-a-pointer&#34;&gt;Exception to array not decaying into a pointer?&lt;/a&gt;&lt;br /&gt;
在c11 6.3.2.1 Lvalues, arrays, and function designators第3点说明了&lt;br /&gt;
array不会退化的4种场景. Except when it is&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;the operand of the sizeof operator,&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;the _Alignof operator, or the&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;unary &amp;amp; operator, or&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;is a string literal used to initialize an array, an expression that has type&lt;br /&gt;
‘‘array of type’’ is converted to an expression with type ‘‘pointer to type’’&lt;br /&gt;
that points to the initial element of the array object and is not an lvalue.&lt;br /&gt;
If the array object has register storage class, the behavior is undefined.&lt;br /&gt;
这4种场景之外, 那么array名退化的结果是pointer.&lt;br /&gt;
这个pointer和我们最常用的pointer如int *p有什么区别呢?&lt;br /&gt;
首先array decay是type上的转化array -&amp;gt; pointer.&lt;br /&gt;
其次数组名原来是lvalue -&amp;gt; not an lvalue更谈不上modifiable.&lt;br /&gt;
type: tyepof(array[0]) *&lt;br /&gt;
value: &amp;amp;array[0] or array&lt;br /&gt;
property: not lvalue&lt;br /&gt;
当然这只是c11上的说明, 我们只要明白为什么不能修改一个decay数组名就行了.&lt;br /&gt;
实现的个人猜测是: 根据lvalue的定义decay后数组名还是lvalue, 只不过一直都不是modifiable.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为什么作为函数形参的数组名可以++, 而作为变量的数组名就不可以.&lt;br /&gt;
因为形参数组名被当初pointer处理modifiable lvalue, 而实参数组名只是传值而已.&lt;br /&gt;
而普通数组名是一个lvalue,不能修改.&lt;/p&gt;

&lt;h3 id=&#34;why-innermost-dimension-can-be-omit-in-array&#34;&gt;Why innermost dimension can be omit in array&lt;/h3&gt;

&lt;p&gt;用不到.&lt;br /&gt;
In essence, all arrays in C are one-dimensional.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Because the array will decay to pointer and to calculate offset to&lt;br /&gt;
the elements of the array you do not need to know the innermost dimension.&lt;/p&gt;

&lt;p&gt;Compiler has to know by how much to increment the pointer when&lt;br /&gt;
indexing on the first dimension for example. So if an int array is named a,&lt;/p&gt;

&lt;h2 id=&#34;integer-promotion&#34;&gt;Integer Promotion&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.idryman.org/blog/2012/11/21/integer-promotion/&#34;&gt;Deep C: Integer Promotion&lt;/a&gt;&lt;br /&gt;
* &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/fc9te331.aspx&#34;&gt;Integral Promotions&lt;/a&gt;&lt;br /&gt;
0xF int&lt;br /&gt;
0xFFFFFFFF unsigned int&lt;/p&gt;

&lt;h2 id=&#34;scopes-of-identifiers&#34;&gt;Scopes of identifiers&lt;/h2&gt;

&lt;p&gt;For each different entity that an identifier designates, the identifier is visible (i.e., can be&lt;br /&gt;
used) only within a region of program text called its scope.&lt;br /&gt;
* four kinds of scopes: function, file, block, and function prototype&lt;br /&gt;
If the declarator or type specifier that declares the identifier&lt;br /&gt;
appears outside of any block or list of parameters, the identifier has file scope, which&lt;br /&gt;
terminates at the end of the translation unit.&lt;/p&gt;

&lt;p&gt;If the declarator or type specifier that&lt;br /&gt;
declares the identifier appears inside a block or within the list of parameter declarations in&lt;br /&gt;
a function definition, the identifier has block scope, which terminates at the end of the&lt;br /&gt;
associated block.&lt;/p&gt;

&lt;p&gt;If the declarator or type specifier that declares the identifier appears&lt;br /&gt;
within the list of parameter declarations in a function prototype (not part of a function&lt;br /&gt;
definition), the identifier has function prototype scope, which terminates at the end of the&lt;br /&gt;
function declarator.&lt;/p&gt;

&lt;p&gt;If an identifier designates two different entities in the same name&lt;br /&gt;
space, the scopes might overlap.&lt;/p&gt;

&lt;h2 id=&#34;linkages-of-identifiers&#34;&gt;linkages of identifiers&lt;/h2&gt;

&lt;p&gt;An identifier declared in different scopes or in the same scope more than once can be&lt;br /&gt;
made to refer to the same object or function by a process called linkage.&lt;br /&gt;
* There are three kinds of linkage: external, internal, and none.&lt;br /&gt;
* There is no linkage between different identifiers.&lt;br /&gt;
* external linkage&lt;br /&gt;
In the set of translation units and libraries that constitutes an entire program, each&lt;br /&gt;
declaration of a particular identifier with external linkage denotes the same object or&lt;br /&gt;
function. &amp;ndash;c11&lt;/p&gt;

&lt;p&gt;If the name has external linkage,&lt;br /&gt;
the entity that name denotes may be referred to from another translation unit&lt;br /&gt;
using a distinct declaration for that same name,&lt;br /&gt;
and from other scopes within the same translation unit using distinct declarations. &amp;ndash;wikipedia&lt;br /&gt;
* Internal linkage&lt;br /&gt;
Within one translation unit, each declaration of an identifier with internal&lt;br /&gt;
linkage denotes the same object or function. &amp;ndash;c11&lt;/p&gt;

&lt;p&gt;Were the name given internal linkage,&lt;br /&gt;
such a declaration would denote a distinct entity, although using the same name,&lt;br /&gt;
but its entity could be referred to by distinct declarations within the same translation unit.  &amp;ndash;wikipedia&lt;br /&gt;
* No linkage&lt;br /&gt;
Each declaration of an identifier with no linkage denotes a unique entity. &amp;ndash;c11&lt;br /&gt;
A name that has no linkage at all cannot be referred to from declarations in different scopes,&lt;br /&gt;
not even from within the same translation unit. &amp;ndash;wikipedia&lt;/p&gt;

&lt;h2 id=&#34;name-spaces-of-identifiers&#34;&gt;Name spaces of identifiers&lt;/h2&gt;

&lt;h2 id=&#34;storage-durations-of-objects&#34;&gt;Storage durations of objects&lt;/h2&gt;

&lt;p&gt;An object has a storage duration that determines its lifetime.&lt;br /&gt;
There are four storage durations: static, thread, automatic, and allocated.&lt;br /&gt;
The lifetime of an object is the portion of program execution during which storage is&lt;br /&gt;
guaranteed to be reserved for it.&lt;br /&gt;
In book 21st Century C, it was named memory mode.&lt;br /&gt;
* static storage duration&lt;br /&gt;
An object whose identifier is declared without the storage-class specifier _Thread_local,&lt;br /&gt;
and either with external or internal linkage or with the storage-class specifier static(for no linkage &amp;ndash;firo),&lt;br /&gt;
has static storage duration.&lt;/p&gt;

&lt;p&gt;Its lifetime is the entire execution of the program and its stored value is initialized only once,&lt;br /&gt;
prior to program startup.&lt;br /&gt;
* automatic storage duration&lt;br /&gt;
An object whose identifier is declared with no linkage and without the storage-class&lt;br /&gt;
specifier static has automatic storage duration, as do some compound literals.&lt;br /&gt;
* alloced storage duration&lt;br /&gt;
The lifetime of an allocated object extends from the allocation until the deallocation.&lt;br /&gt;
* Thread storage duration&lt;br /&gt;
details in c11&lt;/p&gt;

&lt;h2 id=&#34;alignment-of-objects&#34;&gt;Alignment of objects&lt;/h2&gt;

&lt;p&gt;An alignment is an implementation-defined integer value representing the number of bytes between&lt;br /&gt;
successive addresses at which a given object can be allocated.&lt;br /&gt;
More deatils in cs.md&lt;/p&gt;

&lt;h2 id=&#34;declarations&#34;&gt;Declarations&lt;/h2&gt;

&lt;p&gt;A declaration specifies the interpretation and attributes of a set of identifiers.&lt;br /&gt;
A definition of an identifier is a declaration for that identifier that:&lt;br /&gt;
for an object, causes storage to be reserved for that object;&lt;br /&gt;
for a function, includes the function body;&lt;br /&gt;
for an enumeration constant, is the (only) declaration of the identifier;&lt;br /&gt;
for a typedef name, is the first (or only) declaration of the identifier.&lt;br /&gt;
The declaration specifiers consist of a sequence of specifiers that indicate the linkage,&lt;br /&gt;
storage duration, and part of the type of the entities that the declarators denote.&lt;/p&gt;

&lt;h2 id=&#34;marco&#34;&gt;Marco&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/huyansoft/article/details/2484297&#34;&gt;如果#操作符出现在对象宏的替换列表中,则仅作为一个普通字符,不具有下述含义&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;expressions&#34;&gt;Expressions&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;cast&lt;br /&gt;
A cast does not yield an lvalue.&lt;/p&gt;

&lt;h2 id=&#34;lexical-element&#34;&gt;Lexical element&lt;/h2&gt;

&lt;h3 id=&#34;character-constants&#34;&gt;Character constants&lt;/h3&gt;

&lt;p&gt;An integer character constant has type int.&lt;/p&gt;

&lt;h2 id=&#34;lexical-pitfall&#34;&gt;lexical pitfall&lt;/h2&gt;

&lt;h2 id=&#34;greedy-lexical-analysis&#34;&gt;Greedy lexical analysis&lt;/h2&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Write tokens with blank!&lt;br /&gt;
x = y/&lt;em&gt;p;  /&lt;/em&gt; oops, hidden error.*/&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Associative&lt;br /&gt;
You donot need to remember it! Just use it!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Precedence&lt;br /&gt;
Need to remember, but if you not sure, parenthess.&lt;/p&gt;

&lt;h2 id=&#34;inline-和宏的区别&#34;&gt;inline 和宏的区别&lt;/h2&gt;

&lt;p&gt;inline的好处与坏处&lt;br /&gt;
没有调用的开销效率很高, 但是调试代码复杂了, 内链函数的实现是拷贝副本消耗内存.&lt;br /&gt;
inline有类型检测, 宏没有.&lt;/p&gt;

&lt;h2 id=&#34;c-standard-library&#34;&gt;C standard library&lt;/h2&gt;

&lt;h2 id=&#34;faq&#34;&gt;FAQ&lt;/h2&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Logical operation with signed value? x86!&lt;br /&gt;
int c = 0xFFFFFFFF;  int d = c &amp;gt;&amp;gt; 31; =&amp;gt; d == f;&lt;br /&gt;
unsigned c = 0xFFFFFFFF;  int d = c &amp;gt;&amp;gt; 31; d!= f;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;shift beyond bits long?&lt;br /&gt;
c &amp;gt;&amp;gt; 296 == c &amp;gt;&amp;gt; 8&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;变量同名不同类型不同文件, 通过extern, 否则就是multiple definition&lt;br /&gt;
这是c语言最为迷糊的地方.简单说来类似union, 具体我也不清楚.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;所有名字引用同一个object&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不同文件中不同类型的sizeof和当前文件类型一直.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;c-standard-library-1&#34;&gt;C standard library&lt;/h1&gt;

&lt;p&gt;NULL?&lt;/p&gt;

&lt;h2 id=&#34;string-handling&#34;&gt;String handling&lt;/h2&gt;

&lt;p&gt;kernel/lib/string.c&lt;br /&gt;
* Copying functions&lt;br /&gt;
memcpy: dest&lt;br /&gt;
memmove: dest&lt;br /&gt;
strcpy: dest, 拷贝\0&lt;br /&gt;
strncpy: dest, if src_len &amp;gt;= n; 0 NULL, if src _len &amp;lt; n; (n - len) NULL;&lt;br /&gt;
strlcpy: src_len, mini(n -1, src_len -1) + \0, src_len 用你返回啊!&lt;br /&gt;
* Concatenation functions&lt;br /&gt;
strcat: dest, overwrite dest \0 with src util src \0&lt;br /&gt;
strncat: dest, 末尾一定有\0&lt;br /&gt;
* Comparison functions&lt;br /&gt;
memcmp: 差值,&lt;br /&gt;
strcmp: -1, 0, 1, 如果整个s1都比完了NULL or &amp;ndash;n ==0 for strncmp, return 0&lt;br /&gt;
* Search functions&lt;br /&gt;
memchr, NULL or p;&lt;br /&gt;
strchr,ditto, 到\0返回NUll&lt;br /&gt;
strrchr,ditto, last occurence.&lt;br /&gt;
strspn: s1开始有多少在s2中.&lt;br /&gt;
strcspn: s1开始有多少不在s2中.&lt;br /&gt;
strpbrk: s2中第一次出现的位置&lt;br /&gt;
strstr: 找子串, 用memcmp&lt;/p&gt;

&lt;h1 id=&#34;asm-in-c-code&#34;&gt;ASM in c code&lt;/h1&gt;

&lt;p&gt;c语言嵌入汇编这不是c语言的特性是编译器的feature.&lt;br /&gt;
&lt;a href=&#34;https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html#Using-Assembly-Language-with-C&#34;&gt;How to Use Inline Assembly Language in C Code&lt;/a&gt;&lt;br /&gt;
#MIPS&lt;br /&gt;
bdi 4, 8 delay solt&lt;br /&gt;
mips instruction size is fixed, 32bit, 4byte.&lt;br /&gt;
instruction address:  instrction in hex formate    instruction in string formate, 260&lt;br /&gt;
8002c28c:   8c440104    lw  a0,260(v0)&lt;br /&gt;
##ASM codes Fixme&lt;br /&gt;
move &amp;lt;-&lt;br /&gt;
j long jump&lt;br /&gt;
b short jump&lt;br /&gt;
a0, a1&amp;hellip;99% is parameters.&lt;br /&gt;
##lwr &amp;amp; lwl&lt;br /&gt;
load a word&lt;br /&gt;
different with endianess&lt;br /&gt;
register 63&amp;hellip;..32&amp;hellip;&amp;hellip;0&lt;br /&gt;
big endian: lwl high bits in b + 0&lt;br /&gt;
little endian: lwl high in b + off&lt;br /&gt;
向中心&lt;/p&gt;

&lt;h1 id=&#34;x86&#34;&gt;x86&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://heather.cs.ucdavis.edu/~matloff/50/PLN/lock.pdf&#34;&gt;Intel’s ‘cmpxchg’ instruction&lt;/a&gt;&lt;br /&gt;
eax: e stand for 32&lt;br /&gt;
rax: r stand for 64&lt;br /&gt;
&lt;a href=&#34;http://x86.renejeschke.de/html/file_module_x86_id_159.html&#34;&gt;lock prefix in x86&lt;/a&gt;&lt;br /&gt;
the lock prefix make instruction atomic!&lt;/p&gt;

&lt;h2 id=&#34;registers-purpose&#34;&gt;registers&amp;rsquo; purpose&lt;/h2&gt;

&lt;h2 id=&#34;register&#34;&gt;Register&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;gs&lt;br /&gt;
The linux kernel uses GS to access cpu-specific memory.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;gdtr&lt;br /&gt;
GDT&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;tr&lt;br /&gt;
TSS addressing&lt;br /&gt;
#Wildcards&lt;br /&gt;
&lt;a href=&#34;http://whatis.techtarget.com/definition/wildcard-character&#34;&gt;A wildcard character is a type of meta character&lt;/a&gt;&lt;br /&gt;
##Type&lt;/p&gt;

&lt;h3 id=&#34;standard-wildcards-globbing-patterns&#34;&gt;Standard Wildcards (globbing patterns)&lt;/h3&gt;

&lt;p&gt;File and directory patterns&lt;br /&gt;
?: must stand for a character&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Regular expression&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;SQL&lt;br /&gt;
#Shell&lt;/p&gt;

&lt;h2 id=&#34;test&#34;&gt;test&lt;/h2&gt;

&lt;h3 id=&#34;n-is-not-equivalent-to-z&#34;&gt;-n is not equivalent to ! -z&lt;/h3&gt;

&lt;p&gt;Be caution! just juse -z and !-z&lt;/p&gt;

&lt;h2 id=&#34;ls&#34;&gt;ls&lt;/h2&gt;

&lt;p&gt;-l: show hardlinks of file/dir in 2nd column&lt;br /&gt;
drwsrwsr-T: T stand for sticky bit no other execution bit&lt;br /&gt;
##eval&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;create variable name&lt;br /&gt;
&lt;strong&gt;var=&amp;ldquo;name&amp;rdquo;&lt;br /&gt;
eval &amp;ldquo;export &amp;ndash; \&amp;ldquo;$&lt;/strong&gt;var=firo\&amp;ldquo;&amp;rdquo;&lt;br /&gt;
set | grep firo&lt;br /&gt;
__var=&amp;lsquo;name&amp;rsquo;&lt;br /&gt;
bbb=&amp;lsquo;firo&amp;rsquo;&lt;br /&gt;
##expr&lt;br /&gt;
expr &amp;ldquo;$name&amp;rdquo; : &amp;lsquo;(.*).conf&amp;rsquo;&lt;br /&gt;
##find&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;find symbols in object&lt;br /&gt;
find . -name &amp;lsquo;a.out&amp;rsquo; -exec nm -D {} \; -print&lt;br /&gt;
find . -name &amp;lsquo;*.o&amp;rsquo; -print0 | xargs -0 nm -A | egrep &amp;lsquo; (i|y)$&amp;rsquo;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;rm&lt;br /&gt;
find . -name ‘your_pattern*’ -exec rm -f {} \;&lt;br /&gt;
find . -name ‘your_pattern*’ -delete&lt;/p&gt;

&lt;h2 id=&#34;grep&#34;&gt;grep&lt;/h2&gt;

&lt;p&gt;-c: count of match&lt;br /&gt;
##pipe&lt;br /&gt;
find . -type d | while read d; do cnt=$(ls $d | grep tgz | wc -l); echo &amp;ldquo;$cnt $d&amp;rdquo;; done | sort -n &amp;gt;stat&lt;br /&gt;
#AWK&lt;br /&gt;
netstat -n | awk &amp;lsquo;/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}&amp;rsquo;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Filesystem</title>
      <link>http://firoyang.org/cs/fs/</link>
      <pubDate>Fri, 27 Feb 2015 15:46:12 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/fs/</guid>
      <description>

&lt;h1 id=&#34;open&#34;&gt;open()&lt;/h1&gt;

&lt;p&gt;最烦, 看什么系统调用参数了.&lt;br /&gt;
那一大堆很少用到的组合还有undefined, 太扯淡了.&lt;br /&gt;
也说不上碎碎的问题, 要理解着来, 看man 手册, 贴子显然不是&lt;br /&gt;
最后的注意还是看实现吧.&lt;br /&gt;
build_open_flags()还是看不出&lt;br /&gt;
man里面有一句&lt;br /&gt;
 The (undefined) effect of O_RDONLY | O_TRUNC varies among implementations.&lt;br /&gt;
On many systems the file is actually truncated.&lt;/p&gt;

&lt;p&gt;#Hacks&lt;br /&gt;
I suddenly find that a good way to understand fs in kernel is to manupulate a small and complete fs, like ramfs or tmpfs.&lt;/p&gt;

&lt;p&gt;#VFS&lt;br /&gt;
##Common concepts&lt;br /&gt;
* VFS:Common fs interface plus fs anstraction layer!&lt;/p&gt;

&lt;h2 id=&#34;unix-fs-related-abstractions-file-directory-entries-inodes-and-mount-points&#34;&gt;Unix fs-related abstractions: file, directory entries, inodes, and mount points.&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Filesytem: a hierarchial storage of data adhering to a specific structure.&lt;br /&gt;
In unix, fs are mounted at a specific mount point in global hierarchy known as a namespace.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;file: and ordered string of bytes.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;directory: analogous to a folder and usally contains related files.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;dentry: Each component of a path is called a directory entry.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;inode: Unix separate the concept of a file from any associated infomation(file metadata) inode!&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;supreblock: a data structure containing information about the filesystem as a whole.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;vfs-primary-objects-superblock-inode-dentry-file&#34;&gt;VFS primary objects: superblock, inode, dentry, file.&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;supreblock: a specific mounted filesystem.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;inode: unit for fs. all the information needed by the kernel to manipulate a file or directory.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;dentry: accelerate access fs, dcache! a single component of a path, certainly include &lt;em&gt;regular&lt;/em&gt; file.&lt;br /&gt;
VFS treats directory as non-exist &lt;em&gt;normal&lt;/em&gt; file. directory and dentry is not the same at all, different congitive level!&lt;br /&gt;
In VFS, file, dentry, and inode all represents dir and file and others, in others words struct file can stand for a dir!&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;file: an open normal file as associated with a process.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##Step of how to use ext2 fs&lt;br /&gt;
* Register a fs type in kernel.&lt;br /&gt;
struct file_system_type: basic fs driver codes!&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;mkfs.ext2&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;shell mount -&amp;gt; sys_mount -&amp;gt; file_system_type-&amp;gt;mount =&amp;gt; root dentry and dentry-&amp;gt;d_sb!&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;sys_open -&amp;gt;&lt;br /&gt;
path_init()&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;get start point current-&amp;gt;fs{root, pwd}&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;link_path_walk() to the parent dentry of last entry vim in /sbin/vim. deal with diff mounted fs(ext2 and windows ntfs)&lt;br /&gt;
do_last()&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;dentry,look_dcache(), if not in dcache, d_alloc(); d_op = sb-&amp;gt;s_dentry_op&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;file, if not open, file-&amp;gt;f_op = inode-&amp;gt;i_fop&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;sys_write -&amp;gt;&lt;br /&gt;
file-&amp;gt;f_op-&amp;gt;write()&amp;hellip;&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##How make dentry&lt;br /&gt;
d_alloc() alloc new dentry&lt;br /&gt;
parent_entry-&amp;gt;d_inode-&amp;gt;i_op-&amp;gt;lookup=ext2_lookup()-&amp;gt; ext2_iget() -&amp;gt; use raw_inode make inode-&amp;gt;&lt;br /&gt;
set inode to dentry&lt;/p&gt;

&lt;p&gt;#Procfs&lt;br /&gt;
##How many parts does procfs has?&lt;br /&gt;
* process-specific read only /proc/&lt;pid&gt;/&lt;br /&gt;
* process tuneable interface. /proc/&lt;pid&gt;/&lt;br /&gt;
* kernel sysctl, importanta kernel tuneable files. /proc/sys/kernel net vm fs&amp;hellip;&lt;br /&gt;
* Read only kernel infomation. /proc&lt;br /&gt;
##I think, important directory need to know.&lt;br /&gt;
/proc/sys/kernel&lt;/p&gt;

&lt;h1 id=&#34;sysfs&#34;&gt;Sysfs&lt;/h1&gt;

&lt;p&gt;sysfs is strongly depend on driver module, just rmmod tg3 then /sys/class/net/enp9s0 went away!&lt;/p&gt;

&lt;h1 id=&#34;ramfs&#34;&gt;Ramfs&lt;/h1&gt;

&lt;p&gt;fs/ramfs&lt;/p&gt;

&lt;p&gt;##reference&lt;br /&gt;
&lt;a href=&#34;http://www.thegeekstuff.com/2008/11/overview-of-ramfs-and-tmpfs-on-linux/&#34;&gt;Overview of RAMFS and TMPFS on Linux&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;#tmpfs&lt;br /&gt;
mm/shmem.c&lt;br /&gt;
&lt;a href=&#34;http://wangcong.org/2012/02/17/-e5-85-b3-e4-ba-8e-tmpfs/&#34;&gt;关于 tmpfs&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;#rootfs&lt;br /&gt;
init/do_mounts.c&lt;br /&gt;
init_rootfs()&lt;br /&gt;
init_mount_tree&lt;br /&gt;
rootfs = IS_ENABLED(CONFIG_TMPFS) ? tmpfs : ramfs&lt;br /&gt;
但是在do_basic_setup才初始化.&lt;br /&gt;
rootfs_initcall(populate_rootfs);&lt;/p&gt;

&lt;p&gt;#initramfs&lt;br /&gt;
init/initramfs.c&lt;/p&gt;

&lt;p&gt;initrd-&amp;gt;initramfs&lt;br /&gt;
{&lt;br /&gt;
    linus&amp;rsquo; ramfs -&amp;gt; /tmpfs&lt;br /&gt;
}&lt;/p&gt;

&lt;p&gt;##Difference with initrd&lt;br /&gt;
initrd is image with specific fs type, like ext2, need driver built-in kernel.&lt;br /&gt;
initramfs is a cpio, like tar only simpler, populated to rootfs in kernel, with fs type rootfs&lt;/p&gt;

&lt;p&gt;##request hard drive driver maybe fs driver&lt;br /&gt;
ata_host_register-&amp;gt;ata_scsi_scan_host-&amp;gt;__scsi_add_device-&amp;gt;scsi_probe_and_add_lun -&amp;gt;scsi_add_lun&lt;/p&gt;

&lt;p&gt;subsys_initcall(genhd_device_init);-&amp;gt;kobj_map_init{bdev_map.probe.get = base_probe}&lt;/p&gt;

&lt;p&gt;subsys_initcall(init_scsi);4-&amp;gt;scsi_sysfs_register{autoprobe = 1;}&lt;br /&gt;
rootfs_initcall(populate_rootfs);-&amp;gt;{unpack_to_rootfs; 解压initramfs到rootfs}&lt;br /&gt;
module_initinit_sd;6-&amp;gt;scsi_register_driver -&amp;gt;driver_register-&amp;gt;bus_add_driver -&amp;gt;driver_attach -&amp;gt;driver_probe_device-&amp;gt; drv-&amp;gt;probe(dev)=sd_probe_async-&amp;gt;add_disk -&amp;gt; register_disk -&amp;gt; get_gendisk -&amp;gt; kobj_lookup { bdev_map.probe.get()=base_probe(){request_module}}&lt;/p&gt;

&lt;p&gt;##mount fs&lt;br /&gt;
kernel_init_freeable-&amp;gt; if /init in initramfs 可以访问 根文件系统挂在和chroot交给/init也就是systemd&lt;br /&gt;
如果/init不可以访问 prepare_namespace{挂在真正的文件系统}&lt;/p&gt;

&lt;h1 id=&#34;faq&#34;&gt;FAQ&lt;/h1&gt;

&lt;h2 id=&#34;forbid-ln&#34;&gt;forbid ln&lt;/h2&gt;

&lt;p&gt;hard link to directory, recursive&lt;br /&gt;
hard link to file accross partitions, may led confilict with inode number.&lt;/p&gt;

&lt;h2 id=&#34;stick-bit&#34;&gt;stick bit&lt;/h2&gt;

&lt;p&gt;chmod +t&lt;br /&gt;
1777&lt;br /&gt;
只有owner 和root才能删除这个文件, 用于/tmp&lt;/p&gt;

&lt;h2 id=&#34;time-of-file&#34;&gt;time of file&lt;/h2&gt;

&lt;h3 id=&#34;atime&#34;&gt;atime&lt;/h3&gt;

&lt;p&gt;perhaps the most stupid Unix design idea of all times,&amp;rdquo; adding: &amp;ldquo;[T]hink about this a bit: &amp;lsquo;For every file that is read from the disk, lets do a &amp;hellip; write to the disk! And, for every file that is already cached and which we read from the cache &amp;hellip; do a write to the disk!&amp;rsquo;&amp;rdquo; He further emphasized the performance impact thus:&lt;/p&gt;

&lt;h4 id=&#34;find-relatime-options&#34;&gt;find relatime options&lt;/h4&gt;

&lt;p&gt;cat /proc/mounts&lt;br /&gt;
man mount&lt;/p&gt;

&lt;p&gt;##mount root device&lt;br /&gt;
root= name_to_dev_t, mount_root in prepare_namespace&lt;br /&gt;
如果/init不能 sys_access, 则prepare_namespace,切换到真正的root=指定的设备上设备在sd_probe上初始化了.&lt;br /&gt;
systemd负责挂在文件系统, 切换.&lt;/p&gt;

&lt;p&gt;subsys_initcall 4 genhd_device_init with base_probe{ request_module()}&lt;br /&gt;
module_init 6 -&amp;gt;init_sd-&amp;gt;sync_schedule_domain(sd_probe_async&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
