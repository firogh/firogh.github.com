<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Cs on f(x) </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://firoyang.org/cs/</link>
    <language>en-us</language>
    <author>Firo Yang</author>
    
    <updated>Wed, 02 Jan 2019 00:00:00 UTC</updated>
    
    <item>
      <title>Kernel memory bug - SLAB&#39;s 3 lists are corrupted.</title>
      <link>http://firoyang.org/cs/bug_mm_1/</link>
      <pubDate>Wed, 02 Jan 2019 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/bug_mm_1/</guid>
      <description>

&lt;p&gt;Recently, I was working on a kernel memory bug.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://apibugzilla.suse.com/show_bug.cgi?id=1118875&#34;&gt;https://apibugzilla.suse.com/show_bug.cgi?id=1118875&lt;/a&gt;&lt;br /&gt;
L3: kernel BUG at ../mm/slab.c:2804! bad LRU list and active values in page structs in possible use-after-free&lt;/p&gt;

&lt;p&gt;After digging the binary vmcore file of kdump, I got the following findings.&lt;/p&gt;

&lt;h1 id=&#34;node-0&#34;&gt;Node 0&lt;/h1&gt;

&lt;h2 id=&#34;partial&#34;&gt;Partial&lt;/h2&gt;

&lt;p&gt;list page.lru  -H 0xffff8801a7c01348 -s page.lru,s_mem,active,slab_cache,flags &amp;gt;n0p.log&lt;br /&gt;
n0p -&amp;gt; n0f=0xffff8801a7c01358&lt;/p&gt;

&lt;h2 id=&#34;full&#34;&gt;Full&lt;/h2&gt;

&lt;p&gt;list page.lru  -H 0xffff8801a7c01358 -s page.lru,s_mem,active,slab_cache,flags &amp;gt;n0f.log&lt;br /&gt;
n0f -&amp;gt;&lt;br /&gt;
ffffea0006902380&lt;br /&gt;
    lru = {&lt;br /&gt;
      next = 0xffffea0080ed53e0,&lt;br /&gt;
      prev = 0xffffea00405f8ae0&lt;br /&gt;
    }&lt;br /&gt;
    s_mem = 0xffff8801a408e000&lt;br /&gt;
      active = 16&lt;br /&gt;
    slab_cache = 0xffff8801a7c00400&lt;br /&gt;
  flags = 6755398367314048&lt;br /&gt;
ffffea0080ed53c0&lt;br /&gt;
    lru = {&lt;br /&gt;
      next = 0xffffea00422a34e0,&lt;br /&gt;
      prev = 0xffffea00069023a0&lt;br /&gt;
    }&lt;br /&gt;
    s_mem = 0xffff88203b54f000&lt;br /&gt;
      active = 7&lt;br /&gt;
    slab_cache = 0xffff8801a7c00400&lt;br /&gt;
  flags = 24769796876796032&lt;br /&gt;
&amp;hellip; -&amp;gt; n1f = 0xffff881107c00358&lt;/p&gt;

&lt;h1 id=&#34;node-1&#34;&gt;Node 1&lt;/h1&gt;

&lt;h2 id=&#34;partial-1&#34;&gt;Partial&lt;/h2&gt;

&lt;p&gt;crash&amp;gt; list page.lru  -H 0xffff881107c00348 -s page.lru,s_mem,active,slab_cache,flags &amp;gt;n1p.log&lt;br /&gt;
nip-&amp;gt; SLAB ffffea0043ab74e0 -&amp;gt; 0xffff881107c00348 = n1p&lt;br /&gt;
SLAB ffffea0043ab74e0&amp;rsquo;s prev pointing to 0xffff881107c00358&lt;/p&gt;

&lt;h2 id=&#34;full-1&#34;&gt;Full&lt;/h2&gt;

&lt;p&gt;crash&amp;gt; list page.lru  -H 0xffff881107c00358 -s page.lru,s_mem,active,slab_cache,flags &amp;gt;n1f.log&lt;br /&gt;
n1f-&amp;gt; SLAB ffffea0043ab74e0  -&amp;gt; &amp;hellip; -&amp;gt; 0xffff881107c00348 = n1p&lt;/p&gt;

&lt;p&gt;This issue occured on a NUMA system with 2 memory nodes.&lt;br /&gt;
Both node 0 and node 1&amp;rsquo;s SLAB&amp;rsquo;s partial and full lists were corrupted. After looking into this issue a few days, I talked to Vlastimil Babka.&lt;br /&gt;
He provided a fix for this issue. That is 7810e6781e0fcbca78b91cf65053f895bf59e85f - mm, page_alloc: do not break __ GFP_THISNODE by zonelist reset.&lt;/p&gt;

&lt;p&gt;Now, I have a question: why did I cannot solve this issue?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Memory-ordering model</title>
      <link>http://firoyang.org/cs/consistency_model/</link>
      <pubDate>Sat, 16 Dec 2017 15:46:12 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/consistency_model/</guid>
      <description>

&lt;p&gt;When we are talking on memory model, we are refering memory consistency model or memory ordering model.&lt;/p&gt;

&lt;h1 id=&#34;practices&#34;&gt;Practices&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://preshing.com/20120515/memory-reordering-caught-in-the-act/&#34;&gt;Memory Reordering Caught in the Act&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;memory-model&#34;&gt;Memory model&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://homes.cs.washington.edu/~bornholt/post/memory-models.html#fn:lamport&#34;&gt;Memory Consistency Models: A Primer&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.hpl.hp.com/techreports/Compaq-DEC/WRL-95-7.pdf&#34;&gt;Shared Memory Consistency Models: A Tutorial&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://preshing.com/20120930/weak-vs-strong-memory-models/&#34;&gt;Weak vs. Strong Memory Models&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;x86-memory-model&#34;&gt;x86 memory model&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.06.07c.pdf&#34;&gt;Memory Barriers: a Hardware View for Software Hackers - must read&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://bartoszmilewski.com/2008/11/05/who-ordered-memory-fences-on-an-x86/&#34;&gt;x86 is TSO why it borthers fence?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.cnblogs.com/caidi/p/6708789.html&#34;&gt;共同进入与饥饿&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://stackoverflow.com/questions/27595595/when-are-x86-lfence-sfence-and-mfence-instructions-required&#34;&gt;When are x86 LFENCE, SFENCE and MFENCE instructions required?&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;c11-memory-model&#34;&gt;C11 memory model&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://en.cppreference.com/w/c/atomic/memory_order&#34;&gt;C memory order&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/42967.pdf&#34;&gt;Outlawing Ghosts: Avoiding Out-of-Thin-Air Results&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4375.html&#34;&gt;Out-of-Thin-Air Execution is Vacuous&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.cl.cam.ac.uk/~pes20/weakmemory/&#34;&gt;Relaxed-Memory Concurrency&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.cl.cam.ac.uk/~pes20/cpp/model.pdf&#34;&gt;Mathematizing C++ Concurrency: The Isabelle/HOL model&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;compiler-memory-model&#34;&gt;Compiler memory model&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://preshing.com/20120625/memory-ordering-at-compile-time/&#34;&gt;Memory Ordering at Compile Time&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://blog.regehr.org/archives/232&#34;&gt;A Guide to Undefined Behavior in C and C++, Part 3&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;linux-kernel-memory-model&#34;&gt;Linux kernel memory model&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/718628/&#34;&gt;A formal kernel memory-ordering model&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/720550/&#34;&gt;A formal kernel memory-ordering model (part 2)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4374.html&#34;&gt;Linux-Kernel Memory Model&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://events.linuxfoundation.org/sites/events/files/slides/LinuxMM.2016.09.19a.LCE_.pdf&#34;&gt;Linux-Kernel Memory Ordering: Help Arrives At Last!&lt;/a&gt; and &lt;a href=&#34;https://www.youtube.com/watch?v=ULFytshTvIY&#34;&gt;Talk on youtube on this!&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The definitive guide to Linux x86 entry.S</title>
      <link>http://firoyang.org/cs/entry/</link>
      <pubDate>Wed, 26 Apr 2017 21:39:41 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/entry/</guid>
      <description>

&lt;p&gt;Definitive? Actually, it&amp;rsquo;s not and going to die.&lt;/p&gt;

&lt;h1 id=&#34;ref&#34;&gt;ref&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://groups.google.com/forum/#!topic/comp.arch/CjDs4MJCBow%5B1-25%5D&#34;&gt;https://groups.google.com/forum/#!topic/comp.arch/CjDs4MJCBow%5B1-25%5D&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Documentation/x86/entry_64.txt&lt;br /&gt;
&lt;a href=&#34;http://www.lenky.info/archives/2013/03/2245&#34;&gt;对Linux x86-64架构上硬中断的重新认识&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/&#34;&gt;The Definitive Guide to Linux System Calls&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.groad.net/bbs/thread-3276-1-1.html&#34;&gt;选择内存屏障指令|alternative&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;fs and gs register&lt;br /&gt;
For using in TLS, please check &lt;a href=&#34;http://wiki.osdev.org/Thread_Local_Storage#ABI&#34;&gt;OSDEV TLS&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;#ifdef CONFIG_X86_64&lt;br /&gt;
#define __percpu_seg            gs&lt;br /&gt;
#define __percpu_mov_op         movq&lt;br /&gt;
#else&lt;br /&gt;
#define __percpu_seg            fs&lt;br /&gt;
#define __percpu_mov_op         movl&lt;br /&gt;
#endif&lt;/p&gt;

&lt;p&gt;Steps to handle intterrupt&lt;/p&gt;

&lt;p&gt;For logical address to linear address, see intel SDM v3a 3.4 LOGICAL AND LINEAR ADDRESSES.&lt;br /&gt;
For stack switching during escalate the CPL, see SDM v3a 5.8.5 stack switching. The processor will automatically chose the espCPL stack to use during changing in privilege level.&lt;br /&gt;
For more details on stack switching, please check the Figure 5-13. Stack Switching During an Interprivilege-Level Call&lt;br /&gt;
For fast system call, check 3a 5.8.7 Performing Fast Calls to System Procedures&lt;br /&gt;
For TSS and TR, check 3a 7.2&lt;br /&gt;
For Linux hanld irq processes, check ULK 3rd Chapter 4: Hardware Handling of Interrupts and Exceptions&lt;/p&gt;

&lt;h1 id=&#34;for-syscall&#34;&gt;For syscall&lt;/h1&gt;

&lt;p&gt;Common path for syscalls&lt;br /&gt;
glibc -&amp;gt; AT_SYSINFO-&amp;gt; __kernel_vsyscall -&amp;gt; sysenter/syscall/in0x80&lt;br /&gt;
just for vDSO syscalls&lt;br /&gt;
glibc -&amp;gt; AT_SYSINFO_EHDR-&amp;gt; vDSO elf&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hello world! a journey to computer science</title>
      <link>http://firoyang.org/cs/hello/</link>
      <pubDate>Thu, 13 Apr 2017 20:42:49 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/hello/</guid>
      <description>

&lt;p&gt;In this series, I will a simple hello world program to explain the every important concept in cmputer science.&lt;br /&gt;
So let&amp;rsquo;s go.&lt;/p&gt;

&lt;p&gt;Do you know vDSO?&lt;br /&gt;
If a C program, gtod, calls the system call gettimeofday in vDSO, how does this program know the address of gettimeofday?&lt;/p&gt;

&lt;p&gt;ldd gtod&lt;br /&gt;
    linux-gate.so.1 (0xf7766000)&lt;br /&gt;
    libdl.so.2 =&amp;gt; /lib/libdl.so.2 (0xf7743000)&lt;br /&gt;
    libc.so.6 =&amp;gt; /lib/libc.so.6 (0xf7568000)&lt;br /&gt;
    /lib/ld-linux.so.2 (0x56639000)&lt;br /&gt;
Check this commit of glibc:&lt;br /&gt;
30e32d23eb06cbeae02e51c7c4df150736dba795&lt;br /&gt;
Set up GLRO(dl_sysinfo_dso) under [NEED_DL_SYSINFO_DSO] as well&lt;br /&gt;
AT_SYSINFO_EHDR&lt;/p&gt;

&lt;p&gt;Gcc 32bit support&lt;br /&gt;
ca677d3c3cd0eba7d1f03092517aea553a0e8569&lt;br /&gt;
Add x86 32 bit vDSO time function support&lt;br /&gt;
kernel&lt;br /&gt;
37c975545ec63320789962bf307f000f08fabd48&lt;/p&gt;

&lt;h1 id=&#34;start-the-program&#34;&gt;start the program&lt;/h1&gt;

&lt;p&gt;sysdeps/x86_64/dl-machine.h: -&amp;gt; _start -&amp;gt;_dl_start-&amp;gt;/elf/dl-sysdep.c:83:_dl_sysdep_start-&amp;gt;dl_main&lt;/p&gt;

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://a3f.at/lists/linkers&#34;&gt;Linkers 20 parts by Gold author Ian Lance Taylor&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/#locating-the-vdso-in-memory&#34;&gt;The Definitive Guide to Linux System Calls&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Page fault</title>
      <link>http://firoyang.org/cs/page_fault/</link>
      <pubDate>Thu, 06 Apr 2017 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/page_fault/</guid>
      <description>

&lt;h1 id=&#34;page-fault&#34;&gt;Page Fault&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;page-fault exceptions error code&lt;br /&gt;
v3a: 4.7 - Figure 4-12. Page-Fault Error Code&lt;br /&gt;
P, W/R, U/S, I/D, RSVD&lt;br /&gt;
user/kernel mode, kerne space/userspace addr, good/bad area&lt;/p&gt;

&lt;h2 id=&#34;kernel-mode&#34;&gt;kernel mode&lt;/h2&gt;

&lt;h3 id=&#34;userspace-address&#34;&gt;Userspace address&lt;/h3&gt;

&lt;p&gt;Ondemanding page&lt;br /&gt;
COW - do_wp_page&lt;/p&gt;

&lt;h3 id=&#34;kernel-address&#34;&gt;kernel address&lt;/h3&gt;

&lt;p&gt;vmalloc&lt;/p&gt;

&lt;h3 id=&#34;an-invalide-address-nocontext&#34;&gt;An invalide address - nocontext&lt;/h3&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;fixup_exception&lt;br /&gt;
&lt;a href=&#34;https://www.linuxjournal.com/article/2135&#34;&gt;Kernel-Level Exception Handling&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.kernel.org/doc/Documentation/x86/exception-tables.txt&#34;&gt;https://www.kernel.org/doc/Documentation/x86/exception-tables.txt&lt;/a&gt;&lt;br /&gt;
ex_handler&lt;br /&gt;
SIGSEGV the task since it passed the invalid address to kernel&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;kernel oops&lt;br /&gt;
the address wasn&amp;rsquo;t from user space. It should be a kernel bug.&lt;br /&gt;
kproxy module error&lt;/p&gt;

&lt;h2 id=&#34;user-mode&#34;&gt;User mode&lt;/h2&gt;

&lt;h3 id=&#34;bad-area&#34;&gt;Bad area&lt;/h3&gt;

&lt;p&gt;PF_USER ? SIGSEGV&lt;/p&gt;

&lt;h2 id=&#34;do-page-fault-nuclus&#34;&gt;do_page_fault() - nuclus&lt;/h2&gt;

&lt;h3 id=&#34;kernel-address-1&#34;&gt;kernel address:&lt;/h3&gt;

&lt;p&gt;vmalloc,spurious_fault, kprobes_fault, PF_USER ? bad_are_nosemaphore SIGSEGV, no_context&lt;/p&gt;

&lt;h3 id=&#34;user-space-address&#34;&gt;user space address:&lt;/h3&gt;

&lt;h4 id=&#34;bad-area-1&#34;&gt;Bad area&lt;/h4&gt;

&lt;p&gt;1) !find_vma&lt;br /&gt;
2) !Permission&lt;/p&gt;

&lt;h4 id=&#34;stack&#34;&gt;stack&lt;/h4&gt;

&lt;p&gt;premise: grows down: address &amp;gt; 65536 + 32 * sizeof(unsigned long) + rsp&lt;br /&gt;
expand_stack(): expand vma of stack; + good area workflow.&lt;/p&gt;

&lt;h4 id=&#34;good-area&#34;&gt;good area&lt;/h4&gt;

&lt;p&gt;handle_mm_fault &amp;amp;&amp;amp; error_handle&lt;/p&gt;

&lt;h2 id=&#34;handle-mm-fault-good-area&#34;&gt;handle_mm_fault - good area&lt;/h2&gt;

&lt;p&gt;FAULT_FLAG_WRITE        0x01    /* Fault was a write access &lt;em&gt;/&lt;br /&gt;
FAULT_FLAG_MKWRITE      0x02    /&lt;/em&gt; Fault was mkwrite of existing pte &lt;em&gt;/&lt;br /&gt;
FAULT_FLAG_ALLOW_RETRY  0x04    /&lt;/em&gt; Retry fault if blocking &lt;em&gt;/&lt;br /&gt;
FAULT_FLAG_RETRY_NOWAIT 0x08    /&lt;/em&gt; Don&amp;rsquo;t drop mmap_sem and wait when retrying &lt;em&gt;/&lt;br /&gt;
FAULT_FLAG_KILLABLE     0x10    /&lt;/em&gt; The fault task is in SIGKILL killable region &lt;em&gt;/&lt;br /&gt;
FAULT_FLAG_TRIED        0x20    /&lt;/em&gt; Second try &lt;em&gt;/&lt;br /&gt;
FAULT_FLAG_USER         0x40    /&lt;/em&gt; The fault originated in userspace &lt;em&gt;/&lt;br /&gt;
FAULT_FLAG_REMOTE       0x80    /&lt;/em&gt; faulting for non current tsk/mm &lt;em&gt;/&lt;br /&gt;
FAULT_FLAG_INSTRUCTION  0x100   /&lt;/em&gt; The fault was during an instruction fetch */&lt;/p&gt;

&lt;h3 id=&#34;do-anonymous-page&#34;&gt;do_anonymous_page&lt;/h3&gt;

&lt;p&gt;page: alloc_zeroed_user_highpage_movable&lt;br /&gt;
page_add_new_anon_rmap&lt;br /&gt;
set_pte_at&lt;/p&gt;

&lt;h3 id=&#34;do-fault&#34;&gt;do_fault&lt;/h3&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;normal read - do_read_fault&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;file private mappings - do_cow_fault&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;shared(file or anonymous mappings) - do_shared_fault&lt;/p&gt;

&lt;h3 id=&#34;do-swap-page&#34;&gt;do_swap_page&lt;/h3&gt;

&lt;h3 id=&#34;do-wp-page&#34;&gt;do_wp_page&lt;/h3&gt;

&lt;p&gt;true cow&lt;/p&gt;

&lt;h2 id=&#34;dbg-kernel-oops&#34;&gt;DBG: Kernel oops&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kernel.org/doc/Documentation/oops-tracing.txt&#34;&gt;kernel oops tracing&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://vegardno.blogspot.com/2016/08/sync-debug.html?m=1&#34;&gt;Debugging a kernel crash found by syzkaller&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;lqo&#34;&gt;LQO&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;why down_read in page_fault&lt;br /&gt;
&lt;a href=&#34;http://wangcong.org/2012/06/01/-e4-b8-ba-e4-bb-80-e4-b9-88linux-e5-86-85-e6-a0-b8-e4-b8-8d-e5-85-81-e8-ae-b8-e5-9c-a8-e4-b8-ad-e6-96-ad-e4-b8-ad-e4-bc-91-e7-9c-a0-ef-bc-9f/&#34;&gt;http://wangcong.org/2012/06/01/-e4-b8-ba-e4-bb-80-e4-b9-88linux-e5-86-85-e6-a0-b8-e4-b8-8d-e5-85-81-e8-ae-b8-e5-9c-a8-e4-b8-ad-e6-96-ad-e4-b8-ad-e4-bc-91-e7-9c-a0-ef-bc-9f/&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;enable IRQ in page fault&lt;br /&gt;
for user mode&lt;br /&gt;
commit 891cffbd6bcba26409869c19c07ecd4bfc0c2460&lt;br /&gt;
Author: Linus Torvalds &lt;a href=&#34;mailto:torvalds@linux-foundation.org&#34;&gt;torvalds@linux-foundation.org&lt;/a&gt;&lt;br /&gt;
Date:   Sun Oct 12 13:16:12 2008 -0700&lt;/p&gt;

&lt;p&gt;x86/mm: do not trigger a kernel warning if user-space disables interrupts and generates a page fault&lt;br /&gt;
for kernel mode&lt;br /&gt;
简直精髓&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What about down_read(&amp;amp;mm-&amp;gt;mmap_sem)?&lt;br /&gt;
linux-tglx&lt;br /&gt;
commit b50661029222940e24d2fba7c982ac0774a38c78&lt;br /&gt;
Author: Andi Kleen &lt;a href=&#34;mailto:ak@muc.de&#34;&gt;ak@muc.de&lt;/a&gt;&lt;br /&gt;
Date:   Thu Sep 16 22:00:12 2004 -0700&lt;/p&gt;

&lt;p&gt;[PATCH] x86-64: avoid deadlock in page fault handler&lt;/p&gt;

&lt;p&gt;Avoid deadlock when kernel fault happens inside mmap sem.&lt;br /&gt;
Check ULKv3 Page 380.&lt;br /&gt;
&lt;a href=&#34;https://lkml.org/lkml/2004/5/19/108&#34;&gt;https://lkml.org/lkml/2004/5/19/108&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lkml.org/lkml/2013/5/13/418&#34;&gt;https://lkml.org/lkml/2013/5/13/418&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;memory-mappings&#34;&gt;memory mappings&lt;/h1&gt;

&lt;p&gt;TLPI:chapter 49&lt;br /&gt;
LSP: Chapter 8&lt;br /&gt;
rmap: anonymous page: asyn: page fault&lt;br /&gt;
rmap: file page: syn vma_link_file&lt;/p&gt;

&lt;h2 id=&#34;anonymouse-private-mappings&#34;&gt;Anonymouse private mappings&lt;/h2&gt;

&lt;p&gt;anonymous page&lt;br /&gt;
* onset&lt;br /&gt;
malloc exploit it to alloc memory&lt;br /&gt;
* nuclus&lt;br /&gt;
do_anonymous_page&lt;/p&gt;

&lt;h2 id=&#34;file-private-mappings-text-and-iniliazed-data&#34;&gt;File private mappings -text and iniliazed data.&lt;/h2&gt;

&lt;p&gt;双空, anonymous page&lt;br /&gt;
* onset - mmap&lt;br /&gt;
do_mmap -&amp;gt; mmap_region -&amp;gt; call_mmap-&amp;gt;generic_file_mmap-&amp;gt;vma-&amp;gt;vm_ops = &amp;amp; generic_file_vm_ops&lt;br /&gt;
* nuclus -&amp;gt; page fault -&amp;gt; do_cow_page&lt;br /&gt;
1. get page and cow:  __do_fault-&amp;gt; vma-&amp;gt;vm_ops-&amp;gt;fault = filemap_fault -&amp;gt; page cache ? page_cache_read add to lru&lt;br /&gt;
2. add page to anon lru list: finish_fault-&amp;gt;alloc_set_pte-&amp;gt; page_add_new_anon_rmap -&amp;gt; __SetPageSwapBacked&lt;/p&gt;

&lt;h3 id=&#34;example-text-and-initalized-data&#34;&gt;Example text and initalized data&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://www.greenend.org.uk/rjk/tech/dataseg.html#summary&#34;&gt;??&amp;mdash;p PROT_NOME mapping&lt;/a&gt;&lt;br /&gt;
show_vma_header_prefix&lt;br /&gt;
cat /proc/self/maps&lt;br /&gt;
7ffff7a17000-7ffff7bcc000 r-xp 00000000 08:03 1188168                    /usr/lib64/libc-2.27.so ============&amp;gt; text&lt;br /&gt;
7ffff7bcc000-7ffff7dcc000 &amp;mdash;p 001b5000 08:03 1188168                    /usr/lib64/libc-2.27.so ============&amp;gt; PROT_NONE&lt;br /&gt;
7ffff7dcc000-7ffff7dd0000 r&amp;ndash;p 001b5000 08:03 1188168                    /usr/lib64/libc-2.27.so ============&amp;gt; read only data&lt;br /&gt;
7ffff7dd0000-7ffff7dd2000 rw-p 001b9000 08:03 1188168                    /usr/lib64/libc-2.27.so ============&amp;gt; initialized&lt;br /&gt;
7ffff7dd2000-7ffff7dd6000 rw-p 00000000 00:00 0&lt;br /&gt;
strace -e mmap,mprotect cat /dev/null&lt;br /&gt;
mmap(NULL, 3926752, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7ffff7a17000       ===&amp;gt; text&lt;br /&gt;
mprotect(0x7ffff7bcc000, 2097152, PROT_NONE) = 0                                ======================&amp;gt; PROT_NONE&lt;br /&gt;
mmap(0x7ffff7dcc000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1b5000) = 0x7ffff7dcc000&lt;br /&gt;
mmap(0x7ffff7dd2000, 15072, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7ffff7dd2000&lt;br /&gt;
mprotect(0x7ffff7dcc000, 16384, PROT_READ) = 0                                          ========&amp;gt; read only data&lt;/p&gt;

&lt;h2 id=&#34;anonymouse-shared-mappings-parent-and-child-share-memory&#34;&gt;Anonymouse shared mappings - Parent and child share memory&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lore.kernel.org/patchwork/patch/174306/&#34;&gt;vmscan: limit VM_EXEC protection to file pages&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/452035/&#34;&gt;ashmem&lt;/a&gt;&lt;br /&gt;
file page: i_mmap&lt;br /&gt;
* onset - mmap&lt;br /&gt;
do_mmap -&amp;gt; mmap_region -&amp;gt; vma_link -&amp;gt; (__shmem_file_setup) &amp;amp;&amp;amp; __vma_link_file: into i_mmap interval_tree.&lt;br /&gt;
* nuclus - share fault&lt;br /&gt;
do_shared_fault&lt;br /&gt;
shmem_getpage_gfp&lt;br /&gt;
mapping = inode-&amp;gt;i_mapping&lt;br /&gt;
shmem_add_to_page_cache&lt;br /&gt;
* dirty a shared page since it&amp;rsquo;s write fault&lt;br /&gt;
do_shared_fault-&amp;gt;fault_dirty_shared_page&lt;br /&gt;
* what about read fault?&lt;br /&gt;
seems read won&amp;rsquo;t dirty the shared page.&lt;br /&gt;
* Swaping out a anonymouse shared page&lt;br /&gt;
pageout-&amp;gt;shmem_writepage - Move the page from the page cache to the swap cache; and swp_to_radix_entry&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/588802/&#34;&gt;map_pages&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;write-protect-for-shared-page&#34;&gt;Write protect for shared page&lt;/h3&gt;

&lt;p&gt;do_wp_page -&amp;gt; wp_page_reuse&lt;br /&gt;
[PATCH] mm: tracking shared dirty pages - d08b3851da41d0ee60851f2c75b118e1f7a5fc89&lt;/p&gt;

&lt;h2 id=&#34;file-shared-mappings-a-memory-mapped-i-o-b-ipc-using-a-shared-file-mapping&#34;&gt;File shared mappings - a) Memory-mapped I/O, b)IPC using a shared file mapping&lt;/h2&gt;

&lt;p&gt;file page: i_mmap&lt;/p&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;mapping:  anon &amp;amp; private, anon&lt;br /&gt;
from: anonymous page, file-backing&lt;br /&gt;
to: swap area, file on the disk&lt;br /&gt;
rmap:&lt;br /&gt;
lru:&lt;br /&gt;
cache: swap cache, page cache&lt;br /&gt;
read:&lt;br /&gt;
write:&lt;br /&gt;
backend: swap area, disk&lt;br /&gt;
PageAnon:       f&amp;amp;p, a&amp;amp;p&lt;br /&gt;
!page_is_file_cache:    f&amp;amp;p, a&amp;amp;p, a&amp;amp;s&lt;/p&gt;

&lt;h2 id=&#34;swap&#34;&gt;swap&lt;/h2&gt;

&lt;p&gt;systemd-&amp;gt;swapon-&amp;gt;sys_swapon&lt;br /&gt;
&amp;amp;def_blk_fops&lt;/p&gt;

&lt;p&gt;do_shared_fault&lt;br /&gt;
shmem_fault&lt;br /&gt;
shmem_alloc_and_acct_page&lt;/p&gt;

&lt;p&gt;swap in&lt;br /&gt;
swapin_readahead&lt;br /&gt;
swap_readpage&lt;br /&gt;
swap_page_sector&lt;/p&gt;

&lt;h2 id=&#34;process-of-swap&#34;&gt;process of swap&lt;/h2&gt;

&lt;h3 id=&#34;swapping-out-pages&#34;&gt;Swapping out pages&lt;/h3&gt;

&lt;p&gt;lru -&amp;gt; swap cache -&amp;gt; updating pte with try to unmap -&amp;gt; write page into swap area -&amp;gt; delete_from_swap_cache()&lt;br /&gt;
shrink_page_list&lt;br /&gt;
key commit:&lt;br /&gt;
mm: cma: discard clean pages during contiguous allocation instead of migration - 02c6de8d757cb32c0829a45d81c3dfcbcafd998b&lt;br /&gt;
mm: reclaim MADV_FREE pages - 802a3a92ad7ac0b9be9df229dee530a1f0a8039b check mark_page_lazyfree&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/590693/&#34;&gt;mm: support madvise(MADV_FREE)&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;swapping-in-pages&#34;&gt;Swapping in pages&lt;/h3&gt;

&lt;h2 id=&#34;fork&#34;&gt;fork&lt;/h2&gt;

&lt;h2 id=&#34;dfc8d636cdb95f7b792d5ba8c9f3b295809c125d&#34;&gt;dfc8d636cdb95f7b792d5ba8c9f3b295809c125d&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>IO and events</title>
      <link>http://firoyang.org/cs/io/</link>
      <pubDate>Tue, 04 Apr 2017 20:08:35 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/io/</guid>
      <description>

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/87892/what-is-the-status-of-posix-asynchronous-i-o-aio&#34;&gt;What is the status of POSIX asynchronous I/O AIO&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://stackoverflow.com/questions/5844955/whats-the-difference-between-event-driven-and-asynchronous-between-epoll-and-a&#34;&gt;hat&amp;rsquo;s the difference between event-driven and asynchronous? Between epoll and AIO?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://davmac.org/davpage/linux/async-io.html&#34;&gt;Asynchronous I/O and event notification on linux&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.gnu.org/software/libc/manual/html_node/Asynchronous-I_002fO.html&#34;&gt;Gnu Libc Perform I/O Operations in Parallel&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;really-confuing-conceptions&#34;&gt;Really confuing conceptions&lt;/h1&gt;

&lt;p&gt;What is Asynchronous I/O?&lt;br /&gt;
The onset of I/O is splitted from nuclus.&lt;br /&gt;
First, asynchronous I/O can be happned in UP machine.&lt;br /&gt;
AIO is based on Proactor, more portable.&lt;/p&gt;

&lt;h1 id=&#34;aynchoronous-event-notfication&#34;&gt;Aynchoronous event notfication&lt;/h1&gt;

&lt;p&gt;epoll is based on Reactor pattern.&lt;br /&gt;
signal is based on Observer pattern.&lt;br /&gt;
For the ease of use, the select loop is implemented as an &lt;em&gt;event loop&lt;/em&gt; with callbacks.&lt;br /&gt;
libevent and libev is a well-designed &lt;em&gt;event loop&lt;/em&gt;.Check shadowsocks for using of libev.&lt;/p&gt;

&lt;h1 id=&#34;faq&#34;&gt;FAQ&lt;/h1&gt;

&lt;p&gt;memory-map IO&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Softirq of Linux Kernel</title>
      <link>http://firoyang.org/cs/softirq/</link>
      <pubDate>Mon, 03 Apr 2017 13:09:05 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/softirq/</guid>
      <description>

&lt;p&gt;##softirq&lt;br /&gt;
同一个softirq可以在不同的CPU上同时运行，softirq必须是可重入的。&lt;br /&gt;
* not allow execute nest but can recusive lock:local_bh_disable&lt;br /&gt;
current-&amp;gt;preemt_count + SOFIRQ_OFFSET also disable preempt current process.&lt;br /&gt;
* hardirq on, can&amp;rsquo;t sleep&lt;br /&gt;
* not percpu&lt;/p&gt;

&lt;h2 id=&#34;tasklet-and-kernel-timer-is-based-on-softirq&#34;&gt;tasklet and kernel timer is based on softirq&lt;/h2&gt;

&lt;p&gt;新增softirq, 是要重新编译内核的, 试试tasklet也不错.&lt;br /&gt;
.不允许两个两个相同类型的tasklet同时执行，即使在不同的处理器上&lt;br /&gt;
* First of all, it&amp;rsquo;s a conglomerate of mostly unrelated jobs,&lt;br /&gt;
 which run in the context of a randomly chosen victim&lt;br /&gt;
 w/o the ability to put any control on them. &amp;ndash;Thomas Gleixner&lt;/p&gt;

&lt;p&gt;tasklet different with other softirq is run  signal cpu core&lt;br /&gt;
spinlock_bh wider then spinlock&lt;/p&gt;

&lt;p&gt;###time of softirq&lt;br /&gt;
* follow hardirq, irq_exit()&lt;br /&gt;
* re-enables softirq, local_bh_enable/spin_unlock_bh(); explicity checks executes, netstack/blockIO.&lt;br /&gt;
* ksoftirqd&lt;/p&gt;

&lt;p&gt;###tasklet&lt;br /&gt;
tasklet like a workqueue, sofirq like kthread. that is wonderful, does it?&lt;br /&gt;
tasklet 被__tasklet_schedule到某个cpu的percu 变量tasklet_vec.tail上保证了&lt;br /&gt;
只有一个cpu执行同一时刻.&lt;/p&gt;

&lt;p&gt;#FAQ&lt;br /&gt;
##When to save irq rather than just disable irq&lt;br /&gt;
local_irq_disable() used in the code path that never disabled interrupts.&lt;br /&gt;
local_irq_save(flags) used in the code path that already disabled interrupts.&lt;/p&gt;

&lt;p&gt;##what about irq nested?&lt;br /&gt;
&lt;a href=&#34;http://lwn.net/Articles/380937/&#34;&gt;http://lwn.net/Articles/380937/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://thread.gmane.org/gmane.linux.kernel/1152658&#34;&gt;Deal PF_MEMALLOC in softirq&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>x86 interrupt and exception</title>
      <link>http://firoyang.org/cs/interrupt_and_exception/</link>
      <pubDate>Mon, 03 Apr 2017 13:02:12 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/interrupt_and_exception/</guid>
      <description>

&lt;p&gt;#Interrupt&lt;/p&gt;

&lt;h2 id=&#34;init&#34;&gt;init&lt;/h2&gt;

&lt;p&gt;native_init_IRQ() -&amp;gt;  set_intr_gate(i, irq_entries_start&amp;hellip;&lt;br /&gt;
irq_entries_start define in arch/x86/kernel/entry_32.S&lt;/p&gt;

&lt;p&gt;##Interrupt Context terminology&lt;br /&gt;
* interrupt context - in_irq or in_interrupt&lt;br /&gt;
irq_enter&lt;br /&gt;
* bh context - in_softirq&lt;br /&gt;
local_bh_disable&lt;br /&gt;
__do_softirq -&amp;gt; __local_bh_disable_ip&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Scheduling in operating system</title>
      <link>http://firoyang.org/cs/scheduling/</link>
      <pubDate>Wed, 29 Mar 2017 10:49:04 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/scheduling/</guid>
      <description>

&lt;h1 id=&#34;ref&#34;&gt;ref&lt;/h1&gt;

&lt;p&gt;Process scheduling in Linux &amp;ndash; Volker Seeker from University of Edinburgh&lt;br /&gt;
&lt;a href=&#34;https://tampub.uta.fi/bitstream/handle/10024/96864/GRADU-1428493916.pdf&#34;&gt;A complete guide to Linux process scheduling&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.kernel.org/doc/Documentation/scheduler/sched-design-CFS.txt&#34;&gt;https://www.kernel.org/doc/Documentation/scheduler/sched-design-CFS.txt&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;problems&#34;&gt;Problems&lt;/h1&gt;

&lt;h2 id=&#34;why-scheduling&#34;&gt;Why scheduling?&lt;/h2&gt;

&lt;p&gt;Customers demand multitasking/concurrent&lt;br /&gt;
Processes are blocked&lt;/p&gt;

&lt;h2 id=&#34;fairness&#34;&gt;Fairness&lt;/h2&gt;

&lt;p&gt;Unit: /proc/sys/kernel/sched_min_granularity_ns&lt;/p&gt;

&lt;h1 id=&#34;conceptions&#34;&gt;Conceptions&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://android.googlesource.com/kernel/msm/+/android-msm-bullhead-3.10-marshmallow-dr/Documentation/scheduler/sched-hmp.txt&#34;&gt;Cpu capacity&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;running-compensator-records-the-running-process&#34;&gt;Running Compensator records the running process&lt;/h1&gt;

&lt;p&gt;scheduler_tick&lt;br /&gt;
{&lt;br /&gt;
    update_rq_clock&lt;br /&gt;
    task_tick_fair -&amp;gt; entity_tick&lt;br /&gt;
    {&lt;br /&gt;
        update_curr&lt;br /&gt;
        {&lt;br /&gt;
            sum_exec_runtime - total runtime&lt;br /&gt;
            cfs_rq-&amp;gt;exec_clock - cfs_rq runtime&lt;br /&gt;
            vruntime    - inverse proportion to the weight or priority&lt;br /&gt;
            update_min_vruntime&lt;br /&gt;
            {&lt;br /&gt;
                cfs_rq-&amp;gt;curr, leftmost, min_vruntime, who is min?&lt;br /&gt;
            }&lt;br /&gt;
            cpuacct - cpu sys/user time&lt;br /&gt;
        }&lt;br /&gt;
    }&lt;br /&gt;
}&lt;/p&gt;

&lt;h1 id=&#34;next-pick-next-task-fair&#34;&gt;Next -&amp;gt; pick_next_task_fair&lt;/h1&gt;

&lt;p&gt;put_prev_entity: update_curr; insert into rb-tree;&lt;br /&gt;
pick_next_entity: left most of rb-tree.&lt;br /&gt;
set_next_entity: remove next from tree since it will disturb inserting and deleting when it is being updated.&lt;/p&gt;

&lt;h1 id=&#34;unrunnable&#34;&gt;Unrunnable&lt;/h1&gt;

&lt;p&gt;dequeue_task&lt;/p&gt;

&lt;h1 id=&#34;resuming&#34;&gt;Resuming&lt;/h1&gt;

&lt;p&gt;try_to_wake_up-&amp;gt;ttwu_queue-&amp;gt;ttwu_do_activate-&amp;gt; or local wakeup: schedule-&amp;gt;try_to_wake_up_local-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    ttwu_activate               #=== speical compensation and enqueue rq&lt;br /&gt;
    {&lt;br /&gt;
        activate_task&lt;br /&gt;
        p-&amp;gt;on_rq = TASK_ON_RQ_QUEUED    #=== 1) rq for task; 2)&lt;br /&gt;
    }&lt;br /&gt;
    ttwu_do_wakeup              #=== normal compensation&lt;br /&gt;
    {&lt;br /&gt;
        check_preempt_curr&lt;br /&gt;
        p-&amp;gt;state = TASK_RUNNING;&lt;br /&gt;
    }&lt;br /&gt;
}&lt;/p&gt;

&lt;p&gt;enqueue_task-&amp;gt; place_entity compensation for wakeup process&lt;/p&gt;

&lt;h2 id=&#34;wake-up-a-sleep-task&#34;&gt;wake up a sleep task&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;se-&amp;gt;on_rq &amp;amp; TASK_ON_RQ_QUEUED; deactivate_task set on_rq to 0;
enqueue_task_fair handles group stuff
enqueue_entity deals with sched_entity - uptodate the vruntime, load average, account load numa perfering,
sysctl_sched_latency: the cfs pledge to the pre-existing tasks that they have 6ms to run before new task to run.
try_to_wake_up_local for local task
try_to_wake_up for any task
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;new-task&#34;&gt;New task&lt;/h1&gt;

&lt;p&gt;speical debit compensation: sched_fork-&amp;gt;task_fork_fair-&amp;gt;place_entity - compensation for new process&lt;br /&gt;
normal compensation: wake_up_new_task&lt;br /&gt;
{&lt;br /&gt;
    activate_task               #=== speical compensation&lt;br /&gt;
    check_preempt_curr          #=== normal compensation&lt;br /&gt;
}&lt;/p&gt;

&lt;h1 id=&#34;priority&#34;&gt;Priority&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;weight&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;priority&lt;br /&gt;
DEFAULT_PRIO&lt;br /&gt;
fs/proc/array.c&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;latency&#34;&gt;Latency&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;sched_nr_latency= /proc/sys/kernel/sched_latency_ns / /proc/sys/kernel/sched_min_granularity_ns&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;if running process &amp;gt; sched_nr_latency, latency cannot be ensured. just focus on min granularity&lt;/p&gt;

&lt;h2 id=&#34;lqo&#34;&gt;LQO&lt;/h2&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;is the difference of leftmost and rightmost smaller than sched_min_granularity_ns??&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sched_slice&lt;/p&gt;

&lt;h1 id=&#34;energy&#34;&gt;Energy&lt;/h1&gt;

&lt;p&gt;blocked &amp;amp; schedule&lt;br /&gt;
check preempt &amp;amp; schedule&lt;br /&gt;
check_preempt_tick              # new preempts curr&lt;br /&gt;
{&lt;br /&gt;
curr running time &amp;gt; sched_slice     # enough time to yield.&lt;br /&gt;
curr - leftmost &amp;gt; sched_slice       # nice to others.&lt;br /&gt;
}&lt;br /&gt;
check_preempt_wakeup                # the wakeuped preempts curr&lt;br /&gt;
{&lt;br /&gt;
curr - wakeuped &amp;gt; sysctl_sched_wakeup_granularity;  # pass the wakeup-preempt-delay&lt;br /&gt;
}&lt;/p&gt;

&lt;h1 id=&#34;io-wait&#34;&gt;io wait&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/342378/&#34;&gt;https://lwn.net/Articles/342378/&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;load-avg&#34;&gt;Load avg&lt;/h1&gt;

&lt;p&gt;update_load&lt;em&gt;avg&lt;br /&gt;
&lt;a href=&#34;https://en.wikipedia.org/wiki/Load&#34;&gt;https://en.wikipedia.org/wiki/Load&lt;/a&gt;&lt;/em&gt;(computing)&lt;br /&gt;
Check External links&lt;br /&gt;
calc_load_fold_active&lt;/p&gt;

&lt;h2 id=&#34;etymology-avenrun&#34;&gt;Etymology - avenrun&lt;/h2&gt;

&lt;p&gt;average nr. of running processes during&lt;br /&gt;
&lt;a href=&#34;https://casper.berkeley.edu/svn/trunk/roach/sw/linux/arch/s390/appldata/appldata_os.c&#34;&gt;https://casper.berkeley.edu/svn/trunk/roach/sw/linux/arch/s390/appldata/appldata_os.c&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;lqo-1&#34;&gt;LQO&lt;/h1&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;h_nr_running and throttled&lt;br /&gt;
sched: Implement hierarchical task accounting for SCHED_OTHER - 953bfcd10e6f3697233e8e5128c611d275da39c1&lt;br /&gt;
&lt;a href=&#34;https://groups.google.com/forum/#!topic/linux.kernel/gRzxHclMy50&#34;&gt;https://groups.google.com/forum/#!topic/linux.kernel/gRzxHclMy50&lt;/a&gt;&lt;br /&gt;
&amp;lsquo;root&amp;rsquo;&lt;br /&gt;
\&lt;br /&gt;
&amp;lsquo;A&amp;rsquo;&lt;br /&gt;
/ \&lt;br /&gt;
t1 t2&lt;br /&gt;
root.nr_running := 2&lt;br /&gt;
root.h_nr_running := 2&lt;br /&gt;
Check enqueue_task_fair()&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;group schedule&lt;br /&gt;
&lt;a href=&#34;https://www.kernel.org/doc/Documentation/scheduler/sched-design-CFS.txt&#34;&gt;https://www.kernel.org/doc/Documentation/scheduler/sched-design-CFS.txt&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;idle&lt;br /&gt;
&lt;a href=&#34;https://www.kernel.org/doc/Documentation/scheduler/sched-arch.txt&#34;&gt;https://www.kernel.org/doc/Documentation/scheduler/sched-arch.txt&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/136065/&#34;&gt;improve SMP reschedule and idle routines&lt;/a&gt;&lt;br /&gt;
TIF_POLLING_NRFLAG -&amp;gt; Need-Resched-Flag?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;process migration&lt;br /&gt;
e761b7725234276a802322549cee5255305a0930&lt;br /&gt;
Introduce cpu_active_map and redo sched domain managment&lt;br /&gt;
When to migration&lt;br /&gt;
    sched_setaffinity __set_cpus_allowed_ptr manuly&lt;br /&gt;
    Selecting a new CPU during wak up a sleeper&lt;br /&gt;
    For balancing, selecting CPU during  wake up new process in _do_fork&lt;br /&gt;
    execve&amp;rsquo;s sched_exec&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;shceduler clock&lt;br /&gt;
rq-&amp;gt;clock is nano seconds?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;clock_task and wraps&lt;br /&gt;
fe44d62122829959e960bc699318d58966922a69&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;START_DEBIT&lt;br /&gt;
no standalone commit&lt;br /&gt;
bf0f6f24a1ece8988b243aefe84ee613099a9245&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;why ahead?&lt;br /&gt;
8 /*&lt;br /&gt;
9  * Place new tasks ahead so that they do not starve already running&lt;br /&gt;
10  * tasks&lt;br /&gt;
11  */&lt;br /&gt;
12 SCHED_FEAT(START_DEBIT, true)&lt;br /&gt;
the tree is named timeline&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://lwn.net/Articles/404993/&#34;&gt;Improving scheduler latency &lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;skip next last buddy&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;git-log&#34;&gt;Git log&lt;/h1&gt;

&lt;p&gt;e9c8431185d6c406887190519f6dbdd112641686&lt;br /&gt;
TASK_WAKING; see migrate_task_rq_fair and try_to_wake_up&lt;br /&gt;
88ec22d3edb72b261f8628226cd543589a6d5e1b&lt;br /&gt;
In order to remove the cfs_rq dependency from set_task_cpu() we need to ensure the task is cfs_rq invariant for all callsites.&lt;br /&gt;
2f950354e6d535b892f133d20bd6a8b09430424c&lt;br /&gt;
sched/fair: Fix fairness issue on migration&lt;br /&gt;
&lt;a href=&#34;http://linux.kernel.narkive.com/p15Wmn0i/migrated-cfs-task-getting-an-unfair-advantage&#34;&gt;Migrated CFS task getting an unfair advantage&lt;/a&gt;&lt;br /&gt;
30cfdcfc5f180fc21a3dad6ae3b7b2a9ee112186&lt;br /&gt;
curr was not kept in rb-tree&lt;/p&gt;

&lt;h1 id=&#34;sd&#34;&gt;SD&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/80911/&#34;&gt;Scheduling domains&lt;/a&gt;&lt;br /&gt;
set sd&lt;br /&gt;
kernel_init_freeable-&amp;gt;&lt;br /&gt;
sched_init_smp-&amp;gt;&lt;br /&gt;
init_sched_domains-&amp;gt;build_sched_domains:-&amp;gt;&lt;br /&gt;
&lt;strong&gt;visit_domain_allocation_hell()-&amp;gt;&lt;/strong&gt;sdt_alloc() alloc the sdd-&amp;gt;sg which is used by build groups&lt;br /&gt;
and sg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(); it covered the size of cpumask&lt;br /&gt;
/* Build the groups for the domains */&lt;br /&gt;
detach_destroy_domains&lt;br /&gt;
cpu_attach_domain&lt;/p&gt;

&lt;p&gt;CONFIG_SCHED_MC=y&lt;br /&gt;
static noinline struct sched_domain *                                   &lt;br /&gt;
sd&lt;em&gt;init&lt;/em&gt;##type(struct sched_domain_topology_level *tl, int cpu)         &lt;br /&gt;
{                                                                       &lt;br /&gt;
        struct sched_domain *sd = *per_cpu&lt;em&gt;ptr(tl-&amp;gt;data.sd, cpu);       &lt;br /&gt;
        *sd = SD&lt;/em&gt;##type##_INIT;                                         &lt;br /&gt;
        SD_INIT_NAME(sd, type);                                         &lt;br /&gt;
        sd-&amp;gt;private = &amp;amp;tl-&amp;gt;data;                                        &lt;br /&gt;
        return sd;                                                      &lt;br /&gt;
}&lt;br /&gt;
tl-&amp;gt;mask(cpu)&lt;br /&gt;
static struct sched_domain_topology_level default_topology[] = {&lt;br /&gt;
#ifdef CONFIG_SCHED_SMT&lt;br /&gt;
        { sd_init_SIBLING, cpu_smt_mask, },&lt;br /&gt;
#endif&lt;br /&gt;
#ifdef CONFIG_SCHED_MC&lt;br /&gt;
        { sd_init_MC, cpu_coregroup_mask, },&lt;br /&gt;
#endif&lt;br /&gt;
#ifdef CONFIG_SCHED_BOOK&lt;br /&gt;
        { sd_init_BOOK, cpu_book_mask, },&lt;br /&gt;
#endif&lt;br /&gt;
        { sd_init_CPU, cpu_cpu_mask, },&lt;br /&gt;
        { NULL, },&lt;br /&gt;
};&lt;br /&gt;
CONFIG_CPUSETS=y&lt;br /&gt;
get sd&lt;br /&gt;
idle_balance&lt;br /&gt;
for_each_domain&lt;/p&gt;

&lt;p&gt;panic&lt;br /&gt;
find_busiest_group&lt;br /&gt;
find_next_bit&lt;br /&gt;
__next_cpu&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Console and TTY</title>
      <link>http://firoyang.org/cs/console/</link>
      <pubDate>Sat, 05 Dec 2015 14:06:29 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/console/</guid>
      <description>

&lt;p&gt;343 line&lt;br /&gt;
1. /dev/console 指向正在运行的tty 和tty0 一样ttyN not pts, console 佬变.&lt;br /&gt;
2. /dev/tty 一直指向所在的那个不变.&lt;/p&gt;

&lt;h1 id=&#34;about-the-design&#34;&gt;About the design&lt;/h1&gt;

&lt;p&gt;Why dose we use /dev/xxx to represent the &amp;ldquo;tty&amp;rdquo; device?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The whole point with &amp;ldquo;everything is a file&amp;rdquo; is not that you have some random filename (indeed, sockets and pipes show that &amp;ldquo;file&amp;rdquo; and &amp;ldquo;filename&amp;rdquo;&lt;br /&gt;
have nothing to do with each other), but the fact that you can use common tools to operate on different things. &amp;ndash; Linus&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So we got the key point!&lt;br /&gt;
In order to use the common tools, file ops and vfs layer, the tty device is &amp;ldquo;abstructed&amp;rdquo; to&lt;br /&gt;
files by us. Addnationaly, we must assurance that is the files is &lt;em&gt;different&lt;/em&gt;. What does&lt;br /&gt;
the word &amp;ldquo;dirrerent&amp;rdquo; means is not that you have some random different filename, but the&lt;br /&gt;
fact that you can access the real device through the different.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Wikipedia:&lt;br /&gt;
In mathematics, injections, surjections and bijections are classes of functions distinguished by the manner in which arguments (input expression&amp;gt; s from the domain) and images (output expressions from the codomain) are related or mapped to each other.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I got an insight that abstruction is a non-injective, right?&lt;br /&gt;
But non-injective may not be a anstruction.&lt;br /&gt;
An asbstruction should come from manipulating different objects.&lt;br /&gt;
Non-injective, 多对一; Multiplex, 一对多.&lt;br /&gt;
So we can use mathematical language to describe the linux subsystem.&lt;br /&gt;
From real life device to a filesystem file.&lt;br /&gt;
* Abstruction: Non-injective, Multiplex(not partial function).&lt;br /&gt;
* Jection num: injective, or non-jective, or multiplex; Jection level: domain set and codoain set!&lt;br /&gt;
Abstruction -&amp;gt; Control abstruction and data abstruction -&amp;gt; Abstruction layer&lt;/p&gt;

&lt;p&gt;软件设计的两个主要目的.&lt;br /&gt;
1. 简化, 易用,易操作, 如computer architecture, tty subsystem. 抽象.&lt;br /&gt;
2. Separation of concerns, modular(abstruciton in layer), 笛卡尔划分的思想&lt;/p&gt;

&lt;h1 id=&#34;tty-struct-disc-data&#34;&gt;tty_struct-&amp;gt;disc_data&lt;/h1&gt;

&lt;p&gt;tty_init_dev-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    initialize_tty_struct-&amp;gt;tty_ldisc_init&lt;br /&gt;
    tty_ldisc_setup-&amp;gt;tty_ldisc_open-&amp;gt;n_tty_open-&amp;gt; tty-&amp;gt;disc_data = ldata;&lt;br /&gt;
}&lt;br /&gt;
sys_vhangup-&amp;gt;tty_vhangup_self-&amp;gt;__tty_hangup-&amp;gt;tty_ldisc_hangup-&amp;gt;tty_ldisc_reinit&lt;br /&gt;
vfs_write-&amp;gt;redirected_tty_write-&amp;gt;tty_write-&amp;gt;n_tty_write-&amp;gt;process_output&lt;/p&gt;

&lt;h1 id=&#34;early-con&#34;&gt;early_con&lt;/h1&gt;

&lt;p&gt;EARLYCON_DECLARE(uart8250, early_serial8250_setup); EARLYCON_DECLARE(uart, early_serial8250_setup);&lt;br /&gt;
setup_earlycon-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    parse_options-&amp;gt;&lt;br /&gt;
    {&lt;br /&gt;
        parse earlycon_device-&amp;gt;port-&amp;gt;uartclk and&lt;br /&gt;
        earlycon_device-&amp;gt;baud&lt;br /&gt;
    }&lt;br /&gt;
    setup = early_serial8250_setup-&amp;gt; init_port(device);&lt;br /&gt;
    register_console(early_console_dev.con)&lt;br /&gt;
}&lt;/p&gt;

&lt;h1 id=&#34;earlyprintk&#34;&gt;earlyprintk&lt;/h1&gt;

&lt;p&gt;early_param(&amp;ldquo;earlyprintk&amp;rdquo;, setup_early_printk)-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    early_serial_init-&amp;gt;&lt;br /&gt;
    {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;}
early_console_register(&amp;amp;early_serial_console, keep);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;h1 id=&#34;cpu-hotplug&#34;&gt;cpu hotplug&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;onset&lt;br /&gt;
static struct smp_hotplug_thread softirq_threads {&lt;br /&gt;
.thread_fn              = run_ksoftirqd&lt;br /&gt;
};&lt;br /&gt;
early_initcall(spawn_ksoftirqd)-&amp;gt;mpboot_register_percpu_thread(&amp;amp;softirq_threads)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;nucles onset&lt;br /&gt;
suspend_enter-&amp;gt;enable_nonboot_cpus-&amp;gt;_cpu_up-&amp;gt;smpboot_create_threads-&amp;gt;&lt;strong&gt;smpboot_create_thread(&amp;amp;hotplug_threads)-&amp;gt;&lt;br /&gt;
kthread_create_on_cpu(smpboot_thread_fn-&amp;gt; ht-&amp;gt;thread_fn(td-&amp;gt;cpu)= run_ksoftirqd-&amp;gt;&lt;/strong&gt;do_softirq-&amp;gt;h-&amp;gt;action(h) = run_timer_softirq-&amp;gt;&lt;br /&gt;
__run_timers-&amp;gt;call_timer_fn)&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;vt 就是个tty也有tty_driver 叫console_driver.&lt;/p&gt;

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;h1 id=&#34;contents&#34;&gt;Contents&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://superuser.com/questions/144666/what-is-the-difference-between-shell-console-and-terminal&#34;&gt;What is the difference between shell, console, and terminal?&lt;/a&gt;&lt;br /&gt;
What does console do in kernel or u-boot?&lt;br /&gt;
Linux console?&lt;br /&gt;
Computer terminal: keyboard + dispaly&lt;br /&gt;
Terminal emulator:&lt;/p&gt;

&lt;h1 id=&#34;get-a-glance-on-u-boot&#34;&gt;get a glance on u-boot&lt;/h1&gt;

&lt;p&gt;start.S:board_init_r&lt;br /&gt;
init_sequence_f: -&amp;gt;init_baud_rate; serial_init; console_init_f&lt;br /&gt;
serial_init -&amp;gt;&amp;amp;eserial1_device-&amp;gt;start=eserial##port##_init-&amp;gt;NS16550_init: UART divisor init.&lt;br /&gt;
Firstly, the struct of serial define some input and output funtion.&lt;br /&gt;
It&amp;rsquo;s basic function of serial, put or get!&lt;br /&gt;
console_init_f: just gd-&amp;gt;have_console = 1;&lt;br /&gt;
init_sequence_r: stdio_init_tables,initr_serial, stdio_add_devices, console_init_r,&lt;br /&gt;
initr_serial: just register &amp;amp;eserial1_device to serial_devices&lt;br /&gt;
stdio_add_devices: drv_system_init, serial_stdio_init&lt;br /&gt;
drv_system_init: register default serial dev to devs.list.&lt;br /&gt;
serial_stdio_init: register &amp;amp;eserial1_device to devs.list. Duplicate, but serial dev &amp;ldquo;eserial0&amp;rdquo;  and system &amp;ldquo;serial&amp;rdquo;.&lt;br /&gt;
console_init_r: console_doenv -&amp;gt;console_setfile:stdio_devices[file(0/1/2)] = dev; actually, dev is &amp;ldquo;serial&amp;rdquo;, but they may be KBD!&lt;br /&gt;
看来console的真正作用就是在serial和kbd中选择一个, 可能多选iomux?&lt;br /&gt;
main_loop:cli_loop: getc!&lt;/p&gt;

&lt;h1 id=&#34;what-is-platform-device-or-driver&#34;&gt;what is platform device or driver?&lt;/h1&gt;

&lt;h1 id=&#34;a-reallife-serial8250&#34;&gt;A reallife serial8250&lt;/h1&gt;

&lt;p&gt;drivers/tty/serial/8250/8250_boca.c:plat_serial8250_port&lt;br /&gt;
module_init-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    serial8250_init-&amp;gt;serial8250_isa_init_ports-&amp;gt;serial8250_ports[i].port.ops = &amp;amp;serial8250_pops; //insidious&lt;br /&gt;
    boca_init-&amp;gt;platform_device_register(&amp;amp;boca_device); //register platform device and data.&lt;br /&gt;
}&lt;br /&gt;
* uart_port-&amp;gt;tty_port&lt;/p&gt;

&lt;p&gt;serial8250_probe(plat_serial8250_port)-&amp;gt;serial8250_register_8250_port(uart_8250_port)-&amp;gt;&lt;br /&gt;
uart_add_one_port(&amp;amp;serial8250_reg, &amp;amp;uart-&amp;gt;port=uart_port)-&amp;gt;&lt;br /&gt;
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uart_configure_port-&amp;gt;
{
    port-&amp;gt;ops-&amp;gt;config_port(port, flags)=serial8250_config_port
    if post is console and not registered; register!
    we know that uport-&amp;gt;cons = drv-&amp;gt;cons; what is the relation to registering about up-&amp;gt;cons.
    why we register it? where does drv-&amp;gt;cons come from?
    //这个uart_driver drv就是serial8250_reg, 我们也就知道了
    // console是设备的一种天生能力. 能否使用, 只关乎你是否想用, 就是配置相关的config SERIAL8250_CONSOLE
    // con_driver is the backends, vga, dummy/serial?, fb. 
}
tty_port_register_device_attr-&amp;gt;
{
    //tty_driver  tty_port
    tty_port_link_device
    tty_register_device_attr
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;h1 id=&#34;simple-conceptions&#34;&gt;Simple conceptions&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.linusakesson.net/programming/tty/&#34;&gt;You must read this -&amp;gt; The TTY demystified&lt;/a&gt;&lt;br /&gt;
System consoles are generalized to computer terminals, which are abstracted respectively by virtual consoles and terminal emulators.&lt;br /&gt;
        UART&lt;br /&gt;
        Line displine + TTY(pts, dummy/serial, kbd+vga/fb)&lt;br /&gt;
* System console&lt;br /&gt;
Virtual termial, Terminal emulator/telnet/ssh -&amp;gt; pts ,Physical terminal&lt;br /&gt;
You need at least one virtual terminal device in order to make use of your keyboard and monitor.&lt;br /&gt;
VT combine keyboard and display see con_init&lt;br /&gt;
con_init init a virtual terminal like gnome-terminal but in kernel.&lt;br /&gt;
con_init mainly init display.&lt;br /&gt;
vty_init mainly init kbd&lt;br /&gt;
They all can be system console.(Exception pts??), if you enable it.&lt;br /&gt;
Console is the entry of linux system.&lt;br /&gt;
* Console driver &amp;ndash; banckends of  console&lt;br /&gt;
struct console 指定了console的结构.&lt;br /&gt;
* Console config&lt;br /&gt;
If I disable CONFIG_SERIAL8250_CONSOLE(enable vt console), then no booting log and I can not login system.&lt;br /&gt;
If I disable CONFIG_VT_CONSOLE(enable serail console, /dev/console point to ttyS0 see show_cons_active), no booting log but I can lgin system.&lt;br /&gt;
How to explain this phenomena?&lt;br /&gt;
From show_cons_active, we know /dev/console should come from console_drivers.&lt;br /&gt;
/dev/console is really the pointer.&lt;br /&gt;
Now, let&amp;rsquo;s inspect open /dev/console.&lt;br /&gt;
* Open /dev/console&lt;br /&gt;
Fisrt, it&amp;rsquo;s the very last place of booting kernel.&lt;br /&gt;
start_kernel-&amp;gt;rest_init-&amp;gt;kernel_init-&amp;gt;kernel_init_freeable-&amp;gt;sys_open((const char __user *) &amp;ldquo;/dev/console&amp;rdquo;, O_RDWR, 0)-&amp;gt;&amp;hellip;-&amp;gt;&lt;br /&gt;
console_fops-&amp;gt;tty_open-&amp;gt;&lt;br /&gt;
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Sitiuations: disbale VT CONSOLE byt enable SERIAL8250_CONSOLE.
// This function work only for /dev/tty
// ls -l /dev/tty
// crw-rw-rw- 1 root tty 5, 0 Dec 10 10:24 /dev/tty
tty_open_current_tty-&amp;gt;
{
    /dev/console is 5:1, just return NULL
}
//This index should be Ctrl + Alt + Fn??
// tty_struct is corresponding virtual console, or just console??
// lookup tty_driver. It looks like lookup a inode, right?
tty_lookup_driver-&amp;gt;
{
    // Find a tty_driver by device() in console_drivers.
    // So we know, got a console, then got a tty_driver, right?
    // Where do the components of console_drivers come form?
    // At present, we should have only serial8250_console because 
    // console vt_console_driver is disabled by us! But tty_driver console_driver
    // still do exist!So console and tty is really separated!
    // When we init vt, we get the tty_driver console_driver with con_ops type of tty_operations.
    // tty_drivers have the same major with /dev/tty0!
    // char_dev -&amp;gt; tty_driver int vty_init, not disable.
    // vt console---^
    console_device-&amp;gt;c-&amp;gt;device(c, index)
    // What about serial8250_console?
    // Where is the tty_driver of serial8250_console?
    // console-&amp;gt;data = uart_driver-&amp;gt;tty_driver.
    // We got another scene : uart-&amp;gt;tty
    // serial8250 console-&amp;gt;data-^
    // serial&#39;s tty_driver alloced in serial8250_init with uart_ops.
    // vt&#39;s tty_driver alloced in vty_init.
    // We summarize these:
    // uart_driver serial8250_reg &amp;lt;-&amp;gt;  vc dev or /dev/tty*
    // serial tty driver &amp;lt;-&amp;gt; vt tty driver 
    // fs:vty_init &amp;lt;-&amp;gt; module:serial8250_init
    // tty driver ops con_ops &amp;lt;-&amp;gt; uart_ops
    // vt use major to connect tty and  vc dev
    // serial use major and -&amp;gt; to connect tty and uart_driver
    // It seems that uart and tty has a strong relationship, yet vt.
    // Ok... we got tty driver.
    // If we disable vt console, then here is the serial8250 tty_driver.
}
// Lookup for tty_struct
tty_driver_lookup_tty -&amp;gt;
{
    //tty_struct is alloced in init function alloc_tty_driver.
    // ttys, termios, ports, cdevs.
    // ttys was used by tty_standard_install then tty_driver_install_tty 
    // then tty_init_dev then ok we return to tty open. So this is the start place.

    So we know tty_driver-&amp;gt;ttys[*] must be NULL.
}
tty_init_dev-&amp;gt;
{
    // tty_driver likes a process, ttys like the files, tty_struct like a file!
    // So we know a tty_struct is a tty file.
    // tty_driver much like a inode
    //So tty_struct-&amp;gt;ops = tty_driver-&amp;gt;ops = &amp;amp; uart_ops
    alloc_tty_struct-&amp;gt;tty-&amp;gt;ops = driver-&amp;gt;ops;
    tty_driver_install_tty(driver, tty_struct)-&amp;gt; tty_standard_install-&amp;gt;driver-&amp;gt;ttys[tty-&amp;gt;index] = tty;
}
// Ok... We got a tty_struct.
// Add /dev/console to tty_struct-&amp;gt;tty_files
tty_add_file
// At present, what have we done?
// open(/dev/console)-&amp;gt;console_drivers-&amp;gt;console-&amp;gt;tty_driver-&amp;gt;tty_struct, right?

tty-&amp;gt;ops-&amp;gt;open(tty, filp)-&amp;gt;//ops = &amp;amp;uart_ops
{
    uart_ops-&amp;gt;open = uart_open-&amp;gt;
    {
        uart-&amp;gt; tty struct
        struct uart_driver *drv = (struct uart_driver *)tty-&amp;gt;driver-&amp;gt;driver_state;
        struct uart_state *state = drv-&amp;gt;state + line; //uart_state
        tty-&amp;gt;driver_data = state;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
// At present, we understand the flow of open /dev/console to serial console&lt;/p&gt;

&lt;h1 id=&#34;what-about-opening-dev-console-to-vt-console&#34;&gt;What about opening /dev/console to vt console&lt;/h1&gt;

&lt;p&gt;sys_open(/dev/console)-&amp;gt; &amp;hellip; tty_open -&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    tty_lookup_driver-&amp;gt; get tty_driver=console_driver,&lt;br /&gt;
    Through the name console_driver, we know, vt tty_driver is the defaut driver of console!&lt;br /&gt;
    // 同时, 我们也应该知道所谓的kernel的system console 是你只要enable了先关的config CONFIG_VT_CONSOLE and CONFIG_SERIAL_8250_CONSOLE.&lt;br /&gt;
    // system console就有了, printk也就有了归处. In other words, you registered, you got printed&lt;br /&gt;
    // In theory, you should be able to input something, like sysrq, I maybe test tomorrow.&lt;br /&gt;
    // 那么在kernel_init中sys_open又是什么鬼呢?&lt;br /&gt;
    // dev/tty 是专门真对进程的, 就是进程之前打开了一个tty就存在singnal里, 这个dev/tty就是取出来的.&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;h1 id=&#34;总结下-打开-dev-console-会从console-drivers-最终到达tty-driver&#34;&gt;总结下, 打开/dev/console, 会从console_drivers, 最终到达tty_driver.&lt;/h1&gt;

&lt;h1 id=&#34;这和-dev-tty-dev-ttys-从tty-drivers-差不多&#34;&gt;这和/dev/tty* /dev/ttyS* 从tty_drivers, 差不多.&lt;/h1&gt;

&lt;p&gt;// 这么输出为什么不会打窜了?&lt;br /&gt;
// How ctrl alt Fn work?&lt;br /&gt;
// echo xxx /dev/tty in serial tty_lookup_driver&lt;br /&gt;
// 另一个问题, serial 的terminal?&lt;/p&gt;

&lt;h1 id=&#34;the-perspective&#34;&gt;The perspective&lt;/h1&gt;

&lt;p&gt;/dev/*&lt;br /&gt;
vfs&lt;br /&gt;
chrdev&lt;br /&gt;
tty_fops&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;gt;tty core&lt;br /&gt;
    ld_ops &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;&amp;gt; tty line discipline(for read, write)&lt;br /&gt;
tty_driver con_ops/uart_ops&amp;mdash;&amp;mdash;&amp;ndash;&amp;gt; tty driver and tty_operations&lt;br /&gt;
HW&lt;br /&gt;
There are three different types of tty drivers: console, serial port, and pty.&lt;br /&gt;
serial8250_default_handle_irq&lt;br /&gt;
UART console&lt;br /&gt;
              |&amp;mdash;- Virtual terminal &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; VT console&lt;br /&gt;
              |                 | &amp;ndash; VT console&lt;br /&gt;
              |&amp;mdash;-&lt;br /&gt;
        Terminal&amp;ndash;|&lt;br /&gt;
              |&amp;mdash;-&lt;/p&gt;

&lt;h1 id=&#34;what-about-console&#34;&gt;What about console?&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;early_con&lt;br /&gt;
start_kernel or setup_arch(arm)-&amp;gt;parse_early_param-&amp;gt;do_early_param-&amp;gt;p-&amp;gt;setup_func()= setup_early_printk-&amp;gt;register_console&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;vga_con&lt;br /&gt;
start_kerenl-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
// All about vga console&lt;br /&gt;
set_arch-&amp;gt; conswitchp = &amp;amp;vga_con; or conswitchp = &amp;amp;dummy_con;&lt;br /&gt;
console_init-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
        tty_ldisc_begin-&amp;gt;tty_register_ldisc(N_TTY, &amp;amp;tty_ldisc_N_TTY);&lt;br /&gt;
    console_initcall(con_init);&lt;br /&gt;
console_initcall(serial8250_console_init)&lt;br /&gt;
    con_init-&amp;gt;&lt;br /&gt;
    {&lt;br /&gt;
        // vc-&amp;gt;vc_sw-&amp;gt;con_putcs is DUMMY&lt;br /&gt;
        //内存映射64KB or 32KB的VGA区域. 启动VGA&lt;br /&gt;
        conswitchp-&amp;gt;con_startup = vgacon_startup -&amp;gt;vga_vram_base = VGA_MAP_MEM(vga_vram_base, vga_vram_size);&lt;br /&gt;
        con_driver_map[0~MAX_NR_CONSOLES] = conswitchp; //空间换时间&lt;br /&gt;
        // 核心内容!&lt;br /&gt;
        for (currcons = 0; currcons &amp;lt; MIN_NR_CONSOLES; currcons++) {&lt;br /&gt;
            // 给vc_cons[currcons].d分配内存&lt;br /&gt;
            vc_cons[currcons].d = vc = kzalloc(sizeof(struct vc_data), GFP_NOWAIT);&lt;br /&gt;
            INIT_WORK(&amp;amp;vc_cons[currcons].SAK_work, vc_SAK);&lt;br /&gt;
            //初始化vc_cons[currcons].d&lt;br /&gt;
            tty_port_init(&amp;amp;vc-&amp;gt;port);&lt;br /&gt;
            // 继续初始化, 主要是确定screenbuf size&lt;br /&gt;
            visual_init(vc, currcons, 1);&lt;br /&gt;
            // 给vc_screenbuf分配内存&lt;br /&gt;
            vc-&amp;gt;vc_screenbuf = kzalloc(vc-&amp;gt;vc_screenbuf_size, GFP_NOWAIT);&lt;br /&gt;
            vc_init(vc, vc-&amp;gt;vc_rows, vc-&amp;gt;vc_cols,&lt;br /&gt;
                currcons || !vc-&amp;gt;vc_sw-&amp;gt;con_save_screen);&lt;br /&gt;
        }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    [    0.000000] Console: colour VGA+ 80x25
    register_console(&amp;amp;vt_console_driver);//vt_console can use vgacon writing.
}
serial8250_console_init-&amp;gt;register_console(&amp;amp;serial8250_console) to console_drivers; exclusive_console.
[    0.000000] console [tty0] enabled
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
module_init(serial8250_init);??&lt;br /&gt;
}&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;fbcon&lt;br /&gt;
register_framebuffer-&amp;gt; do_take_over_console -&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
do_register_con_driver-&amp;gt;csw-&amp;gt;con_startup();registered_con_driver&lt;br /&gt;
do_bind_con_driver -&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    [    3.882220] Console: switching to colour dummy device 80x25&lt;br /&gt;
    [    4.720732] Console: switching to colour frame buffer device 170x48&lt;br /&gt;
}&lt;br /&gt;
}&lt;/p&gt;

&lt;h2 id=&#34;vga-text-console-printk-write&#34;&gt;VGA text console printk &amp;amp; write&lt;/h2&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;kernel space&lt;br /&gt;
printk-&amp;gt; &amp;hellip;-&amp;gt;log_buf&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;userspace for ttyN&lt;br /&gt;
tty_fops-&amp;gt;write=tty_write-&amp;gt; tty_ldisc_N_TTY-&amp;gt;write=n_tty_write-&amp;gt; tty_driver-&amp;gt;ops=con_ops-&amp;gt;write=con_write-&amp;gt;do_con_write&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;agent&lt;br /&gt;
console_drivers-&amp;gt;vt_console_driver-&amp;gt;serial8250_console-&amp;gt;NULL&lt;br /&gt;
console_unlock-&amp;gt;..-&amp;gt;__call_console_drivers-&amp;gt; console_drivers-&amp;gt;write = vt_console_print&lt;br /&gt;
{&lt;br /&gt;
//保存到screen buf, vga_con也什么不做啊.&lt;br /&gt;
scr_writew((vc-&amp;gt;vc_attr &amp;lt;&amp;lt; 8) + c, (unsigned short *)vc-&amp;gt;vc_pos);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;h1 id=&#34;what-about-tty&#34;&gt;What about tty&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;onset&lt;br /&gt;
console_init-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
tty_ldisc_begin-&amp;gt;tty_register_ldisc(N_TTY, &amp;amp;tty_ldisc_N_TTY);&lt;br /&gt;
console_initcall(con_init);&lt;br /&gt;
console_initcall(serial8250_console_init)&lt;br /&gt;
}&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;N_TTY:&lt;a href=&#34;http://www.linux.it/~rubini/docs/serial/serial.html&#34;&gt;Serial Drivers by Alessandro Rubini&lt;/a&gt;&lt;br /&gt;
fs_initcall:chr_dev_init-&amp;gt;drivers/tty/tty_io.c: tty_init-&amp;gt;&lt;br /&gt;
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* /dev/tty0 = /dev/console console_ops */
/* /dev/tty = the /dev/ttyN whererun echo /dev/tty tty_ops */

//&amp;quot;/dev/tty&amp;quot;,
cdev_init(&amp;amp;tty_cdev, &amp;amp;tty_fops);
&amp;quot;/dev/console&amp;quot;
cdev_init(&amp;amp;console_cdev, &amp;amp;console_fops);
vty_init-&amp;gt;
{
    //&amp;quot;dev/tty0&amp;quot;    
    cdev_init(&amp;amp;vc0_cdev, console_fops); 
    //&amp;quot;/dev/ttyN&amp;quot;
    tty_register_driver-&amp;gt;
    {
        // What does tty_register_driver do ?
        // Alloc and register chr dev region.
        // Add cdev with tty_ops and above region.
        // Register tty device
        // Why do we register tty devices?
        // These devices must be used in some place.
        // After registering itself, the driver registers the devices it controls through the tty_register_device function. 
        // 原来是把major 和minor做成dev_t放到driver-&amp;gt;cdevs[index].dev里面了.
        // 也就是说driver-&amp;gt;cdevs[index]就是tty driver控制的device啊, 怪不得cdev_init(&amp;amp;driver-&amp;gt;cdevs[index], &amp;amp;tty_fops);
        // 那么看来用到的时候就是open了, 竟然没有不过有个tty_get_device用了tty_class
        // tty_register_device_attr-&amp;gt;device_register-&amp;gt;device_add-&amp;gt;klist_add_tail(&amp;amp;dev-&amp;gt;knode_class,&amp;amp;dev-&amp;gt;class-&amp;gt;p-&amp;gt;klist_devices)
        // 果然是在open tty-&amp;gt;dev = tty_get_device(tty);在alloc_tty_struct
        // 不知道这个tty-&amp;gt;dev在哪里用, 不管他了.
        tty_register_device(_attr) -&amp;gt;tty_cdev_add-&amp;gt; cdev_init(&amp;amp;driver-&amp;gt;cdevs[index], &amp;amp;tty_fops);
    }
    kbd_init
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
device_init:serial8250_init-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    // In this function we decide &amp;ldquo;/dev/ttyS*&amp;rdquo;&lt;br /&gt;
    // dmesg |grep Serial&lt;br /&gt;
    // [    0.696341] Serial: &lt;sup&gt;8250&lt;/sup&gt;&amp;frasl;&lt;sub&gt;16550&lt;/sub&gt; driver, 32 ports, IRQ sharing enabled&lt;br /&gt;
    // serial8250.c -&amp;gt; tty_io.c&lt;br /&gt;
    serial8250_reg.nr = UART_NR;&lt;br /&gt;
    ret = uart_register_driver(&amp;amp;serial8250_reg);&lt;br /&gt;
    tty_driver set to uart_driver by uart_register_driver -&amp;gt;&lt;br /&gt;
    {&lt;br /&gt;
        drv-&amp;gt;state = kzalloc        //uart_state&lt;br /&gt;
        normal-&amp;gt;driver_state    = drv; //args struct uart_driver *drv = &amp;amp;serial8250_reg&lt;br /&gt;
        tty_set_operations(normal, &amp;amp;uart_ops);&lt;br /&gt;
        struct tty_port &lt;em&gt;port = &amp;amp;state-&amp;gt;port&lt;br /&gt;
        tty_port_init(port);&lt;br /&gt;
        port-&amp;gt;ops = &amp;amp;uart_port_ops; //tty_port&lt;br /&gt;
        // We register &amp;ldquo;/dev/ttyS&lt;/em&gt;&amp;rdquo; files here.&lt;br /&gt;
        static struct uart_driver serial8250_reg = {&lt;br /&gt;
            .owner                  = THIS_MODULE,&lt;br /&gt;
            .driver_name            = &amp;ldquo;serial&amp;rdquo;,&lt;br /&gt;
            .dev_name               = &amp;ldquo;ttyS&amp;rdquo;,&lt;br /&gt;
            .major                  = TTY_MAJOR,&lt;br /&gt;
            .minor                  = 64,&lt;br /&gt;
            .cons                   = SERIAL8250_CONSOLE,&lt;br /&gt;
        };&lt;br /&gt;
        retval = tty_register_driver(normal); -&amp;gt; register_chrdev_region(dev, driver-&amp;gt;num, driver-&amp;gt;name) //32, ttyS?*? should be tty_ops&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;}
serial8250_register_ports(&amp;amp;serial8250_reg, &amp;amp;serial8250_isa_devs-&amp;gt;dev);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
* nucleus&lt;br /&gt;
tty_write-&amp;gt;ld-&amp;gt;ops-&amp;gt;write=n_tty_write-&amp;gt;(tty_struct tty-&amp;gt;ops-&amp;gt;write)=uart_write-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    struct uart_state *state = tty-&amp;gt;driver_data;&lt;br /&gt;
    port = state-&amp;gt;uart_port;&lt;br /&gt;
    circ = &amp;amp;state-&amp;gt;xmit;&lt;br /&gt;
    memcpy(circ-&amp;gt;buf + circ-&amp;gt;head, buf, c);&lt;br /&gt;
    uart_start-&amp;gt;__uart_start-&amp;gt;(uart_port-&amp;gt;ops-&amp;gt;start_tx(port)); //&amp;amp;uart_port_ops ?? uart_ops??&lt;br /&gt;
}&lt;/p&gt;

&lt;h1 id=&#34;what-about-pseudoterminal&#34;&gt;What about Pseudoterminal&lt;/h1&gt;

&lt;p&gt;/dev/ptmx is the &amp;ldquo;pseudo-terminal master multiplexer&amp;rdquo;. from wikipedia&lt;br /&gt;
static struct tty_driver *ptm_driver;&lt;br /&gt;
static struct tty_driver *pts_driver;&lt;br /&gt;
module_init(pty_init)-&amp;gt;unix98_pty_init-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    tty_set_operations(ptm_driver, &amp;amp;ptm_unix98_ops);&lt;br /&gt;
    tty_register_driver(ptm_driver)&lt;br /&gt;
    tty_set_operations(pts_driver, &amp;amp;pty_unix98_ops);&lt;br /&gt;
    tty_register_driver(pts_driver)&lt;br /&gt;
    ptmx_fops = tty_fops;&lt;br /&gt;
    ptmx_fops.open = ptmx_open;&lt;br /&gt;
    cdev_init(&amp;amp;ptmx_cdev, &amp;amp;ptmx_fops);&lt;br /&gt;
}&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;How to use ptmx?&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;tty-drivers&#34;&gt;tty drivers&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;cat /proc/tty/drivers&lt;br /&gt;
/dev/tty             /dev/tty        5       0 system:/dev/tty&lt;br /&gt;
/dev/console         /dev/console    5       1 system:console&lt;br /&gt;
/dev/ptmx            /dev/ptmx       5       2 system&lt;br /&gt;
/dev/vc/0            /dev/vc/0       4       0 system:vtmaster&lt;br /&gt;
usbserial            /dev/ttyUSB   188 0-511 serial&lt;br /&gt;
serial               /dev/ttyS       4 64-95 serial&lt;br /&gt;
pty_slave            /dev/pts      136 0-1048575 pty:slave&lt;br /&gt;
pty_master           /dev/ptm      128 0-1048575 pty:master&lt;br /&gt;
unknown              /dev/tty        4 1-63 console&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;question&#34;&gt;Question?&lt;/h1&gt;

&lt;p&gt;what is /dev/vcs?&lt;/p&gt;

&lt;h1 id=&#34;backup&#34;&gt;Backup&lt;/h1&gt;

&lt;p&gt;./drivers//tty/vt/vt.c:3042:        register_chrdev_region(MKDEV(TTY_MAJOR, 0), 1, &amp;ldquo;/dev/vc/0&amp;rdquo;) &amp;lt; 0)&lt;br /&gt;
./drivers//tty/vt/vc_screen.c:644:  if (register_chrdev(VCS_MAJOR, &amp;ldquo;vcs&amp;rdquo;, &amp;amp;vcs_fops))&lt;br /&gt;
./drivers//tty/tty_io.c:3377:       error = register_chrdev_region(dev, driver-&amp;gt;num, driver-&amp;gt;name);&lt;br /&gt;
./drivers//tty/tty_io.c:3414:   unregister_chrdev_region(dev, driver-&amp;gt;num);&lt;br /&gt;
./drivers//tty/tty_io.c:3430:   unregister_chrdev_region(MKDEV(driver-&amp;gt;major, driver-&amp;gt;minor_start),&lt;br /&gt;
./drivers//tty/tty_io.c:3607:       register_chrdev_region(MKDEV(TTYAUX_MAJOR, 0), 1, &amp;ldquo;/dev/tty&amp;rdquo;) &amp;lt; 0)&lt;br /&gt;
./drivers//tty/tty_io.c:3613:       register_chrdev_region(MKDEV(TTYAUX_MAJOR, 1), 1, &amp;ldquo;/dev/console&amp;rdquo;) &amp;lt; 0)&lt;br /&gt;
./drivers//tty/pty.c:841:       register_chrdev_region(MKDEV(TTYAUX_MAJOR, 2), 1, &amp;ldquo;/dev/ptmx&amp;rdquo;) &amp;lt; 0)&lt;/p&gt;

&lt;h1 id=&#34;hugh-in-n-tty-write&#34;&gt;hugh in n_tty_write&lt;/h1&gt;

&lt;p&gt;uart_flush_buffer-&amp;gt; tty_wakeup&lt;br /&gt;
serial8250_handle_port-&amp;gt; transmit_chars&lt;br /&gt;
n_tty_read/poll-&amp;gt;input_available_p-&amp;gt;flush_to_ldisc-&amp;gt;n_tty_receive_buf-&amp;gt;uart_flush_chars&lt;br /&gt;
n_tty_write-&amp;gt;uart_flush_chars-&amp;gt;uart_start&lt;br /&gt;
n_tty_write-&amp;gt;uart_write-&amp;gt; uart_start-&amp;gt;start_tx -&amp;gt; serial8250_start_tx -&amp;gt; transmit_chars-&amp;gt;uart_write_wakeup -&amp;gt;uart_tasklet_action-&amp;gt;tty_wakeup&lt;/p&gt;

&lt;h1 id=&#34;echo-char&#34;&gt;Echo char&lt;/h1&gt;

&lt;p&gt;===serial chipset&lt;br /&gt;
serial8250_interrupt&lt;br /&gt;
seirial8250_handle_port&lt;br /&gt;
receive_chars&lt;/p&gt;

&lt;p&gt;===serial abstruction&lt;br /&gt;
uart_insert_char&lt;/p&gt;

&lt;p&gt;===terminal device&lt;br /&gt;
tty_insert_flip_char&lt;/p&gt;

&lt;p&gt;receive_chars-&amp;gt;tty_flip_buffer_push -&amp;gt;flush_to_ldisc-&amp;gt;&lt;br /&gt;
=== Line discipline&lt;br /&gt;
disc-&amp;gt;receive_buf=n_tty_receive_buf-&amp;gt;n_tty_receive_char-&amp;gt;echo_char&lt;/p&gt;

&lt;h1 id=&#34;uart-port&#34;&gt;uart_port&lt;/h1&gt;

&lt;p&gt;serial8250_register_ports&lt;br /&gt;
struct uart_8250_port *up = &amp;amp;serial8250_ports[i];&lt;br /&gt;
uart_add_one_port(drv, &amp;amp;up-&amp;gt;port);&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>System booting</title>
      <link>http://firoyang.org/cs/boot/</link>
      <pubDate>Thu, 12 Nov 2015 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/boot/</guid>
      <description>

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;Documentation/x86/boot.txt&lt;br /&gt;
&lt;a href=&#34;http://linuxdevices.linuxgizmos.com/introducing-initramfs-a-new-model-for-initial-ram-disks-a/&#34;&gt;Introducing initramfs, a new model for initial RAM disks&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://duartes.org/gustavo/blog/post/kernel-boot-process/&#34;&gt;The Kernel Boot Process&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;kernel-boot-process&#34;&gt;kernel boot process&lt;/h1&gt;

&lt;p&gt;arch/x86/boot/header.S::start_of_setup&lt;br /&gt;
arch/x86/boot/main.c::main()&lt;br /&gt;
    arch/x86/boot/memory.c::detect_memory()&lt;br /&gt;
    arch/x86/boot/memory.c::detect_memory_e820() = boot_params.e820_entries&lt;br /&gt;
    &amp;hellip;&lt;br /&gt;
    arch/x86/boot/pm.c::go_to_protected_mode()&lt;br /&gt;
arch/x86/boot/pmjump.S::protected_mode_jump&lt;br /&gt;
arch/x86/kernel/compressed/head_64.S::startup_32&lt;br /&gt;
arch/x86/kernel/compressed/head_64.S::startup_64&lt;br /&gt;
arch/x86/kernel/head_64.S::startup_64&lt;br /&gt;
kernel/main.c::start_kernel()&lt;br /&gt;
    &amp;hellip;&lt;br /&gt;
    arch/x86/kernel/setup_64.c::setup_arch()&lt;br /&gt;
        &amp;hellip;&lt;br /&gt;
        arch/x86/kernel/setup_64.c::memory_setup()&lt;br /&gt;
        arch/x86/kernel/e820_64.c::machine_specific_memory_setup()&lt;br /&gt;
        arch/x86/kernel/e820_64.c::sanitize_e820_map(boot_params.e820_map, &amp;amp;boot_params.e820_entries)&lt;br /&gt;
        &amp;hellip;&lt;br /&gt;
        arch/x86/kernel/e820_64.c::finish_e820_parsing()&lt;br /&gt;
        &amp;hellip;&lt;br /&gt;
        arch/x86/kernel/e820_64.c::e820_register_active_regions()&lt;br /&gt;
        &amp;hellip;&lt;br /&gt;
        arch/x86/kernel/acpi/boot.c::acpi_boot_table_init()&lt;br /&gt;
        arch/x86/kernel/pci-dma.c::dma32_reserve_bootmem()&lt;br /&gt;
        arch/x86/kernel/acpi/sleep.c::acpi_reserve_bootmem()&lt;br /&gt;
        arch/x86/kernel/efi_64.c::efi_reserve_bootmem()&lt;br /&gt;
        &amp;hellip;&lt;br /&gt;
        arch/x86/kernel/acpi/boot.c::acpi_boot_init()&lt;br /&gt;
        &amp;hellip;&lt;br /&gt;
        arch/x86/kernel/e820_64.c::e820_reserve_resources()&lt;br /&gt;
        arch/x86/kernel/e820_64.c::e820_mark_nosave_regions()&lt;br /&gt;
        arch/x86/kernel/e820_64.c::e820_setup_gap()&lt;br /&gt;
        &amp;hellip;&lt;br /&gt;
    }&lt;br /&gt;
    drivers/acpi/bus.c::acpi_early_init()&lt;br /&gt;
    kernel/main.c::rest_init()&lt;br /&gt;
        arch/x86/kernel/process_32.c::kernel_thread(kernel_init, NULL, CLONE_FS | CLONE_SIGHAND);&lt;br /&gt;
}&lt;br /&gt;
kernel/main.c::kernel_init()&lt;br /&gt;
 &amp;hellip;&lt;br /&gt;
 do_basic_setup()&lt;br /&gt;
  &amp;hellip;&lt;br /&gt;
  drivers/base/init.c::driver_init()&lt;br /&gt;
  &amp;hellip;&lt;br /&gt;
  init/main.c::do_initcalls()&lt;br /&gt;
 }&lt;br /&gt;
 &amp;hellip;&lt;br /&gt;
 init/main.c::init_post()&lt;br /&gt;
}&lt;/p&gt;

&lt;h1 id=&#34;reloctaion-for-decompress&#34;&gt;Reloctaion for decompress&lt;/h1&gt;

&lt;p&gt;974f221c84b05b1dc2f5ea50dc16d2a9d1e95eda&lt;br /&gt;
x86/boot: Move compressed kernel to the end of the decompression buffer&lt;/p&gt;

&lt;h1 id=&#34;realmode&#34;&gt;Realmode&lt;/h1&gt;

&lt;p&gt;The first 640KB RAM&lt;br /&gt;
cat /proc/iomem&lt;br /&gt;
00000000-00000fff : reserved&lt;br /&gt;
00001000-000913ff : System RAM&lt;br /&gt;
00091400-0009ffff : reserved&lt;br /&gt;
000a0000-000bffff : PCI Bus 0000:00&lt;br /&gt;
000c0000-000cfdff : Video ROM&lt;br /&gt;
000d0000-000d99ff : Adapter ROM&lt;br /&gt;
000da000-000dafff : Adapter ROM&lt;br /&gt;
000e0000-000fffff : reserved&lt;br /&gt;
  000f0000-000fffff : System ROM&lt;br /&gt;
00100000-bcb01fff : System RAM   # 1MB; Bootloader uses real_to_prot and prot_to_real to load the kernel image to this place.&lt;br /&gt;
  01000000-0183d36c : Kernel code # That&amp;rsquo;s why the kernel was called big kernel.&lt;br /&gt;
  0183d36d-01f42d3f : Kernel data&lt;br /&gt;
  020c1000-02209fff : Kernel bss&lt;/p&gt;

&lt;h1 id=&#34;horrable-commit-description-on-phys-base&#34;&gt;Horrable commit description on phys_base&lt;/h1&gt;

&lt;p&gt;commit 1ab60e0f72f71ec54831e525a3e1154f1c092408&lt;br /&gt;
Author: Vivek Goyal &lt;a href=&#34;mailto:vgoyal@in.ibm.com&#34;&gt;vgoyal@in.ibm.com&lt;/a&gt;&lt;br /&gt;
Date:   Wed May 2 19:27:07 2007 +0200&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[PATCH] x86-64: Relocatable Kernel Support
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;normalize-cs&#34;&gt;Normalize %cs&lt;/h1&gt;

&lt;p&gt;程序的起始地址在链接脚本中被设置为 0，如果 setup 被加载到其他地方(起始地&lt;br /&gt;
址不为 0 的地方)，那么指令里面访问的全局符号都会有重定位的问题。由于 Boot Loader&lt;br /&gt;
跳转到上面这段代码的时候，把 DS 设置为 setup 加载的基地址，而第 17 行访问_end 默认&lt;br /&gt;
是用数据段寄存器 DS 的，所以不会有重定位的问题。但是在 38 行转移指令用的 CS 寄存器，&lt;br /&gt;
而符号 main 的地址是在链接期决定的，现在加载的基地址改变了，那肯定会出问题了。所&lt;br /&gt;
以事先在第 24 行把 CS 设置为和 DS 一样，这样就解决了重定位的问题了。代码的最后跳转&lt;br /&gt;
到了 arch/x86/boot/main.c 中的 main 函数中继续执行。&lt;/p&gt;

&lt;h1 id=&#34;print-with-int-0x10&#34;&gt;print with int $0x10&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/38041478/int-10h-not-working-in-qemu&#34;&gt;https://stackoverflow.com/questions/38041478/int-10h-not-working-in-qemu&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;a20&#34;&gt;A20&lt;/h1&gt;

&lt;p&gt;[Why enable A20 line in Protected Mode?][&lt;a href=&#34;https://stackoverflow.com/questions/33827474/why-enable-a20-line-in-protected-mode&#34;&gt;https://stackoverflow.com/questions/33827474/why-enable-a20-line-in-protected-mode&lt;/a&gt;]&lt;br /&gt;
This gate, (the A20 gate), is controlled by a GPIO pin on the keyboard controller IC. Thus, you need to enable it before going into protected mode. If you didn&amp;rsquo;t, (and say you flat-mapped all 4GB of physical memory), then as Micheal Petch indicated, &amp;ldquo;every odd numbered megabyte region will be inaccessible. So 1mb-2mb will actually reference 0-1mb, 3mb-4mb will reference 2mb-3mb etc.&amp;rdquo; See also:&lt;/p&gt;

&lt;h1 id=&#34;contents&#34;&gt;Contents&lt;/h1&gt;

&lt;p&gt;What basic initializations should be perfomed when power on?&lt;br /&gt;
How do we load the kernel to memory?&lt;br /&gt;
What does kernel do when kernel boot.&lt;br /&gt;
MBR vs BIOS?&lt;br /&gt;
PC vs embedded&lt;br /&gt;
Kernel init&lt;br /&gt;
before start_kernel&lt;br /&gt;
start_kernel&lt;br /&gt;
reset_init &amp;amp; kernel_init&lt;/p&gt;

&lt;h1 id=&#34;boot-and-init&#34;&gt;Boot and init&lt;/h1&gt;

&lt;p&gt;Power button -&amp;gt; cpu reset -&amp;gt; BIOS -&amp;gt; hard drive -&amp;gt; Grub boot.S/MBR aa5a -&amp;gt; Grub diskboot.S -&amp;gt; &amp;hellip; -&amp;gt; The kernel real-mode setup code. _start of arch/x86/boot/header.S&lt;br /&gt;
Aligh register, Stack and BSS for C function to run. -&amp;gt; main-&amp;gt;startup_32-&amp;gt;startup_64-&amp;gt; __START_KERNEL_map-&amp;gt;&amp;hellip; start_kernel&lt;br /&gt;
&lt;a href=&#34;https://github.com/torvalds/linux/blob/master/Documentation/x86/boot.txt#L130&#34;&gt;Kernel legacy boot sector&lt;/a&gt; start form 4d5a of arch/x86/boot/header.S&lt;br /&gt;
is only used by something link &amp;lsquo;qemu-system-x86_64 vmlinuz-3.18-generic&amp;rsquo;. It&amp;rsquo;s obsoleted that is what legacy means.&lt;/p&gt;

&lt;h1 id=&#34;p4080-board&#34;&gt;p4080 Board&lt;/h1&gt;

&lt;p&gt;PBL&lt;br /&gt;
1. initialize I2C, SPI, eLBC, eSDHC.&lt;br /&gt;
2. Load RCW and boot init commands from above.&lt;br /&gt;
3. write date to conf register and memory&lt;/p&gt;

&lt;h1 id=&#34;config&#34;&gt;config&lt;/h1&gt;

&lt;p&gt;CCSRBAR -&amp;gt; CCSR&lt;br /&gt;
default is 0x0_FE00_0000&lt;br /&gt;
CCSRBAR is in CCSR memory. odd. stored in 0(CCSRBAR).&lt;br /&gt;
CCSRBAR always points to itself.&lt;br /&gt;
holdoff&lt;/p&gt;

&lt;h1 id=&#34;u-boot&#34;&gt;u-boot&lt;/h1&gt;

&lt;p&gt;ft_fixup_cpu -&amp;gt; determine_mp_bootpg(NULL) &amp;amp; fdt_add_mem_rsv&lt;/p&gt;

&lt;p&gt;main_loop-&amp;gt; &amp;hellip;-&amp;gt;./common/bootm_os.c:410:&amp;hellip; do_bootm_states-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
bootm_find_other-&amp;gt;bootm_find_ramdisk_fdt-&amp;gt;bootm_find_fdt-&amp;gt;boot_get_fdt&amp;amp;set_working_fdt_addr(0x0200000)-&amp;gt;IMAGE_FORMAT_FIT-&amp;gt;&lt;br /&gt;
&amp;amp;&lt;br /&gt;
boot_fn = bootm_os_get_boot_func(images-&amp;gt;os.os)=[IH_OS_LINUX] =&lt;br /&gt;
&amp;amp;&lt;br /&gt;
boot_selected_os-&amp;gt;boot_fn=do_bootm_linux-&amp;gt;boot_body_linux-&amp;gt;image_setup_linux-&amp;gt;image_setup_libfdt-&amp;gt;&lt;br /&gt;
board/freescale/corenet_ds/corenet_ds.c ft_board_setup-&amp;gt; ft_cpu_setup-&amp;gt;&lt;br /&gt;
}&lt;/p&gt;

&lt;h1 id=&#34;ppc-multicore-booting&#34;&gt;PPC multicore booting&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;There are two possibilites to make secondary cores booting failed.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;There is a bug in the code executed by Secondary cores&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;The spin table address, passed to croe0, is not correct, so we did not really kick the secondary cores.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CCSRBAR&lt;br /&gt;
MPC86xx_MCM_OFFSET&lt;br /&gt;
srio_boot_master_release_slave&lt;/p&gt;

&lt;p&gt;uboot-&amp;gt;&lt;br /&gt;
set the cpu-release-addr at funciton ft_fixup_cpu(), I am not sure.&lt;/p&gt;

&lt;p&gt;core0 run, 2nd cores holdoff&lt;br /&gt;
core0 set BPTR and kick(BRR) 2nd cores, 2nd cores spintable loop in uboot function setup_mp&lt;br /&gt;
core0 -&amp;gt; arch/powerpc/cpu/mpc85xx/start.S-&amp;gt;_start_e500&lt;br /&gt;
board_init_r-&amp;gt;cpu_init_r-&amp;gt; setup_mp-&amp;gt; {&lt;br /&gt;
&lt;strong&gt;bootpg_addr = (u32)virt_to_phys(&amp;amp;&lt;/strong&gt;second_half_boot_page); //Assembly code for put core to spin tablea. Used by __secondary_start_page&lt;br /&gt;
__spin_table_addr = (u32)get_spin_phys_addr();// used by __second_half_boot_page&lt;br /&gt;
bootpg = BPTR = __secondary_start_page&lt;br /&gt;
plat_mp_up-&amp;gt;kick BRR &amp;amp; Boot Space Translation&lt;br /&gt;
}&lt;br /&gt;
2nd cores holdoff -&amp;gt; &lt;strong&gt;secondary_start_page&lt;br /&gt;
kernel-&amp;gt;&lt;br /&gt;
core0 boot kernel, core0 kickoff 2nd cores spintable, triger 2nd core&amp;rsquo;s spin table by writing  the spin table field with the desired address&lt;br /&gt;
2nd cores ePAPR-&amp;gt;spintable-&amp;gt;addr_l=&lt;/strong&gt;early_start-&amp;gt;__secondary_start-&amp;gt;smp_ops-&amp;gt;setup_cpu-&amp;gt;cpu_idle&lt;br /&gt;
arch/powerpc/kernel/head_fsl_booke.S&lt;br /&gt;
U-boot logs:&lt;br /&gt;
Reserving MP boot page to 7ffff000^M^M - &amp;ndash;   -   MP spin table&lt;br /&gt;
address.&lt;br /&gt;
SPAG : fdt_fixup_fman_firmware, 567^M^M&lt;br /&gt;
^M^M&lt;br /&gt;
..r.^M^M&lt;br /&gt;
VDBG : ft_cpu_setup, 737, comment fdt_fixup_memory ^M^M&lt;br /&gt;
VDBG: Secondary cores are not held in reset.^M^M&lt;br /&gt;
Kernel Logs:&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 1 to ack^M^M&lt;br /&gt;
smp: failed starting cpu 1 (rc -2)^M^M&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 2 to ack^M^M&lt;br /&gt;
smp: failed starting cpu 2 (rc -2)^M^M&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 3 to ack^M^M&lt;br /&gt;
smp: failed starting cpu 3 (rc -2)^M^M&lt;br /&gt;
Brought up 1 CPUs^M^M&lt;br /&gt;
devtmpfs: initialized^M^M&lt;/p&gt;

&lt;p&gt;Note that u-boot can&amp;rsquo;t detect  memory above 2G and we need to check&lt;br /&gt;
if kernel is accessing at high mem of 2G or 4G.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Computer architecture</title>
      <link>http://firoyang.org/cs/arch/</link>
      <pubDate>Tue, 13 Oct 2015 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/arch/</guid>
      <description>

&lt;h1 id=&#34;ref&#34;&gt;ref&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://people.cs.clemson.edu/~mark/architects.html&#34;&gt;https://people.cs.clemson.edu/~mark/architects.html&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;asm&#34;&gt;ASM&lt;/h1&gt;

&lt;p&gt;Reference asm global label in C&lt;br /&gt;
char _text[];           x86_64_64;&lt;br /&gt;
unsigned long _text;    x86_64_PC32&lt;br /&gt;
They are different in amrithmatic operstion.&lt;/p&gt;

&lt;p&gt;##Reference&lt;br /&gt;
&lt;a href=&#34;http://people.eecs.berkeley.edu/~rcs/research/interactive_latency.html&#34;&gt;Latency Numbers Every Programmer Should Know&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://youtu.be/cNN_tTXABUA&#34;&gt;How a CPU Works&lt;/a&gt;&lt;br /&gt;
A Symbolic Analysis of Relay and Switching Circuits&lt;br /&gt;
The Mathematical Theory of Communication&lt;br /&gt;
Given a symbol level, the architecture is the description of the system in&lt;br /&gt;
whatever system-description scheme exists next below the symbol level. - Newell, 1990, p. 81&lt;br /&gt;
&lt;a href=&#34;https://news.ycombinator.com/item?id=9844090&#34;&gt;Ask HN: How to learn about the history of computing?&lt;/a&gt;&lt;br /&gt;
《模拟电子技术基础 童诗白 第四版》第一章前半部分&lt;br /&gt;
Structured Computer Organization 6th Edition&lt;br /&gt;
Digital Design and Computer Architecture 2nd Edition&lt;br /&gt;
Computer Organization and Design 5th Edition&lt;br /&gt;
Write Great Code: Volume 1: Understanding the Machine&lt;br /&gt;
See MIPS run&lt;br /&gt;
Intel 64 and IA-32 architectures software developers manual combined volumes 3A, 3B, and 3C: System programming guide&lt;br /&gt;
Microelectronics&lt;/p&gt;

&lt;h2 id=&#34;isa&#34;&gt;ISA&lt;/h2&gt;

&lt;p&gt;model: 1570s, &amp;ldquo;likeness made to scale; architect&amp;rsquo;s set of designs,&amp;rdquo; from Middle French modelle&lt;br /&gt;
Semantics in computer science: In programming language theory, semantics is the field concerned&lt;br /&gt;
with the rigorous mathematical study of the meaning of programming languages.&lt;br /&gt;
Language primitive&lt;br /&gt;
ISA: memory model, registers, data types, instructions, word size(?).&lt;br /&gt;
Memory model: unit of address resolution, word, aligment, address space, addressing mode, memory barrier/memory order primitive&amp;rsquo;s semantics.&lt;br /&gt;
#x86 Interrupt&lt;br /&gt;
If interrupt occured in user mode, then cpu will context swith for potential reschedule.&lt;br /&gt;
The Interrupt Descriptor Table (IDT) is a data structure used by the x86 architecture to implement an interrupt vector table.&lt;br /&gt;
##Hardware interrupts&lt;br /&gt;
are used by devices to communicate that they require attention from the operating system.&lt;br /&gt;
asynchronus&lt;br /&gt;
more details in init_IRQ() or set_irq() in driver.&lt;br /&gt;
##software interrupt&lt;br /&gt;
synchronus&lt;br /&gt;
more details in trap_init().&lt;br /&gt;
* exception or trap&lt;br /&gt;
is caused either by an exceptional condition in the processor itself,&lt;br /&gt;
divide zero painc?&lt;br /&gt;
* special instruction, for example INT 0x80&lt;br /&gt;
or a special instruction in the instruction set which causes an interrupt when it is executed.&lt;/p&gt;

&lt;h1 id=&#34;i-o-ic&#34;&gt;I/O IC&lt;/h1&gt;

&lt;p&gt;serial communication: UART(16550) + RS-232&lt;br /&gt;
parallel communication: SCSI, ISA, ATA, PCI, FSB&lt;/p&gt;

&lt;h1 id=&#34;data-struct-aligment&#34;&gt;Data struct aligment&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.catb.org/esr/structure-packing/&#34;&gt;The Lost Art of C Structure Packing&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://en.wikipedia.org/wiki/Data_structure_alignment#Typical_alignment_of_C_structs_on_x86&#34;&gt;Typical alignment of C structs on x86&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;为什么需要结构体对齐&#34;&gt;为什么需要结构体对齐?&lt;/h2&gt;

&lt;p&gt;struct foo {&lt;br /&gt;
char c;&lt;br /&gt;
int i;};&lt;br /&gt;
如果是32位, cpu 一次取4byte a word 数据.&lt;br /&gt;
如果我们把i的前3byte和c存到一起, 剩下1byte of i自己单独存.&lt;br /&gt;
那么我们访问i这个数据就要读两个4byte a word. 对cpu来说性能损耗.&lt;br /&gt;
如果我们把i单独放到4byte 对齐的地址, 那么我们只需要一次cpu读取.fast!&lt;/p&gt;

&lt;h2 id=&#34;产生非对齐访问的场景&#34;&gt;产生非对齐访问的场景&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Casting variables to types of different lengths, 比如char * 到int *&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Pointer arithmetic followed by access to at least 2 bytes of data , 不太理解.&lt;/p&gt;

&lt;h2 id=&#34;我们做什么&#34;&gt;我们做什么?&lt;/h2&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;什么也不干, 按默认对齐来Natural alignment&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为了不影响性能, 同时减少内存使用, 编程时最好显示reorder.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;get/put_unaligned  to avoid analigned access.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通过attribute aligned指定对齐要求.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;数据要在不同体系, 32/64之间使用, 比如网络,写到disk, 我们必须要attribute packed&lt;br /&gt;
也就是说不对齐, 不同平台对齐可能不同, 我们不能让数据corruption.&lt;/p&gt;

&lt;h2 id=&#34;如果数据不对齐有什么-cpu怎么办&#34;&gt;如果数据不对齐有什么, cpu怎么办?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kernel.org/doc/Documentation/unaligned-memory-access.txt&#34;&gt;必读UNALIGNED MEMORY ACCESSES&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果用了packed, 编译器会生成extra代码阻止非对齐访问, performance loss.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cpu呢? 可能正确处理raise a exception to fix it with performance loss.&lt;/p&gt;

&lt;h2 id=&#34;calculate-the-sizeof-of-aligned-c-struct&#34;&gt;Calculate the sizeof of aligned c struct&lt;/h2&gt;

&lt;p&gt;Data alignment means putting the data at a memory address equal to some multiple of the word size,&lt;br /&gt;
which increases the system&amp;rsquo;s performance due to the way the CPU handles memory.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;find the widest scalar member and attribute( aligned(x)) to determin alignment.&lt;br /&gt;
找到结构体内scalar和attribute最大的对齐要求.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;fill the member to alignement without wrap&lt;br /&gt;
把结构的成员一次填满对齐宽度, 不够的填到下个对齐宽度, 空出来留着padding&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Pading to alignment&lt;br /&gt;
填上所有空.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;endianess&#34;&gt;Endianess&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.yolinux.com/TUTORIALS/Endian-Byte-Order.html&#34;&gt;Endianness: Big and Little Endian Byte Order&lt;/a&gt;&lt;br /&gt;
应该说bit endianess 实际存储只有MSB &amp;hellip; LSB这一种二进制表达形式! 在上面的文章的representtion, 辅证这一点.&lt;br /&gt;
这篇文章&lt;a href=&#34;http://tonybai.com/2013/05/21/talk-about-bitfield-in-c-again/&#34;&gt;再谈C语言位域&lt;/a&gt;,&lt;br /&gt;
之所以输出逆序, 是因为错误里理解了, bit 序. bit 序是cpu 读取的方式, 不是存储的方式!&lt;/p&gt;

&lt;h2 id=&#34;bit-endianness-https-en-wikipedia-org-wiki-bit-numbering&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Bit_numbering&#34;&gt;bit endianness&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;这样就可以更好的理解iphdr:&lt;br /&gt;
#if defined(__LITTLE_ENDIAN_BITFIELD)&lt;br /&gt;
    &lt;strong&gt;u8    ihl:4,&lt;br /&gt;
        version:4;&lt;br /&gt;
#elif defined (&lt;/strong&gt;BIG_ENDIAN_BITFIELD)&lt;br /&gt;
    __u8    version:4,&lt;br /&gt;
        ihl:4;&lt;br /&gt;
#else&lt;br /&gt;
#error  &amp;ldquo;Please fix &lt;asm/byteorder.h&gt;&amp;ldquo;&lt;br /&gt;
#endif&lt;br /&gt;
ipv4 header的拓扑&lt;br /&gt;
version ihl&lt;br /&gt;
0100 0101&lt;br /&gt;
因为le的cpu是 lsb first, 也就是从最左面的1开始读, 所以第一个是ihl&lt;br /&gt;
而be的cpu是 msb first, 从最右开始所以version开头.&lt;br /&gt;
而使用unsigned char ver_ihl&lt;br /&gt;
(ver_ihl &amp;amp; 0xf0)&amp;gt;&amp;gt; 4 = version&lt;br /&gt;
ver_ihl &amp;amp; 0x0f = ihl&lt;br /&gt;
是无关cpu读取顺序的.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux time subsystem</title>
      <link>http://firoyang.org/cs/time/</link>
      <pubDate>Tue, 22 Sep 2015 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/time/</guid>
      <description>

&lt;p&gt;我写作的主要目的是理清基本概念与原理, 而非实现,细节这一类.&lt;/p&gt;

&lt;p&gt;时间是人类发明出来的概念, Kant也认为时间是心智概念.&lt;br /&gt;
一百年前的世界和现在有什么不同呢?这个提问揭示生活中时间最重要的用途,&lt;br /&gt;
*标记*某中状态下的世界. 所谓的过去世界不过是世界的一个个连续状态&lt;br /&gt;
那么时空穿越, 就变成了保住项少龙这个肉身不变, 世界的其他部分完全&lt;br /&gt;
转变到过去的某一个状态. 而所谓现在世界就被抹杀了.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The future is already here – it&#39;s just not evenly distributed.
                        — William Gibson
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;人想回到&amp;rdquo;过去&amp;rdquo;多半源于情感因素, 而想去&amp;rdquo;未来&amp;rdquo;则是因为&amp;rdquo;物质&amp;rdquo;的缘故.&lt;br /&gt;
想象下中国的未来50年, 很可能是现在美国or西欧现在的样子.虽然中西虽然处在&lt;br /&gt;
时间概念上相同的现在, 而物质世界确实&amp;rdquo;过去&amp;rdquo;和&amp;rdquo;未来&amp;rdquo;之差.&lt;/p&gt;

&lt;p&gt;比如我们下周而要开会, 那么此时下周二就是有意识的规划未来, 时间依然是标记.&lt;br /&gt;
UTC/GMT&lt;br /&gt;
Based on caesium microwave atomic clock&lt;br /&gt;
Leap second&lt;/p&gt;

&lt;h2 id=&#34;genus-differentia-definition&#34;&gt;Genus-differentia definition&lt;/h2&gt;

&lt;p&gt;interrupt, clock event,  clock source, tick, timer, timekeeping, gettimeofday.&lt;/p&gt;

&lt;h2 id=&#34;unites&#34;&gt;unites&lt;/h2&gt;

&lt;p&gt;cputime = jiffies under HZ (FIXME)&lt;br /&gt;
sum_exec_runtime nanoseconds&lt;br /&gt;
clockt = jiffies but under USER_HZ&lt;/p&gt;

&lt;h2 id=&#34;功用定义&#34;&gt;功用定义&lt;/h2&gt;

&lt;p&gt;获取时间&lt;br /&gt;
timer&lt;br /&gt;
sleep ?&lt;br /&gt;
update sched info&lt;/p&gt;

&lt;h2 id=&#34;发生定义-设计-etymology-history-operational-definition&#34;&gt;发生定义/设计   etymology, history Operational definition&lt;/h2&gt;

&lt;p&gt;timekeeping/计时:时刻．&lt;br /&gt;
clock source: 时间之源, 表针之力.&lt;br /&gt;
clock event: 闹铃之力, 经过tick展现能力.&lt;br /&gt;
tick: timer的中断事件叫tick, tick device产生tick, 可以说tick决定了clock_event event_handler进而决定了, clock_event行为.&lt;br /&gt;
tickless:&lt;br /&gt;
for timer: use HW timer one shot, set next.&lt;br /&gt;
for update time: in above HW timer, not good&lt;br /&gt;
for sched: for priority distributed in time slice, use timer.&lt;br /&gt;
dynamic tick/no HZ:&lt;br /&gt;
No HZ in idle&lt;br /&gt;
No HZ while only 1 process running for HPC.&lt;br /&gt;
tick devies 就是clock event包了层虎皮.&lt;br /&gt;
tick broadcast framework:  based on tick device&lt;br /&gt;
clock: 可记录时间, 表盘.利用timekeeping&lt;br /&gt;
timer: use clock. what about timer_list?&lt;br /&gt;
timer_list: do in softirq&lt;br /&gt;
* timekeeping aspect&lt;br /&gt;
onset: start_kernel -&amp;gt; timekeeping_init &amp;amp; time_init &amp;amp;(rest_init-&amp;gt; kernel_init-&amp;gt; &lt;br /&gt;
kernel_init_freeable-&amp;gt;do_basic_setup-&amp;gt;do_initcalls&amp;ndash;device_initcall(init_clocksource_sysfs))&lt;br /&gt;
nucleus:used by clock see init_posix_timers and update_wall_time and sys_time&lt;br /&gt;
coda:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;clock source aspect&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;tick device layer aspect&lt;br /&gt;
per_cpu(tick_cpu_device, cpu)&lt;br /&gt;
onset: time_init-&amp;gt;mach-&amp;gt;init_time-&amp;gt;&amp;hellip;clockevents_register_device-&amp;gt;tick_check_new_device&lt;br /&gt;
nucleus: a38x_timer_interrupt-&amp;gt;a38x_clkevt.event_handler&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;tick broadcast framework&lt;br /&gt;
onset:&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;clock aspect&lt;br /&gt;
k_clock&lt;br /&gt;
onset:init_posix_timers &amp;amp; init_posix_cpu_timers&lt;br /&gt;
nucleus: 用户-&amp;gt; posix_clock-&amp;gt;timepkeeping-&amp;gt;clock_socurce&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;timer aspect&lt;br /&gt;
onset: open_softirq(HRTIMER_SOFTIRQ, run_hrtimer_softirq);&lt;br /&gt;
nucleus: common_timer_set&lt;br /&gt;
hrtimer_interrupt | (tick_handle_periodic-&amp;gt; tick_periodic-&amp;gt; update_process_times-&amp;gt;run_local_timers-&amp;gt;hrtimer_run_queues)-&amp;gt;__run_hrtimer-&amp;gt;timer.function = posix_timer_fn;(set in common_timer_set)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;计算机概念&lt;br /&gt;
system clock CLOCK_REALTIME CLOCK_MONOTONIC&lt;br /&gt;
time.h time_t=tm=timeval=timespec calendar time  clock_t&lt;/p&gt;

&lt;p&gt;clock event -&amp;gt; tick device-&amp;gt; handle function&lt;br /&gt;
clock event 相较于timer更为抽象, timer 是一种用途,timer 通过clock event来实现功能,&lt;br /&gt;
clock event 通过timer来体现自己, timer面向使用者的onset,&lt;br /&gt;
而clock event 则是偏向于nucleus and coda.&lt;br /&gt;
timer: 标记不能立即执行的变化.&lt;br /&gt;
clock source: 用一些整型抽象一个过程, 对于时间来说, 简直是完美的抽象.&lt;br /&gt;
* kernel requirement&lt;br /&gt;
linux的时间子系统要求硬件timer提供下面两种能力：&lt;br /&gt;
一是free running的counter，此外需要能够在指定的counter值上产生中断的能力。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux virtualization</title>
      <link>http://firoyang.org/cs/virt/</link>
      <pubDate>Wed, 17 Jun 2015 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/virt/</guid>
      <description>

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.oenhan.com/kvm-src-3-cpu&#34;&gt;KVM源代码分析3:CPU虚拟化&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html-single/Virtualization_Tuning_and_Optimization_Guide/&#34;&gt;VIRTUALIZATION TUNING AND OPTIMIZATION GUIDE&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文着重探讨下kvm的实现, 11年在snia的实习的时候, 接触过一点.&lt;br /&gt;
已经过去将近4年了,  当初看到qemu的代码, 被吓到了, 我靠, 这代码量赶上内核了!&lt;br /&gt;
现在kvm核心就1069行当前kernel 4.1 rc7, qemu虽然赶不上kernel但是也不少1144756.&lt;br /&gt;
看过指环王的, 都知道神奇中土大陆是托尔金虚构的魔幻世界,那里活着阿拉贡和&lt;br /&gt;
他的朋友们, 以及他们精彩的历程.人的想象力, 如此神奇, 他能使人超越时间与&lt;br /&gt;
空间去体验到不同生命历程.&lt;br /&gt;
今天, 我们来探索一下&lt;a href=&#34;https://en.wikipedia.org/wiki/Virtualization&#34;&gt;虚拟化&lt;/a&gt;&lt;br /&gt;
如wikipedia所说, 虚拟化始于上个世纪60年代, 这是指的计算机领域内的.&lt;br /&gt;
显然, 我们要把眼光放得更远, 因为我们想洞见一些深层次的内容.&lt;br /&gt;
法国哲学家福柯一生都在从事&amp;rdquo;知识考古学&amp;rdquo;, 而我也喜欢在研究问题时, 从语言学特别是&lt;br /&gt;
词源角度开始. virtual这个词, 最早来自于中世纪拉丁文virtualis, 涵义是&lt;br /&gt;
influencing by physical virtues or capabilities,&lt;br /&gt;
effective with respect to inherent natural qualities&lt;br /&gt;
受某种实在的长处能力影响, 源自本质的效用.&lt;br /&gt;
这里从两种角度理解virtual, 受影响者, 影响者本身.&lt;br /&gt;
所以这里virtual的真实涵义应该是延续某种内在的本质并施加于外物.&lt;br /&gt;
这个英文单词的汉语翻译是很有趣的, 摘自金山词霸:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;virtual 音节划分：vir▪tual
英 [ˈvɜ:tʃuəl] 美 [ˈvɜ:rtʃuəl]
adj.实质上的，事实上的；（计算机）虚拟的；&amp;lt;物&amp;gt;有效的，虚像的；（粒子）实际存在的
虚；虚拟艺术；虚拟的；模拟帐户
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个词汇简直是英语翻译界的笑话, 一会实一会虚, 非常让人困惑!&lt;br /&gt;
话说回来, 这个词的翻译确实有难度.我翻译的话会叫质延.&lt;br /&gt;
很多事情, 在我们出生前就决定了, 我是89年9月出生的.&lt;br /&gt;
我们搞懂了所谓&amp;rdquo;虚拟化&amp;rdquo;的实质, 之后就可以继续探索了.&lt;br /&gt;
如wikipedia, 所说计算机领域的虚拟化更多的是指hardware virtualization.&lt;br /&gt;
没错就是延伸硬件的特质, 准确说是在软件层继续延伸硬件的特质.&lt;br /&gt;
好, 首先, 我们要搞懂硬件都有那些特质? 硬件有很多, 在计算机领域指什么呢?&lt;br /&gt;
没错, CPU, 硬盘, 电路板, 内存, 鼠标键盘等等. 那么他们有什么特质呢?&lt;br /&gt;
所谓的特质就是特别的性质, 一种属性, 哲学上, 称之为事物对外物的作用的一种表现.&lt;br /&gt;
那么CPU的最大特质就是指令处理, 我想这也是虚拟化的核心吧!&lt;br /&gt;
我们硬件虚拟化延伸的终点是让另一个操作系统运行于当前操作系统提供的硬件特质延伸之上.&lt;br /&gt;
终于进入正文了. 现在我们自己来设计一套虚拟化基础架构, 让一个简单的kernel运行在当前的fedora&lt;br /&gt;
之上.&lt;/p&gt;

&lt;h1 id=&#34;intel-vt-x&#34;&gt;Intel VT-x&lt;/h1&gt;

&lt;p&gt;VMCS manages transitons into and out of VMX non-root operation(VM entries and VM exits) as well as processor behavior&lt;br /&gt;
in VMX non-root operation.&lt;br /&gt;
ORGANIZATION OF VMCS DATA&lt;br /&gt;
The VMCS data are organized into six logical groups:&lt;br /&gt;
Guest-state area. Processor state is saved into the guest-state area on VM exits and loaded from there on VM entries.&lt;br /&gt;
Host-state area. Processor state is loaded from the host-state area on VM exits.&lt;br /&gt;
VM-exit control fields. These fields control VM exits.&lt;br /&gt;
VM-execution control fields. These fields control processor behavior in VMX non-root operation. They determine in part the causes of VM exits.&lt;br /&gt;
VM-entry control fields. These fields control VM entries.&lt;br /&gt;
VM-exit information fields. These fields receive information on VM exits and describe the cause and the nature of VM exits. On some processors, these fields are read-only. 3&lt;/p&gt;

&lt;p&gt;VMX NON-ROOT OPERATION&lt;br /&gt;
INSTRUCTIONS THAT CAUSE VM EXITS&lt;br /&gt;
Relative Priority of Faults and VM Exits&lt;br /&gt;
Instructions That Cause VM Exits Unconditionally&lt;br /&gt;
Instructions That Cause VM Exits Conditionally&lt;br /&gt;
OTHER CAUSES OF VM EXITS&lt;/p&gt;

&lt;p&gt;CHANGES TO INSTRUCTION BEHAVIOR IN VMX NON-ROOT OPERATION&lt;/p&gt;

&lt;p&gt;VM ENTRIES&lt;/p&gt;

&lt;p&gt;VM EXITS&lt;/p&gt;

&lt;p&gt;VMX SUPPORT FOR ADDRESS TRANSLATION&lt;/p&gt;

&lt;p&gt;APIC VIRTUALIZATION AND VIRTUAL INTERRUPTS&lt;/p&gt;

&lt;h1 id=&#34;代码实现&#34;&gt;代码实现&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;KVM architecture&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Kernel running flow&lt;br /&gt;
svm.ko -&amp;gt; svm_init(svm.c) -&amp;gt; kvm_init(kvm_main.c) -&amp;gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;File&lt;br /&gt;
svm.c vmx.c kvm_main.c kvm_svm.h&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Function&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Struct&lt;br /&gt;
kvm_x86_ops x86.h&lt;br /&gt;
vcpu_svm    kvm_svm.h&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;qemu-system-ppc&#34;&gt;qemu-system-ppc&lt;/h1&gt;

&lt;p&gt;-mem-path:&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Algorithms and data structues</title>
      <link>http://firoyang.org/cs/algorithm/</link>
      <pubDate>Wed, 27 May 2015 12:42:12 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/algorithm/</guid>
      <description>

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://cstheory.stackexchange.com/questions/19759/core-algorithms-deployed#&#34;&gt;Core algorithms deployed&lt;/a&gt;&lt;br /&gt;
Algorithms: Design Techniques and Analysis&lt;br /&gt;
The Algorithm Design Manual 2nd Edition&lt;/p&gt;

&lt;h1 id=&#34;computational-complexity-theory&#34;&gt;Computational complexity theory&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://bigocheatsheet.com/&#34;&gt;http://bigocheatsheet.com/&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;core-conceptions&#34;&gt;Core conceptions&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;representations&lt;br /&gt;
&lt;a href=&#34;https://www.geeksforgeeks.org/binary-tree-array-implementation/&#34;&gt;Linked vs sequential&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ADT vs data structure&lt;br /&gt;
ADT is a data type defined by its behavior.&lt;br /&gt;
&lt;a href=&#34;https://en.wikipedia.org/wiki/Data_type#Abstract_data_types&#34;&gt;Any type that does not specify an implementation is an abstract data type.&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;linked-list&#34;&gt;Linked list&lt;/h1&gt;

&lt;h2 id=&#34;static-linked-list&#34;&gt;Static linked list&lt;/h2&gt;

&lt;p&gt;Reprented in an array.&lt;/p&gt;

&lt;h2 id=&#34;internal-vs-external-liked&#34;&gt;Internal vs external liked&lt;/h2&gt;

&lt;p&gt;Sometimes, SLUB put freelist in object&lt;/p&gt;

&lt;h2 id=&#34;kernel-doubly-linked-list-operations&#34;&gt;kernel doubly linked list operations&lt;/h2&gt;

&lt;h3 id=&#34;add&#34;&gt;add&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;kernel version&lt;br /&gt;
next-&amp;gt;prev = new;&lt;br /&gt;
new-&amp;gt;next = next;&lt;br /&gt;
new-&amp;gt;prev = prev;&lt;br /&gt;
prev-&amp;gt;next = new;&lt;/p&gt;

&lt;h3 id=&#34;delete&#34;&gt;delete&lt;/h3&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;kernel version&lt;br /&gt;
next-&amp;gt;prev = prev;&lt;br /&gt;
WRITE_ONCE(prev-&amp;gt;next, next);&lt;br /&gt;
entry-&amp;gt;next = LIST_POISON1;&lt;br /&gt;
entry-&amp;gt;prev = LIST_POISON2;&lt;/p&gt;

&lt;h1 id=&#34;bl-list&#34;&gt;BL list&lt;/h1&gt;

&lt;p&gt;kernel: add bl_list - 4e35e6070b1ceed89c3bba2af4216c286fb1dafd&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;double-linked-list&#34;&gt;Double linked list&lt;/h1&gt;

&lt;h1 id=&#34;associative-array&#34;&gt;Associative array&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=qTZJLJ3Gm6Q&#34;&gt;Essentials: Brian Kernighan on Associative Arrays - Computerphile&lt;/a&gt;&lt;br /&gt;
vs indexed array&lt;/p&gt;

&lt;h2 id=&#34;associativity&#34;&gt;Associativity&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;trade-off&lt;br /&gt;
a) Checking more places takes more power and chip area,&lt;br /&gt;
b) and potentially more time. On the other hand, caches with more associativity suffer fewer misses&lt;br /&gt;
fully associative - the best miss rates, but practical only for a small number of entries&lt;br /&gt;
N-way set associative cache: 8 is a common choice for later implementations&lt;br /&gt;
direct-mapped cache - if two locations map to the same entry, they may continually knock each other out. anti-fragmantion worsens this case.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;judy-array&#34;&gt;Judy array&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://judy.sourceforge.net/&#34;&gt;http://judy.sourceforge.net/&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;hashtable&#34;&gt;Hashtable&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/510202/&#34;&gt;A generic hash table&lt;/a&gt;&lt;br /&gt;
hash function&lt;/p&gt;

&lt;h1 id=&#34;bst&#34;&gt;BST&lt;/h1&gt;

&lt;p&gt;Pre-order&lt;br /&gt;
In-order traversal&lt;br /&gt;
Post-order&lt;br /&gt;
postfix and prefix and sort&lt;/p&gt;

&lt;h1 id=&#34;graph&#34;&gt;Graph&lt;/h1&gt;

&lt;h1 id=&#34;depth-first-sarch&#34;&gt;Depth first sarch&lt;/h1&gt;

&lt;p&gt;DAG&lt;/p&gt;

&lt;h1 id=&#34;redblack-tree&#34;&gt;Redblack tree&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/count-of-smaller-numbers-after-self/description/&#34;&gt;https://leetcode.com/problems/count-of-smaller-numbers-after-self/description/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://yuex.in/post/2017/08/red-black-tree-in-action.html&#34;&gt;http://yuex.in/post/2017/08/red-black-tree-in-action.html&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;interval-tree-in-kernel&#34;&gt;Interval tree in kernel&lt;/h1&gt;

&lt;p&gt;anonymous page: anon_vma_interval_tree_insert&lt;/p&gt;

&lt;h1 id=&#34;trie&#34;&gt;Trie&lt;/h1&gt;

&lt;p&gt;Trie is prefix tree.&lt;br /&gt;
Trees only store keys.&lt;br /&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=AXjmTQ8LEoI&#34;&gt;Trie Data Structure&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=MC-iQHFdEDI&#34;&gt;Trie with numeric key&lt;/a&gt;&lt;br /&gt;
* terms very confused&lt;br /&gt;
&lt;a href=&#34;https://stackoverflow.com/questions/14708134/what-is-the-difference-between-trie-and-radix-trie-data-structures&#34;&gt;Radix tree vs Trie, check radix meaning&lt;/a&gt;&lt;br /&gt;
Patricia is compact trie or Patricia is radix = 2 trie?&lt;/p&gt;

&lt;h1 id=&#34;radix-tree-in-kernel-not-wikipedia&#34;&gt;Radix tree in kernel not wikipedia&lt;/h1&gt;

&lt;p&gt;page cache: page_cache_tree_insert&lt;br /&gt;
Wikipedia: Radix tree looks like a compact trie.&lt;br /&gt;
Kernel: Radix tree was more like a Multi-level index associative arrya or judy array.&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/175432/&#34;&gt;Trees I: Radix trees&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://events17.linuxfoundation.org/sites/events/files/slides/LinuxConNA2016%20-%20Radix%20Tree.pdf&#34;&gt;Enhancing the Linux Radix Tree&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=v0C9_Fp-co4&#34;&gt;The design and implementation of the XArray&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/688130/&#34;&gt;A multi-order radix tree&lt;/a&gt;&lt;br /&gt;
radix_tree_init_maxnodes(): height is 11 in kernel?&lt;br /&gt;
&lt;strong&gt;radix_tree_create() add one page&lt;/strong&gt;&lt;br /&gt;
radix_tree_lookup_slot: find one page&lt;/p&gt;

&lt;h1 id=&#34;search&#34;&gt;Search&lt;/h1&gt;

&lt;p&gt;Data property: unique key, indexed&lt;br /&gt;
&lt;a href=&#34;https://en.wikipedia.org/wiki/Search_data_structure&#34;&gt;Search data structure&lt;/a&gt;&lt;br /&gt;
Sequencial array: binary search&lt;br /&gt;
Associative array&lt;br /&gt;
BST&lt;br /&gt;
Hashtable&lt;/p&gt;

&lt;h2 id=&#34;which-algorithm&#34;&gt;Which algorithm?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/advantages-of-bst-over-hash-table/&#34;&gt;Advantages of BST over Hash Table&lt;/a&gt;&lt;br /&gt;
1. Can get all keys in sorted order  by just doing in-order traversal of BST&lt;br /&gt;
2. Doing order statistics, finding closest lower and greater elements, doing range  queries  are easy to do with BSTs.&lt;br /&gt;
3. BSTs are easy to implement compared to hashing.&lt;br /&gt;
4. With Self Balancing BSTs, all operations are guarnateed to work in O(logN) time.&lt;/p&gt;

&lt;h1 id=&#34;replacement-polices&#34;&gt;Replacement polices&lt;/h1&gt;

&lt;p&gt;Pseudo-LRU&lt;/p&gt;

&lt;h1 id=&#34;lru&#34;&gt;LRU&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/lru-cache/description/&#34;&gt;Leetcode 146 LRU cache&lt;/a&gt;&lt;br /&gt;
Order items by access times&lt;/p&gt;

&lt;h2 id=&#34;pseudo-lru-2-second-chance-and-queue&#34;&gt;Pseudo LRU/2 - Second chance and queue&lt;/h2&gt;

&lt;p&gt;type: Reclaim&lt;br /&gt;
Order items by enqueueing sequence&lt;br /&gt;
dcache&lt;/p&gt;

&lt;h2 id=&#34;second-chance-and-2q-https-pdfs-semanticscholar-org-d62d-e5f995164fff50f5ce61c0113f6bc9f04225-pdf&#34;&gt;Second chance and &lt;a href=&#34;https://pdfs.semanticscholar.org/d62d/e5f995164fff50f5ce61c0113f6bc9f04225.pdf&#34;&gt;2Q&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Page reclaim algorithm&lt;br /&gt;
type: Reclaim&lt;/p&gt;

&lt;h1 id=&#34;lock&#34;&gt;Lock&lt;/h1&gt;

&lt;p&gt;MCS lock&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
