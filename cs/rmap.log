

# Ref
[The case of the overly anonymous anon_vma][1]
[mm: change anon_vma linking to fix multi-process server scalability issue][2]
5beb49305251e5669852ed541e8e2f2f7696c53e
[1]: https://lwn.net/Articles/383162/
[2]: https://lwn.net/Articles/370145/

# Anonymous pages
Anonymous pages: mmap(ANONYMOUS | PRIVATE)/heap and stack
Anonymous page is different to anonymous mapping; mmap(MAP_ANONYMOUS | MAP_SHARED) is anonymous mapping and filed-based page.

As stated in [LWN][1]: 
Anonymous pages are not normally shared between processes, but every call to fork() will cause all such pages to be shared between the parent and the new child; that sharing will only be broken when one of the processes writes to the page, causing a copy-on-write (COW) operation to take place. Many pages are never written, so the kernel must be able to locate multiple VMAs which reference a given anonymous page. Otherwise, it would not be able to unmap the page, meaning that the page could not be swapped out.


# Anonymous reverse mappinng
## Prime anon rmap in 2.6.12
In dup_mmap(), we can find Child's VMAs use Parent's anon_vma by:
*tmp = *mpnt;
For COWed page, in do_wp_page(), anon_vma_prepare() won't change the inherited anon_vma.
Even COWed page will reuse parent's anon_vma. I don't think it's good idea. It will increase the cost will scan the anon_vma list.
That's why Rik van Riel said the following, in [a patch][2]

The old anon_vma code can lead to scalability issues with heavily
forking workloads.  Specifically, each anon_vma will be shared
between the parent process and all its child processes.
In a workload with 1000 child processes and a VMA with 1000 anonymous
pages per process that get COWed, this leads to a system with a million
anonymous pages in the same anon_vma, each of which is mapped in just
one of the 1000 processes.  However, the current rmap code needs to
walk them all, leading to O(N) scanning complexity for each page.

What a about a execed Child's anon_vma? Will it reuse parent's anon_vma?
After searching 'exec' in [Rik's patch][2] and looking the code setup_arg_pages() do_exec().
I think execed Child won't reuse parent's anon_vma. It might be because execed Child will use different address space to parent's.

As stated in ULK3 Page 682:
When the kernel assigns the first page frame to an anonymous region, it creates a
new anon_vma data structure...
So Child could have his own anon_vma.

COWed anon page, non-COWed anon page, new anon page
In do_anonymous_page(), we know a new anon page in a anonymous VMA inherited parents's anon_vma will resuse the anon_vma.
page = alloc_zeroed_user_highpage(vma, addr); // a new anon page
...
page_add_anon_rmap(page, vma, addr);
So we know if the new Child make many recursive fork() then the anonymous could collcet many non-COWed page.

Let's give anon_vma in 2.6.2 a defination.
anon_vma is just a collcetion basket for pages(COWed and non-COWed and new anon page) in the inherited VMA and the new anon page in non-inherited VMA to find their VMAs.
So we have two type anon_vma.
Inherited-form-parnet's anon_vma can be used by COWed and non-COWed and new page.
Non-Inherited-Child-own-created anon_vma can be used by new page if the Child won't fork its own Child process.
Refined defination:
anon_vma is one-one correspondence to the inherited anon VMAs started at same address.

There is a problem:
If Child maps a new non-COWed page, we need to reclaim it. 
If there are many VMAs in the anon_vma, it will costly to find the VMA which non-COWed page belongs to.

One more question: if some VMAs in anon_vma don't use the page which we would reclaim, how do you ditinguish this kind of VMAs?
In try_to_unmap_one(), I find this funny function pte = page_check_address(page, mm, address);, it use pte_pfn and page_to_pfn to resolve this issue.
# AVC rmap
How does new rmap solve distinguish COWed page which has same index during reclaim non-COWed page?
In try_to_unmap_one(), I found it was done by page_vma_mapped_walk(); For more details, check the check_pte in page_vma_mapped_walk().

A refined defination:
rmap is a relation.
Objramp is instance of space and time, not pure space.
In terms of space, rmap is a loose relation between PA and VAs. 


