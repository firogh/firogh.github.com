# mnt cache
type: hash table
mount_hashtable

# Dentry cache - dcache
## Think it over and human index
access -> accessers sync -> read inode and fill dentry
## Lifetime
?? refcount = -1; bind -> = 0; get =1, 2, 3...
?? LRU 2: 1st mark. 2nd move to head/tail
## Motion concurrent
### Multiple accessers synchronization
#### Locked lookup insert
1. lookup cache
if not; created the dentry, mark as ubound and update progress
2. get lock
lookup cache
if found, discard dentry
if not, insert dentry
Check d_alloc_parallel and ext2_lookup in lookup_slow
### Read dentry that is being reclaimed
Lockref and RCU, read and reclaim in parallel
?? [Introducing lockrefs](https://lwn.net/Articles/565734/)
* Read
d_alloc_parallel->lockref_get_not_dead
* reclaim
shrink_dentry_list
__dentry_kill->
{
	spin_lock(&dentry->d_lock);
	lockref_mark_dead		- why -128?
}
?? RCU
[Dcache scalability and RCU-walk](https://lwn.net/Articles/419811/)

## Connections

## cache
* dentry state
in use/bound
in use/unbound
not use/ boud - LRU
not use/unbound - new one

### Search structure 
Hashtable
### Reclaim polices
Third chance
sb->s_dentry_lru
?? LRU Generic LRU infrastructure
[Smarter shrinkers](https://lwn.net/Articles/550463/)
Check prune_dcache_sb
1. in use -> remove it from lru; and wait to be dput to the tail of lru
dentry->d_lockref.count
2. if referenced -> rotate to tail
DCACHE_REFERENCED
3. move it to dispose list
### Write behavior
### Cache coherence

## Example of using dentry
__shmem_file_setup
d_alloc_pseudo
shmem_get_inode-> inode_init_always
d_instantiate
alloc_file
