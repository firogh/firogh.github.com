<!DOCTYPE html>
<html class="no-js" lang="en-US" prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb#">
<head>
    <meta charset="utf-8">

    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="description" content="">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1">


<meta name="keywords" content="cs, ">

 
<meta property="og:type" content="article"/>
<meta property="og:description" content=""/>
<meta property="og:title" content="Algorithms and data structues for kernel hacking : firoyang.org"/>
<meta property="og:site_name" content="Firo Website"/>
<meta property="og:image" content="" />
<meta property="og:image:type" content="image/jpeg" />
<meta property="og:image:width" content="" />
<meta property="og:image:height" content="" />
<meta property="og:url" content="http://firoyang.org/cs/algorithm/">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2015-05-27"/>
<meta property="article:modified_time" content="2015-05-27"/>



<meta property="article:tag" content="cs">





    <base href="http://firoyang.org/">
    <title> Algorithms and data structues for kernel hacking</title>
    <link rel="canonical" href="http://firoyang.org/cs/algorithm/">
    

    <link href='http://fonts.useso.com/css?family=Fjalla+One|Open+Sans:300' rel='stylesheet' type='text/css'>
<link rel="stylesheet" href="/static/css/style.css">

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    
</head>

<body lang="en" itemscope itemtype="http://schema.org/Article">
<header id="header">
	<link rel="stylesheet" href="static/css/font-awesome.min.css">
	<nav id="nav">
	<div id="title"><a href="/">Firo Notes</a></div>
	<div>
	
	</div>
	</nav>
	<nav id="nav">
    	        <ul id="mainnav">
            <li>
            <a href="/review/">
                <span class="icon"> <i aria-hidden="true" class="fa fa-thumbs-o-up"></i></span>
                <span> review</span>
            </a>
            </li>
	
            <li>
            <a href="/history/">
                <span class="icon"> <i aria-hidden="true" class="fa fa-institution"></i></span>
                <span> history </span>
            </a>
            </li>
            <li>
            <a href="/about">
                <span class="icon"> <i aria-hidden="true" class="fa fa-rocket"></i></span>
                <span> Firo </span>
            </a>
            </li>
            <li>
                <a href="/howto/">
                <span class="icon"> <i aria-hidden="true" class="fa fa-gamepad"></i></span>
                <span> howto </span>
            </a>
            </li>
            <li>
            <a href="/kernel/">
                <span class="icon"> <i aria-hidden="true" class="fa fa-linux"></i></span>
                <span> kernel </span>
            </a>
            </li>
            <li>
            <a href="/net/">
                <span class="icon"> <i aria-hidden="true" class="fa fa-globe"></i></span>
                <span> net </span>
            </a>
            </li>
            <li>
            <a href="/philosophy/">
                <span class="icon"> <i aria-hidden="true" class="icon-leaf"></i></span>
                <span> philosophy </span>
            </a>
            </li>
            <li>
                <a href="/cs/">
                <span class="icon"> <i aria-hidden="true" class="fa fa-laptop"></i></span>
                <span> cs </span>
            </a>
            </li>
        </ul>

	</nav>
	<nav id="nav">
       
	</nav>
</header>



 <link rel="stylesheet" href="highlight.js/src/styles/monokai_sublime.min.css">
    <script src="highlight.js/src/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
	<section id="main">
	  <h1 itemprop="name" >Algorithms and data structues for kernel hacking</h1>
	  

<aside id="meta">

    <div>
        <section id="datecount">
          <h4 id="date"> Wed May 27, 2015 </h4>
          
        </section>
        
        <ul id="tags">
          
            <li> <a href="http://firoyang.org//tags/cs">cs</a> </li>
          
        </ul>

    </div>


</aside>

<meta itemprop="wordCount" content="733">
<meta itemprop="datePublished" content="2015-05-27">
<meta itemprop="url" content="http://firoyang.org/cs/algorithm/">


	  <div>
		<article itemprop="articleBody" id="content">
		   

<h1 id="reference:0410937a83f6b2d022d3a1c190b257c8">Reference</h1>

<p><a href="http://cstheory.stackexchange.com/questions/19759/core-algorithms-deployed#">Core algorithms deployed</a><br />
Algorithms: Design Techniques and Analysis<br />
kernel/algorithm.md</p>

<h1 id="introduction:0410937a83f6b2d022d3a1c190b257c8">Introduction</h1>

<p>说实话, 这年头想要做点学问还是需要点定力的.<br />
就拿内核中的数据结构与算法来说, 也不是说, 别人来了句, 我靠, awesome!<br />
你也过来瞅两眼, 也能心生感慨, what the fuck! how can this be true?<br />
我说的定力, 不是两耳闻听窗外事, 一心还读圣贤书!而是思维的能力.<br />
这是见真章的地方, 不动脑子是玩不转的, 最终浮于表面, 不得所获.</p>

<p>kfifo 和lock-less list 是kernel中两个基础的数据结构, 用得也不多.<br />
说实在的这些都不是什么特别难的技术, 但是这种较真的东西使最能考察一个人的能力的.<br />
什么能力? 写个链表, 队列谁不会? 这里考察的是人的创造力!<br />
所谓创造力就是一种组合的能力.拆分也是一种组合.</p>

<p>今天, 我们来聊一聊算法. 数据结构在我看来是算法的一种.<br />
到底是什么呢? algorithm这个词来自中古拉丁文algorismus音译自一位阿拉伯数学家的名字<br />
al-Khwarizmi, 这只是一个姓, 类似中文赵钱孙李, al-Khwarizmi这个姓表示<br />
<a href="https://zh.wikipedia.org/wiki/%E8%8A%B1%E5%89%8C%E5%AD%90%E6%A8%A1">花剌子模</a>地方的人.数学家的全名是Abū ‘Abdallāh Muḥammad ibn Mūsā al-Khwārizmī<br />
花剌子模有太阳升起之地之意源于这个国家被大量沙漠围住, 气候干燥. 而lowland, 则是因为其海拔很低.<br />
显然, 这不是我们关心的算法本质. 那么, 为什么欧洲人会把al-Khwarizmi, 作为算法的称谓呢?<br />
al-Khwarizmi向西方引入了10进制计数法和代数. 同时他的名字慢慢被赋予了现代算法的涵义.<br />
也就是algorithm的涵义是慢慢衍生出来的.<br />
那我们能否给算法下一个定义呢:</p>

<pre><code>An informal definition could be &quot;a set of rules that precisely defines a sequence of operations.&quot;
</code></pre>

<p>简单说, 就是一个执行序列. 这有点太概况了.我们需要一个更精准的定义.<br />
同时, 我并不把他限制在计算机科学内.<br />
如果你读过石里克的<a href="http://book.douban.com/subject/1443472/">普通认识论</a>你就会知道, 光的定义也是一波三折.<br />
所谓的定义, 实际上事物某些属性的集合!<br />
我们来考察算法的属性.诚如前面的定义算法是一个执行序列.<br />
那么算法的表现形式呢? 他是抽象的, 根植于人类的思维逻辑当中. 而人的逻辑是通过<br />
语言表述的.所以算法的重要属性就是他是语言这种形式表现出来的.<br />
所以我们的定义, 变成一个被执行的语言序列.<br />
我们还是不满足, 你难道就让我去用这么一句话, 去面对面试时候的各种算法题吗?<br />
现在我们从算法解决的问题入手? 这是算法的目的. 我的目的是让算法更加的通俗易懂.<br />
不是让人们说道, 算法就会去向排序, 二叉树. 这跳跃太大了, 在算法的基础定义和实际的算法之间,<br />
还有一些内容, 值得我们挖掘.我们考察排序和二叉树, 这两种算法:</p>

<pre><code>A sorting algorithm is an algorithm that puts elements of a list in a certain order.
</code></pre>

<p>从排序算法的定义中, 我们窥探到了算法的一些本质属性. 使对象具备某种属性.这里面有序就是一种属性.<br />
再来看二叉树:</p>

<pre><code>a binary tree is a tree data structure in which each node has at most two children, 
which are referred to as the left child and the right child.
</code></pre>

<p>无论是二叉树, 还是排序, 我们都能感受到, 算法在展现一种魔法, 使用元素的建立某种空间结构/关系.<br />
也就是说, 我们的思维本身就具有某种抽象意义上的空间搬运能力.我门知道空间关系, 在确定了个提之后<br />
是十分清晰的前后左右上下, 这样, 现在我们能进一步的定义算法:</p>

<pre><code>算法是使对象具备某种空间关系的而被执行的语言序列
</code></pre>

<p>这里的对象显然是语言层面的.我们的定义是否恰当能呢? 是否所有的算法都是让对象具备某种空间关系吗?<br />
在比如找到两个数组中相同的元素, 类似常见的字符串查找, 也是不具有所谓的空间的关系, 而是更为抽象的序关系.<br />
什么是序关系? c语言的比较操作符 &lt; &gt; = 这些都是序关系, 准确说是二元关系.<br />
而空间关系, 我们也可以通过坐标抽象, 得到数学上的需关系.显然有些时候空间关系更为生动, 但你知道这可以<br />
用order theory解释.<br />
作为最古老的算法gcd, 最大公约数, 不是上面的所谓的序关系结构. 他就是一种纯粹的数学定义.<br />
这个算法的目的不在是一个多个元素的整体了, 只是单独挑出符合性质的其中的元素. 但是在界gcd问题时<br />
我们依然可以把他转换为同过序关系得到答案.而欧几里得的方法, 确不是用gcd定义的方法解的而是用求余的<br />
方法. 求余依然是序的关系, 只不过方法不一样, 一个循环比较一个是通过求余加速了答案的发现.<br />
我们现在姑且认为, 所有算法的最终结果都是为了得到一种序的关系.<br />
我们现在来整理下算法的定义:</p>

<pre><code>算法是使对象具备某种序关系的而被执行的语言序列
</code></pre>

<p>我们现在来考察, 算法的对象, 我们能感觉到他可以具有任何形态.<br />
暂略.<br />
我们来看算法的核心&ndash; 语言序列, 对象, 执行的目的某种序关系, 三者之间的关系.<br />
同时为了更好的理解语言序列.<br />
我们先探索一些重要且常见的思路, 也就是语言序列的patterns.<br />
我们学过的一些算法, 可以用递归的方式解, 而且很简单. 比如二叉树翻转, 二叉树遍历,<br />
快排等等, 作为一种解问题的思路也就是, 语言序列的模式. 我们要彻底的搞懂倒地什么才是</p>

<h2 id="递归-为什么递归可以很好的解决问题:0410937a83f6b2d022d3a1c190b257c8">递归? 为什么递归可以很好的解决问题.</h2>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/62/Droste.jpg/220px-Droste.jpg" alt="递归图" /><br />
就是这种感觉, 你总能看到自己的样子, 每个尽头. 可是计算机的递归是有终止条件, 否则程序就跑飞了.<br />
所以, 无论脑洞多大, 都要想到如何停止递归调用.<br />
就和我们写个for循环for (i=0; i &lt; 10; i++) 一个道理, 本质都是在重复. 递归定义:</p>

<pre><code>递归指由一种（或多种）简单的基本情况定义的一类对象或方法，并规定其他所有情况都能被还原为其基本情况。
</code></pre>

<p>通俗说函数调用自身, 都是递归.一个合格的递归, 有终止条件和非终止条件.非终止条件必须可以通过递归变成终止条件.<br />
现在我们来看下两类经典的算法排序和二叉树.先说二叉树, 各种遍历啊翻转都是用递归实现的.<br />
先不考虑递归的问题, 就比方说我们要把二叉树的所有点都打印出来, 随便打不要管什么深度广度中序啊. 你会怎么办?<br />
一个for循环把所有最left都打出来了, 其他点呢? 没出来.怎么办?为什么二叉树这么难处理啊?<br />
我们之前打印数组or链表一个循环就ok了. 二叉树的和他们的区别是一个点有2个后继.<br />
那么2个后继对我们造成什么影响. for通过单个指针只能得到线性的关系. 那如何得到树式的关系呢?<br />
我们可以从最简单的开始考察空树, 1,2层的树都好办. 3层呢, 就不好办了? 怎么不好办了.<br />
如果我们知识在白板上把每个节点, 画个对号, 就算输出的话, 我们很轻松, 就画完了.<br />
可是在计算机内部, 比如我们现在100层的树我们在left子树上输出, 我们就没有办法知道丛root开始<br />
的right子树的信息了, 我们一条路走到黑, 回不去了. 我门必要track住所谓的right节点的信息.<br />
这很明显, 咋么track住呢?还是以3层树为例我们可以轻而易举的输出上面两层.<br />
如果按层输出, 我们输出当前node把子nodes存到queue里面, 每次都这么干. 我们track住了其他节点的信息了<br />
而链表这种线性结构则是自身就可以track住后继节点的信息, 这就是差别, 多了一个node我们就要<br />
多个地方存他, 在我们的场景你都不需要关系存的顺序, 因为我们就是随便输出, 全输出就可以了.<br />
回过头, 我们来看, 这个解法和递归之间的关系. 只要最终能终止就可以用递归解, 我们这个问题能吗?<br />
显然可以, 停在最底层节点.<br />
void bin_recur(node)<br />
{<br />
    //这是内核的标准风格<br />
    if(!node)<br />
        return</p>

<pre><code>print(node);
bin_recur(node-&gt;left);
bin_recur(node-&gt;right);
</code></pre>

<p>}</p>

<p>完了这就是我们的随意树遍历法, 记住我们只要求输出全部节点就ok了. 至于, node之间的关系, 就随他去吧.哈哈.<br />
无论递归多么简洁, track nrightnode信息一个也不能少, 知识没有眼睛的计算机的眼睛, 就好像盲人的盲文一样.<br />
这个递归的和我们的for循环的结果不一样.不用queue用stack结果就一直了.<br />
广度优先不可以用递归形式, 这是我们知道的第一个不能用递归解的问题.<br />
1. 接下来我们聊3个问题, 什么问题不能用递归解<br />
2. 递归 和非递归如何转换<br />
3. 结合二叉树排序算法探讨递归如何可能.</p>

<h3 id="先看第三个问题-同时我们也知道gcd也是递归算法实现的:0410937a83f6b2d022d3a1c190b257c8">先看第三个问题, 同时我们也知道gcd也是递归算法实现的.</h3>

<p>在这里我们要达成的是递归为什么能解问题. 遇到一个问题时我们我们如何用递归曲解.<br />
我们要用另外一种思想去解释递归, 且最好是生活化的例子.<br />
搜了半天也没有即通俗又深刻的讲解.<br />
我们按着递归的定义来:</p>

<pre><code>递归指由一种（或多种）简单的基本情况定义的一类对象或方法，并规定其他所有情况都能被还原为其基本情况。
</code></pre>

<p>为什么我们不找一个实际生活场景来解释递归呢? 你给我找一个试试, 正常人谁这么做事啊:</p>

<pre><code>To Iterate is Human, to Recurse, Divine
</code></pre>

<p>定义中明确说明了基本情况可以不止一种, 意识到这点很重要. 那么下面我们来看一个递归函数都有什么.<br />
通过定义, 我们知道递归函数只要两部分内容, 基本情况 + 还原到基本情况两部分:</p>

<pre><code>int depth(Tree t){
    if(!t) 
        return 0; 
    int a=depth(t.right); 
    int b=depth(t.left); 
    return (a&gt;b)?(a+1):(b+1); 
}
</code></pre>

<p>求二叉树深度,这个函数的目标就是返回int值树深度<br />
我们试图通过这么小的一个递归函数, 完成我们对所有递归的认知!<br />
基本情况:</p>

<pre><code>return 0 和return (a&gt;b)?(a+1):(b+1);
</code></pre>

<p>还原到基本情况:</p>

<pre><code>int a=depth(t.right);
int b=depth(t.left);
</code></pre>

<p>现在我们要当一回弗兰肯斯坦, 原料都有了, 那我们如何把他组成一个会动且名字叫做递归函数的人呢?<br />
代码本身就是执行序列, 而这些序列的先后关系非常重要.基本情况和还原基本情况具备哪些关系呢?<br />
这是我们要完整认知递归, 所必须面对的问题.<br />
在这个例子当中, 我们可以把基本情况和还原情况分类两类, 从基本情况看:<br />
不需要依赖还原情况和依赖还原情况的基本情况两类.<br />
所以我们主要关注, 基本情况就好了, 我们把基本情况排好了还原情况就不是问题了.<br />
我们总对看不到事物, 不放心,那么还原情况的代码是如何是生效的呢, 怎么就能保证整个程序是我们想要的<br />
正确结果? 也就是说我们必须证明他!如何证明呢?<br />
我们只看第一次调用, 显然如果两次depth调用时正确的, 我们最上面这次也是千真万确的!<br />
也就是说当前的结果正确性依赖于子函数调用的正确性.那么现在问题就变成了, 还原情况是否能<br />
够真正意义上的收敛到基本情况:</p>

<pre><code>int factorial(int n)
{
    int recurse = factorial(n-1);
    int result = n * recurse;
    return result;
}
</code></pre>

<p>这个函数是一个递归函数, 却不能收敛!最后程序直接跑飞了.所以说不是递归就是正确的.<br />
这严格的依赖于你的实现的语言序列!上面这个例子, 只有去没有回!<br />
只有保证了去和回的程序才是合理的! 进一步, 我们的基本情况,可以说都是在还原情况的去和回的路径上.<br />
使用数学归纳法, 我们可以证明递归函数的是否正确!<br />
现在我们更细致的考察基本情况和去回路径的关系.如果基本情况在去的路径上我们就收他是一种independent<br />
情况. 反之, 在回来的路径上, 我们就说他是dependent情况. 不用费心, 去想什么那些基本情况是independent哪些<br />
是dependent这个和具体业务,算法内容相关的.<br />
下面我们看下排序算法以期更加透彻的理解基本情况!先说快排!<br />
不知道你还记得吗, 我早都忘了.哈哈.快排的效率是nlogn,why?简单分析下就知道了.<br />
起始所有的算法都是分治, 只不过分的程度不一样. 快排的思想就是, 又粗到细逐步排序.<br />
显示选一个特定的元素, 之后把其他元素分列这个元素左右, 之后在分别对左右的元素执行相同的动作.<br />
用递归怎么实现呢?<br />
先确定基本情况<br />
小于2个elements不需要排序<br />
if ( (first &gt;= last)<br />
    return;<br />
这样independent就确定了.<br />
pivot= array[first]<br />
while( low &lt;  high){<br />
    while ( a[high] &gt; pivot  )<br />
        high&ndash;;<br />
    a[low]= a[hgih]<br />
    while ( a[low] &lt; pivot)<br />
        low++;<br />
    a[high] = a[low]<br />
}<br />
a[low] = pivot<br />
qs(a, first, low -1)<br />
qs(a, low + 1, last)</p>

<p>从这个算法, 我们可以看出全都是independent的基本情况, 都是还原情况依赖基本情况.<br />
也就是说, 上层的正确性,<br />
我们在前序二叉树遍历也遇到这种, 全是independent的情况.<br />
我们来总结下qsort的基本情况:<br />
他的基本情况是数据的区间.最基本的就是不排序这种<br />
之后是下面这种通用形式. 瞄准一个区间.基本+通用类似归纳法.<br />
那我们现在明白了排除最基本的形态作为终止条件. 其他的基本情况和还原情况表明了这个<br />
算法的核心本质也就是自顶向下top down还是自底向下bottom up的的方法这是最根本的本质.<br />
要比我们之前说的由粗到细逐步排序, 要准确深刻许多!<br />
我们再看归并排序.归并是什么思想呢?正好相反, 它依赖底层的排序.<br />
也就是bottom up的方式, 我们看下msort的代码<br />
merge sort是基于合并,<br />
if (len &lt;= 1)<br />
    return</p>

<p>ms(a, first, len/2)<br />
ms(a, len/2 + 1, last)<br />
merge(a, first, last)<br />
这次是通用情况在最下面.<br />
那我们在来看, 二叉树的的遍历. 前序遍历是top down的思想吗?<br />
先print root, 之后是最左的一排, 从底往上从左往右一次输出left子树<br />
之后, 类似方法输出right子树.但是为什么不是层序遍历的效果呢?这里是收到了树结构的影响.<br />
在排序的例子, 我们以数据的宽度大小得出topdown的思路.<br />
在遍历二叉树, 我们是node的高度和左右作为top的衡量.<br />
这里就不是topdown的思想而是先处理谁后处理谁的问题, 我们反过来看排序算法, topdown<br />
bottomup 似乎也只是一种巧合, 那么我们能不能在qsort的时候只处理两个元素, 之后在递归呢<br />
就好比二叉树中从root到leaf一样之后从leaf到root, 以此往复, 在用递归处理排序是遵从从多到少的去,<br />
从少到多.<br />
二叉树: root-&gt;left leaf -&gt;root-&gt;right leaf<br />
排序:大范围-&gt;个体-&gt;大范围　这也是递归解问题的标准方法逐渐减小问题．<br />
那么我们能否从最小的地方, 之后逐渐变大, 想当然是可以的.回来路径上的mergesort就是一个.<br />
其他的呢插入排序的递归版?<br />
insert sort<br />
if ( len = 1)<br />
    return<br />
isort(a, len -1)<br />
for(i=0; i&lt; len;i++<br />
    sort insert alen<br />
对比非递归版, 我们发现递归给我门提供了两个潜在的for循环.<br />
如果是从bottom up这种方式接的问题, 递归是放在回来的路径.<br />
当然递归也是允许你在取得路径上慢慢扩大处理的问题<br />
插入排序的终止条件编程了len &gt; maxlen.<br />
qsort和msort 一去一回.<br />
我们已经考察递归差不多了,总结下<br />
1. 一去一回, 两个非嵌套循环<br />
2. 最好遵从, 去的是逐渐减小任务. 回时增大.<br />
3. 去回可以互相转换.如isort, 当不是所有的都是要稳定性.</p>

<h3 id="接下来看递归和非递归的转换:0410937a83f6b2d022d3a1c190b257c8">接下来看递归和非递归的转换.</h3>

<p>bubble sort<br />
if len &lt; 2<br />
    return<br />
sort maxer<br />
bulle sort(len -1)<br />
冒泡的递归很简单<br />
那么qsort的非递归版呢<br />
首先递归给了一个for我们得自己补上<br />
for<br />
接下来递归编程压栈就可以了,<br />
下面的问题答案也是本问题的答案.</p>

<h3 id="最后一个问题什么问题不能用递归解:0410937a83f6b2d022d3a1c190b257c8">最后一个问题什么问题不能用递归解?</h3>

<p>二叉树层序遍历递归搞不定.<br />
这个问题实际转换成, 非递归版什么问题搞定什么问题<br />
我简单的认为<br />
1. 问题可被还原.<br />
2. 必要时, 需要stack 信息追踪<br />
没了. 好关于递归就到这里.<br />
在考察语言序列的顺序问题.递归的顺序我们很清楚了.但我们似乎还迷茫.<br />
实际上我们接触的问题都不是用递归解的.<br />
比如内核的伙伴系统, page cache这些算法. 实际上是这些结构的延伸.<br />
所有的函数方法都是为了让操作对象, 保持相应结构的性质.<br />
也就是说这种算法的核心与目的就是结构, 使数据保持这种结构, 算法的目的达到了.<br />
重点在于维护结构整体, 这点看来和排序算法一样, 一个是侧重空间关系, 一个数值关系.<br />
可以说都是在保证空间性质的前提, 完成量的性质:</p>

<pre><code>我们得到两个基本概念, 描述数据个体的量, 与整体的空间结构.
</code></pre>

<p>空间结构是框架, 量则是内容.<br />
现在我们来看一个实际的算法问题, 如何判断两边是否有环, 这里说的主要是空间结构.<br />
这个问题主要关注数据的空间结构, 最简单的加个访问标志位.不加呢, 别的方法呢?<br />
再加一个指针, 也能解决.通过辅助数据结构两个指针解决了这个问题. 现在回想问题.<br />
我们判断环, 实质上是找到一个等价的条件, 这个条件, 要不然是 ==, 要不然是 !=<br />
这和具体逻辑有关. 但是我们一定可以确定的就是我们需要right 和left两个operand.<br />
需要至少两个对比的对象.而这个对象本质就是量. 这里想提供解决问题的通用方式.<br />
判断问题要有两个量. 而这两个量.<br />
这里揭示了算法的核心, 就是在完成特定的问题or 结构, 我们需要辅助的结构:</p>

<pre><code>常见的辅助结构:变量/flag之类, 指针, 队列, stack, 不限制使用数量.
</code></pre>

<p>问题的解决, 变成寻找挑选合适的辅助结构了. 如两个变量比较/flag自身test, 两个指针:</p>

<pre><code>指针的速度是个很重要的解决问题的因素, 如上面的环问题的两个不同指针.
</code></pre>

<p>这也是解决比较问题的, 常见方法.<br />
选好辅助数据结构就是, 运用了. 运用的主要原则就是找到基本情况. 把具备的互斥特征的<br />
基本情况找到, 并应用辅助数据结构解决问题.</p>

<h2 id="动态规划问题:0410937a83f6b2d022d3a1c190b257c8">动态规划问题</h2>

<p>DP通常是以递归化简问题形式出现.</p>

		</article>
	  </div>
	</section>

<aside id=comments>
    <div><h2> Comments </h2></div>
    <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'firoyang';
    var disqus_identifier = 'http:\/\/firoyang.org\/cs\/algorithm\/';
    var disqus_title = 'Algorithms and data structues for kernel hacking';
    var disqus_url = 'http:\/\/firoyang.org\/cs\/algorithm\/';

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</aside>

<footer>
  <div>
    <p>
    &copy; 2014 ~ 2016 <span itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Firo Yang</span></span>
<a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/80x15.png" /></a>. Powered by <a href="http://gohugo.io">Hugo</a>.
        Theme by <a href="http://spf13.com">Steve Francia <a href="http://firoyang.org">Firo Yang</a>.
    </p>
  </div>
</footer>
<script type="text/javascript">
(function(){var j=function(a,b){return window.getComputedStyle?getComputedStyle(a).getPropertyValue(b):a.currentStyle[b]};var k=function(a,b,c){if(a.addEventListener)a.addEventListener(b,c,false);else a.attachEvent('on'+b,c)};var l=function(a,b){for(key in b)if(b.hasOwnProperty(key))a[key]=b[key];return a};window.fitText=function(d,e,f){var g=l({'minFontSize':-1/0,'maxFontSize':1/0},f);var h=function(a){var b=e||1;var c=function(){a.style.fontSize=Math.max(Math.min(a.clientWidth/(b*10),parseFloat(g.maxFontSize)),parseFloat(g.minFontSize))+'px'};c();k(window,'resize',c)};if(d.length)for(var i=0;i<d.length;i++)h(d[i]);else h(d);return d}})();
fitText(document.getElementById('title'), 1)
</script>


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-63396532-1', 'auto');
  ga('send', 'pageview');

</script>


</body>
</html>


<script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[','\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});
</script>

</body>
