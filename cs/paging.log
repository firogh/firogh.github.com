

# Summary
pte -> page flags -> page

# PTE and PDE and page flags
v3a chapter 4.5 4-level paging, p132, Figure 4-11. Formats of CR3 and Paging-Structure Entries with 4-Level Paging
| G | PAT | D | A | PCD | PWT | U/S | R/W | Present
## PTE pte_none
x86/mm: Ignore A/D bits in pte/pmd/pud_none() -  97e3c602ccbdd7db54e92fe05675c664c052a466
## PTE Encode and de-code a swap entry

|     ...            | 11| 10|  9|8|7|6|5| 4| 3|2| 1|0| <- bit number
|     ...            |SW3|SW2|SW1|G|L|D|A|CD|WT|U| W|P| <- bit names
| OFFSET (14->63) | TYPE (9-13)  |0|0|X|X| X| X|X|SD|0| <- swp entry
Check SWP_TYPE_FIRST_BIT
Swap work on only userspace pages.
## _PAGE_SWP_SOFT_DIRTY
Documentation/vm/soft-dirty.txt
## _PAGE _PROTNONE
https://www.spinics.net/lists/newbies/msg08579.html
man mprotect, PROT_NONE
userspace addr is associated with non-GLOBAL pte, so the 8th G is reused by PROT_NONE.

# struct page
## SWAP
* private
store swap type and offset/slot in private
Check page_swapcount
__add_to_swap_cache -> set_page_private
why?
* mapping
NULL
* flags
PG_swapcache
* _refcount
### 
## _refcount
after __alloc_pages_nodemask _refcount=0, 
post_alloc_hook: init should be 0. 
but set_page_refcounted -> set_page_count(page, 1);
and Check put_page
## _mapcount
from -1: page_mapcount_reset
### LQO
* page in swap cache vs swap area?
* counters vs _mapcount vs _refcount
_mapcount: numbers of ptes; check page_mapped
# Ref
v3a Chapter 4
https://wiki.osdev.org/Paging
https://en.wikipedia.org/wiki/Paging

# Links
[1]: http://larmbr.com/2014/01/19/the-evolution-of-4-level-page-talbe-in-linux/
[2]: http://ytliu.info/blog/2016/03/14/linuxnei-cun-chu-shi-hua-assembly/
# x86 64
[Linux内核4级页表的演进][1]
[Linux内存初始化][2]
PAE is 3-level page tables: pgd, pmd, pte.
So early_level4_pgt(level4, level3, level2) in startup_64() with 
ENTRY(secondary_startup_64)
  /* Enable PAE mode and PGE */
  movl  $(X86_CR4_PAE | X86_CR4_PGE), %ecx
  movq  %rcx, %cr4

  /* Setup early boot stage 4 level pagetables. */
  addq  phys_base(%rip), %rax
  movq  %rax, %cr3

should be OK.

X86_CR0_PG: enable paging.
x86_64_start_kernel


All processes's page table(task_strcut pgd) was derived form init_mm's swapper_pg_dir which inited in native_pagetable_init(). #FIXME.
# PGTs init 
arch_add_memory: hotplug
init_mem_mapping: normal
setup_arch->init_memory_mapping

# Sparse page tables
8170e6bed465b4b0c7687f93e9948aca4358a33b
x86, 64bit: Use a #PF handler to materialize early mappings on demand

# vmemmap page tables
vmemmap_populate
## hotplug
add_memory
|-add_memory_resource
 |-add_memory_resource
  |-arch_add_memory
   |-__add_pages
    |-__add_section
     |-sparse_add_one_section
      |-kmalloc_section_memmap
       |-sparse_mem_map_populate
        |-vmemmap_populate
# sparse_init
|-sparse_early_mem_map_alloc if !CONFIG_SPARSEMEM_ALLOC_MEM_MAP_TOGETHER
|-sparse_early_mem_maps_alloc_node if CONFIG_SPARSEMEM_ALLOC_MEM_MAP_TOGETHER

# Walk on page tables
ptdump_walk_pgd_level_core
and change page attr
__change_page_attr

# page table
pgd_ctor

remap_pfn_range

##Page table
mk_pte(page, pgprot)    pfn_pte(page_to_pfn(page), (pgprot))
原来低12位里面存了flag啊!
__pte(((phys_addr_t)page_nr << PAGE_SHIFT) | massage_pgprot(pgprot));
For vmalloc(), chechk here vmap_page_range_noflush()
For kmap(), check kmap_init()
[How to emulate the process of translate va to pa?](http://edsionte.com/techblog/archives/1966)

## Direct mapping area
high_memory (-128UL << 20)
__get_free_pages()
kmalloc()
kmem_cache_alloc()/slab

## Vmalloc
map_vm_area 页表映射
the page in ZONE_NORMAL will not use directly mapping pfn address! It use VMALLOC address! 

### Vmalloc coherence with vfree() after vmalloc_sync_one
在进程的内核页目录中补上的是只是页目录项，而页表对所有进程来说是共用的，不管vfree()多大的内存块，在vmalloc()时新分配的页表不会被释放，当重新vmalloc()时，仍旧使用原来的页表。 page_fault使得进程的内核页目录项与swapper_pg_dir保持同步，swapper_pg_dir的内核页目录项一旦建立就不再被改变，需要改变的只是共享的页表而已。
deatils in vmalloc_sync_one() and vunmap_pte_range()
只释放pte

## Persistent Kernel Mappings
kmap(struct page *)
How kmap works? 
Check kmap_init(), later!

## Temporay Mappings(Fixmaps)
kmap_atomic()


# Huge page
https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt
[Huge pages part 1 (Introduction)](https://lwn.net/Articles/374424/)
[hugepage 分析](https://ggaaooppeenngg.github.io/zh-CN/2017/04/30/hugepage-%E5%88%86%E6%9E%90/)
## persistent hugepage
Hugetlbfs

## THP
[Transparent hugepages](https://lwn.net/Articles/359158/)
[Transparent huge pages in 2.6.38](https://lwn.net/Articles/423584/)
https://www.kernel.org/doc/Documentation/vm/transhuge.txt
[THP: Hugepage导致进程占用物理内存过多的问题](http://hustcat.github.io/hugepage-problem/)
