This article is actually taking about virtual address space based PAGING.
# LQO
[AMD-V™ Nested Paging](http://developer.amd.com/wordpress/media/2012/10/NPT-WP-1%201-final-TM.pdf)
[Memory Virtualization](http://didawiki.cli.di.unipi.it/lib/exe/fetch.php/magistraleinformaticanetworking/cpa/aa1011/virt3.pdf)
# History
1959 Atlas prototype
[Working prototypes of paging had been developed by 1959.](http://160592857366.free.fr/joe/ebooks/ShareData/Before%20Memory%20was%20Virtual%20By%20Peter%20J.%20Denning%20from%20George%20Mason%20University.pdf)

1962 This paper describes paging. 
[A Must-read on paging: One-Level Storage System](http://www.dcs.gla.ac.uk/~wpc/grcs/kilburn.pdf)
[A Must-read on virtual address space decoupling address and memory location: Dynamic Storage Allocation in the Atlas Computer, Including an Automatic Use of a Backing Store](https://users.soe.ucsc.edu/~sbrandt/221/Papers/History/fotheringham-cacm61.pdf)

1978
[The Manchester Mark I and Atlas: A Historical Perspective](https://dl.acm.org/citation.cfm?id=359331)

# Purposes
The following is cited from 'before memory was virtual' by Peter J. Denning at George Mason University
From their beginnings in the 1940s, electronic computers had two-level storage
systems. In the 1950s, main memory was magnetic cores (today it is RAMs); the
secondary memory was magnetic drums (today it is disks). The processor (CPU)
could address only the main memory. A major part of a programmer’s job was
to devise a good way to divide a program into blocks and to schedule their
moves between the levels. The blocks were called “segments” or “pages” and
the movement operations “overlays” or “swaps”. The designers of the first
operating systems in the 1950s dreamt of relieving the programming burden by
automating all this storage management.

# Formal causes
[Paging from Atlas](http://curation.cs.manchester.ac.uk/computer50/www.computer50.org/kgill/atlas/atdef.html#page):

> Is a technique in which the main store is divided into segments called pages. 
> Large user programs may cover several pages, possibly too many to fit into the available store. 
> The operating systems transfers pages between main store and backing store to ensure 
> the correct page is in main store at any stage during the execution of the programs. 

Also come from 'before memory was virtual'.
At the heart of their idea was a radical innovation --- a distinction between “address” and “memory location”.
Firo: address => virtual address; "memory location" => physical address. Marvellous!
It led them to three inventions. 
(1) They built hardware that automatically translated each address generated by the processor to its current memory location.
Firo: this hardware is MMU including TLB.
(2) They devised demand paging, an interrupt mechanism triggered by the address translator that moved a missing page of data into the main memory.
(3) They built a replacement algorithm, a procedure to detect and move the least useful pages back to secondary memory.
Firo: PFRA
## address translator - MMU

## Page table
v3a: P121 
5 (A) Accessed; indicates whether software has accessed the 4-KByte page referenced by this entry (see Section 4.8)
6 (D) Dirty; indicates whether software has written to the 4-KByte page referenced by this entry (see Section 4.8)
Check _PAGE_BIT_ACCESSED

## Page faults

## Address space

## Memory mapping
_mapcount -1: page_mapcount_reset
kmap(), check kmap_init()

# Material
## x86_64 paging
v3a Chapter 4
PAE is 3-level page tables: pgd, pmd, pte.
So early_level4_pgt(level4, level3, level2) in startup_64() with 
ENTRY(secondary_startup_64)
  /* Enable PAE mode and PGE */
  movl  $(X86_CR4_PAE | X86_CR4_PGE), %ecx
  movq  %rcx, %cr4
  /* Setup early boot stage 4 level pagetables. */
  addq  phys_base(%rip), %rax
  movq  %rax, %cr3
X86_CR0_PG: enable paging.
x86_64_start_kernel
setup_arch -> 
	init_mem_mapping //set page table and cr3.
	early_trap_pf_init //  X86_TRAP_PF, page_fault) => do_page_fault
