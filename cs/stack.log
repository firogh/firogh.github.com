
# Procedure and subroutine and linkage method
https://people.cs.clemson.edu/~mark/subroutines.html
https://en.wikipedia.org/wiki/Subroutine
* 1945 Turing on subroutines in [Proposed electronic calculator.](http://www.alanturing.net/turing_archive/archive/p/p01/P01-011.html)
In Chapter 6. Outline of Logical Control.
We also wish to be able to arrange for the splitting up of operations into...
When we wish to start on a subsidiary operation we need only make a note
of where we left off the major operation...
* 1952 [The use of sub-routines in programmes](http://www.laputan.org/pub/papers/wheeler.pdf)
The above remarks may be summarized by saying sub-routines are very useful — although not absolutely necessary — and that the prime objectives to be born in mind when constructing them are simplicity of use, correctness of codes and accuracy of description. All complexities should—if possible—be buried out of sight.
* 1960 [Dijkstra, E. W. (1960). "Recursive Programming"](https://link.springer.com/article/10.1007%2FBF01386232)
[link register](https://en.wikipedia.org/wiki/Link_register)

# References
[Expanding the kernel stack](https://lwn.net/Articles/600644/)
[Virtually mapped kernel stacks](https://lwn.net/Articles/692208/)
[x86_64 Kernel Stacks](https://www.kernel.org/doc/html/latest/x86/kernel-stacks.html)

# kernel
task_struct->stack:task_stack_page
task_struct->thread.sp: top of stack
## canary
https://my.oschina.net/macwe/blog/610357
boot_init_stack_canary

# x86 TSS and sp0
[x86/entry/64: Remove thread_struct::sp0](https://lore.kernel.org/patchwork/patch/828764/):d375cf1530595e33961a8844192cddab913650e3
GDT -> TSS descriptor -> TSS
tss_struct cpu_tss, ltr, str
TSS: x86_hw_tss v3a: 7.7
## Onset
arch/x86/include/asm/desc.h
DECLARE_PER_CPU_PAGE_ALIGNED(struct gdt_page, gdt_page);        #===> GDT
arch/x86/kernel/process.c
DEFINE_PER_CPU_SHARED_ALIGNED(struct tss_struct, cpu_tss)       #===> tss_struct
start_kernel ... ->start_secondary and trap_init->
cpu_init
        t->x86_tss.io_bitmap_base = offsetof(struct tss_struct, io_bitmap);
        load_sp0(t, &current->thread);  #===> tss->x86_tss.sp0 = thread->sp0
        set_tss_desc(cpu, t);           #===> set tss descriptor to GDT; tss descriptor.base = tss_struct
        load_TR_desc();                 #===> ltr
_do_fork -> copy_process
        dup_task_struct
                stack = alloc_thread_stack_node(tsk, node);             # ===> THREAD_SIZE 2 pages.
                tsk->stack = stack;
        copy_thread_tls
                # arch/x86/include/asm/processor.h
                # #define task_pt_regs(tsk)       ((struct pt_regs *)(tsk)->thread.sp0 - 1)
                p->thread.sp0 = (unsigned long)task_stack_page(p) + THREAD_SIZE;        # task->stack; THREAD_SIZE 2 pages;
                childregs = task_pt_regs(p);
                # struct fork_frame {
                #       struct inactive_task_frame frame;
                #       struct pt_regs regs;
                # };
                fork_frame = container_of(childregs, struct fork_frame, regs);
                p->thread.sp = (unsigned long) fork_frame;
                *childregs = *current_pt_regs();
        # Add child task to run_queue. Then scheded.
__switch_to -> load_sp0(tss, next);
## nuclus
entry_SYSCALL_64 -> movq    PER_CPU_VAR(cpu_current_top_of_stack), %rsp
