# References
[The next steps for swap](https://lwn.net/Articles/717707/)
[In defence of swap: common misconceptions](https://chrisdown.name/2018/01/02/in-defence-of-swap.html)
[Reconsidering swapping](https://lwn.net/Articles/690079/)
[2.6 swapping behavior](https://lwn.net/Articles/83588/)
1978 Swapping in [UNIX Implementation K. Thompson](https://users.soe.ucsc.edu/~sbrandt/221/Papers/History/thompson-bstj78.pdf)

# PTE Encode and de-code a swap entry
|     ...            | 11| 10|  9|8|7|6|5| 4| 3|2| 1|0| <- bit number
|     ...            |SW3|SW2|SW1|G|L|D|A|CD|WT|U| W|P| <- bit names
| OFFSET (14->63)    | TYPE(9-13)|0|0|X|X| X| X|X|SD|0| <- swp entry
Check SWP_TYPE_FIRST_BIT
Swap work on only userspace pages.
_PAGE_SWP_SOFT_DIRTY and Documentation/vm/soft-dirty.txt

# Swappiness
https://www.kernel.org/doc/Documentation/sysctl/vm.txt

# Observalbility
swap_show swap_info nr_swapfiles

# swap address space
swapper_spaces[]

# ->private & PG_swapcache vs ->mapping & index
tglx: commit 4875a6018bcc53201ddbf745bff35ed723b468eb
Author:     Andrew Morton <akpm@osdl.org>
AuthorDate: Mon Apr 12 00:54:03 2004 -0700
    [PATCH] rmap 2 anon and swapcache
    From: Hugh Dickins <hugh@veritas.com>
    Tracking anonymous pages by anon_vma,pgoff or mm,address needs a
    pointer,offset pair in struct page: mapping,index the natural choice.  But
    swapcache uses those for &swapper_space,swp_entry_t.
    It's trivial to separate swapcache from pagecache with radix tree; most of
    swapper_space is actually unused, just a fiction to pretend swap like file;
    and page->private is a good place to keep swp_entry_t, now that swap never
    uses bufferheads
[...]
+ * On an anonymous page mapped into a user virtual memory area,
+ * page->mapping points to its anon_vma, not to a struct address_space.
+ *
+ * Please note that, confusingly, "page_mapping" refers to the inode
+ * address_space which maps the page from disk; whereas "page_mapped"
+ * refers to user virtual address space into which the page is mapped.
+ */
+static inline struct address_space *page_mapping(struct page *page)
+{
+       return PageAnon(page)? NULL: page->mapping;

# Enable Swap
systemd->swapon->sys_swapon
&def_blk_fops

do_shared_fault
shmem_fault
shmem_alloc_and_acct_page

swap in
swapin_readahead
swap_readpage
swap_page_sector

# Swapbacked pages
Private file maps & write page fault

# Try to unmap a PageAnon(page)  - swap code path
commit eb94a8784427b28479f871b5d4121c547808d0fc
Refs: v4.11-4538-geb94a8784427
Author:     Minchan Kim <minchan@kernel.org>
AuthorDate: Wed May 3 14:52:36 2017 -0700
Commit:     Linus Torvalds <torvalds@linux-foundation.org>
CommitDate: Wed May 3 15:52:08 2017 -0700
    mm: fix lazyfree BUG_ON check in try_to_unmap_one()
    If a page is swapbacked, it means it should be in swapcache in      # Firo: this means this try_to_unmap comes from shrik_page_list()
    try_to_unmap_one's path.
    If a page is !swapbacked, it mean it shouldn't be in swapcache in   # This is MAD_FREE page.
    try_to_unmap_one's path.
+                       if (unlikely(PageSwapBacked(page) != PageSwapCache(page))) {
+                               WARN_ON_ONCE(1);
+                               ret = SWAP_FAIL;
+                               page_vma_mapped_walk_done(&pvmw);
+                               break;

# Swapping out pages
lru -> swap cache -> updating pte with try to unmap -> write page into swap area -> delete_from_swap_cache()
key commit:
mm: cma: discard clean pages during contiguous allocation instead of migration - 02c6de8d757cb32c0829a45d81c3dfcbcafd998b
mm: reclaim MADV_FREE pages - 802a3a92ad7ac0b9be9df229dee530a1f0a8039b check mark_page_lazyfree
[mm: support madvise(MADV_FREE)](https://lwn.net/Articles/590693/)

## Swapping out shared anonymous pages
pageout->shmem_writepage - Move the page from the page cache to the swap cache; and swp_to_radix_entry

# Swapping in pages
do_page_fault->do_swap_page
