
# Reference
[Driver porting: per-CPU variables](https://lwn.net/Articles/22911/)
[Per-cpu patches on top of PDA stuff...   Rusty Russell](https://lists.linuxfoundation.org/pipermail/virtualization/2006-September/thread.html#5010)
[Using %gs for per-cpu areas on x86 ](https://lists.linuxfoundation.org/pipermail/virtualization/2006-September/thread.html#5042)
[A graphic explanation](https://www.cnblogs.com/yangjiguang/p/8277720.html)jj

# Crash practise
p __per_cpu_offset
p this_cpu_off:all
__per_cpu_offset is same as irq_stack_union

# Per-CPU for boot CPU
1. strart_kernel->setup_per_cpu_areas
/*
 * Up to this point, the boot CPU has been using .init.data
 * area.  Reload any changed state for the boot CPU.
 */
                if (!cpu)
                        switch_to_new_gdt(cpu);
2. CPU state barier
start_kernel->trap_init->cpu_init
/*
 * cpu_init() initializes state that is per-CPU. Some data is already
 * initialized (naturally) in the bootstrap process, such as the GDT
 * and IDT. We reload them nevertheless, this function acts as a
 * 'CPU state barrier', nothing should get across.
 * A lot of state is already set up in PDA init for 64 bit
 */
switch_to_new_gdt->load_percpu_segment

# Per-CPU for Secondary CPUs
	commit f32ff5388d86518c0375ccdb330d3b459b9c405e
	Author: Tejun Heo <tj@kernel.org>
	Date:   Tue Jan 13 20:41:35 2009 +0900
	    x86: load pointer to pda into %gs while brining up a CPU
## BSP
strart_kernel->setup_per_cpu_areas
kernel_init->smp_init-> ... ->native_cpu_up -> common_cpu_up -> initial_gs = per_cpu_offset(cpu)
## AP
secondary_startup_64 -> initial_gs
cpu_init->load_percpu_segment

# irq_stack_union 
It is type of union and it's the first element in Per-CPU area

# load_percpu_segment
load_percpu_segment: load gs with 0 and set gs.base to irq_stack_union.gs_base.

# SWAPGS
check SWAPGS in ret_from_fork or system calls.

# Per-cpu memory for user-space
https://lwn.net/Articles/611946/

# Runtime per-cpu 
pcpu_create_chunk()

# Task's gsbase or gsindex and %gs
Task has nothing related to %gs in current kernel implemention.
It means all tasks share the same %gs, so there is no need to save a gsbase/gsindex per task.
Check load_percpu_segment.
