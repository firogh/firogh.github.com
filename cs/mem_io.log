# Memory I/O
---
tags: [ kernel ] 
layout: post
date: 2017-04-06
title: Page fault
category: cs
---

# 1959 paging
[Paging](https://en.wikipedia.org/wiki/Paging) according to [History of VM](https://en.wikipedia.org/wiki/Virtual_memory) is developed at 1959.

The following is cited from 'before memory was virtual' by Peter J. Denning at George Mason University
From their beginnings in the 1940s, electronic computers had two-level storage systems. In the 1950s, main memory was magnetic cores (today it is RAMs); the secondary memory was magnetic drums (today it is disks). The processor (CPU) could address only the main memory. A major part of a programmer’s job was to devise a good way to divide a program into blocks and to schedule their moves between the levels. The blocks were called “segments” or “pages” and the movement operations “overlays” or “swaps”. The designers of the first operating systems in the 1950s dreamt of relieving the programming burden by automating all this storage management. 

[Paging from Atlas](http://curation.cs.manchester.ac.uk/computer50/www.computer50.org/kgill/atlas/atdef.html#page):

> Is a technique in which the main store is divided into segments called pages. 
> Large user programs may cover several pages, possibly too many to fit into the available store. 
> The operating systems transfers pages between main store and backing store to ensure 
> the correct page is in main store at any stage during the execution of the programs. 

Also come from 'before memory was virtual'.
At the heart of their idea was a radical innovation --- a distinction between “address” and “memory location”.
It led them to three inventions. 
(1) They built hardware that automatically translated each address generated by the processor to its current memory location.
(2) They devised demand paging, an interrupt mechanism triggered by the address translator that moved a missing page of data into the main memory.
(3) They built a replacement algorithm, a procedure to detect and move the least useful pages back to secondary memory.

# Page Fault
* page-fault exceptions error code
v3a: 4.7 - Figure 4-12. Page-Fault Error Code
P, W/R, U/S, I/D, RSVD
user/kernel mode, kerne space/userspace address, good/bad area

# Kernel address
vmalloc,spurious_fault, kprobes_fault
## Bad area
[fixup_exception](https://www.kernel.org/doc/Documentation/x86/exception-tables.txt)
[Kernel-Level Exception Handling](https://www.linuxjournal.com/article/2135)
SIGSEGV 
kernel oops 

# Userspace address
## Bad area
PF_USER ? SIGSEGV
## Stack
premise: grows down: address > 65536 + 32 * sizeof(unsigned long) + rsp
expand_stack(): expand vma of stack; + good area workflow.
## Private anonymous page
Check 'man madvise' for private anonymous page.
Stack and Heap - mmap, brk: do_anonymous_page 
Library Private read & write: do_wp_page, 
Library Private write: cow page, do_cow_page
### do_cow_page
1. get page and cow:  __do_fault-> vma->vm_ops->fault = filemap_fault -> page cache ? page_cache_read add to lru
2. add page to anon lru list: finish_fault->alloc_set_pte-> page_add_new_anon_rmap -> __SetPageSwapBacked
### Page, rmap, pte
page: alloc_zeroed_user_highpage_movable
page_add_new_anon_rmap
set_pte_at
## Private file page
Libray Private  read: do_read_page, pte prot is PAGE_COPY check protection_map.
map_region         vma->vm_page_prot = vm_get_page_prot(vm_flags);
do_set_pte(vma, address, fault_page, pte, false, false); vm_page_prot
## Shared file page
do_shared_page
## Shared anonymous page
do_shared_page
## Swap page
do_swap_page

# Read and write pages - Copy-on-write technique.
## do_read_page
[map_pages](https://lwn.net/Articles/588802/)

# Synchronization
## down_read(&mm->mmap_sem)?
linux-tglx
commit b50661029222940e24d2fba7c982ac0774a38c78
Author: Andi Kleen <ak@muc.de>
Date:   Thu Sep 16 22:00:12 2004 -0700
    [PATCH] x86-64: avoid deadlock in page fault handler
    Avoid deadlock when kernel fault happens inside mmap sem.
Check ULKv3 Page 380.
https://lkml.org/lkml/2004/5/19/108
https://lkml.org/lkml/2013/5/13/418
## IRQ
commit 891cffbd6bcba26409869c19c07ecd4bfc0c2460
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Oct 12 13:16:12 2008 -0700
    x86/mm: do not trigger a kernel warning if user-space disables interrupts and generates a page fault

# Propection
tglx: commit 0457d99a336be658cea1a5bdb689de5adb3b382d
Author: Andi Kleen <ak@muc.de>
Date:   Tue Feb 12 20:17:35 2002 -0800
    [PATCH] x86_64 merge: arch + asm
    This adds the x86_64 arch and asm directories and a Documentation/x86_64.
+/*
+ * The i386 can't do page protection for execute, and considers that
+ * the same are read. Also, write permissions imply read permissions.
+ * This is the closest we can get..
+ */
+#define __P000 PAGE_NONE
+#define __P001 PAGE_READONLY
+#define __P010 PAGE_COPY
+#define __P011 PAGE_COPY
+#define __P100 PAGE_READONLY
+#define __P101 PAGE_READONLY
+#define __P110 PAGE_COPY
+#define __P111 PAGE_COPY
+#define __S000 PAGE_NONE
