<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Kernel on f(x) </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://firoyang.org/tags/kernel/</link>
    <language>en-us</language>
    <author>Firo Yang</author>
    
    <updated>Tue, 22 Sep 2015 00:00:00 UTC</updated>
    
    <item>
      <title>Linux time subsystem</title>
      <link>http://firoyang.org/cs/time/</link>
      <pubDate>Tue, 22 Sep 2015 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/time/</guid>
      <description>

&lt;p&gt;我写作的主要目的是理清基本概念与原理, 而非实现,细节这一类.&lt;/p&gt;

&lt;p&gt;时间是人类发明出来的概念, Kant也认为时间是心智概念.&lt;br /&gt;
一百年前的世界和现在有什么不同呢?这个提问揭示生活中时间最重要的用途,&lt;br /&gt;
*标记*某中状态下的世界. 所谓的过去世界不过是世界的一个个连续状态&lt;br /&gt;
那么时空穿越, 就变成了保住项少龙这个肉身不变, 世界的其他部分完全&lt;br /&gt;
转变到过去的某一个状态. 而所谓现在世界就被抹杀了.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The future is already here – it&#39;s just not evenly distributed.
                        — William Gibson
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;人想回到&amp;rdquo;过去&amp;rdquo;多半源于情感因素, 而想去&amp;rdquo;未来&amp;rdquo;则是因为&amp;rdquo;物质&amp;rdquo;的缘故.&lt;br /&gt;
想象下中国的未来50年, 很可能是现在美国or西欧现在的样子.虽然中西虽然处在&lt;br /&gt;
时间概念上相同的现在, 而物质世界确实&amp;rdquo;过去&amp;rdquo;和&amp;rdquo;未来&amp;rdquo;之差.&lt;/p&gt;

&lt;p&gt;比如我们下周而要开会, 那么此时下周二就是有意识的规划未来, 时间依然是标记.&lt;br /&gt;
UTC/GMT&lt;br /&gt;
Based on caesium microwave atomic clock&lt;br /&gt;
Leap second&lt;/p&gt;

&lt;h2 id=&#34;genus-differentia-definition&#34;&gt;Genus-differentia definition&lt;/h2&gt;

&lt;p&gt;interrupt, clock event,  clock source, tick, timer, timekeeping, gettimeofday.&lt;/p&gt;

&lt;h2 id=&#34;unites&#34;&gt;unites&lt;/h2&gt;

&lt;p&gt;cputime = jiffies under HZ (FIXME)&lt;br /&gt;
sum_exec_runtime nanoseconds&lt;br /&gt;
clockt = jiffies but under USER_HZ&lt;/p&gt;

&lt;h2 id=&#34;功用定义&#34;&gt;功用定义&lt;/h2&gt;

&lt;p&gt;获取时间&lt;br /&gt;
timer&lt;br /&gt;
sleep ?&lt;br /&gt;
update sched info&lt;/p&gt;

&lt;h2 id=&#34;发生定义-设计-etymology-history-operational-definition&#34;&gt;发生定义/设计   etymology, history Operational definition&lt;/h2&gt;

&lt;p&gt;timekeeping/计时:时刻．&lt;br /&gt;
clock source: 时间之源, 表针之力.&lt;br /&gt;
clock event: 闹铃之力, 经过tick展现能力.&lt;br /&gt;
tick: timer的中断事件叫tick, tick device产生tick, 可以说tick决定了clock_event event_handler进而决定了, clock_event行为.&lt;br /&gt;
tickless:&lt;br /&gt;
for timer: use HW timer one shot, set next.&lt;br /&gt;
for update time: in above HW timer, not good&lt;br /&gt;
for sched: for priority distributed in time slice, use timer.&lt;br /&gt;
dynamic tick/no HZ:&lt;br /&gt;
No HZ in idle&lt;br /&gt;
No HZ while only 1 process running for HPC.&lt;br /&gt;
tick devies 就是clock event包了层虎皮.&lt;br /&gt;
tick broadcast framework:  based on tick device&lt;br /&gt;
clock: 可记录时间, 表盘.利用timekeeping&lt;br /&gt;
timer: use clock. what about timer_list?&lt;br /&gt;
timer_list: do in softirq&lt;br /&gt;
* timekeeping aspect&lt;br /&gt;
onset: start_kernel -&amp;gt; timekeeping_init &amp;amp; time_init &amp;amp;(rest_init-&amp;gt; kernel_init-&amp;gt; &lt;br /&gt;
kernel_init_freeable-&amp;gt;do_basic_setup-&amp;gt;do_initcalls&amp;ndash;device_initcall(init_clocksource_sysfs))&lt;br /&gt;
nucleus:used by clock see init_posix_timers and update_wall_time and sys_time&lt;br /&gt;
coda:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;clock source aspect&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;tick device layer aspect&lt;br /&gt;
per_cpu(tick_cpu_device, cpu)&lt;br /&gt;
onset: time_init-&amp;gt;mach-&amp;gt;init_time-&amp;gt;&amp;hellip;clockevents_register_device-&amp;gt;tick_check_new_device&lt;br /&gt;
nucleus: a38x_timer_interrupt-&amp;gt;a38x_clkevt.event_handler&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;tick broadcast framework&lt;br /&gt;
onset:&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;clock aspect&lt;br /&gt;
k_clock&lt;br /&gt;
onset:init_posix_timers &amp;amp; init_posix_cpu_timers&lt;br /&gt;
nucleus: 用户-&amp;gt; posix_clock-&amp;gt;timepkeeping-&amp;gt;clock_socurce&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;timer aspect&lt;br /&gt;
onset: open_softirq(HRTIMER_SOFTIRQ, run_hrtimer_softirq);&lt;br /&gt;
nucleus: common_timer_set&lt;br /&gt;
hrtimer_interrupt | (tick_handle_periodic-&amp;gt; tick_periodic-&amp;gt; update_process_times-&amp;gt;run_local_timers-&amp;gt;hrtimer_run_queues)-&amp;gt;__run_hrtimer-&amp;gt;timer.function = posix_timer_fn;(set in common_timer_set)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;计算机概念&lt;br /&gt;
system clock CLOCK_REALTIME CLOCK_MONOTONIC&lt;br /&gt;
time.h time_t=tm=timeval=timespec calendar time  clock_t&lt;/p&gt;

&lt;p&gt;clock event -&amp;gt; tick device-&amp;gt; handle function&lt;br /&gt;
clock event 相较于timer更为抽象, timer 是一种用途,timer 通过clock event来实现功能,&lt;br /&gt;
clock event 通过timer来体现自己, timer面向使用者的onset,&lt;br /&gt;
而clock event 则是偏向于nucleus and coda.&lt;br /&gt;
timer: 标记不能立即执行的变化.&lt;br /&gt;
clock source: 用一些整型抽象一个过程, 对于时间来说, 简直是完美的抽象.&lt;br /&gt;
* kernel requirement&lt;br /&gt;
linux的时间子系统要求硬件timer提供下面两种能力：&lt;br /&gt;
一是free running的counter，此外需要能够在指定的counter值上产生中断的能力。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The Journey to RCU</title>
      <link>http://firoyang.org/cs/rcu/</link>
      <pubDate>Sun, 24 May 2015 09:52:12 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/rcu/</guid>
      <description>

&lt;h1 id=&#34;rcu-stalls&#34;&gt;RCU stalls&lt;/h1&gt;

&lt;p&gt;update_process_times-&amp;gt;rcu_check_callbacks-&amp;gt;rcu_pending-&amp;gt;__rcu_pending-&amp;gt;check_cpu_stall-&amp;gt;print_other_cpu_stall&lt;/p&gt;

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;iframe frameborder=&#34;no&#34; border=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; width=330 height=86 src=&#34;http://music.163.com/outchain/player?type=2&amp;id=444737&amp;auto=1&amp;height=66&#34;&gt;&lt;/iframe&gt;&lt;br /&gt;
&lt;a href=&#34;http://lse.sourceforge.net/locking/rcupdate.html&#34;&gt;官网Read-Copy Update Mutual Exclusion&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://lse.sourceforge.net/locking/rcu/HOWTO/index.html&#34;&gt;Read Copy Update HOWTO&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://lse.sourceforge.net/locking/rcu/rcupdate_doc.html&#34;&gt;Read-Copy Update Mutual-Exclusion in Linux&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://pages.cs.wisc.edu/~thanhdo/qual-notes/sync/sync2-rcu.txt&#34;&gt;Thanh Do&amp;rsquo;s notes Read-copy update. In Ottawa Linux Symposium, July 2001&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;why-do-need-rcu&#34;&gt;Why do need RCU&lt;/h1&gt;

&lt;p&gt;For &lt;a href=&#34;http://en.wikipedia.org/wiki/Scalability&#34;&gt;scalable&lt;/a&gt; mutual exclusion.&lt;br /&gt;
scale有两个词源涵义Proto-Germanic原始日耳曼, 酒杯, 盘子, 称重的盘子, 后来演化成标量的意思.&lt;br /&gt;
scalar在数学上是标量, 在c语言指int float, Scalar processor标量计算机也是来源于此.&lt;br /&gt;
另一个出处是Latin拉丁文scandere, 有攀爬之意, 进而衍生出扩展之意.&lt;br /&gt;
From wikipedia,  A system whose performance improves after adding hardware,&lt;br /&gt;
proportionally to the capacity added, is said to be a scalable system.&lt;br /&gt;
&lt;a href=&#34;https://www.ibm.com/developerworks/cn/linux/l-rcu/&#34;&gt;因为rwlock, brlock在多核性能下降.需要个高性能的锁&lt;/a&gt;&lt;br /&gt;
言下之意, 就是其他的mutual exclusion 机制不能很好的扩展, 需要RCU.&lt;br /&gt;
Read Copy Update HOWTO介绍了当初RCU开发的动机:&lt;br /&gt;
* Increase in cost of conventional locks&lt;br /&gt;
第一个原因也是最重要的, 最根本原因.&lt;br /&gt;
传统的锁the contended lock如spinlock实现上不断访问内存轮询锁当前状态, cpu和内存速度的*越来越*巨大差异;&lt;br /&gt;
一种新的锁机制减少访问内存,就成了强烈的需求.&lt;br /&gt;
* Cache benefits of lock-free reads&lt;br /&gt;
传统锁/tried-and-true 如spinlock一类的实现在多核下, 在出现锁竞争时会导致&lt;a href=&#34;http://www.quora.com/What-is-cache-line-bouncing-How-spinlock-may-trigger-this-frequently&#34;&gt;cache line bouncing&lt;/a&gt;.&lt;br /&gt;
3个cpu, A占有spinlock, 另外两个轮询尝试获取在test and set版本的&lt;br /&gt;
spinlock, 如果Bcpu 修改lock那么C cpu的d cache line 就会强制无效,&lt;br /&gt;
之后c 也修改lock, B的d cache line就无效了.之后B又来了, 就这样.&lt;br /&gt;
在不同cpu之间同步数据, 会耗费很多cpu 指令周期.&lt;br /&gt;
像&lt;a href=&#34;https://www.ibm.com/developerworks/cn/linux/l-cn-spinlock/&#34;&gt;x86的spinlock的实现用lock指令前缀锁住总线&lt;/a&gt;,&lt;br /&gt;
其他cpu or dma就不能访问内存, 降低系统的性能, ibm这篇文章说P6之后的处理器减少这种危害.&lt;br /&gt;
* Avoiding complicated races&lt;br /&gt;
No deadlock, 减少了开发维护.&lt;/p&gt;

&lt;h1 id=&#34;how-to-use-rcu&#34;&gt;How to use RCU&lt;/h1&gt;

&lt;p&gt;list rcu&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/263130/&#34;&gt;What is RCU? Part 2: Usage&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www2.rdrop.com/users/paulmck/techreports/RCUUsage.2013.02.24a.pdf&#34;&gt;RCU Usage In the Linux Kernel: One Decade Later&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;what-is-rcu&#34;&gt;What is RCU&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.rdrop.com/~paulmck/RCU/whatisRCU.html&#34;&gt;What is RCU, Really?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/262464/&#34;&gt;What is RCU, Fundamentally?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://lwn.net/Articles/264090/&#34;&gt;RCU part 3: the RCU API&lt;/a&gt;&lt;br /&gt;
RCU supports concurrency between a single updater and multiple readers!&lt;/p&gt;

&lt;h2 id=&#34;design-pattern&#34;&gt;Design pattern&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Publish-Subscribe&lt;br /&gt;
For updater before synchnization_rcu(); similar to softirq rcu&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Observer&lt;br /&gt;
For updater to wait For Pre-Existing RCU Readers to Complete&lt;br /&gt;
Maintain Multiple Versions of Recently Updated Objects&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;positivism-implementions&#34;&gt;Positivism Implementions&lt;/h1&gt;

&lt;h2 id=&#34;classic-rcu&#34;&gt;Classic RCU&lt;/h2&gt;

&lt;p&gt;Classic RCU requires that read-side critical sections obey the same rules&lt;br /&gt;
obeyed by the critical sections of pure spinlocks:&lt;br /&gt;
blocking or sleeping of any sort is strictly prohibited.&lt;/p&gt;

&lt;h2 id=&#34;preemtible-rcu&#34;&gt;Preemtible RCU&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://lwn.net/Articles/253651/&#34;&gt;The design of preemptible read-copy-update&lt;/a&gt;&lt;br /&gt;
stage 的切换是由rcu_read_unlock 推动的!&lt;/p&gt;

&lt;h2 id=&#34;tree-rcu&#34;&gt;Tree RCU&lt;/h2&gt;

&lt;p&gt;For hundreds and thounds CPU cores&lt;/p&gt;

&lt;p&gt;#FAQ&lt;br /&gt;
* Difference with primitive and atomic&lt;br /&gt;
* Grace period is synchroinze_rcu or a softirq justment&lt;br /&gt;
* __rcu sparse will warn you if you access that pointer without the services of one of the variants of rcu_dereference().&lt;/p&gt;

&lt;h1 id=&#34;below-is-how-to-use-rcu&#34;&gt;Below is how to use RCU!&lt;/h1&gt;

&lt;h1 id=&#34;reference-1&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www2.rdrop.com/users/paulmck/techreports/RCUUsage.2013.02.24a.pdf&#34;&gt;RCU Usage In the Linux Kernel: One Decade Later&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;本文内容并非我原创, 实际上是翻译加上个人理解Paul E. McKenney的paper.Credit to Paul and others.&lt;br /&gt;
本文不关心RCU的实现.&lt;br /&gt;
本文的核心目标就是了解如何使用RCU.&lt;br /&gt;
所有使用RCU代码, 都可以分为4部分:&lt;br /&gt;
RCU read critical section: 就是rcu_read_lock()和rcu_read_unlock()之间的代码.&lt;br /&gt;
update: 这部分代码在synchronize_rcu/call_rcu之前执行. 比如给pointer = new_data;&lt;br /&gt;
synchronize: 这部分代码是等待调用synchronize/call_rcu时的所有Rcu read critical section 执行完.&lt;br /&gt;
free: 这部分是在上面synchronize/call_rcu确认所有对就数据引用的RCU read critical section都执行完了, 安全释放内存.&lt;br /&gt;
Paul的paper总结了5种用法, 并且附上了代码, 便于理解.&lt;br /&gt;
理解的过程实质上是用RCU的外衣再次理解这个5种方法!&lt;/p&gt;

&lt;h1 id=&#34;wait-for-completion&#34;&gt;Wait for Completion&lt;/h1&gt;

&lt;p&gt;内核中有&lt;a href=&#34;https://lwn.net/Articles/23993/&#34;&gt;完成量completion&lt;/a&gt;的基础设施&lt;br /&gt;
上面的RCU read critical section和synchronize可以构成completion的语义.&lt;br /&gt;
为什么要用RCU而不是内核自身提供的completion函数呢?&lt;br /&gt;
Paul的文中举的例子实在NMI中要作这样的事情, 显然基于waitqueue的completion是毫无用处的.&lt;br /&gt;
所以这里的RCU, 应该叫做Completion RCU-version.&lt;/p&gt;

&lt;h1 id=&#34;reference-counting&#34;&gt;Reference Counting&lt;/h1&gt;

&lt;p&gt;传统的引用计数就是往结构体里面内嵌一个atomic,加加减减.&lt;br /&gt;
但RCU实现的引用计数把实际工作转移到softirq-rcu部分去了.&lt;br /&gt;
Paul给了一个例子, 我认为是及其不合适的.因为他忽略了softirq部分随着smp的核数增多&lt;br /&gt;
同样也会带来性能的损耗,而不是almost zero in his paper.&lt;br /&gt;
引用计数和完成量的区别, 除了语义上的差异, 看起来没有太大的区分.FIXME.&lt;/p&gt;

&lt;h1 id=&#34;type-safe-memory&#34;&gt;Type Safe Memory&lt;/h1&gt;

&lt;h1 id=&#34;publish-subscribe&#34;&gt;Publish-Subscribe&lt;/h1&gt;

&lt;h1 id=&#34;read-write-lock-alternative&#34;&gt;Read-Write Lock Alternative&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>Kernel hacking</title>
      <link>http://firoyang.org/cs/hacking/</link>
      <pubDate>Sat, 25 Apr 2015 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/hacking/</guid>
      <description>

&lt;h1 id=&#34;kernel-hacking&#34;&gt;kernel hacking&lt;/h1&gt;

&lt;p&gt;The cxgb3_*_send() functions return NET&lt;em&gt;XMIT&lt;/em&gt; values, which are&lt;br /&gt;
positive integers values. So don&amp;rsquo;t treat positive return values&lt;br /&gt;
as an error.&lt;br /&gt;
67f1aee6f45059fd6b0f5b0ecb2c97ad0451f6b3&lt;/p&gt;

&lt;h1 id=&#34;old-questions&#34;&gt;old questions&lt;/h1&gt;

&lt;p&gt;What is platform driver?&lt;br /&gt;
find source code of config&lt;br /&gt;
How to print backtrace by kernel oops, and why it&amp;rsquo;s not exact?&lt;br /&gt;
What is abi&lt;br /&gt;
why get_unaligned_be16?&lt;br /&gt;
 _THIS&lt;em&gt;IP&lt;/em&gt; vs &lt;strong&gt;FUNCTIONS&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&#34;kernel-data-type&#34;&gt;kernel data type&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://yarchive.net/comp/linux/kernel_headers.html&#34;&gt;__u32&lt;/a&gt; and &lt;a href=&#34;http://www.linuxjournal.com/article/5783&#34;&gt;this&lt;/a&gt; and dd3e chapter 10.&lt;/p&gt;

&lt;h1 id=&#34;the-principle-of-kernel-driver-backport&#34;&gt;The principle of kernel &amp;amp; driver backport&lt;/h1&gt;

&lt;p&gt;将高本版kernel的feature移植到低版本的kernel的过程就是backport.&lt;br /&gt;
1. 尽量保持与mainline的代码一致&lt;br /&gt;
2. 做好取舍不要引入太多patch.&lt;/p&gt;

&lt;h2 id=&#34;开发流程&#34;&gt;开发流程&lt;/h2&gt;

&lt;p&gt;理清所引入feature的代码. 主要数据结构以及功能流程.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://wangcong.org/2007/03/09/-e8-b5-b0-e8-bf-91linux-e5-86-85-e6-a0-b8/&#34;&gt;走近Linux内核&amp;ndash; 王聪&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;kernel-hacker之路&#34;&gt;kernel hacker之路&lt;/h1&gt;

&lt;p&gt;我实在太想聊这个话题 &amp;ndash; 内核hacker的成长之路!&lt;br /&gt;
不是教你写第一个kernel module, 就灭火了. 而是持续的一步步成长为&lt;br /&gt;
内核的中坚力量, 甚至是maintainer.&lt;br /&gt;
作为一个内核爱好者, 从接触到现在已经3年半了. 然而, 我对自己是非常失望的.&lt;br /&gt;
因为我看了3年多的书, 从今年(15)5月才开始, 给社区提补丁.&lt;br /&gt;
起始我在12年的11月份曾经给社区, 提过几次补丁. 后来有那么两三次, 想帮着修复&lt;br /&gt;
kernel panic 和oops的问题, 基本上个人感觉难度非常太大就无极而终了.&lt;br /&gt;
5月份这次, 我是因为实在不想在看书籍了, 市面上稍微有点名的书籍, 我都看过.&lt;br /&gt;
实在太厌烦再看书了, 我把自己和另外一个内核hacker 王聪做了对比, 得出结论:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;赶快滚去给社区提patch! 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我挨个看了王聪给社区提的前50个patch. 都是很简单的修改.&lt;br /&gt;
我几次挫败都是, 因为没能找到合适内核事情去做, 最终没有下文了.&lt;br /&gt;
今天, 我在给社区提了20个左右的patch 10几个被接收了. 我现在找到了一条成长路.&lt;/p&gt;

&lt;h2 id=&#34;内核我现在认为可以给新人做得事&#34;&gt;内核我现在认为可以给新人做得事&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/284099/&#34;&gt;https://lwn.net/Articles/284099/&lt;/a&gt;  这个帖子, 提供了新手可以做得事情, 我觉得非常好.&lt;br /&gt;
smatch coccinelle的分析结果.&lt;br /&gt;
源码中标注的FIXME和TODO, 简单的提过去很难被接受, 难的这些开发者自己都没搞定, 新人更难.&lt;br /&gt;
这也不是一条好路.&lt;br /&gt;
内核bugzilla kerneloops上问题, 这个很难.&lt;br /&gt;
找一个和内核相关的工作驱动啊, 网络开发, 虚拟化, 存储都非常赞.&lt;br /&gt;
自己搞个feature, 感觉更难, 这个需要需求驱动.&lt;br /&gt;
没有一条轻松的路让你走, 但你却不应该光着脚走在上面!!!&lt;br /&gt;
内核之外有很多值得珍惜的. 尽力做好, 你能做的, 开始点滴积累.&lt;br /&gt;
终有一天会聚成沧海, 前提是你等得到那天, 不要亏待自己.&lt;br /&gt;
内核之路始终时不那么清晰, 但是反思过后, 你便知道, 该去做什么了.&lt;br /&gt;
这也许是最难受的情况了.&lt;br /&gt;
Linus 之前说过, 搞得内核你得用起来. uml 是个不错的开端.&lt;br /&gt;
用起来才是王道!&lt;/p&gt;

&lt;p&gt;#git&lt;br /&gt;
&lt;a href=&#34;http://git-scm.com/docs/gittutorial&#34;&gt;gittutorial - A tutorial introduction to Git&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;linux-source-code&#34;&gt;linux source code&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kernel.org/doc/man-pages/linux-next.html&#34;&gt;Working with linux-next&lt;/a&gt;&lt;br /&gt;
要add git://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git不是https.&lt;br /&gt;
我之前改了好多bug基于linus的分支, 提交后被告知别人已改. 后来Julia告诉我要基于linux-next开发.&lt;br /&gt;
我的linux next remote 就叫next, 基于其创建开发分支.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git branch now next/master
git pull next master:now
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;你提patch-社区的困惑是什么&#34;&gt;你提patch, 社区的困惑是什么?&lt;/h1&gt;

&lt;p&gt;每个kernel newbie 都应该完整看完这个mail list&lt;br /&gt;
&lt;a href=&#34;http://thread.gmane.org/gmane.linux.kernel/683798/focus=684297&#34;&gt;http://thread.gmane.org/gmane.linux.kernel/683798/focus=684297&lt;/a&gt;&lt;br /&gt;
你能看到鹰派的Al还有温和派Andrew Morton.&lt;br /&gt;
为什么&lt;a href=&#34;http://kernelnewbies.org/这么重要网站&#34;&gt;http://kernelnewbies.org/这么重要网站&lt;/a&gt;, 不做的好一点, 至少界面友好点.&lt;br /&gt;
应该找个机会, 整一下.&lt;/p&gt;

&lt;h1 id=&#34;fix-kernel-mistakes&#34;&gt;Fix kernel mistakes&lt;/h1&gt;

&lt;p&gt;内核至今如此优秀就是因为, 成千上万前赴后继的开发者笔耕不缀的结果.&lt;br /&gt;
别当豆包不当干粮, 虽然, 你不能设计出很牛的算法, or 什么子系统,&lt;br /&gt;
但是内核还有很多问题有待解决, 正所谓老虎也要打, 苍蝇也要拍; 千里之堤毁于蚁穴.&lt;br /&gt;
我提过好些这种patch Dan Carpenter都告诉我Linus已经改了.&lt;/p&gt;

&lt;h2 id=&#34;kernel-newbie上有个list&#34;&gt;kernel newbie上有个list&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://kernelnewbies.org/KernelJanitors/Todo&#34;&gt;KernelJanitors/Todo&lt;/a&gt;&lt;br /&gt;
* Style fix&lt;br /&gt;
如:&lt;br /&gt;
remove_wait_queue(entry-&amp;gt;wait_address,&amp;amp;entry-&amp;gt;wait);&lt;br /&gt;
remove_wait_queue(entry-&amp;gt;wait_address, &amp;amp;entry-&amp;gt;wait);&lt;/p&gt;

&lt;h2 id=&#34;smatch&#34;&gt;Smatch&lt;/h2&gt;

&lt;p&gt;smatch这个工具是Dan写的主要就是为了找到内核的小问题, 基本用法:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    make CHECK=&amp;quot;~/path/to/smatch/smatch -p=kernel&amp;quot; C=1 \
            bzImage modules | tee warns.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;smatch 会产生好多可疑的问题, 细心寻找吧.&lt;br /&gt;
你找到了, 那么就是修改了.&lt;br /&gt;
记住在smatch之前一点要git pull next master:now一下, 保证checkout到了now的分支.&lt;/p&gt;

&lt;h2 id=&#34;coccinelle&#34;&gt;Coccinelle&lt;/h2&gt;

&lt;p&gt;Coccinelle是 Julia Lawall 写的静态检测工具.very nice.&lt;br /&gt;
自己研究吧&lt;br /&gt;
Documentation/coccinelle.txt&lt;br /&gt;
&lt;a href=&#34;http://pagesperso-systeme.lip6.fr/Julia.Lawall/tutorial.pdf&#34;&gt;http://pagesperso-systeme.lip6.fr/Julia.Lawall/tutorial.pdf&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;生成patch&#34;&gt;生成patch&lt;/h2&gt;

&lt;p&gt;先修改.&lt;br /&gt;
之后git add&lt;br /&gt;
在commit 之前你要 git log &amp;ndash;online path/to/modification/file&lt;br /&gt;
看下提交的titile:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git log  --oneline drivers/base/firmware_class.c
5455c8c firmware: Fix memory leak in error path
e0fd9b1 firmware: use const for remaining firmware names
f9692b2 firmware: fix possible use after free on name on a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主义冒号:后一定要有一个空格!&lt;br /&gt;
你会还是看下Document下的submitting的文档.&lt;br /&gt;
之后commit:&lt;br /&gt;
先是类似上面的一行oneline 简要说明&lt;br /&gt;
空一行.&lt;br /&gt;
之后具体描述下.&lt;br /&gt;
commit后, 生成patch&lt;br /&gt;
如果你只提交了一次:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git format-patch HEAD^..HEAD
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个命令就ok了.&lt;br /&gt;
如果commit多次, 自己斟酌两次diff的commit id了, HEAD^ 和HEAD都是commit id.&lt;br /&gt;
这样就生成了patch, 一般叫做0001-xxx-ooo.patch之类的&lt;br /&gt;
如我这个, 已被接收:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0001-firmware-Fix-memory-leak-in-error-path.patch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;commit id 是5455c8c3284a63e2673d1be7f040fb245cbf9be9&lt;/p&gt;

&lt;h2 id=&#34;测试patch&#34;&gt;测试patch&lt;/h2&gt;

&lt;p&gt;复杂的patch要编译内核, 安装的机器上跑一下.&lt;/p&gt;

&lt;h2 id=&#34;发送patch&#34;&gt;发送patch&lt;/h2&gt;

&lt;p&gt;天朝用户自己打梯子吧proxychains shadowsocks.&lt;br /&gt;
基本步骤是&lt;br /&gt;
先编译一下:&lt;br /&gt;
make path/to/modification/file.o&lt;br /&gt;
之后&lt;br /&gt;
./scripts/checkpatch.pl&lt;br /&gt;
之后 get maintainer&lt;br /&gt;
./scripts/get_maintainer.pl&lt;/p&gt;

&lt;p&gt;发送的时候, 发给维护者 &amp;ndash;cc其他人, 还有cc 一个mailist, 如果没有合适的list的话,&lt;br /&gt;
就cc到linux-kernel@vger.kernel.org, 这是个开放的list, 有合适的list了, 就不要cc它了.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;proxychains git send-email --to ming.lei@canonical.com --cc gregkh@linuxfoundation.org --cc kernel-janitors@vger.kernel.org 0001-firmware-Fix-memory-leak-in-error-path.patch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;免不了你要返工重新修改.这时候, 新生成的patch这样:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git format-patch --subject-prefix=&amp;quot;PATCH v2&amp;quot; HEAD^..HEAD
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改几次就v几.&lt;br /&gt;
和社区交流的时候, 要注意礼貌, 而且要感谢别人对你的patch做出的建议,&lt;br /&gt;
没有人的时间是被猪拱来的.&lt;/p&gt;

&lt;p&gt;这些都是比较简单(代码量上)的patch, 要想提交深度的还需要对某方面的深度.&lt;br /&gt;
基本上这就完了, 你的真正的patch就给社区了.&lt;/p&gt;

&lt;h1 id=&#34;进阶decent&#34;&gt;进阶decent&lt;/h1&gt;

&lt;p&gt;这个是昨天晚上改drivers代码时候, 看到TODO的注释猛然想到的.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grep -nr &#39;FIXME&#39; --include=&amp;quot;*.c&amp;quot;  ./ | tee fixmek.log
grep -nr &#39;TODO&#39; --include=&amp;quot;*.c&amp;quot; ./ | tee todok.log
wc -l fixmek.log 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有6000多个.&lt;/p&gt;

&lt;h1 id=&#34;deeply-involved&#34;&gt;Deeply involved&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://vger.kernel.org/~davem/net_todo.html&#34;&gt;http://vger.kernel.org/~davem/net_todo.html&lt;/a&gt;&lt;br /&gt;
这个列表上的基本都过期了&amp;hellip;.哎&lt;br /&gt;
往深了走不是难事, 主要是意识到内核, 不是什么神秘的东西, 选好一个方向&lt;br /&gt;
简单看看概念见我的&amp;lt;如何学习&amp;gt; 就可以实践.&lt;br /&gt;
必须要意识到, 动手比看再多概念管用, 我就是之前看了太多, 还发展出一个哲学&lt;br /&gt;
体系出来:-) 确实随着现代信息科学给社会带来的巨大变化, 哲学也必须要更新.&lt;br /&gt;
才能更好的服务于人.&lt;br /&gt;
这几天就在, 找内核哪里还不完善, 自己能补上, 今天6号了.&lt;br /&gt;
#patch formate advices&lt;br /&gt;
* Julia Lawall Sorry to be picky,&lt;br /&gt;
but normally people put a space after the colon.  Also,&lt;br /&gt;
the subject line could be shorter: Remove unneeded cast.&lt;br /&gt;
The description part of the subject doesnt have to be unique,&lt;br /&gt;
just the whole thing, asfter the [PATCH] part.&lt;br /&gt;
* Dan Carpenter&lt;br /&gt;
Otherwise your patch was fine, btw.  Other improvements.&lt;br /&gt;
Don&amp;rsquo;t put &amp;ldquo;Drivers:&amp;rdquo; in the subject.&lt;br /&gt;
On Wed, Apr 22, 2015 at 09:10:50PM +0800, Firo Yang wrote:&lt;br /&gt;
&amp;gt; From: Firo Yang &lt;a href=&#34;mailto:firogm@gmail.com&#34;&gt;firogm@gmail.com&lt;/a&gt;&lt;br /&gt;
Don&amp;rsquo;t include this line.  We can get it from you email address.&lt;/p&gt;

&lt;p&gt;Include everyone from the ./scripts/get_maintainer.pl output except&lt;br /&gt;
don&amp;rsquo;t include linux-kernel@vger.kernel.org if there is another mailing&lt;br /&gt;
list there already.&lt;br /&gt;
* To find  patch prefix&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git log --oneline  path/to/file.c
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;更新patch 要加v几&lt;/p&gt;

&lt;p&gt;git format-patch &amp;ndash;subject-prefix=&amp;ldquo;PATCH v2&amp;rdquo; xxx..ooo&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;提交多个patch 要手动生成一个[PATCH 0/N], 这个0就是要写简要描述的.&lt;/p&gt;

&lt;p&gt;proxychains git send-email &amp;ndash;subject &amp;ldquo;[PATCH v2 0/15] Remove unneeded casts of memory-alloc function return values&amp;rdquo; &amp;ndash;thread &amp;ndash;compose &amp;ndash;confirm=compose &amp;ndash;to firogm@gmail.com *.patch&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Dave Miller偏好&lt;br /&gt;
@@ -325,13 +325,15 @@ static inline void empty_child_dec(struct key_vector *n)&lt;br /&gt;
static struct key_vector *leaf_new(t_key key, struct fib_alias *fa)&lt;br /&gt;
{&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;struct tnode *kv = kmem_cache_alloc(trie_leaf_kmem, GFP_KERNEL);&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;struct key_vector *l = kv-&amp;gt;kv;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;struct tnode *kv;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;struct key_vector *l;&lt;br /&gt;
Dave Miller usually prefers it if variables are ordered from longest to shortest.&lt;br /&gt;
So you should probably have l defined first, and then kv.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Filesystem</title>
      <link>http://firoyang.org/cs/fs/</link>
      <pubDate>Fri, 27 Feb 2015 15:46:12 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/fs/</guid>
      <description>

&lt;h1 id=&#34;open&#34;&gt;open()&lt;/h1&gt;

&lt;p&gt;最烦, 看什么系统调用参数了.&lt;br /&gt;
那一大堆很少用到的组合还有undefined, 太扯淡了.&lt;br /&gt;
也说不上碎碎的问题, 要理解着来, 看man 手册, 贴子显然不是&lt;br /&gt;
最后的注意还是看实现吧.&lt;br /&gt;
build_open_flags()还是看不出&lt;br /&gt;
man里面有一句&lt;br /&gt;
 The (undefined) effect of O_RDONLY | O_TRUNC varies among implementations.&lt;br /&gt;
On many systems the file is actually truncated.&lt;/p&gt;

&lt;p&gt;#Hacks&lt;br /&gt;
I suddenly find that a good way to understand fs in kernel is to manupulate a small and complete fs, like ramfs or tmpfs.&lt;/p&gt;

&lt;p&gt;#VFS&lt;br /&gt;
##Common concepts&lt;br /&gt;
* VFS:Common fs interface plus fs anstraction layer!&lt;/p&gt;

&lt;h2 id=&#34;unix-fs-related-abstractions-file-directory-entries-inodes-and-mount-points&#34;&gt;Unix fs-related abstractions: file, directory entries, inodes, and mount points.&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Filesytem: a hierarchial storage of data adhering to a specific structure.&lt;br /&gt;
In unix, fs are mounted at a specific mount point in global hierarchy known as a namespace.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;file: and ordered string of bytes.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;directory: analogous to a folder and usally contains related files.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;dentry: Each component of a path is called a directory entry.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;inode: Unix separate the concept of a file from any associated infomation(file metadata) inode!&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;supreblock: a data structure containing information about the filesystem as a whole.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;vfs-primary-objects-superblock-inode-dentry-file&#34;&gt;VFS primary objects: superblock, inode, dentry, file.&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;supreblock: a specific mounted filesystem.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;inode: unit for fs. all the information needed by the kernel to manipulate a file or directory.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;dentry: accelerate access fs, dcache! a single component of a path, certainly include &lt;em&gt;regular&lt;/em&gt; file.&lt;br /&gt;
VFS treats directory as non-exist &lt;em&gt;normal&lt;/em&gt; file. directory and dentry is not the same at all, different congitive level!&lt;br /&gt;
In VFS, file, dentry, and inode all represents dir and file and others, in others words struct file can stand for a dir!&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;file: an open normal file as associated with a process.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##Step of how to use ext2 fs&lt;br /&gt;
* Register a fs type in kernel.&lt;br /&gt;
struct file_system_type: basic fs driver codes!&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;mkfs.ext2&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;shell mount -&amp;gt; sys_mount -&amp;gt; file_system_type-&amp;gt;mount =&amp;gt; root dentry and dentry-&amp;gt;d_sb!&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;sys_open -&amp;gt;&lt;br /&gt;
path_init()&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;get start point current-&amp;gt;fs{root, pwd}&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;link_path_walk() to the parent dentry of last entry vim in /sbin/vim. deal with diff mounted fs(ext2 and windows ntfs)&lt;br /&gt;
do_last()&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;dentry,look_dcache(), if not in dcache, d_alloc(); d_op = sb-&amp;gt;s_dentry_op&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;file, if not open, file-&amp;gt;f_op = inode-&amp;gt;i_fop&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;sys_write -&amp;gt;&lt;br /&gt;
file-&amp;gt;f_op-&amp;gt;write()&amp;hellip;&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##How make dentry&lt;br /&gt;
d_alloc() alloc new dentry&lt;br /&gt;
parent_entry-&amp;gt;d_inode-&amp;gt;i_op-&amp;gt;lookup=ext2_lookup()-&amp;gt; ext2_iget() -&amp;gt; use raw_inode make inode-&amp;gt;&lt;br /&gt;
set inode to dentry&lt;/p&gt;

&lt;p&gt;#Procfs&lt;br /&gt;
##How many parts does procfs has?&lt;br /&gt;
* process-specific read only /proc/&lt;pid&gt;/&lt;br /&gt;
* process tuneable interface. /proc/&lt;pid&gt;/&lt;br /&gt;
* kernel sysctl, importanta kernel tuneable files. /proc/sys/kernel net vm fs&amp;hellip;&lt;br /&gt;
* Read only kernel infomation. /proc&lt;br /&gt;
##I think, important directory need to know.&lt;br /&gt;
/proc/sys/kernel&lt;/p&gt;

&lt;h1 id=&#34;sysfs&#34;&gt;Sysfs&lt;/h1&gt;

&lt;p&gt;sysfs is strongly depend on driver module, just rmmod tg3 then /sys/class/net/enp9s0 went away!&lt;/p&gt;

&lt;h1 id=&#34;ramfs&#34;&gt;Ramfs&lt;/h1&gt;

&lt;p&gt;fs/ramfs&lt;/p&gt;

&lt;p&gt;##reference&lt;br /&gt;
&lt;a href=&#34;http://www.thegeekstuff.com/2008/11/overview-of-ramfs-and-tmpfs-on-linux/&#34;&gt;Overview of RAMFS and TMPFS on Linux&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;#tmpfs&lt;br /&gt;
mm/shmem.c&lt;br /&gt;
&lt;a href=&#34;http://wangcong.org/2012/02/17/-e5-85-b3-e4-ba-8e-tmpfs/&#34;&gt;关于 tmpfs&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;#rootfs&lt;br /&gt;
init/do_mounts.c&lt;br /&gt;
init_rootfs()&lt;br /&gt;
init_mount_tree&lt;br /&gt;
rootfs = IS_ENABLED(CONFIG_TMPFS) ? tmpfs : ramfs&lt;br /&gt;
但是在do_basic_setup才初始化.&lt;br /&gt;
rootfs_initcall(populate_rootfs);&lt;/p&gt;

&lt;p&gt;#initramfs&lt;br /&gt;
init/initramfs.c&lt;/p&gt;

&lt;p&gt;initrd-&amp;gt;initramfs&lt;br /&gt;
{&lt;br /&gt;
    linus&amp;rsquo; ramfs -&amp;gt; /tmpfs&lt;br /&gt;
}&lt;/p&gt;

&lt;p&gt;##Difference with initrd&lt;br /&gt;
initrd is image with specific fs type, like ext2, need driver built-in kernel.&lt;br /&gt;
initramfs is a cpio, like tar only simpler, populated to rootfs in kernel, with fs type rootfs&lt;/p&gt;

&lt;p&gt;##request hard drive driver maybe fs driver&lt;br /&gt;
ata_host_register-&amp;gt;ata_scsi_scan_host-&amp;gt;__scsi_add_device-&amp;gt;scsi_probe_and_add_lun -&amp;gt;scsi_add_lun&lt;/p&gt;

&lt;p&gt;subsys_initcall(genhd_device_init);-&amp;gt;kobj_map_init{bdev_map.probe.get = base_probe}&lt;/p&gt;

&lt;p&gt;subsys_initcall(init_scsi);4-&amp;gt;scsi_sysfs_register{autoprobe = 1;}&lt;br /&gt;
rootfs_initcall(populate_rootfs);-&amp;gt;{unpack_to_rootfs; 解压initramfs到rootfs}&lt;br /&gt;
module_initinit_sd;6-&amp;gt;scsi_register_driver -&amp;gt;driver_register-&amp;gt;bus_add_driver -&amp;gt;driver_attach -&amp;gt;driver_probe_device-&amp;gt; drv-&amp;gt;probe(dev)=sd_probe_async-&amp;gt;add_disk -&amp;gt; register_disk -&amp;gt; get_gendisk -&amp;gt; kobj_lookup { bdev_map.probe.get()=base_probe(){request_module}}&lt;/p&gt;

&lt;p&gt;##mount fs&lt;br /&gt;
kernel_init_freeable-&amp;gt; if /init in initramfs 可以访问 根文件系统挂在和chroot交给/init也就是systemd&lt;br /&gt;
如果/init不可以访问 prepare_namespace{挂在真正的文件系统}&lt;/p&gt;

&lt;h1 id=&#34;faq&#34;&gt;FAQ&lt;/h1&gt;

&lt;h2 id=&#34;forbid-ln&#34;&gt;forbid ln&lt;/h2&gt;

&lt;p&gt;hard link to directory, recursive&lt;br /&gt;
hard link to file accross partitions, may led confilict with inode number.&lt;/p&gt;

&lt;h2 id=&#34;stick-bit&#34;&gt;stick bit&lt;/h2&gt;

&lt;p&gt;chmod +t&lt;br /&gt;
1777&lt;br /&gt;
只有owner 和root才能删除这个文件, 用于/tmp&lt;/p&gt;

&lt;h2 id=&#34;time-of-file&#34;&gt;time of file&lt;/h2&gt;

&lt;h3 id=&#34;atime&#34;&gt;atime&lt;/h3&gt;

&lt;p&gt;perhaps the most stupid Unix design idea of all times,&amp;rdquo; adding: &amp;ldquo;[T]hink about this a bit: &amp;lsquo;For every file that is read from the disk, lets do a &amp;hellip; write to the disk! And, for every file that is already cached and which we read from the cache &amp;hellip; do a write to the disk!&amp;rsquo;&amp;rdquo; He further emphasized the performance impact thus:&lt;/p&gt;

&lt;h4 id=&#34;find-relatime-options&#34;&gt;find relatime options&lt;/h4&gt;

&lt;p&gt;cat /proc/mounts&lt;br /&gt;
man mount&lt;/p&gt;

&lt;p&gt;##mount root device&lt;br /&gt;
root= name_to_dev_t, mount_root in prepare_namespace&lt;br /&gt;
如果/init不能 sys_access, 则prepare_namespace,切换到真正的root=指定的设备上设备在sd_probe上初始化了.&lt;br /&gt;
systemd负责挂在文件系统, 切换.&lt;/p&gt;

&lt;p&gt;subsys_initcall 4 genhd_device_init with base_probe{ request_module()}&lt;br /&gt;
module_init 6 -&amp;gt;init_sd-&amp;gt;sync_schedule_domain(sd_probe_async&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux device driver</title>
      <link>http://firoyang.org/cs/dd/</link>
      <pubDate>Fri, 27 Feb 2015 15:46:12 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/dd/</guid>
      <description>

&lt;p&gt;#Bibilography&lt;br /&gt;
Driver porting: Device model overview: &lt;a href=&#34;http://lwn.net/Articles/31185/&#34;&gt;http://lwn.net/Articles/31185/&lt;/a&gt;&lt;br /&gt;
/Documentation/driver-model&lt;br /&gt;
The Linux Kernel Driver Model&lt;/p&gt;

&lt;h1 id=&#34;contents&#34;&gt;Contents&lt;/h1&gt;

&lt;p&gt;Why abstruction?&lt;/p&gt;

&lt;h1 id=&#34;device-tree&#34;&gt;Device tree&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;What infomation was included in dtb&lt;br /&gt;
HW platform识别，runtime parameter传递以及硬件设备描述&lt;br /&gt;
for platform device init see arch/powerpc/platforms/52xx/media5200.c ppc_init&lt;br /&gt;
mpc52xx_declare_of_platform_devices&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;How does the device tree subsystem read and parse the dts file?&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;#Why DDM?&lt;br /&gt;
The device model was originally intended to make power management tasks easier&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;I/o Architecture&lt;br /&gt;
1 Expansion hardware.&lt;br /&gt;
Bus includes internal bus/system bus(PCI,ISA,SBus,I2C) and external bus(ieee1394/firewire,USB) and both(SCSI).&lt;br /&gt;
2 Communication with peripherals&lt;br /&gt;
I/O ports&lt;br /&gt;
I/O memory mapping&lt;br /&gt;
Interrupts&lt;br /&gt;
hrough the maintenance of a representation of the host system&amp;rsquo;s hardware structure.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;linux-设备驱动模型&#34;&gt;linux 设备驱动模型&lt;/h1&gt;

&lt;p&gt;分为三层：&lt;br /&gt;
从结构上看，每一层都有对应的数据结构。&lt;br /&gt;
1 设备驱动层，驱动开发工程师，也就是码农们，设计的akashadevice  akashadriver 结构体。&lt;br /&gt;
2 驱动程序核心层 ，是一个通用层，内核中的标准结构，device device_driver bus_type.&lt;br /&gt;
3 Kobject核心层，也是一个通用层， kobject kobj_type kset 组成。&lt;br /&gt;
其实下面还有一个sys文件系统层。&lt;/p&gt;

&lt;p&gt;从操作上看，也是分为三类，初始化 注册 注销&lt;br /&gt;
1 初始化，是局限于每一层的。&lt;br /&gt;
2 注册和注销就是贯穿三层的。&lt;/p&gt;

&lt;p&gt;，我们知道其实总线就是铁轨，而各种设备就是北京东站，大连站。&lt;br /&gt;
我们人呢，就是铁轨上跑的数据。driver还用说就是火车了呗。&lt;br /&gt;
Bus总线这类设备比较特殊,需要内核对总线支持，即总线的核心层；&lt;br /&gt;
另一部分在外设的驱动程序中，负责把驱动挂接到总线，如pci_driver, usb_driver, i2c_driver。记住，这是说的总线的驱动。和挂接在总线上的设备驱动不同。&lt;br /&gt;
就好像open系统调用和驱动程序中file_operations中xxx_open的关系一样。&lt;br /&gt;
作为中间传输用途的总线设备的驱动是在内核当中，已经写好了，不用像各种总线上的设备一样，再写什么专门服务pci，i2c，spi等&lt;br /&gt;
总线设备的驱动，这里感谢下内核，又轻松了不少。pci之类的总线的，驱动就是match probe remove的函数，&lt;br /&gt;
不用专门封装成一个结构体，像我们遇到的block char设备，他们才是真中的外设。总之总线要单独看。&lt;br /&gt;
作为一个外设的驱动是很不容易除了要完成外设本身功能的部分还要处理好和总线的关系。对于pci总线上设备驱动就是由pci_driver来调和的。&lt;/p&gt;

&lt;p&gt;kobject核心层的注册有点小技巧，他是先在作为参数kobj结构体中指定了，这个结构体属于哪里kset，之后在注册函数里，在kset里把kobj链入。&lt;br /&gt;
PS：设备注册和驱动注册是分开的。当设备注册后通过udev开始寻找驱动的过程。驱动是通过pci_device_id和相应设备建立关联的，不是major 和minor设备号。&lt;br /&gt;
可别高乱了。&lt;/p&gt;

&lt;h1 id=&#34;sys-文件系统&#34;&gt;Sys 文件系统&lt;/h1&gt;

&lt;p&gt;bus，总线树跟踪每个总线上的每个设备。实质是保存驱动，设备在device中，用链接指明。&lt;br /&gt;
class, 类树按功能分类设备。&lt;br /&gt;
device，干货，其他的目录都指向这里。&lt;/p&gt;

&lt;h1 id=&#34;kobject&#34;&gt;Kobject&lt;/h1&gt;

&lt;p&gt;清0，init，set name，get，put&lt;br /&gt;
在sys中是dir，attr 是文件&lt;/p&gt;

&lt;h1 id=&#34;kobj-type&#34;&gt;kobj_type&lt;/h1&gt;

&lt;p&gt;release(),&lt;/p&gt;

&lt;h1 id=&#34;kset&#34;&gt;Kset&lt;/h1&gt;

&lt;p&gt;添加kobject到kset（指针，add）&lt;/p&gt;

&lt;h1 id=&#34;bus-device-driver&#34;&gt;Bus, device, driver.&lt;/h1&gt;

&lt;p&gt;#devres&lt;br /&gt;
* devm_kfree&lt;br /&gt;
&lt;a href=&#34;http://lists.freedesktop.org/archives/dri-devel/2013-May/038943.html&#34;&gt;devm_kfree does not need for fail case of probe function and for remove function.&lt;/a&gt;&lt;br /&gt;
__device_release_driver&lt;br /&gt;
really_probe&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a must use devm_kfree Julia Lawall&lt;br /&gt;
The function at91_dt_node_to_map is ultimately called by the function&lt;br /&gt;
&amp;gt; pinctrl_get, which is an exported function.  Since it is possible that this&lt;br /&gt;
&amp;gt; function is not called from within a probe function, for safety, the kfree&lt;br /&gt;
&amp;gt; is converted to a devm_kfree, to both free the data and remove it from the&lt;br /&gt;
&amp;gt; device in a failure situation.&lt;br /&gt;
*for noop devm_kmalloc_release&lt;br /&gt;
devm_kmalloc()-&amp;gt;dr = alloc_dr(devm_kmalloc_release, size, gfp);&lt;br /&gt;
see release_nodes() -&amp;gt;kfree(dr);&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Power management</title>
      <link>http://firoyang.org/cs/pm/</link>
      <pubDate>Fri, 27 Feb 2015 15:46:12 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/pm/</guid>
      <description>

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.wowotech.net/pm_subsystem/generic_pm_architecture.html&#34;&gt;wowotech&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/384146/&#34;&gt;The cpuidle subsystem&lt;/a&gt;cpuidle—Do nothing, efficiently&lt;br /&gt;
&lt;a href=&#34;http://www.marvell.com/embedded-processors/armada-xp/assets/HW_MV78460_OS.PDF&#34;&gt;Hardware Specifications 9.4&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.marvell.com/embedded-processors/armada-xp/assets/ARMADA-XP-Functional-SpecDatasheet.pdf&#34;&gt;Functional Specifications 34&lt;/a&gt;&lt;br /&gt;
Documentation/power&lt;br /&gt;
Controlling Processor C-State Usage in Linux&lt;br /&gt;
&lt;a href=&#34;http://doc.opensuse.org/documentation/html/openSUSE_114/opensuse-tuning/cha.tuning.power.html&#34;&gt;Chapter 11. Power Management&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;C-states: idle core power state&lt;/p&gt;

&lt;h1 id=&#34;the-structure-of-pm-source-codes&#34;&gt;The structure of PM source codes&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Interface&lt;br /&gt;
syscall /sys/power&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;PM core&lt;br /&gt;
kernel/power&lt;br /&gt;
main.c suspend.c suspend_test.c console.c process.c&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Device PM&lt;br /&gt;
driver/base/power &amp;ndash; Power management interface, firo&lt;br /&gt;
power management 是针对device, bus, driver这部分的. 在suspend_devices_and_enter用到dpm_suspend_start.&lt;br /&gt;
driver/各种设备的驱动&lt;br /&gt;
driver/cpuidle &amp;ndash;firo&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Platform PM&lt;br /&gt;
include/linux/suspend.h&amp;mdash;-定义platform dependent PM有关的操作函数集&lt;br /&gt;
就是他platform_suspend_ops&lt;br /&gt;
arch/xxx/mach-xxx/xxx.c or arch/xxx/plat-xxx/xxx.c&amp;mdash;-平台相关的电源管理操作&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;CPU control&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;important-data-structure&#34;&gt;Important data structure&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Platform PM&lt;br /&gt;
platform_suspend_ops, platform plat-* is equivalent to mach-* and microarchitecture.&lt;br /&gt;
plat-* is abustruct from mach-*1 and mach-&lt;em&gt;2 and so on.&lt;br /&gt;
mach-&lt;/em&gt; is more closer to Board!&lt;br /&gt;
所以这个platform_suspend_ops, 是非常重要的, 他包含了所有BSP底层的内容.&lt;br /&gt;
竟然是用suspend_ops这个全局变量, 来承载所有platform相关的内容.&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Device PM&lt;br /&gt;
dev_pm_ops这个和上面是完全不同的两条调用路线,在suspend_devices_and_enter用到dpm_suspend_start.&lt;/p&gt;

&lt;h1 id=&#34;steps-of-suspend&#34;&gt;Steps of suspend&lt;/h1&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Function steps&lt;br /&gt;
state_store-&amp;gt;pm_suspend-&amp;gt;enter_state-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
valid_state &amp;amp; suspend_prepare&lt;br /&gt;
suspend_devices_and_enter-&amp;gt; {&lt;br /&gt;
    suspend_console &amp;amp; ftrace_stop &amp;amp; dpm_suspend_start&lt;br /&gt;
    suspend_enter-&amp;gt;&lt;br /&gt;
    {&lt;br /&gt;
        disable_nonboot_cpus &amp;amp; arch_suspend_disable_irqs&lt;br /&gt;
    }&lt;br /&gt;
}&lt;br /&gt;
}&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;PM core&lt;br /&gt;
freeze userspace&lt;br /&gt;
console&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Device PM&lt;br /&gt;
suspend device&lt;br /&gt;
before and first part in suspend_enter&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Mass stuffs&lt;br /&gt;
CPU &amp;amp; IRQ disable&lt;br /&gt;
syscore&lt;br /&gt;
Device PM check wakeup pendings&lt;br /&gt;
middle part in suspend_enter&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Platform PM&lt;br /&gt;
last part in suspend_enter&lt;/p&gt;

&lt;h1 id=&#34;steps-of-resume&#34;&gt;Steps of resume&lt;/h1&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;knowledge&#34;&gt;Knowledge&lt;/h1&gt;

&lt;p&gt;console switch、process freeze、CPU hotplug、wakeup&lt;/p&gt;

&lt;h1 id=&#34;introdution&#34;&gt;Introdution&lt;/h1&gt;

&lt;p&gt;电源管理都涉及到那些内容?&lt;br /&gt;
PMU MP and DEV, CPU cores, L2 cache, Coherency Fabric, Devices&lt;br /&gt;
Core Power Modes: run, idle/WFI/WFE/stadnby, deep idle/power down&lt;br /&gt;
* WFI: core power down except snoop and interrupt cache working&lt;br /&gt;
disable clocks of the CPU&lt;br /&gt;
snoop other Cores and io agent.&lt;br /&gt;
only snoop block are temporarily woken up and the block back to WFI mode after complete snoop.&lt;br /&gt;
can recognize interrupt.&lt;br /&gt;
* Power down: core power down, l1 flush, cache not mantained/snoop stoped, but l2 &amp;amp; fabric&lt;br /&gt;
can not recognize interrupt, recovery is fully depended on MP_PMU&lt;/p&gt;

&lt;p&gt;In hardware layer, we need &lt;a href=&#34;https://en.wikipedia.org/wiki/Power_Management_Unit&#34;&gt;PMU&lt;/a&gt; to complete power management.&lt;br /&gt;
What is the relation of PMU and CPU?&lt;br /&gt;
armadaxp的PMU与CPU物理上与逻辑上是独立的.&lt;br /&gt;
The Power Management functions are provided by two power manager units:&lt;br /&gt;
The Device Power Management Unit (DEV_PMU)&lt;br /&gt;
The Multiprocessor Power Management Service Unit (MP_PMU).&lt;br /&gt;
PMU省电模式:&lt;/p&gt;

&lt;h1 id=&#34;kernel-cpuidle-subsystem&#34;&gt;kernel cpuidle subsystem&lt;/h1&gt;

&lt;h2 id=&#34;steps-of-cpuilde&#34;&gt;Steps of cpuilde&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;interface&lt;br /&gt;
kernel sched and sysfs&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cpuidle core&lt;br /&gt;
cpuidle.c、driver.c、governor.c、sysfs.c。&lt;br /&gt;
抽象出cpuidle device、cpuidle driver、cpuidle governor三个实体&lt;br /&gt;
一个core对应一个cpuidle device drivers/cpuidle/cpuidle.c.&lt;br /&gt;
device 和driver隔离, 通过全局变量联系 ifndef CONFIG_CPU_IDLE_MULTIPLE_DRIVERS&lt;br /&gt;
管理cpuidle driver 和governor&lt;br /&gt;
上层sched模块 和sysfs 提供接口&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cpuidle governors&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cpuidle drivers&lt;br /&gt;
drivers/cpudile/cpuidle-xxx.c or&lt;br /&gt;
arch/arm/plat-armada/cpuidle.c&lt;br /&gt;
如何进入idle状态&lt;br /&gt;
什么条件下会退出&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;source-code-layout&#34;&gt;Source code layout&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;drivers/cpuidle&lt;br /&gt;
include/linux/cpuidle.h&lt;br /&gt;
cpuidle core、cpuidle governors和cpuidle drivers三个模块&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;kernel\sched\idle.c&lt;br /&gt;
kernel sched中的cpuidle entry&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;important-data-structre&#34;&gt;Important data structre&lt;/h2&gt;

&lt;p&gt;struct cpuidle_driver&lt;br /&gt;
struct cpuidle_state&lt;br /&gt;
struct cpuidle_device used by ladder or menu&lt;/p&gt;

&lt;p&gt;device_initcall -&amp;gt; armadaxp_init_cpuidle -&amp;gt; cpuidle_register_driver  cpuidle_register_device&lt;br /&gt;
cpu_idle -&amp;gt; cpuidle_idle_call&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Synchronization</title>
      <link>http://firoyang.org/cs/synchronization/</link>
      <pubDate>Fri, 27 Feb 2015 15:46:12 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/synchronization/</guid>
      <description>

&lt;p&gt;#Reference&lt;br /&gt;
Perfbook&lt;/p&gt;

&lt;h1 id=&#34;why-we-need-synchronization&#34;&gt;Why we need synchronization&lt;/h1&gt;

&lt;p&gt;a critical section is a piece of code that accesses a shared resource&lt;br /&gt;
(data structure or device) that must not be concurrently accessed by more than one thread of execution.&lt;/p&gt;

&lt;p&gt;This overlap, where the result depends on the relative timing of multiple tasks, is called a race condition.&lt;/p&gt;

&lt;h1 id=&#34;how-to-use-synchronization-mechanism&#34;&gt;How to use synchronization mechanism&lt;/h1&gt;

&lt;p&gt;A must read book&lt;a href=&#34;https://www.kernel.org/pub/linux/kernel/people/rusty/kernel-locking/index.html&#34;&gt;Unreliable Guide To Locking &amp;ndash; Rusty Russell&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;common-usage&#34;&gt;Common usage&lt;/h2&gt;

&lt;p&gt;Protect from interruption by hardware interrupts:&lt;br /&gt;
        local_irq_disable(int irq) &amp;amp; local_irq_enable(int irq)&lt;br /&gt;
Protection from software interrupts:&lt;br /&gt;
        local_bh_disable(void) &amp;amp; local_bh_enable(void)&lt;br /&gt;
Protection from other CPUs:&lt;br /&gt;
        spin_lock(spinlock_t *) &amp;amp; spin_unlock(spinlock_t *)&lt;br /&gt;
Preemption by other user contexts:&lt;br /&gt;
        preempt_disable(void) &amp;amp; preempt_enable(void)&lt;/p&gt;

&lt;h1 id=&#34;what-is-synchronization-in-computer-science&#34;&gt;What is synchronization in computer science&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.etymonline.com/index.php?term=synchronize&#34;&gt;Synchronize&lt;/a&gt;&lt;br /&gt;
synchronization means be of the same time.&lt;br /&gt;
It means &amp;ldquo;make it synchronous&amp;rdquo;, something like coexistence.&lt;/p&gt;

&lt;p&gt;Process synchronization refers to the idea that multiple processes are&lt;br /&gt;
to join up or handshake at a certain point, in order to reach an&lt;br /&gt;
agreement or commit to a certain sequence of action.&lt;br /&gt;
* Mutual exclusion &amp;ndash; only one excution routine in  critical section&lt;br /&gt;
Readers–writers problem&lt;br /&gt;
The Producer-Consumer Problem&lt;br /&gt;
* Cooperative&lt;br /&gt;
TCP Handshake&lt;br /&gt;
* Deadlock&lt;br /&gt;
Dining philosophers problem&lt;br /&gt;
* Starvation&lt;br /&gt;
* Prioirty inversion&lt;br /&gt;
* Busy waiting&lt;/p&gt;

&lt;h1 id=&#34;mutual-exclusion&#34;&gt;Mutual exclusion&lt;/h1&gt;

&lt;h2 id=&#34;spinlock-unsleepable-mutex&#34;&gt;spinlock - unsleepable mutex&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.ibm.com/developerworks/cn/linux/l-cn-spinlock/&#34;&gt;Linux 内核的排队自旋锁FIFO Ticket Spinlock&lt;/a&gt;&lt;br /&gt;
spinlock保护的critical section执行时间短且不睡眠, 副产品就是避免了&lt;br /&gt;
context switch, 相对semaphore效率高.&lt;br /&gt;
显然对于little critical section 使用semaphore而不是spinlock,将带来性能&lt;br /&gt;
上的巨大损耗.&lt;br /&gt;
* rw_lock&lt;/p&gt;

&lt;h2 id=&#34;mutex&#34;&gt;Mutex&lt;/h2&gt;

&lt;p&gt;Monitor lock before sleep.&lt;/p&gt;

&lt;h2 id=&#34;rcu-lockless&#34;&gt;RCU &amp;ndash; lockless&lt;/h2&gt;

&lt;p&gt;Check The Journey to RCU for more details&lt;/p&gt;

&lt;h2 id=&#34;per-cpu&#34;&gt;Per-cpu&lt;/h2&gt;

&lt;h1 id=&#34;cooperative&#34;&gt;Cooperative&lt;/h1&gt;

&lt;h2 id=&#34;semaphore&#34;&gt;semaphore&lt;/h2&gt;

&lt;p&gt;it was implement based on spinlock.&lt;br /&gt;
it can have more than one holder at any time (the number decided at initialization time),&lt;br /&gt;
although it is most commonly used as a single-holder lock (a mutex).&lt;br /&gt;
if you can not get a semaphore, your task will put itself on the wait queue, and be woken&lt;br /&gt;
up the semaphore is released.&lt;br /&gt;
sleepable&lt;br /&gt;
preemptable&lt;/p&gt;

&lt;h2 id=&#34;tcp-handshake&#34;&gt;TCP handshake&lt;/h2&gt;

&lt;h1 id=&#34;memory-barrier&#34;&gt;Memory barrier&lt;/h1&gt;

&lt;h2 id=&#34;refernce&#34;&gt;Refernce&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Memory_barrier&#34;&gt;http://en.wikipedia.org/wiki/Memory_barrier&lt;/a&gt;&lt;br /&gt;
Documentation/memory-barriers.txt&lt;/p&gt;

&lt;h2 id=&#34;common&#34;&gt;Common&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;When a program runs on a single-CPU machine, the hardware performs the necessary bookkeeping&lt;br /&gt;
to ensure that the program executes as if all memory operations were performed in the order&lt;br /&gt;
specified by the programmer (program order), so memory barriers are not necessary.&lt;br /&gt;
However, when the memory is shared with multiple devices, such as other CPUs in a multiprocessor&lt;br /&gt;
system, or memory mapped peripherals, out-of-order access may affect program behavior.&lt;br /&gt;
For example, a second CPU may see memory changes made by the first CPU in a sequence which differs from program order.&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Compiler and cpu do the same optimization: reorder of instructions&lt;/p&gt;

&lt;h2 id=&#34;the-linux-kernel-has-a-variety-of-different-barriers-that-act-at-different&#34;&gt;The Linux kernel has a variety of different barriers that act at different&lt;/h2&gt;

&lt;p&gt;levels:&lt;br /&gt;
(&lt;em&gt;) Compiler barrier.&lt;br /&gt;
(&lt;/em&gt;) CPU memory barriers.&lt;br /&gt;
(*) MMIO write barrier.&lt;/p&gt;

&lt;h2 id=&#34;access-once&#34;&gt;ACCESS_ONCE&lt;/h2&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Does it work cast a variable to volatile?&lt;br /&gt;
No, there is no efects on cast a variable to volatile.&lt;br /&gt;
Because, access variable is before volatile cast! That means you&lt;br /&gt;
still get a register value. What you do is just conversion a temporary&lt;br /&gt;
variable&lt;br /&gt;
Rationale for International Standard&amp;ndash;Programming Languages&amp;ndash;C&lt;br /&gt;
6.7.3&lt;/p&gt;

&lt;h2 id=&#34;for-volatile&#34;&gt;For volatile&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.geeksforgeeks.org/understanding-volatile-qualifier-in-c/&#34;&gt;http://www.geeksforgeeks.org/understanding-volatile-qualifier-in-c/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Linux memory management</title>
      <link>http://firoyang.org/cs/mm/</link>
      <pubDate>Sun, 28 Dec 2014 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/mm/</guid>
      <description>

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;Computer memory#Management_of_memory&lt;br /&gt;
Memory management (operating systems)&lt;/p&gt;

&lt;h1 id=&#34;contents&#34;&gt;Contents&lt;/h1&gt;

&lt;p&gt;Logic gates: SRAM, DRAM&lt;br /&gt;
What is data/contrl/addr bus?&lt;br /&gt;
What problems we will meet in memory management?&lt;br /&gt;
Memory allocation and release. Bootmem and Buddy system is pretty good. Can we eliminate Bootmem?&lt;br /&gt;
How to distribute these memory to processes? Virtual memory.&lt;br /&gt;
How to translate linear address to physical address? Page table.&lt;br /&gt;
Exchange data between primary memory and second memory. Paging.&lt;/p&gt;

&lt;p&gt;What are the pitfall of manuplate directly physcial memory&lt;/p&gt;

&lt;h1 id=&#34;page&#34;&gt;page&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/619514/&#34;&gt;An introduction to compound pages&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;memroy-mangement&#34;&gt;Memroy mangement&lt;/h1&gt;

&lt;h2 id=&#34;gfp-flags&#34;&gt;GFP flags&lt;/h2&gt;

&lt;p&gt;__GFP_IO: allow disk IO&lt;br /&gt;
__GFP_FS: allow fs operations, depend on io.&lt;br /&gt;
more details in lwn, lkd&lt;/p&gt;

&lt;h1 id=&#34;virtual-memory&#34;&gt;Virtual memory&lt;/h1&gt;

&lt;p&gt;##Page table&lt;br /&gt;
mk_pte(page, pgprot)    pfn_pte(page_to_pfn(page), (pgprot))&lt;br /&gt;
原来低12位里面存了flag啊!&lt;br /&gt;
__pte(((phys_addr_t)page_nr &amp;lt;&amp;lt; PAGE_SHIFT) | massage_pgprot(pgprot));&lt;br /&gt;
For vmalloc(), chechk here vmap_page_range_noflush()&lt;br /&gt;
For kmap(), check kmap_init()&lt;br /&gt;
&lt;a href=&#34;http://edsionte.com/techblog/archives/1966&#34;&gt;How to emulate the process of translate va to pa?&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;copy-to-user&#34;&gt;copy_to_user&lt;/h2&gt;

&lt;p&gt;not in kernel?&lt;br /&gt;
read only?&lt;/p&gt;

&lt;h2 id=&#34;flush-tlb-after-page-table-modification&#34;&gt;flush tlb after page table modification.&lt;/h2&gt;

&lt;h2 id=&#34;direct-mapping-area&#34;&gt;Direct mapping area&lt;/h2&gt;

&lt;p&gt;high_memory (-128UL &amp;lt;&amp;lt; 20)&lt;br /&gt;
__get_free_pages()&lt;br /&gt;
kmalloc()&lt;br /&gt;
kmem_cache_alloc()/slab&lt;/p&gt;

&lt;h2 id=&#34;vmalloc&#34;&gt;Vmalloc&lt;/h2&gt;

&lt;p&gt;may sleep.&lt;/p&gt;

&lt;h3 id=&#34;hwo-vmalloc-works&#34;&gt;Hwo Vmalloc works?&lt;/h3&gt;

&lt;p&gt;Work in HIGHMEM and NORMALMEM&lt;br /&gt;
The skeleton is rbtree, root is global variable vmap_area_root.rb_node.&lt;br /&gt;
struct vm_struct likes struct address_space, functionlly;&lt;br /&gt;
struct vmap_area likes struct vm_area_struct.&lt;br /&gt;
map_vm_area 页表映射&lt;br /&gt;
the page in ZONE_NORMAL will not use directly mapping pfn address! It use VMALLOC address!&lt;/p&gt;

&lt;h3 id=&#34;vmalloc-coherence-with-vfree-after-vmalloc-sync-one&#34;&gt;Vmalloc coherence with vfree() after vmalloc_sync_one&lt;/h3&gt;

&lt;p&gt;在进程的内核页目录中补上的是只是页目录项，而页表对所有进程来说是共用的，不管vfree()多大的内存块，在vmalloc()时新分配的页表不会被释放，当重新vmalloc()时，仍旧使用原来的页表。 page_fault使得进程的内核页目录项与swapper_pg_dir保持同步，swapper_pg_dir的内核页目录项一旦建立就不再被改变，需要改变的只是共享的页表而已。&lt;br /&gt;
deatils in vmalloc_sync_one() and vunmap_pte_range()&lt;br /&gt;
只释放pte&lt;/p&gt;

&lt;h2 id=&#34;persistent-kernel-mappings&#34;&gt;Persistent Kernel Mappings&lt;/h2&gt;

&lt;p&gt;kmap(struct page *)&lt;br /&gt;
How kmap works?&lt;br /&gt;
    Check kmap_init(), later!&lt;/p&gt;

&lt;h2 id=&#34;temporay-mappings-fixmaps&#34;&gt;Temporay Mappings(Fixmaps)&lt;/h2&gt;

&lt;p&gt;kmap_atomic()&lt;/p&gt;

&lt;p&gt;##Process virtual memory&lt;br /&gt;
* struct vm_area_struct: The intervals of legal address are called &lt;em&gt;memory areas&lt;/em&gt; is permitted to access.&lt;br /&gt;
* struct address_space: To establish an association between the regions of the vm and the places where the related data are located.&lt;br /&gt;
i_mmap: how many processes opened this file.&lt;br /&gt;
&lt;a href=&#34;https://lkml.org/lkml/2012/8/7/46&#34;&gt;https://lkml.org/lkml/2012/8/7/46&lt;/a&gt;&lt;br /&gt;
* sturct mm_struct: how many files(vm_area_struct) does this process opened.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Memory mappings&lt;br /&gt;
syscall remap_file_pages Nolinear mappings is deprecated, since Linux 3.16&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;link&lt;br /&gt;
a virtual address and physical address. &amp;ndash;page tale&lt;br /&gt;
a memory region of a process and its virtual page addresses. &amp;ndash;vm_area_struct&lt;br /&gt;
a region of file(one physical) and all virtual address spaces(many virtual) into which the region is mapped. address_space-&amp;gt;i_mmap.&lt;br /&gt;
a physical page and the processes that share the page(used in swap case)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;#Page faults&lt;br /&gt;
Page fault: If a process accesses a part of virtual address space not yet associated with a page in memory&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Segemnt fault&lt;br /&gt;
Segment fault: address is not in VMA, namely invalid address! Check bad_area() in x86.&lt;br /&gt;
&lt;a href=&#34;https://www.kernel.org/doc/Documentation/x86/exception-tables.txt&#34;&gt;https://www.kernel.org/doc/Documentation/x86/exception-tables.txt&lt;/a&gt;&lt;br /&gt;
Null pointer: probably, mostly catched in below 0x08048000.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Demanding page&lt;br /&gt;
vmalloc_fault(), 进程从用户态进入内核态不会引起CR3的改变.页表同步!&lt;br /&gt;
expand_stack()/handle_mm_fault()&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;vmalloc fault&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;mm-fault-handler&#34;&gt;mm fault handler&lt;/h2&gt;

&lt;p&gt;arch/powerpc/mm/fault.c&lt;br /&gt;
deatils of trap is in bad_page_fault&lt;/p&gt;

&lt;p&gt;sigbus&lt;br /&gt;
__handle_mm_fault&lt;br /&gt;
{&lt;br /&gt;
        hugetlb_fault CONFIG_HUGETLB_PAGE&lt;br /&gt;
        handle_pte_fault-&amp;gt;&lt;br /&gt;
        {&lt;br /&gt;
                do_linear_fault -&amp;gt; __do_fault&lt;br /&gt;
                {&lt;br /&gt;
                        vma-&amp;gt;vm_ops-&amp;gt;fault(vma, &amp;amp;vmf);&lt;br /&gt;
                }&lt;br /&gt;
                do_anonymous_page&lt;br /&gt;
                {&lt;br /&gt;
                        check_stack_guard_page&lt;br /&gt;
                }&lt;br /&gt;
                do_nonlinear_fault&lt;br /&gt;
                do_swap_page&lt;br /&gt;
                do_wp_page&lt;br /&gt;
                {&lt;br /&gt;
                        vma-&amp;gt;vm_ops-&amp;gt;page_mkwrite(vma, &amp;amp;vmf); //??&lt;br /&gt;
                }&lt;br /&gt;
}&lt;/p&gt;

&lt;p&gt;#Physical memory&lt;br /&gt;
* NUMA/UMA pg_data_t: My PC is UMA, numatop, numastat, numactl&lt;br /&gt;
* ZONE(DMA/NORMAL/HIGHMEM) struct zone:&lt;br /&gt;
* struct page is the basic unit of kernel mm knowns as page frame.&lt;br /&gt;
    The goal of strcut page is to describe physical memory, not the data contained therein.&lt;br /&gt;
* The buddy system is per-zone struct free_area&lt;br /&gt;
* Physical address is connected to Virtual address by pfn = page - mem_map;&lt;/p&gt;

&lt;h2 id=&#34;page-allocator&#34;&gt;page allocator&lt;/h2&gt;

&lt;p&gt;alloc_pages()&lt;br /&gt;
##Page/buffer cache&lt;br /&gt;
struct address_space-&amp;gt;page_tree&lt;br /&gt;
##Page writeback&lt;br /&gt;
data synchronization, the flush threads, pdflush&lt;br /&gt;
##Page swap&lt;br /&gt;
The available RAM memory in a computer is never enough to meet user needs or to always satisfy memory-intensive applications.&lt;/p&gt;

&lt;p&gt;#FAQ&lt;br /&gt;
* Where is Per-CPU variable?&lt;br /&gt;
static Per-CPU in .data(?) below high_memory!&lt;br /&gt;
runtime Per-CPU, it&amp;rsquo;s GFP_KERNEL in pcpu_create_chunk()&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Memory mode&lt;br /&gt;
flat mem -&amp;gt; uma&lt;br /&gt;
discontig -&amp;gt; NUMA&lt;br /&gt;
sparse -&amp;gt; Hotplug + NUMA&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;When does kernel alloc these struct pages in x86_64?&lt;br /&gt;
&lt;a href=&#34;http://lwn.net/Articles/229670/&#34;&gt;http://lwn.net/Articles/229670/&lt;/a&gt;&lt;br /&gt;
vmemmap silimar to memmap&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;When kmap_atomic() BUG_ON effect?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;How cpu resolve address below high_memory?&lt;br /&gt;
Cpu-spicific!&lt;br /&gt;
x86 used page table to all address!&lt;br /&gt;
Mips cpu can be aware of this address!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;How to deal with useless page? : &amp;gt; /home/firo/bigdata&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;pfmemalloc &amp;ndash; skb 表示申请了紧急内存!&lt;br /&gt;
page free&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;compound pages&lt;br /&gt;
18fa11efc279c20af5eefff2bbe814ca067&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
