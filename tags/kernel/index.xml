<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Kernel on f(x) </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://firoyang.org/tags/kernel/</link>
    <language>en-us</language>
    <author>Firo Yang</author>
    
    <updated>Wed, 26 Apr 2017 21:39:41 CST</updated>
    
    <item>
      <title>The definitive guide to Linux x86 entry.S</title>
      <link>http://firoyang.org/cs/entry/</link>
      <pubDate>Wed, 26 Apr 2017 21:39:41 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/entry/</guid>
      <description>

&lt;p&gt;Documentation/x86/entry_64.txt&lt;br /&gt;
&lt;a href=&#34;http://www.lenky.info/archives/2013/03/2245&#34;&gt;对Linux x86-64架构上硬中断的重新认识&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/&#34;&gt;The Definitive Guide to Linux System Calls&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.groad.net/bbs/thread-3276-1-1.html&#34;&gt;选择内存屏障指令|alternative&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;fs and gs register&lt;br /&gt;
For using in TLS, please check &lt;a href=&#34;http://wiki.osdev.org/Thread_Local_Storage#ABI&#34;&gt;OSDEV TLS&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;#ifdef CONFIG_X86_64&lt;br /&gt;
#define __percpu_seg            gs&lt;br /&gt;
#define __percpu_mov_op         movq&lt;br /&gt;
#else&lt;br /&gt;
#define __percpu_seg            fs&lt;br /&gt;
#define __percpu_mov_op         movl&lt;br /&gt;
#endif&lt;/p&gt;

&lt;p&gt;Steps to handle intterrupt&lt;/p&gt;

&lt;p&gt;For logical address to linear address, see intel SDM v3a 3.4 LOGICAL AND LINEAR ADDRESSES.&lt;br /&gt;
For stack switching during escalate the CPL, see SDM v3a 5.8.5 stack switching. The processor will automatically chose the espCPL stack to use during changing in privilege level.&lt;br /&gt;
For more details on stack switching, please check the Figure 5-13. Stack Switching During an Interprivilege-Level Call&lt;br /&gt;
For fast system call, check 3a 5.8.7 Performing Fast Calls to System Procedures&lt;br /&gt;
For TSS and TR, check 3a 7.2&lt;br /&gt;
For Linux hanld irq processes, check ULK 3rd Chapter 4: Hardware Handling of Interrupts and Exceptions&lt;/p&gt;

&lt;h1 id=&#34;for-syscall&#34;&gt;For syscall&lt;/h1&gt;

&lt;p&gt;Common path for syscalls&lt;br /&gt;
glibc -&amp;gt; AT_SYSINFO-&amp;gt; __kernel_vsyscall -&amp;gt; sysenter/syscall/in0x80&lt;br /&gt;
just for vDSO syscalls&lt;br /&gt;
glibc -&amp;gt; AT_SYSINFO_EHDR-&amp;gt; vDSO elf&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Page fault</title>
      <link>http://firoyang.org/cs/page_fault/</link>
      <pubDate>Thu, 06 Apr 2017 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/page_fault/</guid>
      <description>

&lt;p&gt;#Page faults&lt;br /&gt;
Page fault: If a process accesses a part of virtual address space not yet associated with a page in memory&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Segemnt fault&lt;br /&gt;
Segment fault: address is not in VMA, namely invalid address! Check bad_area() in x86.&lt;br /&gt;
&lt;a href=&#34;https://www.kernel.org/doc/Documentation/x86/exception-tables.txt&#34;&gt;https://www.kernel.org/doc/Documentation/x86/exception-tables.txt&lt;/a&gt;&lt;br /&gt;
Null pointer: probably, mostly catched in below 0x08048000.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Demanding page&lt;br /&gt;
vmalloc_fault(), 进程从用户态进入内核态不会引起CR3的改变.页表同步!&lt;br /&gt;
expand_stack()/handle_mm_fault()&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;vmalloc fault&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;mm-fault-handler&#34;&gt;mm fault handler&lt;/h2&gt;

&lt;p&gt;arch/powerpc/mm/fault.c&lt;br /&gt;
deatils of trap is in bad_page_fault&lt;/p&gt;

&lt;p&gt;sigbus&lt;br /&gt;
__handle_mm_fault&lt;br /&gt;
{&lt;br /&gt;
        hugetlb_fault CONFIG_HUGETLB_PAGE&lt;br /&gt;
        handle_pte_fault-&amp;gt;&lt;br /&gt;
        {&lt;br /&gt;
                do_linear_fault -&amp;gt; __do_fault&lt;br /&gt;
                {&lt;br /&gt;
                        vma-&amp;gt;vm_ops-&amp;gt;fault(vma, &amp;amp;vmf);&lt;br /&gt;
                }&lt;br /&gt;
                do_anonymous_page&lt;br /&gt;
                {&lt;br /&gt;
                        check_stack_guard_page&lt;br /&gt;
                }&lt;br /&gt;
                do_nonlinear_fault&lt;br /&gt;
                do_swap_page&lt;br /&gt;
                do_wp_page&lt;br /&gt;
                {&lt;br /&gt;
                        vma-&amp;gt;vm_ops-&amp;gt;page_mkwrite(vma, &amp;amp;vmf); //??&lt;br /&gt;
                }&lt;br /&gt;
}&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kernel debugging primer</title>
      <link>http://firoyang.org/cs/kernel_dbg/</link>
      <pubDate>Wed, 05 Apr 2017 14:45:21 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/kernel_dbg/</guid>
      <description>

&lt;h1 id=&#34;debug-boot-problem&#34;&gt;Debug boot problem&lt;/h1&gt;

&lt;p&gt;debug ignore_loglevel earlyprintk=ttyS0,115200,keep keep_bootcon initcall_debug dyndbg=+plmf&lt;/p&gt;

&lt;h1 id=&#34;dynamic-debug&#34;&gt;Dynamic debug&lt;/h1&gt;

&lt;p&gt;Precondition: CONFIG_DYNAMIC_DEBUG&lt;br /&gt;
How to use it during kernel booting?&lt;br /&gt;
Use boot option:&lt;br /&gt;
dyndbg=&amp;ldquo;file drivers/usb/host/ehci-hcd.c +p; file&lt;br /&gt;
drivers/usb/host/ehci-ppc-of.c +p&amp;rdquo; loglevel=8&lt;br /&gt;
loglevel=8 dyndbg=&amp;ldquo;module ehci_pci +p;&lt;br /&gt;
module ehci_hcd +p; module usbcore +p&amp;rdquo;&lt;br /&gt;
After booting:&lt;br /&gt;
/sys/kernel/debug/dynamic_debug/control&lt;/p&gt;

&lt;h1 id=&#34;dev-print-functions&#34;&gt;Dev print functions&lt;/h1&gt;

&lt;p&gt;drivers/base/core.c&lt;br /&gt;
define_dev_printk_level&lt;br /&gt;
THese functions are like pr_func&lt;/p&gt;

&lt;h1 id=&#34;oops&#34;&gt;oops&lt;/h1&gt;

&lt;p&gt;Kernel oops relates to invalid memory access, including sigev and sigbus.&lt;br /&gt;
&lt;a href=&#34;https://www.kernel.org/doc/Documentation/oops-tracing.txt&#34;&gt;kernel oops tracing&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://vegardno.blogspot.com/2016/08/sync-debug.html?m=1&#34;&gt;Debugging a kernel crash found by syzkaller&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;lockup&#34;&gt;lockup&lt;/h1&gt;

&lt;p&gt;phenomenon: LOCKUP_DETECTOR&lt;br /&gt;
&lt;a href=&#34;https://www.kernel.org/doc/Documentation/lockup-watchdogs.txt&#34;&gt;kernle doc - Softlockup detector and hardlockup detector&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.av8n.com/computer/htm/kernel-lockup.htm&#34;&gt;Debugging Linux Kernel Lockup / Panic / Oops&lt;/a&gt;&lt;br /&gt;
Causes: deadlock, hardware, irqoff and loop&lt;/p&gt;

&lt;h1 id=&#34;hung-task&#34;&gt;hung task&lt;/h1&gt;

&lt;p&gt;phenomenon: DETECT_HUNG_TASK&lt;br /&gt;
Includes the interruptable task.&lt;br /&gt;
Causes: deadlock, race condition&lt;/p&gt;

&lt;h1 id=&#34;kprobes&#34;&gt;kprobes&lt;/h1&gt;

&lt;h1 id=&#34;deadlock&#34;&gt;deadlock&lt;/h1&gt;

&lt;p&gt;Lockdep&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/185666/&#34;&gt;The kernel lock validator&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt&#34;&gt;Runtime locking correctness validator&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lkml.org/lkml/2013/2/4/4&#34;&gt;https://lkml.org/lkml/2013/2/4/4&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://bbs.chinaunix.net/thread-4183696-1-1.html&#34;&gt;http://bbs.chinaunix.net/thread-4183696-1-1.html&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;kasan&#34;&gt;kasan&lt;/h1&gt;

&lt;p&gt;setup_arch-&amp;gt;kasan_init&lt;br /&gt;
&lt;a href=&#34;http://events.linuxfoundation.org/sites/events/files/slides/LinuxCon%20North%20America%202015%20KernelAddressSanitizer.pdf&#34;&gt;KernelAddressSanitizer a fast memory error detector for the Linux kernel&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/zfsonlinux/zfs/pull/4708/commits/01709937be3c28a89eff83e0e657a72826947506&#34;&gt;kasan found stack out of bounds&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/612153/&#34;&gt;lwn The kernel address sanitizer&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lkml.org/lkml/2014/12/3/128&#34;&gt;out of bounds&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;config-debug-pagealloc&#34;&gt;CONFIG_DEBUG_PAGEALLOC&lt;/h1&gt;

&lt;p&gt;check_poison_mem in alloc_pages&lt;br /&gt;
free_pages_prepare posion&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux time subsystem</title>
      <link>http://firoyang.org/cs/time/</link>
      <pubDate>Tue, 22 Sep 2015 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/time/</guid>
      <description>

&lt;p&gt;我写作的主要目的是理清基本概念与原理, 而非实现,细节这一类.&lt;/p&gt;

&lt;p&gt;时间是人类发明出来的概念, Kant也认为时间是心智概念.&lt;br /&gt;
一百年前的世界和现在有什么不同呢?这个提问揭示生活中时间最重要的用途,&lt;br /&gt;
*标记*某中状态下的世界. 所谓的过去世界不过是世界的一个个连续状态&lt;br /&gt;
那么时空穿越, 就变成了保住项少龙这个肉身不变, 世界的其他部分完全&lt;br /&gt;
转变到过去的某一个状态. 而所谓现在世界就被抹杀了.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The future is already here – it&#39;s just not evenly distributed.
                        — William Gibson
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;人想回到&amp;rdquo;过去&amp;rdquo;多半源于情感因素, 而想去&amp;rdquo;未来&amp;rdquo;则是因为&amp;rdquo;物质&amp;rdquo;的缘故.&lt;br /&gt;
想象下中国的未来50年, 很可能是现在美国or西欧现在的样子.虽然中西虽然处在&lt;br /&gt;
时间概念上相同的现在, 而物质世界确实&amp;rdquo;过去&amp;rdquo;和&amp;rdquo;未来&amp;rdquo;之差.&lt;/p&gt;

&lt;p&gt;比如我们下周而要开会, 那么此时下周二就是有意识的规划未来, 时间依然是标记.&lt;br /&gt;
UTC/GMT&lt;br /&gt;
Based on caesium microwave atomic clock&lt;br /&gt;
Leap second&lt;/p&gt;

&lt;h2 id=&#34;genus-differentia-definition&#34;&gt;Genus-differentia definition&lt;/h2&gt;

&lt;p&gt;interrupt, clock event,  clock source, tick, timer, timekeeping, gettimeofday.&lt;/p&gt;

&lt;h2 id=&#34;unites&#34;&gt;unites&lt;/h2&gt;

&lt;p&gt;cputime = jiffies under HZ (FIXME)&lt;br /&gt;
sum_exec_runtime nanoseconds&lt;br /&gt;
clockt = jiffies but under USER_HZ&lt;/p&gt;

&lt;h2 id=&#34;功用定义&#34;&gt;功用定义&lt;/h2&gt;

&lt;p&gt;获取时间&lt;br /&gt;
timer&lt;br /&gt;
sleep ?&lt;br /&gt;
update sched info&lt;/p&gt;

&lt;h2 id=&#34;发生定义-设计-etymology-history-operational-definition&#34;&gt;发生定义/设计   etymology, history Operational definition&lt;/h2&gt;

&lt;p&gt;timekeeping/计时:时刻．&lt;br /&gt;
clock source: 时间之源, 表针之力.&lt;br /&gt;
clock event: 闹铃之力, 经过tick展现能力.&lt;br /&gt;
tick: timer的中断事件叫tick, tick device产生tick, 可以说tick决定了clock_event event_handler进而决定了, clock_event行为.&lt;br /&gt;
tickless:&lt;br /&gt;
for timer: use HW timer one shot, set next.&lt;br /&gt;
for update time: in above HW timer, not good&lt;br /&gt;
for sched: for priority distributed in time slice, use timer.&lt;br /&gt;
dynamic tick/no HZ:&lt;br /&gt;
No HZ in idle&lt;br /&gt;
No HZ while only 1 process running for HPC.&lt;br /&gt;
tick devies 就是clock event包了层虎皮.&lt;br /&gt;
tick broadcast framework:  based on tick device&lt;br /&gt;
clock: 可记录时间, 表盘.利用timekeeping&lt;br /&gt;
timer: use clock. what about timer_list?&lt;br /&gt;
timer_list: do in softirq&lt;br /&gt;
* timekeeping aspect&lt;br /&gt;
onset: start_kernel -&amp;gt; timekeeping_init &amp;amp; time_init &amp;amp;(rest_init-&amp;gt; kernel_init-&amp;gt; &lt;br /&gt;
kernel_init_freeable-&amp;gt;do_basic_setup-&amp;gt;do_initcalls&amp;ndash;device_initcall(init_clocksource_sysfs))&lt;br /&gt;
nucleus:used by clock see init_posix_timers and update_wall_time and sys_time&lt;br /&gt;
coda:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;clock source aspect&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;tick device layer aspect&lt;br /&gt;
per_cpu(tick_cpu_device, cpu)&lt;br /&gt;
onset: time_init-&amp;gt;mach-&amp;gt;init_time-&amp;gt;&amp;hellip;clockevents_register_device-&amp;gt;tick_check_new_device&lt;br /&gt;
nucleus: a38x_timer_interrupt-&amp;gt;a38x_clkevt.event_handler&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;tick broadcast framework&lt;br /&gt;
onset:&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;clock aspect&lt;br /&gt;
k_clock&lt;br /&gt;
onset:init_posix_timers &amp;amp; init_posix_cpu_timers&lt;br /&gt;
nucleus: 用户-&amp;gt; posix_clock-&amp;gt;timepkeeping-&amp;gt;clock_socurce&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;timer aspect&lt;br /&gt;
onset: open_softirq(HRTIMER_SOFTIRQ, run_hrtimer_softirq);&lt;br /&gt;
nucleus: common_timer_set&lt;br /&gt;
hrtimer_interrupt | (tick_handle_periodic-&amp;gt; tick_periodic-&amp;gt; update_process_times-&amp;gt;run_local_timers-&amp;gt;hrtimer_run_queues)-&amp;gt;__run_hrtimer-&amp;gt;timer.function = posix_timer_fn;(set in common_timer_set)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;计算机概念&lt;br /&gt;
system clock CLOCK_REALTIME CLOCK_MONOTONIC&lt;br /&gt;
time.h time_t=tm=timeval=timespec calendar time  clock_t&lt;/p&gt;

&lt;p&gt;clock event -&amp;gt; tick device-&amp;gt; handle function&lt;br /&gt;
clock event 相较于timer更为抽象, timer 是一种用途,timer 通过clock event来实现功能,&lt;br /&gt;
clock event 通过timer来体现自己, timer面向使用者的onset,&lt;br /&gt;
而clock event 则是偏向于nucleus and coda.&lt;br /&gt;
timer: 标记不能立即执行的变化.&lt;br /&gt;
clock source: 用一些整型抽象一个过程, 对于时间来说, 简直是完美的抽象.&lt;br /&gt;
* kernel requirement&lt;br /&gt;
linux的时间子系统要求硬件timer提供下面两种能力：&lt;br /&gt;
一是free running的counter，此外需要能够在指定的counter值上产生中断的能力。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The Journey to RCU</title>
      <link>http://firoyang.org/cs/rcu/</link>
      <pubDate>Sun, 24 May 2015 09:52:12 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/rcu/</guid>
      <description>

&lt;h1 id=&#34;rcu-stalls&#34;&gt;RCU stalls&lt;/h1&gt;

&lt;p&gt;update_process_times-&amp;gt;rcu_check_callbacks-&amp;gt;rcu_pending-&amp;gt;__rcu_pending-&amp;gt;check_cpu_stall-&amp;gt;print_other_cpu_stall&lt;/p&gt;

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;iframe frameborder=&#34;no&#34; border=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; width=330 height=86 src=&#34;http://music.163.com/outchain/player?type=2&amp;id=444737&amp;auto=1&amp;height=66&#34;&gt;&lt;/iframe&gt;&lt;br /&gt;
&lt;a href=&#34;http://lse.sourceforge.net/locking/rcupdate.html&#34;&gt;官网Read-Copy Update Mutual Exclusion&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://lse.sourceforge.net/locking/rcu/HOWTO/index.html&#34;&gt;Read Copy Update HOWTO&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://lse.sourceforge.net/locking/rcu/rcupdate_doc.html&#34;&gt;Read-Copy Update Mutual-Exclusion in Linux&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://pages.cs.wisc.edu/~thanhdo/qual-notes/sync/sync2-rcu.txt&#34;&gt;Thanh Do&amp;rsquo;s notes Read-copy update. In Ottawa Linux Symposium, July 2001&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;why-do-need-rcu&#34;&gt;Why do need RCU&lt;/h1&gt;

&lt;p&gt;For &lt;a href=&#34;http://en.wikipedia.org/wiki/Scalability&#34;&gt;scalable&lt;/a&gt; mutual exclusion.&lt;br /&gt;
scale有两个词源涵义Proto-Germanic原始日耳曼, 酒杯, 盘子, 称重的盘子, 后来演化成标量的意思.&lt;br /&gt;
scalar在数学上是标量, 在c语言指int float, Scalar processor标量计算机也是来源于此.&lt;br /&gt;
另一个出处是Latin拉丁文scandere, 有攀爬之意, 进而衍生出扩展之意.&lt;br /&gt;
From wikipedia,  A system whose performance improves after adding hardware,&lt;br /&gt;
proportionally to the capacity added, is said to be a scalable system.&lt;br /&gt;
&lt;a href=&#34;https://www.ibm.com/developerworks/cn/linux/l-rcu/&#34;&gt;因为rwlock, brlock在多核性能下降.需要个高性能的锁&lt;/a&gt;&lt;br /&gt;
言下之意, 就是其他的mutual exclusion 机制不能很好的扩展, 需要RCU.&lt;br /&gt;
Read Copy Update HOWTO介绍了当初RCU开发的动机:&lt;br /&gt;
* Increase in cost of conventional locks&lt;br /&gt;
第一个原因也是最重要的, 最根本原因.&lt;br /&gt;
传统的锁the contended lock如spinlock实现上不断访问内存轮询锁当前状态, cpu和内存速度的*越来越*巨大差异;&lt;br /&gt;
一种新的锁机制减少访问内存,就成了强烈的需求.&lt;br /&gt;
* Cache benefits of lock-free reads&lt;br /&gt;
传统锁/tried-and-true 如spinlock一类的实现在多核下, 在出现锁竞争时会导致&lt;a href=&#34;http://www.quora.com/What-is-cache-line-bouncing-How-spinlock-may-trigger-this-frequently&#34;&gt;cache line bouncing&lt;/a&gt;.&lt;br /&gt;
3个cpu, A占有spinlock, 另外两个轮询尝试获取在test and set版本的&lt;br /&gt;
spinlock, 如果Bcpu 修改lock那么C cpu的d cache line 就会强制无效,&lt;br /&gt;
之后c 也修改lock, B的d cache line就无效了.之后B又来了, 就这样.&lt;br /&gt;
在不同cpu之间同步数据, 会耗费很多cpu 指令周期.&lt;br /&gt;
像&lt;a href=&#34;https://www.ibm.com/developerworks/cn/linux/l-cn-spinlock/&#34;&gt;x86的spinlock的实现用lock指令前缀锁住总线&lt;/a&gt;,&lt;br /&gt;
其他cpu or dma就不能访问内存, 降低系统的性能, ibm这篇文章说P6之后的处理器减少这种危害.&lt;br /&gt;
* Avoiding complicated races&lt;br /&gt;
No deadlock, 减少了开发维护.&lt;/p&gt;

&lt;h1 id=&#34;how-to-use-rcu&#34;&gt;How to use RCU&lt;/h1&gt;

&lt;p&gt;list rcu&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/263130/&#34;&gt;What is RCU? Part 2: Usage&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www2.rdrop.com/users/paulmck/techreports/RCUUsage.2013.02.24a.pdf&#34;&gt;RCU Usage In the Linux Kernel: One Decade Later&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;what-is-rcu&#34;&gt;What is RCU&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.rdrop.com/~paulmck/RCU/whatisRCU.html&#34;&gt;What is RCU, Really?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/262464/&#34;&gt;What is RCU, Fundamentally?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://lwn.net/Articles/264090/&#34;&gt;RCU part 3: the RCU API&lt;/a&gt;&lt;br /&gt;
RCU supports concurrency between a single updater and multiple readers!&lt;/p&gt;

&lt;h2 id=&#34;design-pattern&#34;&gt;Design pattern&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Publish-Subscribe&lt;br /&gt;
For updater before synchnization_rcu(); similar to softirq rcu&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Observer&lt;br /&gt;
For updater to wait For Pre-Existing RCU Readers to Complete&lt;br /&gt;
Maintain Multiple Versions of Recently Updated Objects&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;positivism-implementions&#34;&gt;Positivism Implementions&lt;/h1&gt;

&lt;h2 id=&#34;classic-rcu&#34;&gt;Classic RCU&lt;/h2&gt;

&lt;p&gt;Classic RCU requires that read-side critical sections obey the same rules&lt;br /&gt;
obeyed by the critical sections of pure spinlocks:&lt;br /&gt;
blocking or sleeping of any sort is strictly prohibited.&lt;/p&gt;

&lt;h2 id=&#34;preemtible-rcu&#34;&gt;Preemtible RCU&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://lwn.net/Articles/253651/&#34;&gt;The design of preemptible read-copy-update&lt;/a&gt;&lt;br /&gt;
stage 的切换是由rcu_read_unlock 推动的!&lt;/p&gt;

&lt;h2 id=&#34;tree-rcu&#34;&gt;Tree RCU&lt;/h2&gt;

&lt;p&gt;For hundreds and thounds CPU cores&lt;/p&gt;

&lt;p&gt;#FAQ&lt;br /&gt;
* Difference with primitive and atomic&lt;br /&gt;
* Grace period is synchroinze_rcu or a softirq justment&lt;br /&gt;
* __rcu sparse will warn you if you access that pointer without the services of one of the variants of rcu_dereference().&lt;/p&gt;

&lt;h1 id=&#34;below-is-how-to-use-rcu&#34;&gt;Below is how to use RCU!&lt;/h1&gt;

&lt;h1 id=&#34;reference-1&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www2.rdrop.com/users/paulmck/techreports/RCUUsage.2013.02.24a.pdf&#34;&gt;RCU Usage In the Linux Kernel: One Decade Later&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;本文内容并非我原创, 实际上是翻译加上个人理解Paul E. McKenney的paper.Credit to Paul and others.&lt;br /&gt;
本文不关心RCU的实现.&lt;br /&gt;
本文的核心目标就是了解如何使用RCU.&lt;br /&gt;
所有使用RCU代码, 都可以分为4部分:&lt;br /&gt;
RCU read critical section: 就是rcu_read_lock()和rcu_read_unlock()之间的代码.&lt;br /&gt;
update: 这部分代码在synchronize_rcu/call_rcu之前执行. 比如给pointer = new_data;&lt;br /&gt;
synchronize: 这部分代码是等待调用synchronize/call_rcu时的所有Rcu read critical section 执行完.&lt;br /&gt;
free: 这部分是在上面synchronize/call_rcu确认所有对就数据引用的RCU read critical section都执行完了, 安全释放内存.&lt;br /&gt;
Paul的paper总结了5种用法, 并且附上了代码, 便于理解.&lt;br /&gt;
理解的过程实质上是用RCU的外衣再次理解这个5种方法!&lt;/p&gt;

&lt;h1 id=&#34;wait-for-completion&#34;&gt;Wait for Completion&lt;/h1&gt;

&lt;p&gt;内核中有&lt;a href=&#34;https://lwn.net/Articles/23993/&#34;&gt;完成量completion&lt;/a&gt;的基础设施&lt;br /&gt;
上面的RCU read critical section和synchronize可以构成completion的语义.&lt;br /&gt;
为什么要用RCU而不是内核自身提供的completion函数呢?&lt;br /&gt;
Paul的文中举的例子实在NMI中要作这样的事情, 显然基于waitqueue的completion是毫无用处的.&lt;br /&gt;
所以这里的RCU, 应该叫做Completion RCU-version.&lt;/p&gt;

&lt;h1 id=&#34;reference-counting&#34;&gt;Reference Counting&lt;/h1&gt;

&lt;p&gt;传统的引用计数就是往结构体里面内嵌一个atomic,加加减减.&lt;br /&gt;
但RCU实现的引用计数把实际工作转移到softirq-rcu部分去了.&lt;br /&gt;
Paul给了一个例子, 我认为是及其不合适的.因为他忽略了softirq部分随着smp的核数增多&lt;br /&gt;
同样也会带来性能的损耗,而不是almost zero in his paper.&lt;br /&gt;
引用计数和完成量的区别, 除了语义上的差异, 看起来没有太大的区分.FIXME.&lt;/p&gt;

&lt;h1 id=&#34;type-safe-memory&#34;&gt;Type Safe Memory&lt;/h1&gt;

&lt;h1 id=&#34;publish-subscribe&#34;&gt;Publish-Subscribe&lt;/h1&gt;

&lt;h1 id=&#34;read-write-lock-alternative&#34;&gt;Read-Write Lock Alternative&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>Yet another guide on the way to linux kernel hacking</title>
      <link>http://firoyang.org/cs/hacking/</link>
      <pubDate>Sat, 25 Apr 2015 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/hacking/</guid>
      <description>

&lt;h1 id=&#34;build-minimal-bootable-rootfs&#34;&gt;Build minimal bootable rootfs&lt;/h1&gt;

&lt;p&gt;./etc/yum.repos.d/&lt;br /&gt;
./etc/yum.repos.d/fedora-updates-testing.repo&lt;br /&gt;
./etc/yum.repos.d/fedora.repo&lt;br /&gt;
./etc/yum.repos.d/fedora-updates.repo&lt;br /&gt;
./etc/yum.repos.d/fedora-cisco-openh264.repo&lt;br /&gt;
can be gotten by supermin &amp;ndash;prepare bash -o /tmp/supermin.d&lt;br /&gt;
or just copy from you host to some place like /home/firo/kernel/k/testfs/&lt;br /&gt;
sudo dnf &amp;ndash;releasever=27 &amp;ndash;installroot=/home/firo/kernel/k/testfs/ &amp;ndash;setopt=reposdir=/home/firo/kernel/k/testfs/etc/yum.repos.d install dnf udev passwd&lt;/p&gt;

&lt;h1 id=&#34;boot-the-kernel-using-this-directroy-as-rootfs-through-qemu&#34;&gt;Boot the kernel using this directroy as rootfs through qemu&lt;/h1&gt;

&lt;h1 id=&#34;resources&#34;&gt;Resources&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/283982/&#34;&gt;Writing an OS in Rust&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;subscribe-linux-kenrel-maillist&#34;&gt;Subscribe linux kenrel maillist&lt;/h1&gt;

&lt;h1 id=&#34;linux-next-source-code&#34;&gt;linux next source code&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kernel.org/doc/man-pages/linux-next.html&#34;&gt;Working with linux-next&lt;/a&gt;&lt;br /&gt;
要add git://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git不是https.&lt;br /&gt;
我之前改了好多bug基于linus的分支, 提交后被告知别人已改. 后来Julia告诉我要基于linux-next开发.&lt;br /&gt;
我的linux next remote 就叫next, 基于其创建开发分支.&lt;/p&gt;

&lt;h1 id=&#34;source-code-navigation&#34;&gt;Source code navigation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/283982/&#34;&gt;&amp;lsquo;Source code reading&amp;rsquo; related sites&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;applying-patches&#34;&gt;Applying patches&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=6zUVS4kJtrA&#34;&gt;100 Linux Tutorials: How to Apply a Patch to the Linux Kernel Stable Tree&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;setup-kvm-test-machine&#34;&gt;Setup kvm test machine&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://kernelnewbies.org/KernelProjects&#34;&gt;Building a KVM host machine.&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;how-to-build-a-minimal-kernel-for-testing&#34;&gt;How to build a minimal kernel for testing?&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://tiny.wiki.kernel.org/&#34;&gt;tiny config @ kernel.org&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://mgalgs.github.io/2015/05/16/how-to-build-a-custom-linux-kernel-for-qemu-2015-edition.html&#34;&gt;3 attempts to reduce the configurations&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;7&#34;&gt;Fedora equivalent of debootstrap&lt;/a&gt;&lt;br /&gt;
Then enable following config option&lt;br /&gt;
CONFIG_CHR_DEV_SG&lt;br /&gt;
Some ftrace stuff&lt;br /&gt;
CONFIG_SLUB&lt;br /&gt;
CONFIG_KASAN&lt;/p&gt;

&lt;h1 id=&#34;for-nfs&#34;&gt;For nfs&lt;/h1&gt;

&lt;p&gt;dnf install nfs-utils&lt;br /&gt;
cat /etc/exports # For more details, man exports&lt;br /&gt;
/home/firo/kernel/k/testfs 127.0.0.1(rw,sync,fsid=0,no_root_squash)&lt;br /&gt;
systemctl start nfs-server.service&lt;br /&gt;
systemctl status nfs-server.service&lt;br /&gt;
● nfs-server.service - NFS server and services&lt;br /&gt;
   Loaded: loaded (/usr/lib/systemd/system/nfs-server.service; disabled; vendor preset: disabled)&lt;br /&gt;
   Active: active (exited) since Sat 2018-03-17 17:52:29 CST; 4s ago&lt;/p&gt;

&lt;h2 id=&#34;test-the-nfs&#34;&gt;Test the nfs&lt;/h2&gt;

&lt;p&gt;sudo mount -t nfs localhost://home/firo/kernel/k/testfs /mnt&lt;br /&gt;
ls /mnt/&lt;br /&gt;
bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var&lt;br /&gt;
if touch prermission denied&lt;br /&gt;
add no_all_squash to/etc/exports&lt;/p&gt;

&lt;h2 id=&#34;nfs-vers&#34;&gt;NFS vers&lt;/h2&gt;

&lt;p&gt;rpcinfo -t localhost nfs&lt;br /&gt;
program 100003 version 3 ready and waiting&lt;br /&gt;
program 100003 version 4 ready and waiting&lt;/p&gt;

&lt;p&gt;rpcinfo -p | grep nfs&lt;br /&gt;
    100003    3   tcp   2049  nfs&lt;br /&gt;
    100003    4   tcp   2049  nfs&lt;br /&gt;
    100227    3   tcp   2049  nfs_acl&lt;/p&gt;

&lt;h2 id=&#34;nfs-errors&#34;&gt;NFS errors&lt;/h2&gt;

&lt;p&gt;[   54.600121] NFS: sending MNT request for 10.0.2.2:/buildarea1/firo/ima/export/dist&lt;br /&gt;
[   54.600121] NFS: failed to create MNT RPC client, status=-101&lt;br /&gt;
[   54.600121] NFS: unable to mount server 10.0.2.2, error -101&lt;br /&gt;
CONFIG_E100 CONFIG_E1000 &amp;hellip;and IP_PNP and DHCP BOOTP RARP&lt;/p&gt;

&lt;h1 id=&#34;qemu-boot-systemd&#34;&gt;Qemu boot systemd&lt;/h1&gt;

&lt;p&gt;qemu-system-x86_64 -nographic -enable-kvm  -kernel ./bzImag  -append &amp;lsquo; console=ttyS0 ip=dhcp root=/dev/nfs nfsroot=192.168.0.104:/home/firo/kernel/k/testfs,nfsvers=3,tcp rw nfsrootdebug debug  raid=noautodetect selinux=0 enforcing=0 &amp;lsquo;&lt;/p&gt;

&lt;p&gt;nfsvers=3,tcp and 192.168.0.104 or 10.0.2.2 are mandatory!&lt;/p&gt;

&lt;h2 id=&#34;dev-ttys0-device&#34;&gt;dev-ttyS0.device&lt;/h2&gt;

&lt;p&gt;[**    ] A start job is running for dev-ttyS0.device (7s / 1min 30s)&lt;br /&gt;
[ TIME ] Timed out waiting for device dev-ttyS0.device.&lt;br /&gt;
[DEPEND] Dependency failed for Serial Getty on ttyS0.&lt;/p&gt;

&lt;p&gt;CONFIG_FHANDLE=y&lt;br /&gt;
&lt;a href=&#34;https://github.com/systemd/systemd/issues/3446&#34;&gt;https://github.com/systemd/systemd/issues/3446&lt;/a&gt;&lt;br /&gt;
And install systemd-udev&lt;/p&gt;

&lt;h1 id=&#34;input-comand-overwrite-itself&#34;&gt;input comand overwrite itself?&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://shallowsky.com/blog/tags/embedded/&#34;&gt;http://shallowsky.com/blog/tags/embedded/&lt;/a&gt;&lt;br /&gt;
resize&lt;br /&gt;
xterm-resize-330-3.fc27.x86_64&lt;br /&gt;
/etc/profile&lt;br /&gt;
PS1=&amp;rsquo;[[\033[0;32m]\u@\h:[\033[36m]\W[\033[0m]]\$ &amp;lsquo;&lt;/p&gt;

&lt;h1 id=&#34;qemu&#34;&gt;qemu&lt;/h1&gt;

&lt;p&gt;access denied by acl file&lt;br /&gt;
qemu-system-x86_64: -netdev bridge,id=inet: bridge helper failed&lt;br /&gt;
&lt;a href=&#34;https://blog.christophersmart.com/2016/08/31/configuring-qemu-bridge-helper-after-access-denied-by-acl-file-error/&#34;&gt;https://blog.christophersmart.com/2016/08/31/configuring-qemu-bridge-helper-after-access-denied-by-acl-file-error/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;sudo ip link set enp0s31f6 master br0&lt;/p&gt;

&lt;h1 id=&#34;systemd&#34;&gt;systemd&lt;/h1&gt;

&lt;p&gt;autologin&lt;br /&gt;
Change /usr/lib/systemd/system/serial-getty@.service to&lt;/p&gt;

&lt;h1 id=&#34;execstart-sbin-agetty-o-p-u-keep-baud-115200-38400-9600-i-term&#34;&gt;ExecStart=-/sbin/agetty -o &amp;lsquo;-p &amp;ndash; \u&amp;rsquo; &amp;ndash;keep-baud 115200,38400,9600 %I $TERM&lt;/h1&gt;

&lt;p&gt;ExecStart=-/sbin/agetty -a root &amp;ndash;keep-baud 115200,38400,9600 %I $TERM&lt;/p&gt;

&lt;h2 id=&#34;unuseful-unfsd-obselete&#34;&gt;Unuseful unfsd obselete&lt;/h2&gt;

&lt;p&gt;exports0&lt;br /&gt;
 cat var/exports0&lt;br /&gt;
/buildarea1/firo/x564 (rw,no_root_squash,no_all_squash,insecure)&lt;/p&gt;

&lt;p&gt;/buildarea1/firo/x564/host-cross/usr/bin/pseudo /buildarea1/firo/x564/host-cross/usr/sbin/unfsd -p -N -i /buildarea1/firo/x564/var/nfs0.pid -e /buildarea1/firo/x564/var/exports0 -x 11111 -n 3049 -y 21111 -m 3048&lt;br /&gt;
 /buildarea1/firo/x564/host-cross/usr/bin/qemu-system-x86_64 -nographic -k en-us -kernel /buildarea1/firo/x564/bitbake_build/tmp/deploy/images/bzImage-qemux86-64.bin -redir udp:20485::17185 -redir tcp:7747::1534 -redir udp:7747::1534 -redir tcp:7748::80 -redir udp:7745::6443 -redir tcp:7741::23 -redir tcp:7740::22 -redir tcp:8998::5698 -redir tcp:8978::5678 -redir tcp:6633::3333 -net user,hostname=qemu33 -net nic,macaddr=52:54:0:12:34:77,model=i82557b -show-cursor -usb -usbdevice wacom-tablet -vga vmware -gdb tcp::4534 -append console=ttyS0,115200 ip=dhcp root=/dev/nfs nfsroot=10.0.2.2:/buildarea1/firo/x564/export/dist,nfsvers=3,port=6349,mountprog=24411,nfsprog=14411,udp,mountport=6348 rw clocksource=pit oprofile.timer=1 UMA=1 -pidfile /buildarea1/firo/x564/host-cross/var/qemu33.pid&lt;/p&gt;

&lt;h2 id=&#34;for-sda&#34;&gt;For sda&lt;/h2&gt;

&lt;p&gt;./kernel/configs/kvm_guest.config&lt;br /&gt;
VFS: Cannot open root device &amp;ldquo;sda&amp;rdquo; or unknown-block(0,0): error -6&lt;br /&gt;
Please append a correct &amp;ldquo;root=&amp;rdquo; boot option; here are the available partitions:&lt;br /&gt;
Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)&lt;br /&gt;
Kernel Offset: disabled&lt;br /&gt;
CONFIG_BLK_DEV_SD&lt;br /&gt;
CONFIG_SATA_AHCI XX&lt;br /&gt;
CONFIG_ATA XX&lt;br /&gt;
CONFIG_ATA_PIIX ok&lt;br /&gt;
process 1 (init) attempted a POSIX timer syscall while CONFIG_POSIX_TIMERS is not set&lt;/p&gt;

&lt;p&gt;CONFIG_POSIX_TIMERS&lt;br /&gt;
FILE_LOCK if udev&lt;br /&gt;
PACKET if udev&lt;br /&gt;
UNIX if udev&lt;br /&gt;
DEVTMPFS if udev&lt;br /&gt;
CONFIG_INOTIFY_USER if udev&lt;br /&gt;
CONFIG_TMPFS if udev&lt;br /&gt;
CONFIG_DEBUG_INFO_REDUCED if CONFIG_DEBUG_INFO&lt;/p&gt;

&lt;p&gt;CONFIG_NETFILTER&lt;br /&gt;
smp&lt;br /&gt;
ext4&lt;br /&gt;
CONFIG_SERIAL_NONSTANDARD=y&lt;/p&gt;

&lt;p&gt;udev requires hotplug support, not started &amp;hellip; failed!&lt;br /&gt;
not cpu hotplug&lt;br /&gt;
CONFIG_HOTPLUG=y&lt;br /&gt;
CONFIG_UEVENT_HELPER_PATH=‚Äù&amp;rdquo;&lt;br /&gt;
CONFIG_NET=y&lt;br /&gt;
CONFIG_UNIX=y&lt;br /&gt;
CONFIG_SYSFS=y&lt;br /&gt;
CONFIG_SYSFS_DEPRECATED*=n&lt;br /&gt;
CONFIG_PROC_FS=y&lt;br /&gt;
CONFIG_TMPFS=y&lt;br /&gt;
CONFIG_TMPFS_POSIX_ACL=y¬†&lt;br /&gt;
CONFIG_INOTIFY=y&lt;br /&gt;
CONFIG_SIGNALFD=y&lt;/p&gt;

&lt;h1 id=&#34;hacker&#34;&gt;Hacker&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/286244/&#34;&gt;Peter Zijlstra: From DOS to kernel hacking&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;what-to-fix&#34;&gt;What to fix?&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://kernelnewbies.org/KernelProjects&#34;&gt;KernelProjects&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/283982/&#34;&gt;linux-wanking@vger.kernel.org&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.linux.com/publications/how-participate-linux-community&#34;&gt;2.7 GETTING STARTED WITH KERNEL DEVELOPMENT&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://pages.cs.wisc.edu/~remzi/OSTEP/&#34;&gt;Operating Systems: Three Easy Pieces&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.brokenthorn.com/Resources/OSDevIndex.html&#34;&gt;BrokenThorn Entertainment Operating System Development Series&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/660404/&#34;&gt;Speeding up kernel development with QEMU&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.linux.org/threads/linux-kernel-reading-guide.5384/&#34;&gt;Linux Kernel Reading Guide&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://phrack.org/index.html&#34;&gt;Phrack&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://sourceforge.net/p/predef/wiki/Architectures/&#34;&gt;Pre-defined Compiler Macros&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;kernel-hacking&#34;&gt;kernel hacking&lt;/h1&gt;

&lt;p&gt;The cxgb3_*_send() functions return NET&lt;em&gt;XMIT&lt;/em&gt; values, which are&lt;br /&gt;
positive integers values. So don&amp;rsquo;t treat positive return values&lt;br /&gt;
as an error.&lt;br /&gt;
67f1aee6f45059fd6b0f5b0ecb2c97ad0451f6b3&lt;/p&gt;

&lt;h1 id=&#34;old-questions&#34;&gt;old questions&lt;/h1&gt;

&lt;p&gt;What is platform driver?&lt;br /&gt;
find source code of config&lt;br /&gt;
How to print backtrace by kernel oops, and why it&amp;rsquo;s not exact?&lt;br /&gt;
What is abi&lt;br /&gt;
why get_unaligned_be16?&lt;br /&gt;
 _THIS&lt;em&gt;IP&lt;/em&gt; vs &lt;strong&gt;FUNCTIONS&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&#34;kernel-data-type&#34;&gt;kernel data type&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://yarchive.net/comp/linux/kernel_headers.html&#34;&gt;__u32&lt;/a&gt; and &lt;a href=&#34;http://www.linuxjournal.com/article/5783&#34;&gt;this&lt;/a&gt; and dd3e chapter 10.&lt;/p&gt;

&lt;h1 id=&#34;the-principle-of-kernel-driver-backport&#34;&gt;The principle of kernel &amp;amp; driver backport&lt;/h1&gt;

&lt;p&gt;将高本版kernel的feature移植到低版本的kernel的过程就是backport.&lt;br /&gt;
1. 尽量保持与mainline的代码一致&lt;br /&gt;
2. 做好取舍不要引入太多patch.&lt;/p&gt;

&lt;h2 id=&#34;开发流程&#34;&gt;开发流程&lt;/h2&gt;

&lt;p&gt;理清所引入feature的代码. 主要数据结构以及功能流程.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://wangcong.org/2007/03/09/-e8-b5-b0-e8-bf-91linux-e5-86-85-e6-a0-b8/&#34;&gt;走近Linux内核&amp;ndash; 王聪&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;kernel-hacker之路&#34;&gt;kernel hacker之路&lt;/h1&gt;

&lt;p&gt;我实在太想聊这个话题 &amp;ndash; 内核hacker的成长之路!&lt;br /&gt;
不是教你写第一个kernel module, 就灭火了. 而是持续的一步步成长为&lt;br /&gt;
内核的中坚力量, 甚至是maintainer.&lt;br /&gt;
作为一个内核爱好者, 从接触到现在已经3年半了. 然而, 我对自己是非常失望的.&lt;br /&gt;
因为我看了3年多的书, 从今年(15)5月才开始, 给社区提补丁.&lt;br /&gt;
起始我在12年的11月份曾经给社区, 提过几次补丁. 后来有那么两三次, 想帮着修复&lt;br /&gt;
kernel panic 和oops的问题, 基本上个人感觉难度非常太大就无极而终了.&lt;br /&gt;
5月份这次, 我是因为实在不想在看书籍了, 市面上稍微有点名的书籍, 我都看过.&lt;br /&gt;
实在太厌烦再看书了, 我把自己和另外一个内核hacker 王聪做了对比, 得出结论:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;赶快滚去给社区提patch! 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我挨个看了王聪给社区提的前50个patch. 都是很简单的修改.&lt;br /&gt;
我几次挫败都是, 因为没能找到合适内核事情去做, 最终没有下文了.&lt;br /&gt;
今天, 我在给社区提了20个左右的patch 10几个被接收了. 我现在找到了一条成长路.&lt;/p&gt;

&lt;h2 id=&#34;内核我现在认为可以给新人做得事&#34;&gt;内核我现在认为可以给新人做得事&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/284099/&#34;&gt;https://lwn.net/Articles/284099/&lt;/a&gt;  这个帖子, 提供了新手可以做得事情, 我觉得非常好.&lt;br /&gt;
smatch coccinelle的分析结果.&lt;br /&gt;
源码中标注的FIXME和TODO, 简单的提过去很难被接受, 难的这些开发者自己都没搞定, 新人更难.&lt;br /&gt;
这也不是一条好路.&lt;br /&gt;
内核bugzilla kerneloops上问题, 这个很难.&lt;br /&gt;
找一个和内核相关的工作驱动啊, 网络开发, 虚拟化, 存储都非常赞.&lt;br /&gt;
自己搞个feature, 感觉更难, 这个需要需求驱动.&lt;br /&gt;
没有一条轻松的路让你走, 但你却不应该光着脚走在上面!!!&lt;br /&gt;
内核之外有很多值得珍惜的. 尽力做好, 你能做的, 开始点滴积累.&lt;br /&gt;
终有一天会聚成沧海, 前提是你等得到那天, 不要亏待自己.&lt;br /&gt;
内核之路始终时不那么清晰, 但是反思过后, 你便知道, 该去做什么了.&lt;br /&gt;
这也许是最难受的情况了.&lt;br /&gt;
Linus 之前说过, 搞得内核你得用起来. uml 是个不错的开端.&lt;br /&gt;
用起来才是王道!&lt;/p&gt;

&lt;p&gt;#git&lt;br /&gt;
&lt;a href=&#34;http://git-scm.com/docs/gittutorial&#34;&gt;gittutorial - A tutorial introduction to Git&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;你提patch-社区的困惑是什么&#34;&gt;你提patch, 社区的困惑是什么?&lt;/h1&gt;

&lt;p&gt;每个kernel newbie 都应该完整看完这个mail list&lt;br /&gt;
&lt;a href=&#34;http://thread.gmane.org/gmane.linux.kernel/683798/focus=684297&#34;&gt;http://thread.gmane.org/gmane.linux.kernel/683798/focus=684297&lt;/a&gt;&lt;br /&gt;
你能看到鹰派的Al还有温和派Andrew Morton.&lt;br /&gt;
为什么&lt;a href=&#34;http://kernelnewbies.org/这么重要网站&#34;&gt;http://kernelnewbies.org/这么重要网站&lt;/a&gt;, 不做的好一点, 至少界面友好点.&lt;br /&gt;
应该找个机会, 整一下.&lt;/p&gt;

&lt;h1 id=&#34;fix-kernel-mistakes&#34;&gt;Fix kernel mistakes&lt;/h1&gt;

&lt;p&gt;内核至今如此优秀就是因为, 成千上万前赴后继的开发者笔耕不缀的结果.&lt;br /&gt;
别当豆包不当干粮, 虽然, 你不能设计出很牛的算法, or 什么子系统,&lt;br /&gt;
但是内核还有很多问题有待解决, 正所谓老虎也要打, 苍蝇也要拍; 千里之堤毁于蚁穴.&lt;br /&gt;
我提过好些这种patch Dan Carpenter都告诉我Linus已经改了.&lt;/p&gt;

&lt;h2 id=&#34;kernel-newbie上有个list&#34;&gt;kernel newbie上有个list&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://kernelnewbies.org/KernelJanitors/Todo&#34;&gt;KernelJanitors/Todo&lt;/a&gt;&lt;br /&gt;
* Style fix&lt;br /&gt;
如:&lt;br /&gt;
remove_wait_queue(entry-&amp;gt;wait_address,&amp;amp;entry-&amp;gt;wait);&lt;br /&gt;
remove_wait_queue(entry-&amp;gt;wait_address, &amp;amp;entry-&amp;gt;wait);&lt;/p&gt;

&lt;h2 id=&#34;smatch&#34;&gt;Smatch&lt;/h2&gt;

&lt;p&gt;smatch这个工具是Dan写的主要就是为了找到内核的小问题, 基本用法:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    make CHECK=&amp;quot;~/path/to/smatch/smatch -p=kernel&amp;quot; C=1 \
            bzImage modules | tee warns.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;smatch 会产生好多可疑的问题, 细心寻找吧.&lt;br /&gt;
你找到了, 那么就是修改了.&lt;br /&gt;
记住在smatch之前一点要git pull next master:now一下, 保证checkout到了now的分支.&lt;/p&gt;

&lt;h2 id=&#34;coccinelle&#34;&gt;Coccinelle&lt;/h2&gt;

&lt;p&gt;Coccinelle是 Julia Lawall 写的静态检测工具.very nice.&lt;br /&gt;
自己研究吧&lt;br /&gt;
Documentation/coccinelle.txt&lt;br /&gt;
&lt;a href=&#34;http://pagesperso-systeme.lip6.fr/Julia.Lawall/tutorial.pdf&#34;&gt;http://pagesperso-systeme.lip6.fr/Julia.Lawall/tutorial.pdf&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;生成patch&#34;&gt;生成patch&lt;/h2&gt;

&lt;p&gt;先修改.&lt;br /&gt;
之后git add&lt;br /&gt;
在commit 之前你要 git log &amp;ndash;online path/to/modification/file&lt;br /&gt;
看下提交的titile:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git log  --oneline drivers/base/firmware_class.c
5455c8c firmware: Fix memory leak in error path
e0fd9b1 firmware: use const for remaining firmware names
f9692b2 firmware: fix possible use after free on name on a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主义冒号:后一定要有一个空格!&lt;br /&gt;
你会还是看下Document下的submitting的文档.&lt;br /&gt;
之后commit:&lt;br /&gt;
先是类似上面的一行oneline 简要说明&lt;br /&gt;
空一行.&lt;br /&gt;
之后具体描述下.&lt;br /&gt;
commit后, 生成patch&lt;br /&gt;
如果你只提交了一次:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git format-patch HEAD^..HEAD
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个命令就ok了.&lt;br /&gt;
如果commit多次, 自己斟酌两次diff的commit id了, HEAD^ 和HEAD都是commit id.&lt;br /&gt;
这样就生成了patch, 一般叫做0001-xxx-ooo.patch之类的&lt;br /&gt;
如我这个, 已被接收:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0001-firmware-Fix-memory-leak-in-error-path.patch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;commit id 是5455c8c3284a63e2673d1be7f040fb245cbf9be9&lt;/p&gt;

&lt;h2 id=&#34;测试patch&#34;&gt;测试patch&lt;/h2&gt;

&lt;p&gt;复杂的patch要编译内核, 安装的机器上跑一下.&lt;/p&gt;

&lt;h2 id=&#34;发送patch&#34;&gt;发送patch&lt;/h2&gt;

&lt;p&gt;天朝用户自己打梯子吧proxychains shadowsocks.&lt;br /&gt;
基本步骤是&lt;br /&gt;
先编译一下:&lt;br /&gt;
make path/to/modification/file.o&lt;br /&gt;
之后&lt;br /&gt;
./scripts/checkpatch.pl&lt;br /&gt;
之后 get maintainer&lt;br /&gt;
./scripts/get_maintainer.pl&lt;/p&gt;

&lt;p&gt;发送的时候, 发给维护者 &amp;ndash;cc其他人, 还有cc 一个mailist, 如果没有合适的list的话,&lt;br /&gt;
就cc到linux-kernel@vger.kernel.org, 这是个开放的list, 有合适的list了, 就不要cc它了.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;proxychains git send-email --to ming.lei@canonical.com --cc gregkh@linuxfoundation.org --cc kernel-janitors@vger.kernel.org 0001-firmware-Fix-memory-leak-in-error-path.patch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;免不了你要返工重新修改.这时候, 新生成的patch这样:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git format-patch --subject-prefix=&amp;quot;PATCH v2&amp;quot; HEAD^..HEAD
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改几次就v几.&lt;br /&gt;
和社区交流的时候, 要注意礼貌, 而且要感谢别人对你的patch做出的建议,&lt;br /&gt;
没有人的时间是被猪拱来的.&lt;/p&gt;

&lt;p&gt;这些都是比较简单(代码量上)的patch, 要想提交深度的还需要对某方面的深度.&lt;br /&gt;
基本上这就完了, 你的真正的patch就给社区了.&lt;/p&gt;

&lt;h1 id=&#34;进阶decent&#34;&gt;进阶decent&lt;/h1&gt;

&lt;p&gt;这个是昨天晚上改drivers代码时候, 看到TODO的注释猛然想到的.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grep -nr &#39;FIXME&#39; --include=&amp;quot;*.c&amp;quot;  ./ | tee fixmek.log
grep -nr &#39;TODO&#39; --include=&amp;quot;*.c&amp;quot; ./ | tee todok.log
wc -l fixmek.log 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有6000多个.&lt;/p&gt;

&lt;h1 id=&#34;deeply-involved&#34;&gt;Deeply involved&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://vger.kernel.org/~davem/net_todo.html&#34;&gt;http://vger.kernel.org/~davem/net_todo.html&lt;/a&gt;&lt;br /&gt;
这个列表上的基本都过期了&amp;hellip;.哎&lt;br /&gt;
往深了走不是难事, 主要是意识到内核, 不是什么神秘的东西, 选好一个方向&lt;br /&gt;
简单看看概念见我的&amp;lt;如何学习&amp;gt; 就可以实践.&lt;br /&gt;
必须要意识到, 动手比看再多概念管用, 我就是之前看了太多, 还发展出一个哲学&lt;br /&gt;
体系出来:-) 确实随着现代信息科学给社会带来的巨大变化, 哲学也必须要更新.&lt;br /&gt;
才能更好的服务于人.&lt;br /&gt;
这几天就在, 找内核哪里还不完善, 自己能补上, 今天6号了.&lt;/p&gt;

&lt;h1 id=&#34;patch-formate-advices&#34;&gt;patch formate advices&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Julia Lawall Sorry to be picky,&lt;br /&gt;
but normally people put a space after the colon.  Also,&lt;br /&gt;
the subject line could be shorter: Remove unneeded cast.&lt;br /&gt;
The description part of the subject doesnt have to be unique,&lt;br /&gt;
just the whole thing, asfter the [PATCH] part.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Dan Carpenter&lt;br /&gt;
Otherwise your patch was fine, btw.  Other improvements.&lt;br /&gt;
Don&amp;rsquo;t put &amp;ldquo;Drivers:&amp;rdquo; in the subject.&lt;br /&gt;
On Wed, Apr 22, 2015 at 09:10:50PM +0800, Firo Yang wrote:&lt;br /&gt;
&amp;gt; From: Firo Yang &lt;a href=&#34;mailto:firogm@gmail.com&#34;&gt;firogm@gmail.com&lt;/a&gt;&lt;br /&gt;
Don&amp;rsquo;t include this line.  We can get it from you email address.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Include everyone from the ./scripts/get_maintainer.pl output except&lt;br /&gt;
don&amp;rsquo;t include linux-kernel@vger.kernel.org if there is another mailing&lt;br /&gt;
list there already.&lt;br /&gt;
* To find  patch prefix&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git log --oneline  path/to/file.c
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;更新patch 要加v几&lt;/p&gt;

&lt;p&gt;git format-patch &amp;ndash;subject-prefix=&amp;ldquo;PATCH v2&amp;rdquo; xxx..ooo&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;提交多个patch 要手动生成一个[PATCH 0/N], 这个0就是要写简要描述的.&lt;/p&gt;

&lt;p&gt;proxychains git send-email &amp;ndash;subject &amp;ldquo;[PATCH v2 0/15] Remove unneeded casts of memory-alloc function return values&amp;rdquo; &amp;ndash;thread &amp;ndash;compose &amp;ndash;confirm=compose &amp;ndash;to firogm@gmail.com *.patch&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Dave Miller偏好&lt;br /&gt;
@@ -325,13 +325,15 @@ static inline void empty_child_dec(struct key_vector *n)&lt;br /&gt;
static struct key_vector *leaf_new(t_key key, struct fib_alias *fa)&lt;br /&gt;
{&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;struct tnode *kv = kmem_cache_alloc(trie_leaf_kmem, GFP_KERNEL);&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;struct key_vector *l = kv-&amp;gt;kv;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;struct tnode *kv;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;struct key_vector *l;&lt;br /&gt;
Dave Miller usually prefers it if variables are ordered from longest to shortest.&lt;br /&gt;
So you should probably have l defined first, and then kv.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;faq&#34;&gt;FAQ&lt;/h1&gt;

&lt;p&gt;kernel module name: scripts/Makefile.lib $(subst -,_,$1)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>An introduction to File system in Linux operating system</title>
      <link>http://firoyang.org/cs/fs/</link>
      <pubDate>Fri, 27 Feb 2015 15:46:12 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/fs/</guid>
      <description>

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.fieldses.org/~bfields/kernel/vfs.txt&#34;&gt;VFS notes&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://web.archive.org/web/20110427023154/http:/kerneltrap.org/node/14148&#34;&gt;Linux: Replacing atime With relatime&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://unix.stackexchange.com/questions/93960/why-is-linuxs-filesystem-designed-as-a-single-directory-tree/&#34;&gt;Why is Linux&amp;rsquo;s filesystem designed as a single directory tree?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://stackoverflow.com/questions/5376116/design-a-file-system&#34;&gt;Design a file system&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;everything-is-a-file&#34;&gt;Everything is a file&lt;/h1&gt;

&lt;p&gt;The whole point with &amp;ldquo;everything is a file&amp;rdquo; is not that you have some&lt;br /&gt;
random filename (indeed, sockets and pipes show that &amp;ldquo;file&amp;rdquo; and &amp;ldquo;filename&amp;rdquo;&lt;br /&gt;
have nothing to do with each other), but the fact that you can use common&lt;br /&gt;
tools to operate on different things. - &lt;a href=&#34;http://yarchive.net/comp/linux/everything_is_file.html&#34;&gt;Linus&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;file-and-directory&#34;&gt;File and directory&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://math.stackexchange.com/a/854656/38596&#34;&gt;What is the meaning/purpose of finding the “foundations of mathematics”?&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;file-operations-onset-nucleus-coda&#34;&gt;File operations - onset, nucleus, coda&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://unix.stackexchange.com/questions/265620/on-unix-systems-why-do-we-have-to-explicitly-open-and-close-files-to-be/265621&#34;&gt;On Unix systems, why do we have to explicitly &lt;code&gt;open()&lt;/code&gt; and &lt;code&gt;close()&lt;/code&gt; files to be able to &lt;code&gt;read()&lt;/code&gt; or &lt;code&gt;write()&lt;/code&gt; them?&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;onset-the-preparing-open&#34;&gt;onset - the preparing open()&lt;/h2&gt;

&lt;p&gt;Prepare the object for processing.&lt;br /&gt;
* Name to inode.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;make dentry&lt;br /&gt;
d_alloc() alloc new dentry&lt;br /&gt;
parent_entry-&amp;gt;d_inode-&amp;gt;i_op-&amp;gt;lookup=ext2_lookup()-&amp;gt; ext2_iget() -&amp;gt; use raw_inode make inode-&amp;gt;&lt;br /&gt;
set inode to dentry&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;#Hacks&lt;br /&gt;
I suddenly find that a good way to understand fs in kernel is to manupulate a small and complete fs, like ramfs or tmpfs.&lt;/p&gt;

&lt;p&gt;#VFS&lt;br /&gt;
##Common concepts&lt;br /&gt;
* VFS:Common fs interface plus fs anstraction layer!&lt;/p&gt;

&lt;h2 id=&#34;unix-fs-related-abstractions-file-directory-entries-inodes-and-mount-points&#34;&gt;Unix fs-related abstractions: file, directory entries, inodes, and mount points.&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Filesytem: a hierarchial storage of data adhering to a specific structure.&lt;br /&gt;
In unix, fs are mounted at a specific mount point in global hierarchy known as a namespace.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;file: and ordered string of bytes.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;directory: analogous to a folder and usally contains related files.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;dentry: Each component of a path is called a directory entry.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;inode: Unix separate the concept of a file from any associated infomation(file metadata) inode!&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;supreblock: a data structure containing information about the filesystem as a whole.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;vfs-primary-objects-superblock-inode-dentry-file&#34;&gt;VFS primary objects: superblock, inode, dentry, file.&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;supreblock: a specific mounted filesystem.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;inode: unit for fs. all the information needed by the kernel to manipulate a file or directory.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;dentry: accelerate access fs, dcache! a single component of a path, certainly include &lt;em&gt;regular&lt;/em&gt; file.&lt;br /&gt;
VFS treats directory as non-exist &lt;em&gt;normal&lt;/em&gt; file. directory and dentry is not the same at all, different congitive level!&lt;br /&gt;
In VFS, file, dentry, and inode all represents dir and file and others, in others words struct file can stand for a dir!&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;file: an open normal file as associated with a process.&lt;/p&gt;

&lt;h2 id=&#34;init-rootfs&#34;&gt;Init Rootfs&lt;/h2&gt;

&lt;p&gt;init_mount_tree&lt;br /&gt;
and sys_chroot&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##Step of how to use ext2 fs&lt;br /&gt;
* Register a fs type in kernel.&lt;br /&gt;
struct file_system_type: basic fs driver codes!&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;mkfs.ext2&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;shell mount -&amp;gt; sys_mount -&amp;gt; file_system_type-&amp;gt;mount =&amp;gt; root dentry and dentry-&amp;gt;d_sb!&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;sys_open -&amp;gt;&lt;br /&gt;
path_init()&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;get start point current-&amp;gt;fs{root, pwd}&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;link_path_walk() to the parent dentry of last entry vim in /sbin/vim. deal with diff mounted fs(ext2 and windows ntfs)&lt;br /&gt;
do_last()&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;dentry,look_dcache(), if not in dcache, d_alloc(); d_op = sb-&amp;gt;s_dentry_op&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;file, if not open, file-&amp;gt;f_op = inode-&amp;gt;i_fop&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;sys_write -&amp;gt;&lt;br /&gt;
file-&amp;gt;f_op-&amp;gt;write()&amp;hellip;&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;faq&#34;&gt;FAQ&lt;/h1&gt;

&lt;h2 id=&#34;forbid-ln&#34;&gt;forbid ln&lt;/h2&gt;

&lt;p&gt;hard link to directory, recursive&lt;br /&gt;
hard link to file accross partitions, may led confilict with inode number.&lt;/p&gt;

&lt;h2 id=&#34;stick-bit&#34;&gt;stick bit&lt;/h2&gt;

&lt;p&gt;chmod +t&lt;br /&gt;
1777&lt;br /&gt;
只有owner 和root才能删除这个文件, 用于/tmp&lt;/p&gt;

&lt;h2 id=&#34;time-of-file&#34;&gt;time of file&lt;/h2&gt;

&lt;h3 id=&#34;atime&#34;&gt;atime&lt;/h3&gt;

&lt;p&gt;perhaps the most stupid Unix design idea of all times,&amp;rdquo; adding: &amp;ldquo;[T]hink about this a bit: &amp;lsquo;For every file that is read from the disk, lets do a &amp;hellip; write to the disk! And, for every file that is already cached and which we read from the cache &amp;hellip; do a write to the disk!&amp;rsquo;&amp;rdquo; He further emphasized the performance impact thus:&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux device driver</title>
      <link>http://firoyang.org/cs/dd/</link>
      <pubDate>Fri, 27 Feb 2015 15:46:12 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/dd/</guid>
      <description>

&lt;p&gt;#Bibilography&lt;br /&gt;
Driver porting: Device model overview: &lt;a href=&#34;http://lwn.net/Articles/31185/&#34;&gt;http://lwn.net/Articles/31185/&lt;/a&gt;&lt;br /&gt;
/Documentation/driver-model&lt;br /&gt;
The Linux Kernel Driver Model&lt;/p&gt;

&lt;h1 id=&#34;device-tree&#34;&gt;Device tree&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;What infomation was included in dtb&lt;br /&gt;
HW platform识别，runtime parameter传递以及硬件设备描述&lt;br /&gt;
for platform device init see arch/powerpc/platforms/52xx/media5200.c ppc_init&lt;br /&gt;
mpc52xx_declare_of_platform_devices&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;How does the device tree subsystem read and parse the dts file?&lt;br /&gt;
#devres&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;devm_kfree&lt;br /&gt;
&lt;a href=&#34;http://lists.freedesktop.org/archives/dri-devel/2013-May/038943.html&#34;&gt;devm_kfree does not need for fail case of probe function and for remove function.&lt;/a&gt;&lt;br /&gt;
__device_release_driver&lt;br /&gt;
really_probe&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;a must use devm_kfree Julia Lawall&lt;br /&gt;
The function at91_dt_node_to_map is ultimately called by the function&lt;br /&gt;
&amp;gt; pinctrl_get, which is an exported function.  Since it is possible that this&lt;br /&gt;
&amp;gt; function is not called from within a probe function, for safety, the kfree&lt;br /&gt;
&amp;gt; is converted to a devm_kfree, to both free the data and remove it from the&lt;br /&gt;
&amp;gt; device in a failure situation.&lt;br /&gt;
*for noop devm_kmalloc_release&lt;br /&gt;
devm_kmalloc()-&amp;gt;dr = alloc_dr(devm_kmalloc_release, size, gfp);&lt;br /&gt;
see release_nodes() -&amp;gt;kfree(dr);&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Power management</title>
      <link>http://firoyang.org/cs/pm/</link>
      <pubDate>Fri, 27 Feb 2015 15:46:12 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/pm/</guid>
      <description>

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.wowotech.net/pm_subsystem/generic_pm_architecture.html&#34;&gt;wowotech&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/384146/&#34;&gt;The cpuidle subsystem&lt;/a&gt;cpuidle—Do nothing, efficiently&lt;br /&gt;
&lt;a href=&#34;http://www.marvell.com/embedded-processors/armada-xp/assets/HW_MV78460_OS.PDF&#34;&gt;Hardware Specifications 9.4&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.marvell.com/embedded-processors/armada-xp/assets/ARMADA-XP-Functional-SpecDatasheet.pdf&#34;&gt;Functional Specifications 34&lt;/a&gt;&lt;br /&gt;
Documentation/power&lt;br /&gt;
Controlling Processor C-State Usage in Linux&lt;br /&gt;
&lt;a href=&#34;http://doc.opensuse.org/documentation/html/openSUSE_114/opensuse-tuning/cha.tuning.power.html&#34;&gt;Chapter 11. Power Management&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;C-states: idle core power state&lt;/p&gt;

&lt;h1 id=&#34;the-structure-of-pm-source-codes&#34;&gt;The structure of PM source codes&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Interface&lt;br /&gt;
syscall /sys/power&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;PM core&lt;br /&gt;
kernel/power&lt;br /&gt;
main.c suspend.c suspend_test.c console.c process.c&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Device PM&lt;br /&gt;
driver/base/power &amp;ndash; Power management interface, firo&lt;br /&gt;
power management 是针对device, bus, driver这部分的. 在suspend_devices_and_enter用到dpm_suspend_start.&lt;br /&gt;
driver/各种设备的驱动&lt;br /&gt;
driver/cpuidle &amp;ndash;firo&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Platform PM&lt;br /&gt;
include/linux/suspend.h&amp;mdash;-定义platform dependent PM有关的操作函数集&lt;br /&gt;
就是他platform_suspend_ops&lt;br /&gt;
arch/xxx/mach-xxx/xxx.c or arch/xxx/plat-xxx/xxx.c&amp;mdash;-平台相关的电源管理操作&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;CPU control&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;important-data-structure&#34;&gt;Important data structure&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Platform PM&lt;br /&gt;
platform_suspend_ops, platform plat-* is equivalent to mach-* and microarchitecture.&lt;br /&gt;
plat-* is abustruct from mach-*1 and mach-&lt;em&gt;2 and so on.&lt;br /&gt;
mach-&lt;/em&gt; is more closer to Board!&lt;br /&gt;
所以这个platform_suspend_ops, 是非常重要的, 他包含了所有BSP底层的内容.&lt;br /&gt;
竟然是用suspend_ops这个全局变量, 来承载所有platform相关的内容.&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Device PM&lt;br /&gt;
dev_pm_ops这个和上面是完全不同的两条调用路线,在suspend_devices_and_enter用到dpm_suspend_start.&lt;/p&gt;

&lt;h1 id=&#34;steps-of-suspend&#34;&gt;Steps of suspend&lt;/h1&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Function steps&lt;br /&gt;
state_store-&amp;gt;pm_suspend-&amp;gt;enter_state-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
valid_state &amp;amp; suspend_prepare&lt;br /&gt;
suspend_devices_and_enter-&amp;gt; {&lt;br /&gt;
    suspend_console &amp;amp; ftrace_stop &amp;amp; dpm_suspend_start&lt;br /&gt;
    suspend_enter-&amp;gt;&lt;br /&gt;
    {&lt;br /&gt;
        disable_nonboot_cpus &amp;amp; arch_suspend_disable_irqs&lt;br /&gt;
    }&lt;br /&gt;
}&lt;br /&gt;
}&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;PM core&lt;br /&gt;
freeze userspace&lt;br /&gt;
console&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Device PM&lt;br /&gt;
suspend device&lt;br /&gt;
before and first part in suspend_enter&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Mass stuffs&lt;br /&gt;
CPU &amp;amp; IRQ disable&lt;br /&gt;
syscore&lt;br /&gt;
Device PM check wakeup pendings&lt;br /&gt;
middle part in suspend_enter&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Platform PM&lt;br /&gt;
last part in suspend_enter&lt;/p&gt;

&lt;h1 id=&#34;steps-of-resume&#34;&gt;Steps of resume&lt;/h1&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;knowledge&#34;&gt;Knowledge&lt;/h1&gt;

&lt;p&gt;console switch、process freeze、CPU hotplug、wakeup&lt;/p&gt;

&lt;h1 id=&#34;introdution&#34;&gt;Introdution&lt;/h1&gt;

&lt;p&gt;电源管理都涉及到那些内容?&lt;br /&gt;
PMU MP and DEV, CPU cores, L2 cache, Coherency Fabric, Devices&lt;br /&gt;
Core Power Modes: run, idle/WFI/WFE/stadnby, deep idle/power down&lt;br /&gt;
* WFI: core power down except snoop and interrupt cache working&lt;br /&gt;
disable clocks of the CPU&lt;br /&gt;
snoop other Cores and io agent.&lt;br /&gt;
only snoop block are temporarily woken up and the block back to WFI mode after complete snoop.&lt;br /&gt;
can recognize interrupt.&lt;br /&gt;
* Power down: core power down, l1 flush, cache not mantained/snoop stoped, but l2 &amp;amp; fabric&lt;br /&gt;
can not recognize interrupt, recovery is fully depended on MP_PMU&lt;/p&gt;

&lt;p&gt;In hardware layer, we need &lt;a href=&#34;https://en.wikipedia.org/wiki/Power_Management_Unit&#34;&gt;PMU&lt;/a&gt; to complete power management.&lt;br /&gt;
What is the relation of PMU and CPU?&lt;br /&gt;
armadaxp的PMU与CPU物理上与逻辑上是独立的.&lt;br /&gt;
The Power Management functions are provided by two power manager units:&lt;br /&gt;
The Device Power Management Unit (DEV_PMU)&lt;br /&gt;
The Multiprocessor Power Management Service Unit (MP_PMU).&lt;br /&gt;
PMU省电模式:&lt;/p&gt;

&lt;h1 id=&#34;kernel-cpuidle-subsystem&#34;&gt;kernel cpuidle subsystem&lt;/h1&gt;

&lt;h2 id=&#34;steps-of-cpuilde&#34;&gt;Steps of cpuilde&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;interface&lt;br /&gt;
kernel sched and sysfs&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cpuidle core&lt;br /&gt;
cpuidle.c、driver.c、governor.c、sysfs.c。&lt;br /&gt;
抽象出cpuidle device、cpuidle driver、cpuidle governor三个实体&lt;br /&gt;
一个core对应一个cpuidle device drivers/cpuidle/cpuidle.c.&lt;br /&gt;
device 和driver隔离, 通过全局变量联系 ifndef CONFIG_CPU_IDLE_MULTIPLE_DRIVERS&lt;br /&gt;
管理cpuidle driver 和governor&lt;br /&gt;
上层sched模块 和sysfs 提供接口&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cpuidle governors&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cpuidle drivers&lt;br /&gt;
drivers/cpudile/cpuidle-xxx.c or&lt;br /&gt;
arch/arm/plat-armada/cpuidle.c&lt;br /&gt;
如何进入idle状态&lt;br /&gt;
什么条件下会退出&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;source-code-layout&#34;&gt;Source code layout&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;drivers/cpuidle&lt;br /&gt;
include/linux/cpuidle.h&lt;br /&gt;
cpuidle core、cpuidle governors和cpuidle drivers三个模块&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;kernel\sched\idle.c&lt;br /&gt;
kernel sched中的cpuidle entry&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;important-data-structre&#34;&gt;Important data structre&lt;/h2&gt;

&lt;p&gt;struct cpuidle_driver&lt;br /&gt;
struct cpuidle_state&lt;br /&gt;
struct cpuidle_device used by ladder or menu&lt;/p&gt;

&lt;p&gt;device_initcall -&amp;gt; armadaxp_init_cpuidle -&amp;gt; cpuidle_register_driver  cpuidle_register_device&lt;br /&gt;
cpu_idle -&amp;gt; cpuidle_idle_call&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Synchronization</title>
      <link>http://firoyang.org/cs/synchronization/</link>
      <pubDate>Fri, 27 Feb 2015 15:46:12 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/synchronization/</guid>
      <description>

&lt;h1 id=&#34;hp&#34;&gt;HP&lt;/h1&gt;

&lt;p&gt;A program is synchro-&lt;br /&gt;
nized if all accesses to shared data are ordered by synchronization operations.&lt;br /&gt;
A&lt;br /&gt;
data reference is ordered by a synchronization operation if, in every possible&lt;br /&gt;
execution, a write of a variable by one processor and an access (either a read or a&lt;br /&gt;
write) of that variable by another processor are separated by a pair of synchroni-&lt;br /&gt;
zation operations, one executed after the write by the writing processor and one&lt;br /&gt;
executed before the access by the second processor???. Cases where variables may&lt;br /&gt;
be updated without ordering by synchronization are called data races because the&lt;br /&gt;
execution outcome depends on the relative speed of the processors, and, like&lt;br /&gt;
races in hardware design, the outcome is unpredictable, which leads to another&lt;br /&gt;
name for synchronized programs: data-race-free.&lt;/p&gt;

&lt;p&gt;#Reference&lt;br /&gt;
Perfbook&lt;br /&gt;
&lt;a href=&#34;https://www.kernel.org/pub/linux/kernel/people/rusty/kernel-locking/index.html&#34;&gt;Unreliable Guide To Locking&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://queue.acm.org/detail.cfm?id=2698990&#34;&gt;Scalability Techniques for Practical Synchronization Primitives&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://web.cecs.pdx.edu/~walpole/class/cse513/slides/3.pdf&#34;&gt;test-and-set&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://people.cs.clemson.edu/~mark/synch.html&#34;&gt;Synchronization Instructions&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;why-we-need-synchronization&#34;&gt;Why we need synchronization&lt;/h1&gt;

&lt;p&gt;a critical section is a piece of code that accesses a shared resource&lt;br /&gt;
(data structure or device) that must not be concurrently accessed by more than one thread of execution.&lt;/p&gt;

&lt;p&gt;This overlap, where the result depends on the relative timing of multiple tasks, is called a race condition.&lt;/p&gt;

&lt;h1 id=&#34;how-to-use-synchronization-mechanism&#34;&gt;How to use synchronization mechanism&lt;/h1&gt;

&lt;p&gt;A must read book&lt;a href=&#34;https://www.kernel.org/pub/linux/kernel/people/rusty/kernel-locking/index.html&#34;&gt;Unreliable Guide To Locking &amp;ndash; Rusty Russell&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;common-usage&#34;&gt;Common usage&lt;/h2&gt;

&lt;p&gt;Protect from interruption by hardware interrupts:&lt;br /&gt;
        local_irq_disable(int irq) &amp;amp; local_irq_enable(int irq)&lt;br /&gt;
Protection from software interrupts:&lt;br /&gt;
        local_bh_disable(void) &amp;amp; local_bh_enable(void)&lt;br /&gt;
Protection from other CPUs:&lt;br /&gt;
        spin_lock(spinlock_t *) &amp;amp; spin_unlock(spinlock_t *)&lt;br /&gt;
Preemption by other user contexts:&lt;br /&gt;
        preempt_disable(void) &amp;amp; preempt_enable(void)&lt;/p&gt;

&lt;h1 id=&#34;what-is-synchronization-in-computer-science&#34;&gt;What is synchronization in computer science&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.etymonline.com/index.php?term=synchronize&#34;&gt;Synchronize&lt;/a&gt;&lt;br /&gt;
synchronization means be of the same time.&lt;br /&gt;
It means &amp;ldquo;make it synchronous&amp;rdquo;, something like coexistence.&lt;/p&gt;

&lt;p&gt;Process synchronization refers to the idea that multiple processes are&lt;br /&gt;
to join up or handshake at a certain point, in order to reach an&lt;br /&gt;
agreement or commit to a certain sequence of action.&lt;br /&gt;
* Mutual exclusion &amp;ndash; only one excution routine in  critical section&lt;br /&gt;
Readers–writers problem&lt;br /&gt;
The Producer-Consumer Problem&lt;br /&gt;
* Cooperative&lt;br /&gt;
TCP Handshake&lt;br /&gt;
* Deadlock&lt;br /&gt;
Dining philosophers problem&lt;br /&gt;
* Starvation&lt;br /&gt;
* Prioirty inversion&lt;br /&gt;
* Busy waiting&lt;/p&gt;

&lt;h1 id=&#34;mutual-exclusion&#34;&gt;Mutual exclusion&lt;/h1&gt;

&lt;h2 id=&#34;spinlock-unsleepable-mutex&#34;&gt;spinlock - unsleepable mutex&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.ibm.com/developerworks/cn/linux/l-cn-spinlock/&#34;&gt;Linux 内核的排队自旋锁FIFO Ticket Spinlock&lt;/a&gt;&lt;br /&gt;
spinlock保护的critical section执行时间短且不睡眠, 副产品就是避免了&lt;br /&gt;
context switch, 相对semaphore效率高.&lt;br /&gt;
显然对于little critical section 使用semaphore而不是spinlock,将带来性能&lt;br /&gt;
上的巨大损耗.&lt;br /&gt;
* rw_lock&lt;/p&gt;

&lt;h2 id=&#34;mutex&#34;&gt;Mutex&lt;/h2&gt;

&lt;p&gt;Monitor lock before sleep.&lt;/p&gt;

&lt;h2 id=&#34;rcu-lockless&#34;&gt;RCU &amp;ndash; lockless&lt;/h2&gt;

&lt;p&gt;Check The Journey to RCU for more details&lt;/p&gt;

&lt;h1 id=&#34;cooperative&#34;&gt;Cooperative&lt;/h1&gt;

&lt;h2 id=&#34;semaphore&#34;&gt;semaphore&lt;/h2&gt;

&lt;p&gt;it was implement based on spinlock.&lt;br /&gt;
it can have more than one holder at any time (the number decided at initialization time),&lt;br /&gt;
although it is most commonly used as a single-holder lock (a mutex).&lt;br /&gt;
if you can not get a semaphore, your task will put itself on the wait queue, and be woken&lt;br /&gt;
up the semaphore is released.&lt;br /&gt;
sleepable&lt;br /&gt;
preemptable&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux memory management</title>
      <link>http://firoyang.org/cs/mm/</link>
      <pubDate>Sun, 28 Dec 2014 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/mm/</guid>
      <description>

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://denninginstitute.com/pjd/PUBS/bvm.pdf&#34;&gt;BEFORE MEMORY WAS VIRTUAL&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/253361/&#34;&gt;Memory part 3: Virtual Memory&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;slab&#34;&gt;SLAB&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kernel.org/doc/gorman/html/understand/understand011.html&#34;&gt;The slab allocator has three principle aims:&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lkml.org/lkml/2000/8/7/65&#34;&gt;Re: When to use kmem_cache_alloc&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;contents&#34;&gt;Contents&lt;/h1&gt;

&lt;p&gt;Logic gates: SRAM, DRAM&lt;br /&gt;
What is data/contrl/addr bus?&lt;br /&gt;
What problems we will meet in memory management?&lt;br /&gt;
Memory allocation and release. Bootmem and Buddy system is pretty good. Can we eliminate Bootmem?&lt;br /&gt;
How to distribute these memory to processes? Virtual memory.&lt;br /&gt;
How to translate linear address to physical address? Page table.&lt;br /&gt;
Exchange data between primary memory and second memory. Paging.&lt;/p&gt;

&lt;p&gt;What are the pitfall of manuplate directly physcial memory&lt;/p&gt;

&lt;h1 id=&#34;memory-pagge-cache-and-buffer-cache&#34;&gt;Memory pagge cache and buffer cache.&lt;/h1&gt;

&lt;p&gt;page cache for memory, buffer cache for fs(block size is dependent on filesystem).&lt;br /&gt;
address_pace-&amp;gt;page_tree: why radix tree, read ahead,&lt;br /&gt;
do_page_fault-&amp;gt;read_page&lt;/p&gt;

&lt;p&gt;For buffer cache: buffer cache is only a wrapper of page for fs operations.&lt;br /&gt;
buffer_head is temporary data released in a deeper function than the function allocing the buffer_head.&lt;br /&gt;
__block_write_full_page&lt;br /&gt;
block_read_full_page&lt;/p&gt;

&lt;p&gt;I can not cover every corner of kernel, so If need, I will learn it.&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Kernel/Index/#Memory_management-Writeback&#34;&gt;The coherency problem, fs-writeback&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/326552/&#34;&gt;Flushing out pdflush&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Kernel/Index/#Memory_management-Swapping&#34;&gt;Swapping&lt;/a&gt;&lt;br /&gt;
User space process: anonymous mapping(stack,heap,mmap), IPC-share memory(anonymous?), private mapping&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Kernel/Index/#Memory_management-Shrinkers&#34;&gt;Shrink cache&lt;/a&gt;&lt;br /&gt;
LRU cache&lt;/p&gt;

&lt;h1 id=&#34;page&#34;&gt;page&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/619514/&#34;&gt;An introduction to compound pages&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;memroy-mangement&#34;&gt;Memroy mangement&lt;/h1&gt;

&lt;h2 id=&#34;gfp-flags&#34;&gt;GFP flags&lt;/h2&gt;

&lt;p&gt;__GFP_IO: allow disk IO&lt;br /&gt;
__GFP_FS: allow fs operations, depend on io.&lt;br /&gt;
more details in lwn, lkd&lt;/p&gt;

&lt;h1 id=&#34;virtual-memory&#34;&gt;Virtual memory&lt;/h1&gt;

&lt;p&gt;vm的提出是为了解决。easy to use。&lt;br /&gt;
1. decoupling physical memory 符号集合。programmer 不需要关注底层细节。 任务转给操作系统。&lt;br /&gt;
2. VM相对物理内存增加了表达能力， 有了更多表达符号。着减少了swap or 不必要的页表抖动。&lt;/p&gt;

&lt;h2 id=&#34;vmalloc&#34;&gt;Vmalloc&lt;/h2&gt;

&lt;p&gt;may sleep.&lt;/p&gt;

&lt;h3 id=&#34;hwo-vmalloc-works&#34;&gt;Hwo Vmalloc works?&lt;/h3&gt;

&lt;p&gt;Work in HIGHMEM and NORMALMEM&lt;br /&gt;
The skeleton is rbtree, root is global variable vmap_area_root.rb_node.&lt;br /&gt;
struct vm_struct likes struct address_space, functionlly;&lt;br /&gt;
struct vmap_area likes struct vm_area_struct.&lt;br /&gt;
map_vm_area 页表映射&lt;br /&gt;
the page in ZONE_NORMAL will not use directly mapping pfn address! It use VMALLOC address!&lt;/p&gt;

&lt;p&gt;##Process virtual memory&lt;br /&gt;
* struct vm_area_struct: The intervals of legal address are called &lt;em&gt;memory areas&lt;/em&gt; is permitted to access.&lt;br /&gt;
* struct address_space: To establish an association between the regions of the vm and the places where the related data are located.&lt;br /&gt;
i_mmap: how many processes opened this file.&lt;br /&gt;
&lt;a href=&#34;https://lkml.org/lkml/2012/8/7/46&#34;&gt;https://lkml.org/lkml/2012/8/7/46&lt;/a&gt;&lt;br /&gt;
* sturct mm_struct: how many files(vm_area_struct) does this process opened.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Memory mappings&lt;br /&gt;
syscall remap_file_pages Nolinear mappings is deprecated, since Linux 3.16&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;link&lt;br /&gt;
a virtual address and physical address. &amp;ndash;page tale&lt;br /&gt;
a memory region of a process and its virtual page addresses. &amp;ndash;vm_area_struct&lt;br /&gt;
a region of file(one physical) and all virtual address spaces(many virtual) into which the region is mapped. address_space-&amp;gt;i_mmap.&lt;br /&gt;
a physical page and the processes that share the page(used in swap case)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;#Physical memory&lt;br /&gt;
* NUMA/UMA pg_data_t: My PC is UMA, numatop, numastat, numactl&lt;br /&gt;
* ZONE(DMA/NORMAL/HIGHMEM) struct zone:&lt;br /&gt;
* struct page is the basic unit of kernel mm knowns as page frame.&lt;br /&gt;
    The goal of strcut page is to describe physical memory, not the data contained therein.&lt;br /&gt;
* The buddy system is per-zone struct free_area&lt;br /&gt;
* Physical address is connected to Virtual address by pfn = page - mem_map;&lt;/p&gt;

&lt;h2 id=&#34;page-allocator&#34;&gt;page allocator&lt;/h2&gt;

&lt;p&gt;alloc_pages()&lt;br /&gt;
##Page/buffer cache&lt;br /&gt;
struct address_space-&amp;gt;page_tree&lt;br /&gt;
##Page writeback&lt;br /&gt;
data synchronization, the flush threads, pdflush&lt;br /&gt;
##Page swap&lt;br /&gt;
The available RAM memory in a computer is never enough to meet user needs or to always satisfy memory-intensive applications.&lt;/p&gt;

&lt;p&gt;#FAQ&lt;br /&gt;
* Where is Per-CPU variable?&lt;br /&gt;
static Per-CPU in .data(?) below high_memory!&lt;br /&gt;
runtime Per-CPU, it&amp;rsquo;s GFP_KERNEL in pcpu_create_chunk()&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Memory mode&lt;br /&gt;
flat mem -&amp;gt; uma&lt;br /&gt;
discontig -&amp;gt; NUMA&lt;br /&gt;
sparse -&amp;gt; Hotplug + NUMA&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;When does kernel alloc these struct pages in x86_64?&lt;br /&gt;
&lt;a href=&#34;http://lwn.net/Articles/229670/&#34;&gt;http://lwn.net/Articles/229670/&lt;/a&gt;&lt;br /&gt;
vmemmap silimar to memmap&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;When kmap_atomic() BUG_ON effect?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;How cpu resolve address below high_memory?&lt;br /&gt;
Cpu-spicific!&lt;br /&gt;
x86 used page table to all address!&lt;br /&gt;
Mips cpu can be aware of this address!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;How to deal with useless page? : &amp;gt; /home/firo/bigdata&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;pfmemalloc &amp;ndash; skb 表示申请了紧急内存!&lt;br /&gt;
page free&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;compound pages&lt;br /&gt;
18fa11efc279c20af5eefff2bbe814ca067&lt;/p&gt;

&lt;h1 id=&#34;memory-initialization-onset&#34;&gt;Memory initialization onset:&lt;/h1&gt;

&lt;p&gt;先从bios 拿信息 main -&amp;gt; detect_memory save in boot_params.e820_map&lt;br /&gt;
之后real -&amp;gt; protected -&amp;gt; long mode&lt;br /&gt;
启动 protected? mode. &lt;a href=&#34;http://www.delorie.com/djgpp/doc/ug/basics/protected.html&#34;&gt;What does protected mode mean&lt;/a&gt;&lt;br /&gt;
setup_arch&lt;br /&gt;
setup_memory_map -&amp;gt; default_machine_specific_memory_setup // Save into struct e820map e820; from boot_params.e820_map. That&amp;rsquo;s all.&lt;br /&gt;
max_pfn = e820_end_of_ram_pfn(); // max_pfn  BIOS-e820: mem 0x0000000100000000-0x00000003227fffff usable and last_pfn = 0x322800(12840MB), so last_pfn is invalid address, use it with &amp;lt;.&lt;br /&gt;
mtrr update max_pfn, see &lt;a href=&#34;https://en.wikipedia.org/wiki/Processor_supplementary_capability&#34;&gt;Processor supplementary capability&lt;/a&gt;&lt;br /&gt;
trim_low_memory_range // reserve 64k&lt;br /&gt;
max_low_pfn = e820_end_of_low_ram_pfn(); //4GB以下的end of block&lt;br /&gt;
memblock_x86_fill// copy e820 to memblock, reconstructs direct memory mapping and setups the direct mapping of the physical memory at PAGE_OFFSET&lt;br /&gt;
early_trap_pf_init //  X86_TRAP_PF, page_fault) =&amp;gt; do_page_fault&lt;br /&gt;
init_mem_mapping //set page table and cr3.&lt;br /&gt;
initmem_init ; NUMA init&lt;br /&gt;
x86_init.paging.pagetable_init();= paging_init //x86_64 -&amp;gt;zone_sizes_init-&amp;gt;&amp;hellip;free_area_init_core&lt;br /&gt;
a little history e820_register_active_region replaced by lmb &lt;a href=&#34;https://lkml.org/lkml/2010/7/13/68&#34;&gt;replaced by&lt;/a&gt; memblock&lt;br /&gt;
reserve_initrd ; // RAMDISK&lt;br /&gt;
总结下, 内存初始化需要的基础.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;e820 get memory region.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;set PF trap do_page_fault.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;set page table and cr3.&lt;br /&gt;
这就完了. 之后开始开始加工.&lt;/p&gt;

&lt;h1 id=&#34;setting-up-arch-specific-and-creating-memblock&#34;&gt;Setting up arch specific and creating memblock&lt;/h1&gt;

&lt;h2 id=&#34;arch-specific-x86-64&#34;&gt;Arch specific x86_64&lt;/h2&gt;

&lt;p&gt;setup_arch-&amp;gt;x86_init.paging.pagetable_init = native_pagetable_init = paging_init -&amp;gt;&lt;/p&gt;

&lt;h2 id=&#34;memblock&#34;&gt;Memblock&lt;/h2&gt;

&lt;p&gt;memblock the &lt;a href=&#34;https://0xax.gitbooks.io/linux-insides/content/mm/linux-mm-1.html&#34;&gt;implementations&lt;/a&gt; of memblock is quite simple. static initialization with variable memblock.&lt;br /&gt;
bootmem is discarded by &lt;a href=&#34;https://lkml.org/lkml/2015/12/21/333&#34;&gt;ARM&lt;/a&gt; and x86&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;using-memblock-to-prepare-for-buddy-system&#34;&gt;Using memblock to prepare for buddy system&lt;/h1&gt;

&lt;h2 id=&#34;zones-and-free-area-free-list&#34;&gt;Zones and free_area.free_list&lt;/h2&gt;

&lt;p&gt;paging_init-&amp;gt;zone_sizes_init.&lt;br /&gt;
{&lt;br /&gt;
    free_area_init_node-&amp;gt;&lt;/p&gt;

&lt;h2 id=&#34;prsent-pages&#34;&gt;prsent_pages&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    calculate_node_totalpages
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;mem-map-page-array&#34;&gt;mem_map/page array:&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;    // mem_map for FLAT, but not for us because we use sparsemem
    alloc_node_mem_map
    free_area_init_core
    {
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;managed-pages&#34;&gt;managed_pages&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;        zone-&amp;gt;managed_pages = zone-&amp;gt;present_pages - memmap_pages - DMA?dma_reserve:0
        // init percpu pageset with boot_pageset
        zone_pcp_init 
        // free_area.free_list
        init_currently_empty_zone(zone, zone_start_pfn, size);
        // Set all page to reserved. MIGRATE_MOVABLE?
        // Set node, zone to page-&amp;gt;flags; set_page_links
        memmap_init_zone 

    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;h2 id=&#34;set-fallback-for-every-zone-and-init-pcp&#34;&gt;Set fallback for every zone and init PCP&lt;/h2&gt;

&lt;p&gt;build_all_zonelists // dmesg&lt;/p&gt;

&lt;h3 id=&#34;precondition&#34;&gt;Precondition&lt;/h3&gt;

&lt;h2 id=&#34;sparse&#34;&gt;Sparse&lt;/h2&gt;

&lt;p&gt;paging_init-&amp;gt;sparse_init&lt;/p&gt;

&lt;h1 id=&#34;mirgate-memory-from-memblock-to-buddy-system&#34;&gt;Mirgate memory from memblock to buddy system&lt;/h1&gt;

&lt;h2 id=&#34;preconditions&#34;&gt;Preconditions&lt;/h2&gt;

&lt;p&gt;mem_map/page array&lt;/p&gt;

&lt;h2 id=&#34;memblock-constantly-y-for-x86&#34;&gt;memblock (constantly Y for x86)&lt;/h2&gt;

&lt;p&gt;memblock_free_late-&amp;gt;&lt;strong&gt;memblock_free_late-&amp;gt;&lt;/strong&gt;free_pages_bootmem&lt;/p&gt;

&lt;h2 id=&#34;bootmem-discarded-by-x86&#34;&gt;bootmem (discarded by x86)&lt;/h2&gt;

&lt;p&gt;memblock_free_late-&amp;gt;free_bootmem_late-&amp;gt;&lt;strong&gt;free_pages_bootmem&lt;br /&gt;
free_all_bootmem-&amp;gt;free_all_bootmem_core-&amp;gt;&lt;/strong&gt;free_pages_bootmem&lt;/p&gt;

&lt;h2 id=&#34;nobootmem&#34;&gt;nobootmem&lt;/h2&gt;

&lt;p&gt;free_bootmem_late-&amp;gt;&lt;strong&gt;free_pages_bootmem&lt;br /&gt;
free_all_bootmem-&amp;gt;free_low_memory_core_early-&amp;gt;&lt;/strong&gt;free_memory_core-&amp;gt;&lt;em&gt;__free_pages_memory&lt;/em&gt;-&amp;gt;&lt;strong&gt;free_pages_bootmem-&amp;gt;&lt;/strong&gt;free_pages_boot_core&lt;/p&gt;

&lt;h2 id=&#34;free-bootmem-core-earyly&#34;&gt;free bootmem core/earyly&lt;/h2&gt;

&lt;p&gt;mm_init-&amp;gt;mem_init-&amp;gt;free_all_bootmem&lt;/p&gt;

&lt;h2 id=&#34;free-bootmem-late&#34;&gt;free bootmem late&lt;/h2&gt;

&lt;p&gt;start_kernel-&amp;gt;efi_free_boot_services-&amp;gt;free_bootmem_late-&amp;gt;__free_pages_bootmem&lt;/p&gt;

&lt;h1 id=&#34;zone-watermarks&#34;&gt;Zone watermarks&lt;/h1&gt;

&lt;p&gt;core_initcall(init_per_zone_wmark_min)&lt;/p&gt;

&lt;p&gt;build_all_zonelists: Just init zones, nothing else. But we have vm_total_pages/zone-&amp;gt;managed_pages initialized in free_all_bootmem();.&lt;br /&gt;
page_alloc_init // drain percpu pageset when cpu dead or dead frozen for CPU hotplug&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
