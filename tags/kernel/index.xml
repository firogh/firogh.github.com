<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Kernel on f(x) </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://firoyang.org/tags/kernel/</link>
    <language>en-us</language>
    <author>Firo Yang</author>
    
    <updated>Sat, 08 Jun 2019 00:00:00 UTC</updated>
    
    <item>
      <title>Linux kernel page allocation</title>
      <link>http://firoyang.org/cs/page_alloc/</link>
      <pubDate>Sat, 08 Jun 2019 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/page_alloc/</guid>
      <description>

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;[Driver porting: low-level memory allocation]&lt;a href=&#34;https://lwn.net/Articles/22909/)&#34;&gt;https://lwn.net/Articles/22909/)&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;history&#34;&gt;History&lt;/h1&gt;

&lt;h1 id=&#34;formal-causes&#34;&gt;Formal causes&lt;/h1&gt;

&lt;h2 id=&#34;hot-and-cold-pages&#34;&gt;Hot and cold pages&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/14768/&#34;&gt;Hot and cold pages&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://patchwork.kernel.org/patch/10013971/&#34;&gt;mm, Remove cold parameter from free_hot_cold_page*&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;gfp-flags&#34;&gt;GFP flags&lt;/h1&gt;

&lt;p&gt;__GFP_THISNODE: 9b819d204cf602eab1a53a9ec4b8d2ca51e02a1d - Add __GFP_THISNODE to avoid fallback to other nodes and ignore cpuset/memory policy restrictions&lt;br /&gt;
__GFP_HIGHMEM in __alloc_zeroed_user_highpage??&lt;/p&gt;

&lt;h1 id=&#34;free-page-state&#34;&gt;Free page state&lt;/h1&gt;

&lt;p&gt;page_expected_state and check_new_page&lt;/p&gt;

&lt;h1 id=&#34;do-anonymous-page-zero-page&#34;&gt;Do anonymous page, zero page&lt;/h1&gt;

&lt;p&gt;tglx: commit 382a7dec462a90ad6ae01227f1e8758ae721f6ed&lt;br /&gt;
Author: Christoph Lameter &lt;a href=&#34;mailto:clameter@sgi.com&#34;&gt;clameter@sgi.com&lt;/a&gt;&lt;br /&gt;
Date:   Tue Feb 1 16:34:17 2005 -0800&lt;br /&gt;
    [PATCH] alloc_zeroed_user_highpage() to fix the clear_user_highpage issue&lt;br /&gt;
Lost tracks&lt;br /&gt;
commit 6fbaac38b85e4bd3936b882392e3a9b45e8acb46&lt;br /&gt;
Author: Linus Torvalds &lt;a href=&#34;mailto:torvalds@athlon.transmeta.com&#34;&gt;torvalds@athlon.transmeta.com&lt;/a&gt;&lt;br /&gt;
Date:   Mon Feb 4 19:14:54 2002 -0800&lt;br /&gt;
    v2.4.7 -&amp;gt; v2.4.7.1&lt;/p&gt;

&lt;h1 id=&#34;obselete-feature-fair-zone-allocation&#34;&gt;Obselete feature - Fair-zone allocation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://lore.kernel.org/patchwork/patch/691300/&#34;&gt;mm, page_alloc: Remove fair zone allocation policy&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/576778/&#34;&gt;Configurable fair allocation zone policy&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;watermarks&#34;&gt;Watermarks&lt;/h1&gt;

&lt;p&gt;totalreserve_pages is wmark high; check calculate_totalreserve_pages and Documentation/sysctl/vm.txt&lt;/p&gt;

&lt;p&gt;Check Documentation/sysctl/vm.txt for min_free_kbytes&lt;br /&gt;
min_free_kbytes_sysctl_handler or watermark_scale_factor_sysctl_handler or&lt;br /&gt;
core_initcall(init_per_zone_wmark_min) -&amp;gt;&lt;br /&gt;
        setup_per_zone_wmarks-&amp;gt; __setup_per_zone_wmarks&lt;br /&gt;
{&lt;br /&gt;
        firo@linux-6qg8:~&amp;gt; grep managed /proc/zoneinfo&lt;br /&gt;
                managed  3973&lt;br /&gt;
                managed  464142&lt;br /&gt;
                managed  7726451&lt;br /&gt;
        &amp;gt;&amp;gt;&amp;gt; 3973 + 464142 + 7726451&lt;br /&gt;
        8194566&lt;br /&gt;
        firo@linux-6qg8:~&amp;gt; cat /proc/sys/vm/min_free_kbytes&lt;br /&gt;
        67584&lt;br /&gt;
        &amp;gt;&amp;gt;&amp;gt; 67584 / 4 * 3973 / 8194566&lt;br /&gt;
        8&lt;br /&gt;
        # Unit of watermark is Page.&lt;br /&gt;
        WMARK_MIN = page_no(min_free_kbytes) * (zone.managed_pages / \Sum of zone.managed_pages)&lt;br /&gt;
        WMARK_LOW = 1.25 * min or min + &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1000&lt;/sub&gt; * zone.managed_pages&lt;br /&gt;
        WMARK_HIGH = 1.5 * min or min + &lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1000&lt;/sub&gt; * zone.managed_pages&lt;br /&gt;
}&lt;br /&gt;
if min_free_kbytes &amp;gt; &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;250&lt;/sub&gt;*total mamanged_pages, we use 1.25 min or 1.5 min&lt;/p&gt;

&lt;h1 id=&#34;zone&#34;&gt;Zone&lt;/h1&gt;

&lt;h2 id=&#34;low-memory-reserved&#34;&gt;Low memory reserved&lt;/h2&gt;

&lt;p&gt;Check Documentation/sysctl/vm.txt for lowmem_reserve_ratio&lt;br /&gt;
lowmem_reserve_ratio_sysctl_handler or core_initcall(init_per_zone_wmark_min) -&amp;gt;&lt;br /&gt;
        setup_per_zone_lowmem_reserve&lt;br /&gt;
firo@linux-6qg8:~&amp;gt; cat /proc/zoneinfo | grep protection&lt;br /&gt;
        protection: (0, 1813, 31994, 31994, 31994)&lt;br /&gt;
        protection: (0, 0, 30181, 30181, 30181)&lt;br /&gt;
        protection: (0, 0, 0, 0, 0)&lt;br /&gt;
        protection: (0, 0, 0, 0, 0)&lt;br /&gt;
        protection: (0, 0, 0, 0, 0)&lt;br /&gt;
Check __alloc_pages_nodemask(), lowmem_reserve is used for checking if there is enough pages in current zone to which allcation fallbacks from a prefered zone.&lt;br /&gt;
lowmem_reserv is used for fallback allcations from a perfered zone in the zonelist.&lt;br /&gt;
The index of lowmme_reserv is the prefered zoneref.zone_idx&lt;/p&gt;

&lt;h2 id=&#34;zone-lists&#34;&gt;Zone lists&lt;/h2&gt;

&lt;p&gt;struct zonelist node_zonelists[MAX_ZONELISTS];&lt;br /&gt;
 * [0]  : Zonelist with fallback&lt;br /&gt;
 * [1]  : No fallback (__GFP_THISNODE)&lt;br /&gt;
start_kernel-&amp;gt;&lt;br /&gt;
        build_all_zonelists&lt;br /&gt;
or hotpulg or /proc/sys/vm/numa_zonelist_order: numa_zonelist_order_handler&lt;br /&gt;
  node_zonelists = {{&lt;br /&gt;
      _zonerefs = {{&lt;br /&gt;
          zone = 0xffff88107ffd5d80, # node 0&lt;br /&gt;
          zone_idx = 2&lt;br /&gt;
          zone = 0xffff88107ffd56c0, # node 0&lt;br /&gt;
          zone_idx = 1&lt;br /&gt;
          zone = 0xffff88107ffd5000, # node 0&lt;br /&gt;
          zone_idx = 0&lt;br /&gt;
          zone = 0xffff88207ffd2d80, # Node 1; fallback.&lt;br /&gt;
          zone_idx = 2&lt;br /&gt;
          zone = 0x0,&lt;br /&gt;
          zone_idx = 0&lt;/p&gt;

&lt;h1 id=&#34;oom&#34;&gt;OOM&lt;/h1&gt;

&lt;p&gt;dump_header(), show_mem(), dump_tasks&lt;/p&gt;

&lt;h1 id=&#34;fsm&#34;&gt;FSM&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;                            |===============================================================================|
                            v                                                                               |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Physical memory ===(free)=&amp;gt; buddy pages ==(page allocator)===&amp;gt; slab objects                                     |&lt;br /&gt;
                        |                                                                                       |&lt;br /&gt;
                        |===(page fault)======== PAS =========&amp;gt; Private page ====|      |===(OOM Kill)===&amp;gt;|     |&lt;br /&gt;
                                                |                                |      |                 |     |&lt;br /&gt;
                                                |                                | ===&amp;gt; |===(PFRA) ======&amp;gt;|     |&lt;br /&gt;
                                                |===============&amp;gt; Shared page====|      |                 | ====|&lt;br /&gt;
                                                                                        |===(do_unmap) ==&amp;gt;|&lt;br /&gt;
                                                                                        |                 |&lt;br /&gt;
                                                                                        |===(exit_mmap) =&amp;gt;|&lt;/p&gt;

&lt;h1 id=&#34;material&#34;&gt;Material&lt;/h1&gt;

&lt;h2 id=&#34;refcount&#34;&gt;_refcount&lt;/h2&gt;

&lt;p&gt;after __alloc_pages_nodemask _refcount=0,&lt;br /&gt;
post_alloc_hook: init should be 0.&lt;br /&gt;
but set_page_refcounted -&amp;gt; set_page_count(page, 1);&lt;br /&gt;
and Check put_page&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>memory mapping</title>
      <link>http://firoyang.org/cs/mmap/</link>
      <pubDate>Wed, 22 Aug 2018 21:39:41 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/mmap/</guid>
      <description>

&lt;p&gt;This article is talking about user space Memory mmapping; it&amp;rsquo;s not limitted to mmap(2) system call.&lt;br /&gt;
&lt;a href=&#34;https://www.ibm.com/support/knowledgecenter/en/ssw_aix_72/com.ibm.aix.genprogc/understanding_mem_mapping.htm&#34;&gt;Understanding memory mapping&lt;/a&gt;&lt;br /&gt;
TLPI:chapter 49 and LSP: Chapter 8&lt;/p&gt;

&lt;h1 id=&#34;history&#34;&gt;History&lt;/h1&gt;

&lt;p&gt;BSD 4.2&lt;br /&gt;
1990 SunOS 4.1&lt;br /&gt;
&lt;a href=&#34;http://bitsavers.trailing-edge.com/pdf/sun/sunos/4.1/800-3846-10A_System_Services_Overview_199003.pdf&#34;&gt;A Must-read: The applications programmer gains access to the facilities of the VM system through several sets of system calls.&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;formal-causes&#34;&gt;Formal causes&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://landley.net/writing/memory-faq.txt&#34;&gt;What are memory mappings? - Landley&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A memory mapping is a set of page table entries describing the properties&lt;br /&gt;
of a consecutive virtual address range.  Each memory mapping has a&lt;br /&gt;
start address and length, permissions (such as whether the program can&lt;br /&gt;
read, write, or execute from that memory), and associated resources (such&lt;br /&gt;
as physical pages, swap pages, file contents, and so on).&lt;br /&gt;
Firo:  mmap, page fault, PFRA.&lt;/p&gt;

&lt;h2 id=&#34;vas&#34;&gt;VAS&lt;/h2&gt;

&lt;p&gt;vma, mm_rb, mmap,&lt;br /&gt;
if file, i_mmap&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;file&#34;&gt;File&lt;/h2&gt;

&lt;h3 id=&#34;pas&#34;&gt;PAS&lt;/h3&gt;

&lt;p&gt;Protection, Shared, Private.&lt;br /&gt;
vm_page_prot, vm_flags&lt;br /&gt;
remove_mapping&lt;/p&gt;

&lt;h3 id=&#34;backing-dev&#34;&gt;Backing dev&lt;/h3&gt;

&lt;p&gt;vm_file, vm_pgoff&lt;/p&gt;

&lt;h2 id=&#34;private-anonymouse-mappings&#34;&gt;Private anonymouse mappings&lt;/h2&gt;

&lt;p&gt;Heap - malloc mmap&lt;/p&gt;

&lt;h2 id=&#34;file-private-mappings&#34;&gt;File private mappings&lt;/h2&gt;

&lt;p&gt;Program: execve text,data,bss&lt;br /&gt;
Libraries&lt;br /&gt;
* onset - mmap&lt;br /&gt;
do_mmap -&amp;gt; mmap_region&lt;br /&gt;
ext2: generic_file_mmap -&amp;gt; vma-&amp;gt;vm_ops = generic_file_vm_ops&lt;br /&gt;
ext4: ext4_file_mmap -&amp;gt; vma-&amp;gt;vm_ops = ext4_file_vm_ops&lt;br /&gt;
both: filemap_fault&lt;br /&gt;
* nuclus&lt;br /&gt;
Write - do_cow_page&lt;br /&gt;
Read - do_read_page&lt;br /&gt;
Read &amp;amp; write - do_wp_page&lt;/p&gt;

&lt;h2 id=&#34;shared-anonymouse-mappings&#34;&gt;Shared anonymouse mappings&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lore.kernel.org/patchwork/patch/174306/&#34;&gt;vmscan: limit VM_EXEC protection to file pages&lt;/a&gt;&lt;br /&gt;
If someone may take advange of reclaimation code by mmap(&amp;hellip;, VM_EXEC, SHRED|ANON), OOM may occur since the old code protect it from reclaiming by add it back to the active list. Great patch. However, program running in tmpfs will also penalized.&lt;br /&gt;
page_is_file_cache &amp;lt; !PageAnon&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/452035/&#34;&gt;ashmem&lt;/a&gt;&lt;br /&gt;
* onset - mmap&lt;br /&gt;
do_mmap -&amp;gt; mmap_region -&amp;gt; vma_link -&amp;gt; (__shmem_file_setup) &amp;amp;&amp;amp; __vma_link_file: into i_mmap interval_tree.&lt;br /&gt;
* nuclus - share fault&lt;br /&gt;
Read: do_read_fault&lt;br /&gt;
Write: do_shared_fault -&amp;gt; shmem_getpage_gfp shmem_add_to_page_cache&lt;br /&gt;
WP: do_wp_page -&amp;gt; wp_page_shared or wp_page_reuse&lt;br /&gt;
b)IPC using a shared file mapping&lt;/p&gt;

&lt;h2 id=&#34;file-shared-mappings-a-memory-mapped-i-o&#34;&gt;File shared mappings - a) Memory-mapped I/O&lt;/h2&gt;

&lt;h1 id=&#34;mmap&#34;&gt;mmap&lt;/h1&gt;

&lt;h2 id=&#34;map-sync&#34;&gt;MAP_SYNC&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/731706/&#34;&gt;Two more approaches to persistent-memory writes&lt;/a&gt;&lt;br /&gt;
dax_iomap_pte_fault&lt;/p&gt;

&lt;h1 id=&#34;madvise&#34;&gt;madvise&lt;/h1&gt;

&lt;h2 id=&#34;madv-sequential-and-reclaim&#34;&gt;MADV_SEQUENTIAL and reclaim&lt;/h2&gt;

&lt;p&gt;mm: more likely reclaim MADV_SEQUENTIAL mappings - 4917e5d0499b5ae7b26b56fccaefddf9aec9369c&lt;/p&gt;

&lt;h2 id=&#34;madv-free&#34;&gt;MADV_FREE&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/590991/&#34;&gt;Volatile ranges and MADV_FREE&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://bugs.python.org/issue26601&#34;&gt;Use new madvise()&amp;rsquo;s MADV_FREE on the private heap&lt;/a&gt;&lt;br /&gt;
commit 854e9ed09dedf0c19ac8640e91bcc74bc3f9e5c9&lt;br /&gt;
Author: Minchan Kim &lt;a href=&#34;mailto:minchan@kernel.org&#34;&gt;minchan@kernel.org&lt;/a&gt;&lt;br /&gt;
Date:   Fri Jan 15 16:54:53 2016 -0800&lt;br /&gt;
    mm: support madvise(MADV_FREE)&lt;br /&gt;
commit 10853a039208c4afaa322a7d802456c8dca222f4&lt;br /&gt;
Author: Minchan Kim &lt;a href=&#34;mailto:minchan@kernel.org&#34;&gt;minchan@kernel.org&lt;/a&gt;&lt;br /&gt;
Date:   Fri Jan 15 16:55:11 2016 -0800&lt;br /&gt;
    mm: move lazily freed pages to inactive list&lt;/p&gt;

&lt;p&gt;commit f7ad2a6cb9f7c4040004bedee84a70a9b985583e&lt;br /&gt;
Author: Shaohua Li &lt;a href=&#34;mailto:shli@fb.com&#34;&gt;shli@fb.com&lt;/a&gt;&lt;br /&gt;
Date:   Wed May 3 14:52:29 2017 -0700&lt;br /&gt;
    mm: move MADV_FREE pages into LRU_INACTIVE_FILE list&lt;/p&gt;

&lt;h1 id=&#34;mprotect&#34;&gt;mprotect&lt;/h1&gt;

&lt;h2 id=&#34;prot-none&#34;&gt;PROT_NONE&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.greenend.org.uk/rjk/tech/dataseg.html#summary&#34;&gt;&amp;mdash;p PROT_NOME mapping&lt;/a&gt;&lt;br /&gt;
show_vma_header_prefix&lt;br /&gt;
cat /proc/self/maps&lt;br /&gt;
7ffff7a17000-7ffff7bcc000 r-xp 00000000 08:03 1188168                    /usr/lib64/libc-2.27.so ============&amp;gt; text&lt;br /&gt;
7ffff7bcc000-7ffff7dcc000 &amp;mdash;p 001b5000 08:03 1188168                    /usr/lib64/libc-2.27.so ============&amp;gt; PROT_NONE&lt;br /&gt;
7ffff7dcc000-7ffff7dd0000 r&amp;ndash;p 001b5000 08:03 1188168                    /usr/lib64/libc-2.27.so ============&amp;gt; read only data&lt;br /&gt;
7ffff7dd0000-7ffff7dd2000 rw-p 001b9000 08:03 1188168                    /usr/lib64/libc-2.27.so ============&amp;gt; initialized&lt;br /&gt;
7ffff7dd2000-7ffff7dd6000 rw-p 00000000 00:00 0&lt;br /&gt;
strace -e mmap,mprotect cat /dev/null&lt;br /&gt;
mmap(NULL, 3926752, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7ffff7a17000       ===&amp;gt; text&lt;br /&gt;
mprotect(0x7ffff7bcc000, 2097152, PROT_NONE) = 0                                ======================&amp;gt; PROT_NONE&lt;br /&gt;
mmap(0x7ffff7dcc000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1b5000) = 0x7ffff7dcc000&lt;br /&gt;
mmap(0x7ffff7dd2000, 15072, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7ffff7dd2000&lt;br /&gt;
mprotect(0x7ffff7dcc000, 16384, PROT_READ) = 0                                          ========&amp;gt; read only data&lt;br /&gt;
/* If _PAGE_BIT_PRESENT is clear, we use these: &lt;em&gt;/&lt;br /&gt;
/&lt;/em&gt; - if the user mapped it with PROT_NONE; pte_present gives true */&lt;br /&gt;
&lt;a href=&#34;https://www.kernel.org/doc/gorman/html/understand/understand006.html&#34;&gt;A MUST READ: Mel on PAGE_PROTNONE&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://volatility-labs.blogspot.com/2015/05/using-mprotect-protnone-on-linux.html&#34;&gt;Using mprotect(.., .., PROT_NONE) on Linux&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lkml.org/lkml/1998/9/21/55&#34;&gt;Linus on _PAGE_PROTNONE&lt;/a&gt;&lt;br /&gt;
 define _PAGE_BIT_PROTNONE      _PAGE_BIT_GLOBAL&lt;br /&gt;
tglx: commit 06d9f6ff137579551a2ee18661847915fe2bb812 (tag: 0.97.5)&lt;br /&gt;
Author: Linus Torvalds &lt;a href=&#34;mailto:torvalds@linuxfoundation.org&#34;&gt;torvalds@linuxfoundation.org&lt;/a&gt;&lt;br /&gt;
Date:   Fri Nov 23 15:09:05 2007 -0500&lt;br /&gt;
    [PATCH] Linux-0.97.5 (September 12, 1992)&lt;br /&gt;
There isn&amp;rsquo;t too much useful information.&lt;br /&gt;
&lt;a href=&#34;https://www.spinics.net/lists/newbies/msg08579.html&#34;&gt;https://www.spinics.net/lists/newbies/msg08579.html&lt;/a&gt;&lt;br /&gt;
man mprotect, PROT_NONE&lt;br /&gt;
userspace addr is associated with non-GLOBAL pte, so the 8th G is reused by PROT_NONE.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The definitive guide to Linux x86 entries</title>
      <link>http://firoyang.org/cs/entry/</link>
      <pubDate>Wed, 26 Apr 2017 21:39:41 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/entry/</guid>
      <description>

&lt;h1 id=&#34;all-entries&#34;&gt;All entries&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kernel.org/doc/Documentation/x86/entry_64.txt&#34;&gt;Documentation/x86/entry_64.txt&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;entry-irq&#34;&gt;Entry irq&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.lenky.info/archives/2013/03/2245&#34;&gt;对Linux x86-64架构上硬中断的重新认识&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;steps-to-handle-intterrupt&#34;&gt;Steps to handle intterrupt&lt;/h2&gt;

&lt;p&gt;For logical address to linear address, see intel SDM v3a 3.4 LOGICAL AND LINEAR ADDRESSES.&lt;br /&gt;
For stack switching during escalate the CPL, see SDM v3a 5.8.5 stack switching. The processor will automatically chose the espCPL stack to use during changing in privilege level.&lt;br /&gt;
For more details on stack switching, please check the Figure 5-13. Stack Switching During an Interprivilege-Level Call&lt;br /&gt;
For fast system call, check 3a 5.8.7 Performing Fast Calls to System Procedures&lt;br /&gt;
For TSS and TR, check 3a 7.2&lt;br /&gt;
For Linux hanld irq processes, check ULK 3rd Chapter 4: Hardware Handling of Interrupts and Exceptions&lt;/p&gt;

&lt;h1 id=&#34;entry-exception&#34;&gt;Entry exception&lt;/h1&gt;

&lt;h2 id=&#34;paranoid-entry&#34;&gt;paranoid_entry&lt;/h2&gt;

&lt;p&gt;Check Documentation/x86/entry_64.txt&lt;/p&gt;

&lt;h2 id=&#34;error-entry&#34;&gt;error_entry&lt;/h2&gt;

&lt;p&gt;tglx: commit 0457d99a336be658cea1a5bdb689de5adb3b382d&lt;br /&gt;
Author:     Andi Kleen &lt;a href=&#34;mailto:ak@muc.de&#34;&gt;ak@muc.de&lt;/a&gt;&lt;br /&gt;
AuthorDate: Tue Feb 12 20:17:35 2002 -0800&lt;br /&gt;
Commit:     Linus Torvalds &lt;a href=&#34;mailto:torvalds@home.transmeta.com&#34;&gt;torvalds@home.transmeta.com&lt;/a&gt;&lt;br /&gt;
CommitDate: Tue Feb 12 20:17:35 2002 -0800&lt;br /&gt;
    [PATCH] x86_64 merge: arch + asm&lt;/p&gt;

&lt;h1 id=&#34;entry-system-calls&#34;&gt;Entry system calls&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/&#34;&gt;The Definitive Guide to Linux System Calls&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;sysenter-vs-syscall&#34;&gt;sysenter vs syscall&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://groups.google.com/forum/#!topic/comp.arch/CjDs4MJCBow%5B1-25%5D&#34;&gt;SYSENTER/SYSEXIT vs.SYSCALL/SYSRET&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://arkanis.de/weblog/2017-01-05-measurements-of-system-call-performance-and-overhead&#34;&gt;Measurements of system call performance and overhead&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://reverseengineering.stackexchange.com/a/16511/16996&#34;&gt;AMD vs Intel and syscall vs sysenter&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.codeguru.com/cpp/misc/misc/system/article.php/c8223/System-Call-Optimization-with-the-SYSENTER-Instruction.htm&#34;&gt;System Call Optimization with the SYSENTER Instruction&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://articles.manugarg.com/systemcallinlinux2_6.html&#34;&gt;Sysenter Based System Call Mechanism in Linux 2.6&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;system-call-restart-mechanism-and-orig-eax&#34;&gt;system call restart mechanism and ORIG_EAX&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/17744/&#34;&gt;A new system call restart mechanism&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lkml.org/lkml/2006/8/29/350&#34;&gt;Why set ORIG_EAX(%esp) to -1 in arch/i386/kernel/entry.S:error_code?&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;kernel-implementations&#34;&gt;kernel implementations&lt;/h2&gt;

&lt;p&gt;arch/x86/include/asm/proto.h&lt;br /&gt;
64-bit long mode: syscall; check syscall_init&lt;br /&gt;
64-bit compatible kernel: sysenter, syscall, or int 0x80; check __kernel_vsyscall and def_idts&lt;br /&gt;
32-bit kernel: int 0x80, sysenter;&lt;/p&gt;

&lt;h3 id=&#34;64-bit-without-compat-32-compatible-kernel-support&#34;&gt;64-bit without COMPAT_32/compatible kernel support&lt;/h3&gt;

&lt;p&gt;./int80&lt;br /&gt;
[  730.583700] traps: int80[1697] general protection ip:4000c4 sp:7ffd84b59730 error:402 in int80[400000+1000]&lt;br /&gt;
Segmentation fault (core dumped)&lt;/p&gt;

&lt;h2 id=&#34;x86-64-rcx-and-r10&#34;&gt;x86_64 rcx and r10&lt;/h2&gt;

&lt;p&gt;Check x86_64 ABI: Linux conventions and  according to &lt;a href=&#34;https://www.felixcloutier.com/x86/syscall&#34;&gt;x86 syscall instruction&lt;/a&gt;, rcx is used to passing next rip.&lt;br /&gt;
According to entry_SYSCALL_64, rcx is rip before it is pushed on the kernel stack. So r10 is right 4th args passed from userspace.&lt;br /&gt;
According to do_syscall_64, regs-&amp;gt;ax = sys_call_table&lt;a href=&#34;regs-&amp;gt;di, regs-&amp;gt;si, regs-&amp;gt;dx, regs-&amp;gt;r10, regs-&amp;gt;r8, regs-&amp;gt;r9&#34;&gt;nr&lt;/a&gt;;&lt;/p&gt;

&lt;h2 id=&#34;x86-32-asmlinkage&#34;&gt;x86_32 asmlinkage&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://qr.ae/Ti5MJJ&#34;&gt;By default gcc passes parameters on the stack for x86-32 arch, so what is it needed for? It&amp;rsquo;s because linux kernel uses -mregparm=3 option which overrides the default behaviour&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/67175/&#34;&gt;enbaled -mregparm=3 Shrinking the kernel with gcc&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://kernelnewbies.org/FAQ/asmlinkage&#34;&gt;What is asmlinkage?&lt;/a&gt;&lt;br /&gt;
However, for C functions invoked from assembly code, we should explicitly declare the function&amp;rsquo;s calling convention, because the parameter passing code in assembly side has been fixed. Show all predefined macros for your compiler&lt;/p&gt;

&lt;h2 id=&#34;vdso&#34;&gt;vDSO&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.linuxjournal.com/content/creating-vdso-colonels-other-chicken?page=0,0&#34;&gt;Creating a vDSO: the Colonel&amp;rsquo;s Other Chicken&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.trilithium.com/johan/2005/08/linux-gate/&#34;&gt;What is linux-gate.so.1&lt;/a&gt;&lt;br /&gt;
glibc -&amp;gt; AT_SYSINFO-&amp;gt; __kernel_vsyscall -&amp;gt; sysenter/syscall/in0x80&lt;br /&gt;
just for vDSO syscalls&lt;br /&gt;
glibc -&amp;gt; AT_SYSINFO_EHDR-&amp;gt; vDSO elf&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/446528/&#34;&gt;On vsyscalls and the vDSO&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://blog.tinola.com/?e=5&#34;&gt;linux syscalls on x86 64&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Page fault</title>
      <link>http://firoyang.org/cs/page_fault/</link>
      <pubDate>Thu, 06 Apr 2017 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/page_fault/</guid>
      <description>

&lt;h1 id=&#34;formal-causes&#34;&gt;Formal causes&lt;/h1&gt;

&lt;p&gt;page frame&lt;br /&gt;
read from backing store&lt;br /&gt;
PTE&lt;/p&gt;

&lt;h1 id=&#34;page-fault&#34;&gt;Page Fault&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;page-fault exceptions error code&lt;br /&gt;
v3a: 4.7 - Figure 4-12. Page-Fault Error Code&lt;br /&gt;
P, W/R, U/S, I/D, RSVD&lt;br /&gt;
user/kernel mode, kerne space/userspace address, good/bad area&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;kernel-address&#34;&gt;Kernel address&lt;/h1&gt;

&lt;p&gt;vmalloc,spurious_fault, kprobes_fault&lt;/p&gt;

&lt;h2 id=&#34;bad-area&#34;&gt;Bad area&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kernel.org/doc/Documentation/x86/exception-tables.txt&#34;&gt;fixup_exception&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.linuxjournal.com/article/2135&#34;&gt;Kernel-Level Exception Handling&lt;/a&gt;&lt;br /&gt;
SIGSEGV&lt;br /&gt;
kernel oops&lt;/p&gt;

&lt;h1 id=&#34;userspace-address&#34;&gt;Userspace address&lt;/h1&gt;

&lt;h2 id=&#34;bad-area-1&#34;&gt;Bad area&lt;/h2&gt;

&lt;p&gt;PF_USER ? SIGSEGV&lt;/p&gt;

&lt;h2 id=&#34;stack&#34;&gt;Stack&lt;/h2&gt;

&lt;p&gt;premise: grows down: address &amp;gt; 65536 + 32 * sizeof(unsigned long) + rsp&lt;br /&gt;
expand_stack(): expand vma of stack; + good area workflow.&lt;/p&gt;

&lt;h2 id=&#34;private-anonymous-page&#34;&gt;Private anonymous page&lt;/h2&gt;

&lt;p&gt;Check &amp;lsquo;man madvise&amp;rsquo; for private anonymous page.&lt;br /&gt;
Stack and Heap - mmap, brk: do_anonymous_page&lt;br /&gt;
Library Private read &amp;amp; write: do_wp_page,&lt;br /&gt;
Library Private write: cow page, do_cow_page&lt;/p&gt;

&lt;h3 id=&#34;do-cow-page&#34;&gt;do_cow_page&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;get page and cow:  __do_fault-&amp;gt; vma-&amp;gt;vm_ops-&amp;gt;fault = filemap_fault -&amp;gt; page cache ? page_cache_read add to lru&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;add page to anon lru list: finish_fault-&amp;gt;alloc_set_pte-&amp;gt; page_add_new_anon_rmap -&amp;gt; __SetPageSwapBacked&lt;/p&gt;

&lt;h3 id=&#34;page-rmap-pte&#34;&gt;Page, rmap, pte&lt;/h3&gt;

&lt;p&gt;page: alloc_zeroed_user_highpage_movable&lt;br /&gt;
page_add_new_anon_rmap&lt;br /&gt;
set_pte_at&lt;/p&gt;

&lt;h2 id=&#34;private-file-page&#34;&gt;Private file page&lt;/h2&gt;

&lt;p&gt;Libray Private  read: do_read_page, pte prot is PAGE_COPY check protection_map.&lt;br /&gt;
map_region         vma-&amp;gt;vm_page_prot = vm_get_page_prot(vm_flags);&lt;br /&gt;
do_set_pte(vma, address, fault_page, pte, false, false); vm_page_prot&lt;/p&gt;

&lt;h2 id=&#34;shared-file-page&#34;&gt;Shared file page&lt;/h2&gt;

&lt;p&gt;do_shared_page&lt;/p&gt;

&lt;h2 id=&#34;shared-anonymous-page&#34;&gt;Shared anonymous page&lt;/h2&gt;

&lt;p&gt;do_shared_page&lt;/p&gt;

&lt;h2 id=&#34;swap-page&#34;&gt;Swap page&lt;/h2&gt;

&lt;p&gt;do_swap_page&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;read-and-write-pages-copy-on-write-technique&#34;&gt;Read and write pages - Copy-on-write technique.&lt;/h1&gt;

&lt;h2 id=&#34;do-read-page&#34;&gt;do_read_page&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/588802/&#34;&gt;map_pages&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;synchronization&#34;&gt;Synchronization&lt;/h1&gt;

&lt;h2 id=&#34;down-read-mm-mmap-sem&#34;&gt;down_read(&amp;amp;mm-&amp;gt;mmap_sem)?&lt;/h2&gt;

&lt;p&gt;linux-tglx&lt;br /&gt;
commit b50661029222940e24d2fba7c982ac0774a38c78&lt;br /&gt;
Author: Andi Kleen &lt;a href=&#34;mailto:ak@muc.de&#34;&gt;ak@muc.de&lt;/a&gt;&lt;br /&gt;
Date:   Thu Sep 16 22:00:12 2004 -0700&lt;br /&gt;
    [PATCH] x86-64: avoid deadlock in page fault handler&lt;br /&gt;
    Avoid deadlock when kernel fault happens inside mmap sem.&lt;br /&gt;
Check ULKv3 Page 380.&lt;br /&gt;
&lt;a href=&#34;https://lkml.org/lkml/2004/5/19/108&#34;&gt;https://lkml.org/lkml/2004/5/19/108&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lkml.org/lkml/2013/5/13/418&#34;&gt;https://lkml.org/lkml/2013/5/13/418&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;irq&#34;&gt;IRQ&lt;/h2&gt;

&lt;p&gt;commit 891cffbd6bcba26409869c19c07ecd4bfc0c2460&lt;br /&gt;
Author: Linus Torvalds &lt;a href=&#34;mailto:torvalds@linux-foundation.org&#34;&gt;torvalds@linux-foundation.org&lt;/a&gt;&lt;br /&gt;
Date:   Sun Oct 12 13:16:12 2008 -0700&lt;br /&gt;
    x86/mm: do not trigger a kernel warning if user-space disables interrupts and generates a page fault&lt;/p&gt;

&lt;h1 id=&#34;propection&#34;&gt;Propection&lt;/h1&gt;

&lt;p&gt;tglx: commit 0457d99a336be658cea1a5bdb689de5adb3b382d&lt;br /&gt;
Author: Andi Kleen &lt;a href=&#34;mailto:ak@muc.de&#34;&gt;ak@muc.de&lt;/a&gt;&lt;br /&gt;
Date:   Tue Feb 12 20:17:35 2002 -0800&lt;br /&gt;
    [PATCH] x86_64 merge: arch + asm&lt;br /&gt;
    This adds the x86_64 arch and asm directories and a Documentation/x86_64.&lt;br /&gt;
+/*&lt;br /&gt;
+ * The i386 can&amp;rsquo;t do page protection for execute, and considers that&lt;br /&gt;
+ * the same are read. Also, write permissions imply read permissions.&lt;br /&gt;
+ * This is the closest we can get..&lt;br /&gt;
+ */&lt;br /&gt;
+#define __P000 PAGE_NONE&lt;br /&gt;
+#define __P001 PAGE_READONLY&lt;br /&gt;
+#define __P010 PAGE_COPY&lt;br /&gt;
+#define __P011 PAGE_COPY&lt;br /&gt;
+#define __P100 PAGE_READONLY&lt;br /&gt;
+#define __P101 PAGE_READONLY&lt;br /&gt;
+#define __P110 PAGE_COPY&lt;br /&gt;
+#define __P111 PAGE_COPY&lt;br /&gt;
+#define __S000 PAGE_NONE&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux time subsystem</title>
      <link>http://firoyang.org/cs/time/</link>
      <pubDate>Tue, 22 Sep 2015 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/time/</guid>
      <description>

&lt;h1 id=&#34;formal-causes&#34;&gt;Formal causes&lt;/h1&gt;

&lt;h1 id=&#34;tsc&#34;&gt;TSC&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://oliveryang.net/2015/09/pitfalls-of-TSC-usage/&#34;&gt;Pitfalls of TSC usage&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/388188/&#34;&gt;The trouble with the TSC&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;genus-differentia-definition&#34;&gt;Genus-differentia definition&lt;/h2&gt;

&lt;p&gt;interrupt, clock event,  clock source, tick, timer, timekeeping, gettimeofday.&lt;/p&gt;

&lt;h2 id=&#34;unites&#34;&gt;unites&lt;/h2&gt;

&lt;p&gt;cputime = jiffies under HZ (FIXME)&lt;br /&gt;
sum_exec_runtime nanoseconds&lt;br /&gt;
clockt = jiffies but under USER_HZ&lt;/p&gt;

&lt;h2 id=&#34;功用定义&#34;&gt;功用定义&lt;/h2&gt;

&lt;p&gt;获取时间&lt;br /&gt;
timer&lt;br /&gt;
sleep ?&lt;br /&gt;
update sched info&lt;/p&gt;

&lt;h2 id=&#34;发生定义-设计-etymology-history-operational-definition&#34;&gt;发生定义/设计   etymology, history Operational definition&lt;/h2&gt;

&lt;p&gt;timekeeping/计时:时刻．&lt;br /&gt;
clock source: 时间之源, 表针之力.&lt;br /&gt;
clock event: 闹铃之力, 经过tick展现能力.&lt;br /&gt;
tick: timer的中断事件叫tick, tick device产生tick, 可以说tick决定了clock_event event_handler进而决定了, clock_event行为.&lt;br /&gt;
tickless:&lt;br /&gt;
for timer: use HW timer one shot, set next.&lt;br /&gt;
for update time: in above HW timer, not good&lt;br /&gt;
for sched: for priority distributed in time slice, use timer.&lt;br /&gt;
dynamic tick/no HZ:&lt;br /&gt;
No HZ in idle&lt;br /&gt;
No HZ while only 1 process running for HPC.&lt;br /&gt;
tick devies 就是clock event包了层虎皮.&lt;br /&gt;
tick broadcast framework:  based on tick device&lt;br /&gt;
clock: 可记录时间, 表盘.利用timekeeping&lt;br /&gt;
timer: use clock. what about timer_list?&lt;br /&gt;
timer_list: do in softirq&lt;br /&gt;
* timekeeping aspect&lt;br /&gt;
onset: start_kernel -&amp;gt; timekeeping_init &amp;amp; time_init &amp;amp;(rest_init-&amp;gt; kernel_init-&amp;gt; &lt;br /&gt;
kernel_init_freeable-&amp;gt;do_basic_setup-&amp;gt;do_initcalls&amp;ndash;device_initcall(init_clocksource_sysfs))&lt;br /&gt;
nucleus:used by clock see init_posix_timers and update_wall_time and sys_time&lt;br /&gt;
coda:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;clock source aspect&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;tick device layer aspect&lt;br /&gt;
per_cpu(tick_cpu_device, cpu)&lt;br /&gt;
onset: time_init-&amp;gt;mach-&amp;gt;init_time-&amp;gt;&amp;hellip;clockevents_register_device-&amp;gt;tick_check_new_device&lt;br /&gt;
nucleus: a38x_timer_interrupt-&amp;gt;a38x_clkevt.event_handler&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;tick broadcast framework&lt;br /&gt;
onset:&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;clock aspect&lt;br /&gt;
k_clock&lt;br /&gt;
onset:init_posix_timers &amp;amp; init_posix_cpu_timers&lt;br /&gt;
nucleus: 用户-&amp;gt; posix_clock-&amp;gt;timepkeeping-&amp;gt;clock_socurce&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;timer aspect&lt;br /&gt;
onset: open_softirq(HRTIMER_SOFTIRQ, run_hrtimer_softirq);&lt;br /&gt;
nucleus: common_timer_set&lt;br /&gt;
hrtimer_interrupt | (tick_handle_periodic-&amp;gt; tick_periodic-&amp;gt; update_process_times-&amp;gt;run_local_timers-&amp;gt;hrtimer_run_queues)-&amp;gt;__run_hrtimer-&amp;gt;timer.function = posix_timer_fn;(set in common_timer_set)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;计算机概念&lt;br /&gt;
system clock CLOCK_REALTIME CLOCK_MONOTONIC&lt;br /&gt;
time.h time_t=tm=timeval=timespec calendar time  clock_t&lt;/p&gt;

&lt;p&gt;clock event -&amp;gt; tick device-&amp;gt; handle function&lt;br /&gt;
clock event 相较于timer更为抽象, timer 是一种用途,timer 通过clock event来实现功能,&lt;br /&gt;
clock event 通过timer来体现自己, timer面向使用者的onset,&lt;br /&gt;
而clock event 则是偏向于nucleus and coda.&lt;br /&gt;
timer: 标记不能立即执行的变化.&lt;br /&gt;
clock source: 用一些整型抽象一个过程, 对于时间来说, 简直是完美的抽象.&lt;br /&gt;
* kernel requirement&lt;br /&gt;
linux的时间子系统要求硬件timer提供下面两种能力：&lt;br /&gt;
一是free running的counter，此外需要能够在指定的counter值上产生中断的能力。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The Journey to RCU</title>
      <link>http://firoyang.org/cs/rcu/</link>
      <pubDate>Sun, 24 May 2015 09:52:12 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/rcu/</guid>
      <description>

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cnhalo.net/2016/06/13/linux-rcu/&#34;&gt;http://www.cnhalo.net/2016/06/13/linux-rcu/&lt;/a&gt; linux 4.9内核rcu实现&lt;/p&gt;

&lt;h1 id=&#34;network-rx-path&#34;&gt;Network RX  path&lt;/h1&gt;

&lt;p&gt;commit 2d331915a04144dad738e725769d8fac06ef6155&lt;br /&gt;
Author: Eric Dumazet &lt;a href=&#34;mailto:edumazet@google.com&#34;&gt;edumazet@google.com&lt;/a&gt;&lt;br /&gt;
Date:   Fri Apr 1 08:52:15 2016 -0700&lt;br /&gt;
    tcp/dccp: use rcu locking in inet_diag_find_one_icsk()&lt;br /&gt;
    RX packet processing holds rcu_read_lock(), so we can remove&lt;br /&gt;
    pairs of rcu_read_lock()/rcu_read_unlock() in lookup functions&lt;br /&gt;
    if inet_diag also holds rcu before calling them.&lt;br /&gt;
    This is needed anyway as __inet_lookup_listener() and&lt;br /&gt;
    inet6_lookup_listener() will soon no longer increment&lt;br /&gt;
    refcount on the found listener.&lt;br /&gt;
    Signed-off-by: Eric Dumazet &lt;a href=&#34;mailto:edumazet@google.com&#34;&gt;edumazet@google.com&lt;/a&gt;&lt;br /&gt;
    Signed-off-by: David S. Miller &lt;a href=&#34;mailto:davem@davemloft.net&#34;&gt;davem@davemloft.net&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;5142 static int process_backlog(struct napi_struct *napi, int quota)&lt;br /&gt;
&amp;hellip;&lt;br /&gt;
5160                 while ((skb = __skb_dequeue(&amp;amp;sd-&amp;gt;process_queue))) {&lt;br /&gt;
5161                         rcu_read_lock();&lt;br /&gt;
5162                         __netif_receive_skb(skb);&lt;br /&gt;
5163                         rcu_read_unlock();&lt;br /&gt;
Refs: v4.1-12249-g2c17d27c36dc&lt;br /&gt;
Author:     Julian Anastasov &lt;a href=&#34;mailto:ja@ssi.bg&#34;&gt;ja@ssi.bg&lt;/a&gt;&lt;br /&gt;
AuthorDate: Thu Jul 9 09:59:10 2015 +0300&lt;br /&gt;
Commit:     David S. Miller &lt;a href=&#34;mailto:davem@davemloft.net&#34;&gt;davem@davemloft.net&lt;/a&gt;&lt;br /&gt;
CommitDate: Fri Jul 10 18:16:36 2015 -0700&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;net: call rcu_read_lock early in process_backlog

Incoming packet should be either in backlog queue or
in RCU read-side section. Otherwise, the final sequence of
flush_backlog() and synchronize_net() may miss packets
that can run without device reference:

CPU 1                  CPU 2
                       skb-&amp;gt;dev: no reference
                       process_backlog:__skb_dequeue
                       process_backlog:local_irq_enable

on_each_cpu for
flush_backlog =&amp;gt;       IPI(hardirq): flush_backlog
                       - packet not found in backlog

                       CPU delayed ...
synchronize_net
- no ongoing RCU
read-side sections

netdev_run_todo,
rcu_barrier: no
ongoing callbacks
                       __netif_receive_skb_core:rcu_read_lock
                       - too late
free dev
                       process packet for freed dev

Fixes: 6e583ce5242f (&amp;quot;net: eliminate refcounting in backlog queue&amp;quot;)
Cc: Eric W. Biederman &amp;lt;ebiederm@xmission.com&amp;gt;
Cc: Stephen Hemminger &amp;lt;stephen@networkplumber.org&amp;gt;
Signed-off-by: Julian Anastasov &amp;lt;ja@ssi.bg&amp;gt;
Signed-off-by: David S. Miller &amp;lt;davem@davemloft.net&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;history&#34;&gt;History&lt;/h1&gt;

&lt;h2 id=&#34;2001-read-copy-update-on-ols-https-www-kernel-org-doc-ols-2001-read-copy-pdf&#34;&gt;2001 &lt;a href=&#34;https://www.kernel.org/doc/ols/2001/read-copy.pdf&#34;&gt;Read-Copy Update on ols&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/541037/&#34;&gt;As of March 2013: Simplifying RCU&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www2.rdrop.com/users/paulmck/RCU/RCUdissertation.2004.07.14e1.pdf&#34;&gt;RCU dissertation.2004.07&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;2008&#34;&gt;2008&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/264090/&#34;&gt;RCU part 3: the RCU API, 2008 edition&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;2010&#34;&gt;2010&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/418853/&#34;&gt;The RCU API, 2010 Edition&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;2014&#34;&gt;2014&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/609904/&#34;&gt;The RCU API, 2014 Edition&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;2019&#34;&gt;2019&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/777036/&#34;&gt;The RCU API, 2019 edition&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;formal-cause&#34;&gt;Formal cause&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kernel.org/doc/Documentation/RCU/Design/Requirements/Requirements.html&#34;&gt;A Tour Through RCU&amp;rsquo;s Requirements&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.rdrop.com/~paulmck/RCU/rcu-exploit.2019.05.01a.pdf&#34;&gt;A Critical RCU Safety Property is&amp;hellip; Ease of Use!&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.rdrop.com/users/paulmck/RCU/whatisRCU.html&#34;&gt;What is RCU?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.kernel.org/doc/Documentation/RCU/whatisRCU.txt&#34;&gt;What is RCU?  &amp;ndash;  &amp;ldquo;Read, Copy, Update&amp;rdquo;&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/652156/&#34;&gt;Requirements for RCU part 1: the fundamentals&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.joelfernandes.org/joel/slides/RCU_in_2019_KernelRecipes.pdf&#34;&gt;RCU in 2019&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=bsyXDAouI6E&#34;&gt;Kernel Recipes 2019 - RCU in 2019&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;rcu-and-dynticks&#34;&gt;RCU and dynticks&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://ertl.jp/~shinpei/conf/ospert13/slides/FredericWeisbecker.pdf&#34;&gt;Status of Linux dynticks&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=G3jHP9kNjwc&#34;&gt;Full dynticks status - Frederic Weisbecker, Red Hat&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;grace-period&#34;&gt;Grace period&lt;/h2&gt;

&lt;p&gt;Documentation/RCU/rcu.txt&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/573424/&#34;&gt;URCU: any period of time during which each reader thread resides in at least one quiescent state is called a grace period.&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/305782/#Start%20a%20new%20grace%20period.&#34;&gt;Start a New Grace Period&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/305782/#Brief%20Overview%20of%20Classic%20RCU%20Implementation&#34;&gt;&amp;hellip; after each CPU has passed through at least one quiescent state, the RCU grace period ends.&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.kernel.org/doc/Documentation/RCU/Design/Expedited-Grace-Periods/Expedited-Grace-Periods.html&#34;&gt;Must-read: Expedited Grace Period Design&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;quiescent-state&#34;&gt;Quiescent state&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://lse.sourceforge.net/locking/rcu/HOWTO/descrip.html&#34;&gt;&amp;hellip; after all the CPUs in the system have gone through at least one &amp;ldquo;quiescent&amp;rdquo; state (such as context switch, idle loop, or user code)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/573424/&#34;&gt;URCU: Any line of code not in an RCU read-side critical section is termed a quiescent state&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/305782/#Pass%20through%20a%20quiescent%20state.&#34;&gt;The rcu and rcu_bh flavors of RCU have different sets of quiescent states.&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://preshing.com/20160726/using-quiescent-states-to-reclaim-memory/&#34;&gt;Using Quiescent States to Reclaim Memory&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;granularity-of-waiting&#34;&gt;granularity of waiting&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/262464/#Wait%20For%20Pre-Existing%20RCU%20Readers%20to%20Complete&#34;&gt;The great advantage of RCU &amp;hellip; without having to explicitly track each and every one of them&lt;/a&gt;&lt;br /&gt;
In RCU&amp;rsquo;s case, the things waited on are called &amp;ldquo;RCU read-side critical sections&amp;rdquo;. ditto.&lt;/p&gt;

&lt;h1 id=&#34;classic-rcu&#34;&gt;Classic RCU&lt;/h1&gt;

&lt;p&gt;commit c17ef45342cc033fdf7bdd5b28615e0090f8d2e7&lt;br /&gt;
Author: Paul E. McKenney &lt;a href=&#34;mailto:paulmck@linux.vnet.ibm.com&#34;&gt;paulmck@linux.vnet.ibm.com&lt;/a&gt;&lt;br /&gt;
Date:   Tue Jun 23 17:12:47 2009 -0700&lt;br /&gt;
    rcu: Remove Classic RCU&lt;br /&gt;
    Remove Classic RCU, given that the combination of Tree RCU and&lt;br /&gt;
    the proposed Bloatwatch RCU do everything that Classic RCU can&lt;br /&gt;
    with fewer bugs.&lt;br /&gt;
tags/v2.6.32-rc1~724^2~29&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/305782/#Brief%20Overview%20of%20Classic%20RCU%20Implementation&#34;&gt;Brief Overview of Classic RCU Implementation&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.wowotech.net/kernel_synchronization/linux2-6-11-RCU.html&#34;&gt;Linux2.6.11版本：classic RCU的实现&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;rcu-sched&#34;&gt;RCU sched&lt;/h1&gt;

&lt;p&gt;commit 9b06e818985d139fd9e82c28297f7744e1b484e1&lt;br /&gt;
Refs: v2.6.12-rc3-362-g9b06e818985d&lt;br /&gt;
Author:     Paul E. McKenney &lt;a href=&#34;mailto:paulmck@us.ibm.com&#34;&gt;paulmck@us.ibm.com&lt;/a&gt;&lt;br /&gt;
AuthorDate: Sun May 1 08:59:04 2005 -0700&lt;br /&gt;
Commit:     Linus Torvalds &lt;a href=&#34;mailto:torvalds@ppc970.osdl.org&#34;&gt;torvalds@ppc970.osdl.org&lt;/a&gt;&lt;br /&gt;
CommitDate: Sun May 1 08:59:04 2005 -0700&lt;br /&gt;
    [PATCH] Deprecate synchronize_kernel, GPL replacement&lt;br /&gt;
    The synchronize_kernel() primitive is used for quite a few different purposes:&lt;br /&gt;
    waiting for RCU readers, waiting for NMIs, waiting for interrupts, and so on.&lt;br /&gt;
    This makes RCU code harder to read, since synchronize_kernel() might or might&lt;br /&gt;
    not have matching rcu_read_lock()s.  This patch creates a new&lt;br /&gt;
    synchronize_rcu() that is to be used for RCU readers and a new&lt;br /&gt;
    synchronize_sched() that is used for the rest.  These two new primitives&lt;br /&gt;
    currently have the same implementation, but this is might well change with&lt;br /&gt;
    additional real-time support.&lt;br /&gt;
+ * synchronize_sched - block until all CPUs have exited any non-preemptive&lt;br /&gt;
+ * kernel code sequences.&lt;br /&gt;
+ * This means that all preempt_disable code sequences, including NMI and&lt;br /&gt;
+ * hardware-interrupt handlers, in progress on entry will have completed&lt;br /&gt;
+ * before this primitive returns.  However, this does not guarantee that&lt;br /&gt;
+ * softirq handlers will have completed, since in some kernels&lt;br /&gt;
+ * This primitive provides the guarantees made by the (deprecated)&lt;br /&gt;
+ * synchronize_kernel() API.  In contrast, synchronize_rcu() only&lt;br /&gt;
+ * guarantees that rcu_read_lock() sections will have completed.&lt;/p&gt;

&lt;h2 id=&#34;rcu-is-mapped-to-either-rcu-sched-or-rcu-preempt-depending-on-configuration&#34;&gt;RCU is mapped to either RCU-sched or RCU-preempt depending on configuration.&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lore.kernel.org/patchwork/cover/164913/&#34;&gt;[RFC,-tip,0/4] RCU cleanups and simplified preemptable RCU&lt;/a&gt;&lt;br /&gt;
o   Rename variables and functions so that RCU-sched is an&lt;br /&gt;
    underlying definition, along with RCU-bh and (when so&lt;br /&gt;
    configured) RCU-preempt.  RCU then maps to either RCU-sched&lt;br /&gt;
    or RCU-preempt, depending on configuration.&lt;br /&gt;
commit d6714c22b43fbcbead7e7b706ff270e15f04a791&lt;br /&gt;
Refs: v2.6.31-rc6-15-gd6714c22b43f&lt;br /&gt;
Author:     Paul E. McKenney &lt;a href=&#34;mailto:paulmck@linux.vnet.ibm.com&#34;&gt;paulmck@linux.vnet.ibm.com&lt;/a&gt;&lt;br /&gt;
AuthorDate: Sat Aug 22 13:56:46 2009 -0700&lt;br /&gt;
Commit:     Ingo Molnar &lt;a href=&#34;mailto:mingo@elte.hu&#34;&gt;mingo@elte.hu&lt;/a&gt;&lt;br /&gt;
CommitDate: Sun Aug 23 10:32:37 2009 +0200&lt;br /&gt;
    rcu: Renamings to increase RCU clarity&lt;br /&gt;
    Make RCU-sched, RCU-bh, and RCU-preempt be underlying&lt;br /&gt;
    implementations, with &amp;ldquo;RCU&amp;rdquo; defined in terms of one of the&lt;br /&gt;
    three.  Update the outdated rcu_qsctr_inc() names, as these&lt;br /&gt;
    functions no longer increment anything.&lt;/p&gt;

&lt;h2 id=&#34;quiescent-states-for-rcu-sched&#34;&gt;Quiescent states for RCU-sched&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.kroening.com/papers/date2018-rcu.pdf&#34;&gt;Verification of Tree-Based Hierarchical Read-Copy Update in the Linux Kernel&lt;/a&gt;&lt;br /&gt;
The non-preemptible RCU-sched flavor’s quiescent states&lt;br /&gt;
apply to CPUs, and are user-space execution, context switch,&lt;br /&gt;
idle, and offline state. Therefore, RCU-sched only needs to&lt;br /&gt;
track tasks and interrupt handlers that are actually running&lt;br /&gt;
because blocked and preempted tasks are always in quiescent states. Thus, RCU-sched needs only track CPU states.&lt;/p&gt;

&lt;h2 id=&#34;rcu-stalls&#34;&gt;RCU stalls&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=23_GOr8Sz-E&#34;&gt;Decoding Those Inscrutable RCU CPU Stall Warnings&lt;/a&gt;&lt;br /&gt;
update_process_times-&amp;gt;rcu_check_callbacks-&amp;gt;rcu_pending-&amp;gt;__rcu_pending-&amp;gt;check_cpu_stall-&amp;gt;print_other_cpu_stall&lt;br /&gt;
Documentation/RCU/stallwarn.txt&lt;/p&gt;

&lt;h1 id=&#34;rcu-preempt-preemptiable-rcu&#34;&gt;RCU-preempt Preemptiable RCU&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.joelfernandes.org/linuxinternals/2018/05/10/5-rcu-preempt-context-switch.html&#34;&gt;Must-read: RCU-preempt: What happens on a context switch&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.rdrop.com/users/paulmck/RCU/realtimeRCU.2005.04.23a.pdf&#34;&gt;Towards Hard Realtime Response from the Linux Kernel on SMP Hardware&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/201195/&#34;&gt;The 1st: Read-copy-update for realtime&lt;/a&gt; &lt;a href=&#34;http://www.rdrop.com/users/paulmck/RCU/OLSrtRCU.2006.08.11a.pdf&#34;&gt;Papper&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/253651/&#34;&gt;The design of preemptible read-copy-update&lt;/a&gt;&lt;br /&gt;
The RCU implementation for the -rt patchset is unusual in that it permits read-side critical sections to be preempted and to be blocked waiting for locks. However, it does not handle general blocking (for example, via the wait_event() primitive): if you need that, you should instead use SRCU.&lt;br /&gt;
&lt;a href=&#34;http://www.rdrop.com/users/paulmck/RCU/realtimeRCU.2005.04.23a.pdf&#34;&gt;Realtime RCU&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.joelfernandes.org/linuxinternals/2018/05/10/5-rcu-preempt-context-switch.html&#34;&gt;RCU-preempt: What happens on a context switch&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;implementation&#34;&gt;Implementation&lt;/h2&gt;

&lt;p&gt;+#define RCU_READ_UNLOCK_NEED_QS (1 &amp;lt;&amp;lt; 2) /* RCU core needs CPU response. */&lt;br /&gt;
f41d911f8c49a5d65c86504c19e8204bb605c4fd&lt;br /&gt;
need_qs&lt;br /&gt;
1d082fd061884a587c490c4fc8a2056ce1e47624&lt;/p&gt;

&lt;h2 id=&#34;rcu-preempt-and-sleeping&#34;&gt;RCU-preempt and sleeping&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.joelfernandes.org/linuxinternals/2018/05/10/5-rcu-preempt-context-switch.html&#34;&gt;A recent discussion on LKML clarified to me that “preempted to run something else” not only covers involuntary preemption but also voluntarily sleeping.&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;joelfernandes.org/linuxinternals/2018/05/10/5-rcu-preempt-context-switch.html&#34;&gt;The exception is -rt &amp;ldquo;spinlock&amp;rdquo; acquisition.  If the &amp;ldquo;spinlock&amp;rdquo; is held,&lt;/a&gt;&lt;br /&gt;
the task acquiring it will block, which is legal within an RCU-preempt&lt;br /&gt;
read-side critical section.&lt;br /&gt;
This exception is why I define bad things in terms of lack of&lt;br /&gt;
susceptibility to priority boosting instead of sleeping.&lt;/p&gt;

&lt;h2 id=&#34;priority-boosting-rcu&#34;&gt;Priority-Boosting RCU&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/220677/&#34;&gt;Priority-Boosting RCU Read-Side Critical Sections&lt;/a&gt;&lt;br /&gt;
CONFIG_RCU_BOOST&lt;/p&gt;

&lt;h2 id=&#34;the-motivation-for-that-cpu-reports-qs&#34;&gt;The motivation for that CPU reports QS&lt;/h2&gt;

&lt;p&gt;@冯博群 你好，请教一个问题，对于rcu-preempt， CPU report QS的意义是什么？ 我理解只有task QS 才不block GP。&lt;br /&gt;
冯博群: qs都是CPU的，每个task都要report qs的话，那记录的结构得多复杂; rcu preempt是搞了一个list用来记录block当前qs的task; 当前gp; 过gp的条件就是list为空，且所有的CPU都report过qs;你说得概念上没啥问题，但是实现中不是这样作的.&lt;/p&gt;

&lt;h1 id=&#34;rcu-bh&#34;&gt;RCU bh&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/ml/linux-kernel/CAJWu+oqCun1Ae6GqPxnS+eCDi3jadGPp+MO8TjOWgs+AiAh79A@mail.gmail.com/&#34;&gt;Questions on rcu-bh design&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;motivation-for-rcu-bh-and-vs-rcu-preempt-https-www-mail-archive-com-linux-kernel-vger-kernel-org-msg1682346-html&#34;&gt;&lt;a href=&#34;https://www.mail-archive.com/linux-kernel@vger.kernel.org/msg1682346.html&#34;&gt;Motivation for RCU-bh and vs RCU-preempt&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kernel.org/doc/Documentation/RCU/Design/Requirements/Requirements.html#Bottom-Half%20Flavor&#34;&gt;From kernel doc rcu design&lt;/a&gt;&lt;br /&gt;
The softirq-disable (AKA “bottom-half”, hence the “_bh” abbreviations) flavor of RCU, or RCU-bh, was developed by Dipankar Sarma to provide a flavor of RCU that could withstand the network-based denial-of-service attacks researched by Robert Olsson. These attacks placed so much networking load on the system that some of the CPUs never exited softirq execution, which in turn prevented those CPUs from ever executing a context switch, which, in the RCU implementation of that time, prevented grace periods from ever ending. The result was an out-of-memory condition and a system hang.&lt;br /&gt;
The solution was the creation of RCU-bh, which does local_bh_disable() across its read-side critical sections, and which uses &lt;em&gt;the transition from one type of softirq processing to another as a quiescent state in addition to context switch, idle, user mode, and offline&lt;/em&gt;. This means that RCU-bh grace periods can complete even when some of the CPUs execute in softirq indefinitely, thus allowing algorithms based on RCU-bh to withstand network-based denial-of-service attacks.&lt;/p&gt;

&lt;h1 id=&#34;srcu&#34;&gt;SRCU&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/202847/&#34;&gt;Sleepable RCU&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;tasks-rcu&#34;&gt;Tasks RCU&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/607117/&#34;&gt;The RCU-tasks subsystem&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;tiny-rcu-rcu-the-bloatwatch-edition&#34;&gt;Tiny RCU / RCU: The Bloatwatch Edition&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/323929/&#34;&gt;RCU: The Bloatwatch Edition&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/396767/&#34;&gt;rcu: Add a TINY_PREEMPT_RCU&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lore.kernel.org/patchwork/patch/373048/&#34;&gt;rcu: Remove TINY_PREEMPT_RCU&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;tree-rcu-hierarchical-rcu&#34;&gt;Tree RCU / Hierarchical RCU&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.kroening.com/papers/date2018-rcu.pdf&#34;&gt;Verification of Tree-Based Hierarchical Read-Copy Update in the Linux Kernel&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/305782&#34;&gt;Hierarchical RCU&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.kernel.org/doc/Documentation/RCU/Design/Memory-Ordering/Tree-RCU-Memory-Ordering.html&#34;&gt;Tree RCU Grace Period Memory Ordering Components &lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.kernel.org/doc/Documentation/RCU/Design/Data-Structures/Data-Structures.html&#34;&gt;A Tour Through TREE_RCU&amp;rsquo;s Data Structures&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.kernel.org/doc/Documentation/RCU/Design/Expedited-Grace-Periods/Expedited-Grace-Periods.html&#34;&gt;A Tour Through TREE_RCU&amp;rsquo;s Expedited Grace Periods&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/453002/&#34;&gt;Tree preempt RCU: 3.0 and RCU: what went wrong&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;list-and-rcu&#34;&gt;list and rcu&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kernel.org/doc/Documentation/RCU/listRCU.rst&#34;&gt;Using RCU to Protect Read-Mostly Linked Lists&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;hlist-nulls&#34;&gt;hlist-nulls&lt;/h2&gt;

&lt;p&gt;commit bbaffaca4810de1a25e32ecaf836eeaacc7a3d11&lt;br /&gt;
Refs: v2.6.28-rc4-513-gbbaffaca4810&lt;br /&gt;
Author:     Eric Dumazet &lt;a href=&#34;mailto:dada1@cosmosbay.com&#34;&gt;dada1@cosmosbay.com&lt;/a&gt;&lt;br /&gt;
AuthorDate: Sun Nov 16 19:37:55 2008 -0800&lt;br /&gt;
Commit:     David S. Miller &lt;a href=&#34;mailto:davem@davemloft.net&#34;&gt;davem@davemloft.net&lt;/a&gt;&lt;br /&gt;
CommitDate: Sun Nov 16 19:37:55 2008 -0800&lt;br /&gt;
    rcu: Introduce hlist_nulls variant of hlist&lt;br /&gt;
    hlist uses NULL value to finish a chain.&lt;br /&gt;
    hlist_nulls variant use the low order bit set to 1 to signal an end-of-list marker.&lt;br /&gt;
    This allows to store many different end markers, so that some RCU lockless&lt;br /&gt;
    algos (used in TCP/UDP stack for example) can save some memory barriers in&lt;br /&gt;
    fast paths.&lt;br /&gt;
&lt;a href=&#34;https://www.kernel.org/doc/Documentation/RCU/rculist_nulls.txt&#34;&gt;Usage of hilsit-nulls in kernel doc&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;slab-and-rcu&#34;&gt;slab and rcu&lt;/h1&gt;

&lt;p&gt;tglx: commit 77631565ae40a44f23eac2e9c440cbceed8962a7&lt;br /&gt;
Author:     Hugh Dickins &lt;a href=&#34;mailto:hugh@veritas.com&#34;&gt;hugh@veritas.com&lt;/a&gt;&lt;br /&gt;
AuthorDate: Mon Aug 23 21:24:22 2004 -0700&lt;br /&gt;
Commit:     Linus Torvalds &lt;a href=&#34;mailto:torvalds@ppc970.osdl.org&#34;&gt;torvalds@ppc970.osdl.org&lt;/a&gt;&lt;br /&gt;
CommitDate: Mon Aug 23 21:24:22 2004 -0700&lt;br /&gt;
    [PATCH] rmaplock: SLAB_DESTROY_BY_RCU&lt;/p&gt;

&lt;p&gt;commit d7de4c1dc3a2faca0bf05d9e342f885cb2696766&lt;br /&gt;
Refs: v2.6.28-rc4-307-gd7de4c1dc3a2&lt;br /&gt;
Author:     Peter Zijlstra &lt;a href=&#34;mailto:a.p.zijlstra@chello.nl&#34;&gt;a.p.zijlstra@chello.nl&lt;/a&gt;&lt;br /&gt;
AuthorDate: Thu Nov 13 20:40:12 2008 +0200&lt;br /&gt;
Commit:     Pekka Enberg &lt;a href=&#34;mailto:penberg@cs.helsinki.fi&#34;&gt;penberg@cs.helsinki.fi&lt;/a&gt;&lt;br /&gt;
CommitDate: Thu Nov 13 20:49:02 2008 +0200&lt;br /&gt;
    slab: document SLAB_DESTROY_BY_RCU&lt;br /&gt;
    Explain this SLAB_DESTROY_BY_RCU thing..&lt;/p&gt;

&lt;h2 id=&#34;slab-typesafe-by-rcu&#34;&gt;SLAB_TYPESAFE_BY_RCU&lt;/h2&gt;

&lt;p&gt;commit 5f0d5a3ae7cff0d7fa943c199c3a2e44f23e1fac&lt;br /&gt;
Refs: v4.11-rc2-1-g5f0d5a3ae7cf&lt;br /&gt;
Author:     Paul E. McKenney &lt;a href=&#34;mailto:paulmck@linux.vnet.ibm.com&#34;&gt;paulmck@linux.vnet.ibm.com&lt;/a&gt;&lt;br /&gt;
AuthorDate: Wed Jan 18 02:53:44 2017 -0800&lt;br /&gt;
Commit:     Paul E. McKenney &lt;a href=&#34;mailto:paulmck@linux.vnet.ibm.com&#34;&gt;paulmck@linux.vnet.ibm.com&lt;/a&gt;&lt;br /&gt;
CommitDate: Tue Apr 18 11:42:36 2017 -0700&lt;br /&gt;
    mm: Rename SLAB_DESTROY_BY_RCU to SLAB_TYPESAFE_BY_RCU&lt;br /&gt;
    A group of Linux kernel hackers reported chasing a bug that resulted&lt;br /&gt;
    from their assumption that SLAB_DESTROY_BY_RCU provided an existence&lt;br /&gt;
    guarantee, that is, that no block from such a slab would be reallocated&lt;br /&gt;
    during an RCU read-side critical section.  Of course, that is not the&lt;br /&gt;
    case.  Instead, SLAB_DESTROY_BY_RCU only prevents freeing of an entire&lt;br /&gt;
    slab of blocks.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Yet another guide on the way to linux kernel hacking</title>
      <link>http://firoyang.org/cs/kernel_hacking/</link>
      <pubDate>Sat, 25 Apr 2015 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/kernel_hacking/</guid>
      <description>

&lt;h1 id=&#34;hacking-goals&#34;&gt;Hacking goals&lt;/h1&gt;

&lt;h2 id=&#34;trade-time-for-space&#34;&gt;Trade time for space&lt;/h2&gt;

&lt;p&gt;search_exception_tables&lt;/p&gt;

&lt;h1 id=&#34;define-asm-extable-handle-from-to-handler&#34;&gt;define _ASM_EXTABLE_HANDLE(from, to, handler)                 &lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;    .pushsection &amp;quot;__ex_table&amp;quot;,&amp;quot;a&amp;quot; ;                         \
    .balign 4 ;                                             \
    .long (from) - . ;                                      \
    .long (to) - . ;                                        \
    .long (handler) - . ;                                   \
    .popsection
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;hacking-area&#34;&gt;Hacking area&lt;/h1&gt;

&lt;p&gt;mm&lt;br /&gt;
&lt;a href=&#34;https://kernsec.org/wiki/index.php/Kernel_Self_Protection_Project&#34;&gt;https://kernsec.org/wiki/index.php/Kernel_Self_Protection_Project&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/749064/&#34;&gt;Variable-length arrays and the max() mess&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=wlqjQe3vDx8&amp;amp;list=PLbzoR-pLrL6rOT6m50HdJFYUHyvA9lurI&amp;amp;index=11&amp;amp;t=0s&#34;&gt;Sub-system Update: Kernel Self-Protection Project - Kees Cook, Google&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;kernel-refactoring&#34;&gt;Kernel refactoring&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://linuxtv.org/wiki/index.php/Development:_Hints_for_Refactoring_Existing_Drivers&#34;&gt;https://linuxtv.org/wiki/index.php/Development:_Hints_for_Refactoring_Existing_Drivers&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=mxxicJZ8cis&#34;&gt;Kernel Recipes 2017 - Refactoring the Linux Kernel - Thomas Gleixner&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;feature&#34;&gt;Feature&lt;/h2&gt;

&lt;p&gt;some results or progress information for PFRA&lt;/p&gt;

&lt;h2 id=&#34;write-your-own-kernel&#34;&gt;Write your own kernel&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://os.phil-opp.com/&#34;&gt;Writing an OS in Rust&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.brokenthorn.com/Resources/OSDevIndex.html&#34;&gt;BrokenThorn Entertainment Operating System Development Series&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;build&#34;&gt;Build&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;if no .config, every config tools make a .config from scrach!&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;oldconfig just for new moduels patch merged in trunk. This no any relations to .config.old and /boot/config.x.y.z&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;make localmodconfig will reduce many unused kernel config.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;make bzImage  #kmods will not build that configured with M!&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;make modules_install INSTALL_MOD_PATH=/home/firo/kmods&lt;br /&gt;
##build signle kernel module&lt;br /&gt;
make menuconfig&lt;br /&gt;
make oldconfig &amp;amp;&amp;amp; make prepare&lt;br /&gt;
make -C $(pwd) M=/home/firo/linux/fs/ext3 modules V=1&lt;br /&gt;
make ARCH=arm CROSS_COMPILE=/usr/bin/arm-linux-gnu- drivers/pcmcia/sa11xx_base.o&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;git-repos&#34;&gt;Git repos&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/572068/&#34;&gt;Git tree maintenance&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;next-tree-2-6-1x-latest-tree-please-rebase-your-patch-against-this-tree-before-send-it-to-upstream&#34;&gt;next tree - 2.6.1x ~ latest tree; please rebase your patch against this tree before send it to upstream&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kernel.org/doc/man-pages/linux-next.html&#34;&gt;Working with linux-next&lt;/a&gt;&lt;br /&gt;
git add git://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git&lt;/p&gt;

&lt;h2 id=&#34;tglx-tree-2-4-2-6-1x&#34;&gt;tglx tree - 2.4 - 2.6.1x&lt;/h2&gt;

&lt;p&gt;origin  git://git.kernel.org/pub/scm/linux/kernel/git/tglx/history.git (fetch)&lt;br /&gt;
origin  git://git.kernel.org/pub/scm/linux/kernel/git/tglx/history.git (push)&lt;/p&gt;

&lt;h2 id=&#34;history-tree-0-2-4&#34;&gt;history tree - 0 - 2.4&lt;/h2&gt;

&lt;p&gt;origin  &lt;a href=&#34;https://git.kernel.org/pub/scm/linux/kernel/git/history/history.git/&#34;&gt;https://git.kernel.org/pub/scm/linux/kernel/git/history/history.git/&lt;/a&gt; (fetch)&lt;br /&gt;
origin  &lt;a href=&#34;https://git.kernel.org/pub/scm/linux/kernel/git/history/history.git/&#34;&gt;https://git.kernel.org/pub/scm/linux/kernel/git/history/history.git/&lt;/a&gt; (push)&lt;br /&gt;
git checkout -b 240p 2.4.0-prerelease&lt;/p&gt;

&lt;h1 id=&#34;blogs&#34;&gt;Blogs&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.joelfernandes.org/linuxinternals/&#34;&gt;http://www.joelfernandes.org/linuxinternals/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://paulmck.livejournal.com/&#34;&gt;https://paulmck.livejournal.com/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;traning&#34;&gt;Traning&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kernel.org/doc/htmldocs/kernel-hacking/index.html&#34;&gt;Unreliable Guide To Hacking The Linux Kernel&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://linux-kernel-labs.github.io/master/index.html&#34;&gt;Bootlin linux kernel labs&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;mailing-list-archives&#34;&gt;Mailing list archives&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kernel.org/lore.html&#34;&gt;The Linux Kernel Archives&lt;/a&gt;&lt;br /&gt;
Online: &lt;a href=&#34;https://lore.kernel.org/lists.html&#34;&gt;https://lore.kernel.org/lists.html&lt;/a&gt;&lt;br /&gt;
Git: &lt;a href=&#34;https://git.kernel.org/pub/scm/public-inbox/&#34;&gt;https://git.kernel.org/pub/scm/public-inbox/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/758034/&#34;&gt;LKML archives on lore.kernel.org&lt;/a&gt;&lt;br /&gt;
and marc.info&lt;/p&gt;

&lt;h1 id=&#34;source-code-navigator&#34;&gt;Source code navigator&lt;/h1&gt;

&lt;p&gt;Just make tags; make cscope&lt;br /&gt;
&lt;a href=&#34;https://www.gnu.org/software/global/links.html&#34;&gt;&amp;lsquo;Source code reading&amp;rsquo; related sites&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;kvm&#34;&gt;KVM&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://blacks3pt3mb3r.wordpress.com/linux-stuffz/264-2/&#34;&gt;Building a KVM host machine.&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/660404/&#34;&gt;Speeding up kernel development with QEMU&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://mgalgs.github.io/2015/05/16/how-to-build-a-custom-linux-kernel-for-qemu-2015-edition.html&#34;&gt;How to Build A Custom Linux Kernel For Qemu&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;build-minimal-bootable-rootfs-fedora&#34;&gt;Build minimal bootable rootfs - fedora&lt;/h2&gt;

&lt;p&gt;./etc/yum.repos.d/&lt;br /&gt;
./etc/yum.repos.d/fedora-updates-testing.repo&lt;br /&gt;
./etc/yum.repos.d/fedora.repo&lt;br /&gt;
./etc/yum.repos.d/fedora-updates.repo&lt;br /&gt;
./etc/yum.repos.d/fedora-cisco-openh264.repo&lt;br /&gt;
can be gotten by supermin &amp;ndash;prepare bash -o /tmp/supermin.d&lt;br /&gt;
or just copy from you host to some place like /home/firo/kernel/k/testfs/&lt;br /&gt;
sudo dnf &amp;ndash;releasever=27 &amp;ndash;installroot=/home/firo/kernel/k/testfs/ &amp;ndash;setopt=reposdir=/home/firo/kernel/k/testfs/etc/yum.repos.d install dnf udev passwd&lt;/p&gt;

&lt;h2 id=&#34;how-to-build-a-minimal-kernel-for-testing&#34;&gt;How to build a minimal kernel for testing?&lt;/h2&gt;

&lt;p&gt;[tiny config @ kernel.org][5]&lt;br /&gt;
[3 attempts to reduce the configurations][6]&lt;br /&gt;
&lt;a href=&#34;7&#34;&gt;Fedora equivalent of debootstrap&lt;/a&gt;&lt;br /&gt;
Then enable following config option&lt;br /&gt;
CONFIG_CHR_DEV_SG&lt;br /&gt;
Some ftrace stuff&lt;br /&gt;
CONFIG_SLUB&lt;br /&gt;
CONFIG_KASAN&lt;/p&gt;

&lt;h2 id=&#34;kernel-org-build-a-tiny-kernel-https-tiny-wiki-kernel-org&#34;&gt;&lt;a href=&#34;https://tiny.wiki.kernel.org/&#34;&gt;Kernel.org: Build a tiny kernel&lt;/a&gt;&lt;/h2&gt;

&lt;h2 id=&#34;kvm-and-nfs&#34;&gt;KVM and NFS&lt;/h2&gt;

&lt;p&gt;qemu-system-x86_64 -nographic -enable-kvm  -kernel ./bzImag  -append &amp;lsquo; console=ttyS0 ip=dhcp root=/dev/nfs nfsroot=192.168.0.104:/home/firo/kernel/k/testfs,nfsvers=3,tcp rw nfsrootdebug debug  raid=noautodetect selinux=0 enforcing=0 &amp;lsquo;&lt;br /&gt;
dnf install nfs-utils&lt;br /&gt;
cat /etc/exports # For more details, man exports&lt;br /&gt;
/home/firo/kernel/k/testfs 127.0.0.1(rw,sync,fsid=0,no_root_squash)&lt;br /&gt;
systemctl start nfs-server.service&lt;br /&gt;
systemctl status nfs-server.service&lt;br /&gt;
● nfs-server.service - NFS server and services&lt;br /&gt;
   Loaded: loaded (/usr/lib/systemd/system/nfs-server.service; disabled; vendor preset: disabled)&lt;br /&gt;
   Active: active (exited) since Sat 2018-03-17 17:52:29 CST; 4s ago&lt;/p&gt;

&lt;h3 id=&#34;test-the-nfs&#34;&gt;Test the nfs&lt;/h3&gt;

&lt;p&gt;sudo mount -t nfs localhost://home/firo/kernel/k/testfs /mnt&lt;br /&gt;
if touch prermission denied, add no_all_squash to/etc/exports&lt;/p&gt;

&lt;h2 id=&#34;nfs-errors&#34;&gt;NFS errors&lt;/h2&gt;

&lt;p&gt;[   54.600121] NFS: sending MNT request for 10.0.2.2:/buildarea1/firo/ima/export/dist&lt;br /&gt;
[   54.600121] NFS: failed to create MNT RPC client, status=-101&lt;br /&gt;
[   54.600121] NFS: unable to mount server 10.0.2.2, error -101&lt;br /&gt;
CONFIG_E100 CONFIG_E1000 &amp;hellip;and IP_PNP and DHCP BOOTP RARP&lt;br /&gt;
try: nfsvers=3,tcp and 192.168.0.104 or 10.0.2.2 are mandatory!&lt;/p&gt;

&lt;h2 id=&#34;nfs-vers&#34;&gt;NFS vers&lt;/h2&gt;

&lt;p&gt;rpcinfo -t localhost nfs&lt;br /&gt;
program 100003 version 3 ready and waiting&lt;br /&gt;
program 100003 version 4 ready and waiting&lt;br /&gt;
rpcinfo -p | grep nfs&lt;br /&gt;
    100003    3   tcp   2049  nfs&lt;br /&gt;
    100003    4   tcp   2049  nfs&lt;br /&gt;
    100227    3   tcp   2049  nfs_acl&lt;/p&gt;

&lt;h1 id=&#34;submitting-patch&#34;&gt;Submitting patch&lt;/h1&gt;

&lt;h2 id=&#34;patch-prefix&#34;&gt;Patch prefix&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;git log --oneline  path/to/file.c
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;resending-the-patch&#34;&gt;Resending the patch&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://meta.stackexchange.com/questions/314212/why-is-it-called-initial-revision-if-its-not-a-revision&#34;&gt;First revision, version, second revision&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://kernelnewbies.org/Outreachyfirstpatch&#34;&gt;Versioning one patch revision&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://kernelnewbies.org/PatchTipsAndTricks&#34;&gt;For example, if you&amp;rsquo;re sending the second revision of a patch, you should use [PATCH v2]&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://kernelnewbies.org/PatchPhilosophy&#34;&gt;use PATCHv2 (or PATCHv3 and so on) in the subject lines instead of PATCH &amp;hellip; To update the subject lines, add the -v 2 (or -v 3, etc) options to git format-patch&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://kernelnewbies.org/PatchPhilosophy&#34;&gt;Finally, to send your new patch series as a reply to the previous one, first look up the Message-Id of the cover letter (or the one-and-only patch) in your previous patch series, and then pass that to the &amp;ndash;in-reply-to= option of either git format-patch or git send-email.&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://kernelnewbies.org/PatchTipsAndTricks&#34;&gt;Patch v2, v3, &amp;hellip; Changes, tags&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;patch-in-series-with-a-cover&#34;&gt;Patch in series with a cover&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;proxychains git send-email --subject &amp;quot;[PATCH v2 0/15] Remove unneeded casts of memory-alloc function return values&amp;quot; --thread --compose --confirm=compose --to firogm@gmail.com *.patch
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;dave-s-miller-s-perferences&#34;&gt;Dave S Miller&amp;rsquo;s perferences&lt;/h2&gt;

&lt;p&gt;@@ -325,13 +325,15 @@ static inline void empty_child_dec(struct key_vector *n)&lt;br /&gt;
  static struct key_vector *leaf_new(t_key key, struct fib_alias *fa)&lt;br /&gt;
  {&lt;br /&gt;
-       struct tnode *kv = kmem_cache_alloc(trie_leaf_kmem, GFP_KERNEL);&lt;br /&gt;
-       struct key_vector *l = kv-&amp;gt;kv;&lt;br /&gt;
+       struct tnode *kv;&lt;br /&gt;
+       struct key_vector *l;&lt;br /&gt;
Dave Miller usually prefers it if variables are ordered from longest to shortest.  So you should probably have l defined first, and then kv.&lt;/p&gt;

&lt;h2 id=&#34;julia-lawall-sorry-to-be-picky&#34;&gt;Julia Lawall Sorry to be picky,&lt;/h2&gt;

&lt;p&gt;but normally people put a space after the colon.  Also,&lt;br /&gt;
the subject line could be shorter: Remove unneeded cast.&lt;br /&gt;
The description part of the subject doesnt have to be unique,&lt;br /&gt;
just the whole thing, asfter the [PATCH] part.&lt;/p&gt;

&lt;h2 id=&#34;dan-carpenter&#34;&gt;Dan Carpenter&lt;/h2&gt;

&lt;p&gt;Otherwise your patch was fine, btw.  Other improvements.&lt;br /&gt;
Don&amp;rsquo;t put &amp;ldquo;Drivers:&amp;rdquo; in the subject.&lt;br /&gt;
On Wed, Apr 22, 2015 at 09:10:50PM +0800, Firo Yang wrote:&lt;br /&gt;
&amp;gt; From: Firo Yang &lt;a href=&#34;mailto:firogm@gmail.com&#34;&gt;firogm@gmail.com&lt;/a&gt;&lt;br /&gt;
Don&amp;rsquo;t include this line.  We can get it from you email address.&lt;br /&gt;
Include everyone from the ./scripts/get_maintainer.pl output except&lt;br /&gt;
don&amp;rsquo;t include linux-kernel@vger.kernel.org if there is another mailing&lt;br /&gt;
list there already.&lt;/p&gt;

&lt;h1 id=&#34;git-mutt-patch&#34;&gt;git mutt patch&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=6zUVS4kJtrA&#34;&gt;Greg: How to Apply a Patch to the Linux Kernel Stable Tree&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;newbies-what-to-do&#34;&gt;newbies! what to do?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/286244/&#34;&gt;Peter Zijlstra: From DOS to kernel hacking&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://kernelnewbies.org/KernelJanitors/Todo&#34;&gt;KernelJanitors/Todo&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/284099/&#34;&gt;linux-wanking@vger.kernel.org&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;smatch&#34;&gt;Smatch&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    make CHECK=&amp;quot;~/path/to/smatch/smatch -p=kernel&amp;quot; C=1 \
            bzImage modules | tee warns.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;coccinelle&#34;&gt;Coccinelle&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>An introduction to File system in Linux operating system</title>
      <link>http://firoyang.org/cs/fs/</link>
      <pubDate>Fri, 27 Feb 2015 15:46:12 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/fs/</guid>
      <description>

&lt;h1 id=&#34;rootfs&#34;&gt;rootfs&lt;/h1&gt;

&lt;p&gt;init_mount_tree&lt;br /&gt;
and sys_chroot&lt;/p&gt;

&lt;h1 id=&#34;fsck&#34;&gt;fsck&lt;/h1&gt;

&lt;p&gt;man systemd-fsck-root.service&lt;/p&gt;

&lt;h1 id=&#34;mkfs&#34;&gt;mkfs&lt;/h1&gt;

&lt;p&gt;e2fsprog&lt;/p&gt;

&lt;h1 id=&#34;block-size&#34;&gt;block size&lt;/h1&gt;

&lt;p&gt;blockdev &amp;ndash;getbsz /dev/sda1&lt;br /&gt;
4096&lt;br /&gt;
sudo tune2fs -l /dev/sda1 | grep size&lt;/p&gt;

&lt;h1 id=&#34;lqo&#34;&gt;LQO&lt;/h1&gt;

&lt;p&gt;如果是很多基本概念没有可以看看，因为就是个中规中矩的教科书，从历史到单机存储方方面面，如果写过store，就没必要了，可以关心rise lab 或者peloton lab他们的项目和publication，我曾经想弄存储，最后觉得最后都是玩电路了，感觉自己玩不下去，就放弃了。整体的工业设计可以找找emc的人写的书&lt;/p&gt;

&lt;h1 id=&#34;acl&#34;&gt;ACL&lt;/h1&gt;

&lt;p&gt;man chmod&lt;/p&gt;

&lt;h2 id=&#34;t-vs-t&#34;&gt;T vs t&lt;/h2&gt;

&lt;p&gt;只有owner 和root才能删除这个文件, 用于/tmp&lt;br /&gt;
touch /tmp/firo; ls -l /tmp/firo&lt;br /&gt;
-rw-rw-r&amp;ndash; 1 firo firo 0 Sep 24 21:20 /tmp/firo&lt;br /&gt;
chmod +t /tmp/firo; ls -l /tmp/firo&lt;br /&gt;
-rw-rw-r-T 1 firo firo 0 Sep 24 21:20 /tmp/firo&lt;br /&gt;
chmod +x /tmp/firo; ls -l /tmp/firo&lt;br /&gt;
-rwxrwxr-t 1 firo firo 0 Sep 24 21:20 /tmp/firo&lt;/p&gt;

&lt;h1 id=&#34;linus-on-atime&#34;&gt;Linus on atime&lt;/h1&gt;

&lt;p&gt;perhaps the most stupid Unix design idea of all times,&amp;rdquo; adding: &amp;ldquo;Think about this a bit: &amp;lsquo;For every file that is read from the disk, lets do a &amp;hellip; write to the disk! And, for every file that is already cached and which we read from the cache &amp;hellip; do a write to the disk!&amp;rsquo;&amp;rdquo; He further emphasized the performance impact thus:&lt;br /&gt;
&lt;a href=&#34;http://web.archive.org/web/20110427023154/http:/kerneltrap.org/node/14148&#34;&gt;Linux: Replacing atime With relatime&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;linus-on-everything-is-a-file&#34;&gt;Linus on  Everything is a file&lt;/h2&gt;

&lt;p&gt;The whole point with &amp;ldquo;everything is a file&amp;rdquo; is not that you have some&lt;br /&gt;
random filename (indeed, sockets and pipes show that &amp;ldquo;file&amp;rdquo; and &amp;ldquo;filename&amp;rdquo;&lt;br /&gt;
have nothing to do with each other), but the fact that you can use common&lt;br /&gt;
tools to operate on different things. - &lt;a href=&#34;http://yarchive.net/comp/linux/everything_is_file.html&#34;&gt;Linus&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;hard-link&#34;&gt;Hard Link&lt;/h2&gt;

&lt;p&gt;hard link to directory, recursive&lt;br /&gt;
hard link to file accross partitions, may led confilict with inode number.&lt;/p&gt;

&lt;h1 id=&#34;sysfs&#34;&gt;Sysfs&lt;/h1&gt;

&lt;p&gt;sysfs is strongly depend on driver module, just rmmod tg3 then /sys/class/net/enp9s0 went away!&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/604413/&#34;&gt;hierarchy of sysfs&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;4-10&#34;&gt;4.10 +&lt;/h2&gt;

&lt;p&gt;kernfs_drain&lt;/p&gt;

&lt;h2 id=&#34;3-14&#34;&gt;3.14&lt;/h2&gt;

&lt;dl&gt;
&lt;dt&gt;modprobe uio_dma_proxy&lt;br /&gt;&lt;/dt&gt;
&lt;dd&gt;&amp;gt; /sys/kernel/debug/tracing/trace&lt;br /&gt;
cat /sys/class/uio/uio0/name &amp;amp;&lt;br /&gt;
echo 1 &amp;gt; /sys/kernel/debug/tracing/tracing_on&lt;br /&gt;
modprobe -r uio_dma_proxy &amp;amp;&lt;br /&gt;
sleep 1&lt;br /&gt;
echo 0 &amp;gt; /sys/kernel/debug/tracing/tracing_on&lt;br /&gt;
#Why DDM?&lt;br /&gt;
The device model was originally intended to make power management tasks easier&lt;br /&gt;&lt;/dd&gt;
&lt;dd&gt;I/o Architecture&lt;br /&gt;
1 Expansion hardware.&lt;br /&gt;
Bus includes internal bus/system bus(PCI,ISA,SBus,I2C) and external bus(ieee1394/firewire,USB) and both(SCSI).&lt;br /&gt;
2 Communication with peripherals&lt;br /&gt;
I/O ports&lt;br /&gt;
I/O memory mapping&lt;br /&gt;
Interrupts&lt;br /&gt;
hrough the maintenance of a representation of the host system&amp;rsquo;s hardware structure.&lt;br /&gt;
&lt;br /&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;modprobe uio_dma_proxy&lt;br /&gt;&lt;/dt&gt;
&lt;dd&gt;&amp;gt; /sys/kernel/debug/tracing/trace&lt;br /&gt;
cat /sys/class/uio/uio0/name &amp;amp;&lt;br /&gt;
echo 1 &amp;gt; /sys/kernel/debug/tracing/tracing_on&lt;br /&gt;
modprobe -r uio_dma_proxy &amp;amp;&lt;br /&gt;
sleep 1&lt;br /&gt;
echo 0 &amp;gt; /sys/kernel/debug/tracing/tracing_on&lt;br /&gt;
#Why DDM?&lt;br /&gt;
The device model was originally intended to make power management tasks easier&lt;br /&gt;&lt;/dd&gt;
&lt;dd&gt;I/o Architecture&lt;br /&gt;
1 Expansion hardware.&lt;br /&gt;
Bus includes internal bus/system bus(PCI,ISA,SBus,I2C) and external bus(ieee1394/firewire,USB) and both(SCSI).&lt;br /&gt;
2 Communication with peripherals&lt;br /&gt;
I/O ports&lt;br /&gt;
I/O memory mapping&lt;br /&gt;
Interrupts&lt;br /&gt;
hrough the maintenance of a representation of the host system&amp;rsquo;s hardware structure.&lt;br /&gt;
&lt;br /&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;modprobe uio_dma_proxy&lt;br /&gt;&lt;/dt&gt;
&lt;dd&gt;&amp;gt; /sys/kernel/debug/tracing/trace&lt;br /&gt;
cat /sys/class/uio/uio0/name &amp;amp;&lt;br /&gt;
echo 1 &amp;gt; /sys/kernel/debug/tracing/tracing_on&lt;br /&gt;
modprobe -r uio_dma_proxy &amp;amp;&lt;br /&gt;
sleep 1&lt;br /&gt;
echo 0 &amp;gt; /sys/kernel/debug/tracing/tracing_on&lt;br /&gt;
#Why DDM?&lt;br /&gt;
The device model was originally intended to make power management tasks easier&lt;br /&gt;&lt;/dd&gt;
&lt;dd&gt;I/o Architecture&lt;br /&gt;
1 Expansion hardware.&lt;br /&gt;
Bus includes internal bus/system bus(PCI,ISA,SBus,I2C) and external bus(ieee1394/firewire,USB) and both(SCSI).&lt;br /&gt;
2 Communication with peripherals&lt;br /&gt;
I/O ports&lt;br /&gt;
I/O memory mapping&lt;br /&gt;
Interrupts&lt;br /&gt;
hrough the maintenance of a representation of the host system&amp;rsquo;s hardware structure.&lt;br /&gt;
&lt;br /&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;modprobe uio_dma_proxy&lt;br /&gt;&lt;/dt&gt;
&lt;dd&gt;&amp;gt; /sys/kernel/debug/tracing/trace&lt;br /&gt;
cat /sys/class/uio/uio0/name &amp;amp;&lt;br /&gt;
echo 1 &amp;gt; /sys/kernel/debug/tracing/tracing_on&lt;br /&gt;
modprobe -r uio_dma_proxy &amp;amp;&lt;br /&gt;
sleep 1&lt;br /&gt;
echo 0 &amp;gt; /sys/kernel/debug/tracing/tracing_on&lt;br /&gt;
#Why DDM?&lt;br /&gt;
The device model was originally intended to make power management tasks easier&lt;br /&gt;&lt;/dd&gt;
&lt;dd&gt;I/o Architecture&lt;br /&gt;
1 Expansion hardware.&lt;br /&gt;
Bus includes internal bus/system bus(PCI,ISA,SBus,I2C) and external bus(ieee1394/firewire,USB) and both(SCSI).&lt;br /&gt;
2 Communication with peripherals&lt;br /&gt;
I/O ports&lt;br /&gt;
I/O memory mapping&lt;br /&gt;
Interrupts&lt;br /&gt;
hrough the maintenance of a representation of the host system&amp;rsquo;s hardware structure.&lt;br /&gt;
&lt;br /&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;dl&gt;
&lt;dt&gt;modprobe uio_dma_proxy&lt;br /&gt;&lt;/dt&gt;
&lt;dd&gt;&amp;gt; /sys/kernel/debug/tracing/trace&lt;br /&gt;
cat /sys/class/uio/uio0/name &amp;amp;&lt;br /&gt;
echo 1 &amp;gt; /sys/kernel/debug/tracing/tracing_on&lt;br /&gt;
modprobe -r uio_dma_proxy &amp;amp;&lt;br /&gt;
sleep 1&lt;br /&gt;
echo 0 &amp;gt; /sys/kernel/debug/tracing/tracing_on&lt;br /&gt;
#Why DDM?&lt;br /&gt;
The device model was originally intended to make power management tasks easier&lt;br /&gt;&lt;/dd&gt;
&lt;dd&gt;I/o Architecture&lt;br /&gt;
1 Expansion hardware.&lt;br /&gt;
Bus includes internal bus/system bus(PCI,ISA,SBus,I2C) and external bus(ieee1394/firewire,USB) and both(SCSI).&lt;br /&gt;
2 Communication with peripherals&lt;br /&gt;
I/O ports&lt;br /&gt;
I/O memory mapping&lt;br /&gt;
Interrupts&lt;br /&gt;
hrough the maintenance of a representation of the host system&amp;rsquo;s hardware structure.&lt;br /&gt;
&lt;br /&gt;&lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;entation of the host system&amp;rsquo;s hardware structure.&lt;/p&gt;

&lt;h1 id=&#34;procfs&#34;&gt;Procfs&lt;/h1&gt;

&lt;p&gt;##How many parts does procfs has?&lt;br /&gt;
* process-specific read only /proc/&lt;pid&gt;/&lt;br /&gt;
* process tuneable interface. /proc/&lt;pid&gt;/&lt;br /&gt;
* kernel sysctl, importanta kernel tuneable files. /proc/sys/kernel net vm fs&amp;hellip;&lt;br /&gt;
* Read only kernel infomation. /proc&lt;br /&gt;
##I think, important directory need to know.&lt;br /&gt;
/proc/sys/kernel&lt;/p&gt;

&lt;h1 id=&#34;btrfs&#34;&gt;btrfs&lt;/h1&gt;

&lt;p&gt;Bdi related&lt;br /&gt;
mount, super_block&lt;br /&gt;
ffff8800f4455740 ffff8800f27f2000 btrfs  /dev/xvda2 /&lt;br /&gt;
ffff880002844200 ffff8800f2798800 autofs systemd-1 /@/proc/sys/fs/binfmt_misc&lt;br /&gt;
ffff8800f44553c0 ffff8800f3d05800 mqueue mqueue    /@/dev/mqueue&lt;br /&gt;
ffff8800f4533c80 ffff8800f44d2000 debugfs debugfs  /@/sys/kernel/debug&lt;br /&gt;
ffff8800f200fc80 ffff8800f27f2000 btrfs  /dev/xvda2 /@/var/cache&lt;br /&gt;
ffff8800f37d9740 ffff8800f27f2000 btrfs  /dev/xvda2 /@/opt&lt;br /&gt;
ffff8800f4455200 ffff8800f27f2000 btrfs  /dev/xvda2 /@/tmp&lt;br /&gt;
ffff8800f4455040 ffff8800f27f2000 btrfs  /dev/xvda2 /@/global/local&lt;br /&gt;
ffff8800f245c900 ffff8800f2eda000 ext3   /dev/xvda1 /@/boot&lt;br /&gt;
ffff880002844040 ffff8800f27f2000 btrfs  /dev/xvda2 /@/var/spool&lt;br /&gt;
ffff880002840040 ffff8800f27f2000 btrfs  /dev/xvda2 /@/var/tmp&lt;br /&gt;
ffff880002840200 ffff8800f27f2000 btrfs  /dev/xvda2 /@/var/opt&lt;br /&gt;
ffff8800f200f900 ffff8800f27f2000 btrfs  /dev/xvda2 /@/var/log&lt;br /&gt;
ffff8800028403c0 ffff8800f27f2000 btrfs  /dev/xvda2 /@/home&lt;br /&gt;
ffff8800f245ce40 ffff8800f27f2000 btrfs  /dev/xvda2 /@/.snapshots&lt;br /&gt;
ffff8800f37d93c0 ffff8800f27f2000 btrfs  /dev/xvda2 /@/lfs&lt;br /&gt;
btrfs_mount&lt;br /&gt;
btrfs_fill_super&lt;br /&gt;
setup_bdi&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux device driver</title>
      <link>http://firoyang.org/cs/device/</link>
      <pubDate>Fri, 27 Feb 2015 15:46:12 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/device/</guid>
      <description>

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;Driver porting: Device model overview: &lt;a href=&#34;http://lwn.net/Articles/31185/&#34;&gt;http://lwn.net/Articles/31185/&lt;/a&gt;&lt;br /&gt;
Documentation/driver-model&lt;br /&gt;
The Linux Kernel Driver Model&lt;/p&gt;

&lt;h1 id=&#34;formal-causes&#34;&gt;Formal causes&lt;/h1&gt;

&lt;h2 id=&#34;dma&#34;&gt;DMA&lt;/h2&gt;

&lt;p&gt;ULK 3rd&lt;/p&gt;

&lt;h2 id=&#34;mapping&#34;&gt;Mapping&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/653585/&#34;&gt;ioremap() and memremap()&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;device-tree&#34;&gt;Device tree&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;What infomation was included in dtb&lt;br /&gt;
HW platform识别，runtime parameter传递以及硬件设备描述&lt;br /&gt;
for platform device init see arch/powerpc/platforms/52xx/media5200.c ppc_init&lt;br /&gt;
mpc52xx_declare_of_platform_devices&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;How does the device tree subsystem read and parse the dts file?&lt;br /&gt;
#devres&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;devm_kfree&lt;br /&gt;
&lt;a href=&#34;http://lists.freedesktop.org/archives/dri-devel/2013-May/038943.html&#34;&gt;devm_kfree does not need for fail case of probe function and for remove function.&lt;/a&gt;&lt;br /&gt;
__device_release_driver&lt;br /&gt;
really_probe&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;a must use devm_kfree Julia Lawall&lt;br /&gt;
The function at91_dt_node_to_map is ultimately called by the function&lt;br /&gt;
&amp;gt; pinctrl_get, which is an exported function.  Since it is possible that this&lt;br /&gt;
&amp;gt; function is not called from within a probe function, for safety, the kfree&lt;br /&gt;
&amp;gt; is converted to a devm_kfree, to both free the data and remove it from the&lt;br /&gt;
&amp;gt; device in a failure situation.&lt;br /&gt;
*for noop devm_kmalloc_release&lt;br /&gt;
devm_kmalloc()-&amp;gt;dr = alloc_dr(devm_kmalloc_release, size, gfp);&lt;br /&gt;
see release_nodes() -&amp;gt;kfree(dr);&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Power management</title>
      <link>http://firoyang.org/dark_ages/pm/</link>
      <pubDate>Fri, 27 Feb 2015 15:46:12 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/dark_ages/pm/</guid>
      <description>

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.wowotech.net/pm_subsystem/generic_pm_architecture.html&#34;&gt;wowotech&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/384146/&#34;&gt;The cpuidle subsystem&lt;/a&gt;cpuidle—Do nothing, efficiently&lt;br /&gt;
&lt;a href=&#34;http://www.marvell.com/embedded-processors/armada-xp/assets/HW_MV78460_OS.PDF&#34;&gt;Hardware Specifications 9.4&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.marvell.com/embedded-processors/armada-xp/assets/ARMADA-XP-Functional-SpecDatasheet.pdf&#34;&gt;Functional Specifications 34&lt;/a&gt;&lt;br /&gt;
Documentation/power&lt;br /&gt;
Controlling Processor C-State Usage in Linux&lt;br /&gt;
&lt;a href=&#34;http://doc.opensuse.org/documentation/html/openSUSE_114/opensuse-tuning/cha.tuning.power.html&#34;&gt;Chapter 11. Power Management&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;C-states: idle core power state&lt;/p&gt;

&lt;h1 id=&#34;the-structure-of-pm-source-codes&#34;&gt;The structure of PM source codes&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Interface&lt;br /&gt;
syscall /sys/power&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;PM core&lt;br /&gt;
kernel/power&lt;br /&gt;
main.c suspend.c suspend_test.c console.c process.c&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Device PM&lt;br /&gt;
driver/base/power &amp;ndash; Power management interface, firo&lt;br /&gt;
power management 是针对device, bus, driver这部分的. 在suspend_devices_and_enter用到dpm_suspend_start.&lt;br /&gt;
driver/各种设备的驱动&lt;br /&gt;
driver/cpuidle &amp;ndash;firo&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Platform PM&lt;br /&gt;
include/linux/suspend.h&amp;mdash;-定义platform dependent PM有关的操作函数集&lt;br /&gt;
就是他platform_suspend_ops&lt;br /&gt;
arch/xxx/mach-xxx/xxx.c or arch/xxx/plat-xxx/xxx.c&amp;mdash;-平台相关的电源管理操作&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;CPU control&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;important-data-structure&#34;&gt;Important data structure&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Platform PM&lt;br /&gt;
platform_suspend_ops, platform plat-* is equivalent to mach-* and microarchitecture.&lt;br /&gt;
plat-* is abustruct from mach-*1 and mach-&lt;em&gt;2 and so on.&lt;br /&gt;
mach-&lt;/em&gt; is more closer to Board!&lt;br /&gt;
所以这个platform_suspend_ops, 是非常重要的, 他包含了所有BSP底层的内容.&lt;br /&gt;
竟然是用suspend_ops这个全局变量, 来承载所有platform相关的内容.&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Device PM&lt;br /&gt;
dev_pm_ops这个和上面是完全不同的两条调用路线,在suspend_devices_and_enter用到dpm_suspend_start.&lt;/p&gt;

&lt;h1 id=&#34;steps-of-suspend&#34;&gt;Steps of suspend&lt;/h1&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Function steps&lt;br /&gt;
state_store-&amp;gt;pm_suspend-&amp;gt;enter_state-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
valid_state &amp;amp; suspend_prepare&lt;br /&gt;
suspend_devices_and_enter-&amp;gt; {&lt;br /&gt;
    suspend_console &amp;amp; ftrace_stop &amp;amp; dpm_suspend_start&lt;br /&gt;
    suspend_enter-&amp;gt;&lt;br /&gt;
    {&lt;br /&gt;
        disable_nonboot_cpus &amp;amp; arch_suspend_disable_irqs&lt;br /&gt;
    }&lt;br /&gt;
}&lt;br /&gt;
}&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;PM core&lt;br /&gt;
freeze userspace&lt;br /&gt;
console&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Device PM&lt;br /&gt;
suspend device&lt;br /&gt;
before and first part in suspend_enter&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Mass stuffs&lt;br /&gt;
CPU &amp;amp; IRQ disable&lt;br /&gt;
syscore&lt;br /&gt;
Device PM check wakeup pendings&lt;br /&gt;
middle part in suspend_enter&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Platform PM&lt;br /&gt;
last part in suspend_enter&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;introdution&#34;&gt;Introdution&lt;/h1&gt;

&lt;p&gt;电源管理都涉及到那些内容?&lt;br /&gt;
PMU MP and DEV, CPU cores, L2 cache, Coherency Fabric, Devices&lt;br /&gt;
Core Power Modes: run, idle/WFI/WFE/stadnby, deep idle/power down&lt;br /&gt;
* WFI: core power down except snoop and interrupt cache working&lt;br /&gt;
disable clocks of the CPU&lt;br /&gt;
snoop other Cores and io agent.&lt;br /&gt;
only snoop block are temporarily woken up and the block back to WFI mode after complete snoop.&lt;br /&gt;
can recognize interrupt.&lt;br /&gt;
* Power down: core power down, l1 flush, cache not mantained/snoop stoped, but l2 &amp;amp; fabric&lt;br /&gt;
can not recognize interrupt, recovery is fully depended on MP_PMU&lt;/p&gt;

&lt;p&gt;In hardware layer, we need &lt;a href=&#34;https://en.wikipedia.org/wiki/Power_Management_Unit&#34;&gt;PMU&lt;/a&gt; to complete power management.&lt;br /&gt;
What is the relation of PMU and CPU?&lt;br /&gt;
armadaxp的PMU与CPU物理上与逻辑上是独立的.&lt;br /&gt;
The Power Management functions are provided by two power manager units:&lt;br /&gt;
The Device Power Management Unit (DEV_PMU)&lt;br /&gt;
The Multiprocessor Power Management Service Unit (MP_PMU).&lt;br /&gt;
PMU省电模式:&lt;/p&gt;

&lt;h1 id=&#34;kernel-cpuidle-subsystem&#34;&gt;kernel cpuidle subsystem&lt;/h1&gt;

&lt;h2 id=&#34;steps-of-cpuilde&#34;&gt;Steps of cpuilde&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;interface&lt;br /&gt;
kernel sched and sysfs&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cpuidle core&lt;br /&gt;
cpuidle.c、driver.c、governor.c、sysfs.c。&lt;br /&gt;
抽象出cpuidle device、cpuidle driver、cpuidle governor三个实体&lt;br /&gt;
一个core对应一个cpuidle device drivers/cpuidle/cpuidle.c.&lt;br /&gt;
device 和driver隔离, 通过全局变量联系 ifndef CONFIG_CPU_IDLE_MULTIPLE_DRIVERS&lt;br /&gt;
管理cpuidle driver 和governor&lt;br /&gt;
上层sched模块 和sysfs 提供接口&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cpuidle governors&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cpuidle drivers&lt;br /&gt;
drivers/cpudile/cpuidle-xxx.c or&lt;br /&gt;
arch/arm/plat-armada/cpuidle.c&lt;br /&gt;
如何进入idle状态&lt;br /&gt;
什么条件下会退出&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;source-code-layout&#34;&gt;Source code layout&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;drivers/cpuidle&lt;br /&gt;
include/linux/cpuidle.h&lt;br /&gt;
cpuidle core、cpuidle governors和cpuidle drivers三个模块&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;kernel\sched\idle.c&lt;br /&gt;
kernel sched中的cpuidle entry&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;important-data-structre&#34;&gt;Important data structre&lt;/h2&gt;

&lt;p&gt;struct cpuidle_driver&lt;br /&gt;
struct cpuidle_state&lt;br /&gt;
struct cpuidle_device used by ladder or menu&lt;/p&gt;

&lt;p&gt;device_initcall -&amp;gt; armadaxp_init_cpuidle -&amp;gt; cpuidle_register_driver  cpuidle_register_device&lt;br /&gt;
cpu_idle -&amp;gt; cpuidle_idle_call&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux memory management</title>
      <link>http://firoyang.org/cs/mm/</link>
      <pubDate>Sun, 28 Dec 2014 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/mm/</guid>
      <description>

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://landley.net/writing/memory-faq.txt&#34;&gt;A must-read: memory FAQ by Landley&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.usenix.org/system/files/conference/atc16/atc16_paper-huang.pdf&#34;&gt;An Evolutionary Study of Linux Memory Management for Fun and Profit&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.kernel.org/doc/html/v4.18/vm/index.html&#34;&gt;Kernel developers MM documentation&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.kernel.org/doc/html/latest/admin-guide/mm/index.html&#34;&gt;kernel.org Memory Management&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://linux-mm.org/&#34;&gt;https://linux-mm.org/&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;history&#34;&gt;History&lt;/h1&gt;

&lt;p&gt;Dragon book 9th chapter 8 main memory&lt;/p&gt;

&lt;h2 id=&#34;1964-fixed-sized-partitioning&#34;&gt;1964 fixed-sized partitioning&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Memory_management_(operating_systems)#Partitioned_allocation&#34;&gt;Partitioned allocation&lt;/a&gt;&lt;br /&gt;
Dragon OS book 8.3.2 Memory Allocation&lt;br /&gt;
OSIDP: 7.2 MEMORY PARTITIONING&lt;br /&gt;
fixed-sized partitions.&lt;br /&gt;
variable-partition scheme or Segmentation&lt;/p&gt;

&lt;h2 id=&#34;1959-paging&#34;&gt;1959 paging&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Paging&#34;&gt;Paging&lt;/a&gt; according to &lt;a href=&#34;https://en.wikipedia.org/wiki/Virtual_memory&#34;&gt;History of VM&lt;/a&gt; is developed at 1959.&lt;/p&gt;

&lt;h2 id=&#34;1961-segmentation&#34;&gt;1961 segmentation&lt;/h2&gt;

&lt;p&gt;Fist appears in Burroughs B5500&lt;/p&gt;

&lt;h2 id=&#34;1963-1965-buddy-system&#34;&gt;1963 ~ 1965  buddy system&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Buddy_memory_allocation&#34;&gt;Buddy memory allocation&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;1956-1962-vm&#34;&gt;1956 ~ 1962 VM&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://denninginstitute.com/pjd/PUBS/bvm.pdf&#34;&gt;BEFORE MEMORY WAS VIRTUAL&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/253361/&#34;&gt;Memory part 3: Virtual Memory&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;purposes&#34;&gt;Purposes&lt;/h1&gt;

&lt;h2 id=&#34;keeping-track-of-physical-memory&#34;&gt;keeping track of physical memory,&lt;/h2&gt;

&lt;p&gt;Buddy system, why?&lt;/p&gt;

&lt;h2 id=&#34;obtain-alloc-and-return-free-memory&#34;&gt;obtain/alloc and return/free memory&lt;/h2&gt;

&lt;p&gt;page allocator&lt;br /&gt;
page reclamation, memory compaction&lt;/p&gt;

&lt;h2 id=&#34;lift-the-burden-of-loading-program-from-application&#34;&gt;Lift the burden of loading program from application&lt;/h2&gt;

&lt;p&gt;paging&lt;/p&gt;

&lt;h2 id=&#34;user-space-application&#34;&gt;user space application&lt;/h2&gt;

&lt;p&gt;VM, memory mapping.&lt;/p&gt;

&lt;h2 id=&#34;mitigating-fragmenatations&#34;&gt;mitigating fragmenatations&lt;/h2&gt;

&lt;p&gt;buddy system, memory compaction&lt;/p&gt;

&lt;h1 id=&#34;formal-cause&#34;&gt;Formal cause&lt;/h1&gt;

&lt;p&gt;[Dynamic Storage Allocation: A Survey and Critical Review]&lt;/p&gt;

&lt;h2 id=&#34;memory-partitioning&#34;&gt;Memory partitioning&lt;/h2&gt;

&lt;p&gt;Check OSIDP 7.2&lt;/p&gt;

&lt;h3 id=&#34;page-vs-variable-sized-memory-allocations&#34;&gt;Page vs variable-sized memory allocations&lt;/h3&gt;

&lt;p&gt;By variable-sized, we are not taking historical segementation.&lt;br /&gt;
Placement algorithm: Best-fit, first-fit. Within variable-szied memory allocations, it&amp;rsquo;s very difficult to track free memories compared with page-sized.&lt;/p&gt;

&lt;h3 id=&#34;segmentation&#34;&gt;Segmentation&lt;/h3&gt;

&lt;p&gt;OSIDP&lt;br /&gt;
The difference, compared to dynamic partitioning, is that with seg-&lt;br /&gt;
mentation a program may occupy more than one partition, and these partitions&lt;br /&gt;
need not be contiguous. Segmentation eliminates internal fragmentation but, like&lt;br /&gt;
dynamic partitioning, it suffers from external fragmentation. However, because a&lt;br /&gt;
process is broken up into a number of smaller pieces, the external fragmentation&lt;br /&gt;
should be less.&lt;/p&gt;

&lt;h3 id=&#34;buddy-system-1965-a-fast-storage-allocator-http-sci-hub-tw-https-dl-acm-org-citation-cfm-doid-365628-365655-buddy-memory-allocation-https-en-wikipedia-org-wiki-buddy-memory-allocation&#34;&gt;&lt;a href=&#34;http://sci-hub.tw/https://dl.acm.org/citation.cfm?doid=365628.365655&#34;&gt;buddy system 1965 a fast storage allocator.&lt;/a&gt; &lt;a href=&#34;https://en.wikipedia.org/wiki/Buddy_memory_allocation&#34;&gt;Buddy memory allocation&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://dl.acm.org/citation.cfm?id=359626&#34;&gt;buddy system variants 1977&lt;/a&gt;&lt;br /&gt;
The following cited from above 1965 paper.&lt;br /&gt;
The oporations involved in obtaining blocks from and retm&amp;rsquo;ning thom to the free&lt;br /&gt;
storage lists aro vory fast, making this scheme particularly appropriate for list structure operations and for other&lt;br /&gt;
situations involving many sizes of blocks which are fixed in size and location. This is in fact tho storago bookkeeping&lt;br /&gt;
mothod used in tho Boll Telephone Laboratories Low-Level List Language&amp;rsquo;&lt;/p&gt;

&lt;p&gt;OSIDP&lt;br /&gt;
Both fixed and dynamic partitioning schemes have drawbacks. A fixed partitioning&lt;br /&gt;
scheme limits the number of active processes and may use space inefficiently if there is&lt;br /&gt;
a poor match between available partition sizes and process sizes. A dynamic partition-&lt;br /&gt;
ing scheme is more complex to maintain and includes the overhead of compaction. An&lt;br /&gt;
interesting compromise is the buddy system&lt;/p&gt;

&lt;h2 id=&#34;fragmentations&#34;&gt;Fragmentations&lt;/h2&gt;

&lt;h2 id=&#34;zones&#34;&gt;Zones&lt;/h2&gt;

&lt;p&gt;ULK 2: 7.1.2 Memory Zones&lt;br /&gt;
LDD: Memory zones&lt;br /&gt;
LKD3: Zones&lt;br /&gt;
UVM: Chapter 2  Describing Physical Memory&lt;br /&gt;
history: commit 4d1ceac2980133513fec009b18514f026ff58afa (tag: 2.3.23pre5)&lt;br /&gt;
Author: Linus Torvalds &lt;a href=&#34;mailto:torvalds@linuxfoundation.org&#34;&gt;torvalds@linuxfoundation.org&lt;/a&gt;&lt;br /&gt;
Date:   Fri Nov 23 15:27:55 2007 -0500&lt;br /&gt;
    Import 2.3.23pre5&lt;br /&gt;
+#define MEM_TYPE_DMA           0&lt;br /&gt;
+#define MEM_TYPE_NORMAL                1&lt;br /&gt;
+#define MEM_TYPE_HIGH          2&lt;/p&gt;

&lt;p&gt;history: commit cb75bc5a9d9a433f6b5c8015a0f43c1b4d0fad79 (tag: 2.3.27pre6)&lt;br /&gt;
Author: Linus Torvalds &lt;a href=&#34;mailto:torvalds@linuxfoundation.org&#34;&gt;torvalds@linuxfoundation.org&lt;/a&gt;&lt;br /&gt;
Date:   Fri Nov 23 15:28:33 2007 -0500&lt;br /&gt;
    Import 2.3.27pre6&lt;br /&gt;
+ *  Reshaped it to be a zoned allocator, Ingo Molnar, Red Hat, 1999&lt;br /&gt;
-#define MEM_TYPE_DMA           0&lt;br /&gt;
-#define MEM_TYPE_NORMAL                1&lt;br /&gt;
+#define ZONE_DMA               0&lt;br /&gt;
+#define ZONE_NORMAL            1&lt;br /&gt;
-static struct free_area_struct free_area[NR_MEM_TYPES][NR_MEM_LISTS];&lt;br /&gt;
+typedef struct zone_struct {&lt;/p&gt;

&lt;h1 id=&#34;material&#34;&gt;Material&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/753269/&#34;&gt;Zone-lock and mmap_sem scalability&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Page frame reclaimation</title>
      <link>http://firoyang.org/cs/pfra/</link>
      <pubDate>Sun, 28 Dec 2014 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/pfra/</guid>
      <description>

&lt;h1 id=&#34;formal-causes&#34;&gt;Formal causes&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kernel.org/doc/gorman/html/understand/understand013.html&#34;&gt;Chapter 10  Page Frame Reclamation&lt;/a&gt;&lt;br /&gt;
Exceptional condition&lt;br /&gt;
2nd chance&lt;/p&gt;

&lt;h2 id=&#34;reverse-process-of-page-fault-of-a-memory-mapping&#34;&gt;reverse process of page fault of a memory  mapping&lt;/h2&gt;

&lt;p&gt;PTEs: try_to_unmap:&lt;br /&gt;
Dirty? Buffer_head?&lt;/p&gt;

&lt;h3 id=&#34;remove-mapping-file-swap-in-pas&#34;&gt;remove_mapping: file/swap in PAS&lt;/h3&gt;

&lt;p&gt;commit 49d2e9cc4544369635cd6f4ef6d5bb0f757079a7&lt;br /&gt;
Refs: v2.6.15-1461-g49d2e9cc4544&lt;br /&gt;
Author:     Christoph Lameter &lt;a href=&#34;mailto:clameter@sgi.com&#34;&gt;clameter@sgi.com&lt;/a&gt;&lt;br /&gt;
AuthorDate: Sun Jan 8 01:00:48 2006 -0800&lt;br /&gt;
Commit:     Linus Torvalds &lt;a href=&#34;mailto:torvalds@g5.osdl.org&#34;&gt;torvalds@g5.osdl.org&lt;/a&gt;&lt;br /&gt;
CommitDate: Sun Jan 8 20:12:41 2006 -0800&lt;br /&gt;
    [PATCH] Swap Migration V5: migrate_pages() function&lt;/p&gt;

&lt;h2 id=&#34;workingset&#34;&gt;workingset&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/495543/&#34;&gt;Better active/inactive list balancing&lt;/a&gt;&lt;br /&gt;
commit a528910e12ec7ee203095eb1711468a66b9b60b0&lt;br /&gt;
Refs: v3.14-7406-ga528910e12ec&lt;br /&gt;
Author:     Johannes Weiner &lt;a href=&#34;mailto:hannes@cmpxchg.org&#34;&gt;hannes@cmpxchg.org&lt;/a&gt;&lt;br /&gt;
AuthorDate: Thu Apr 3 14:47:51 2014 -0700&lt;br /&gt;
Commit:     Linus Torvalds &lt;a href=&#34;mailto:torvalds@linux-foundation.org&#34;&gt;torvalds@linux-foundation.org&lt;/a&gt;&lt;br /&gt;
CommitDate: Thu Apr 3 16:21:01 2014 -0700&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mm: thrash detection-based file cache sizing
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;gfp-flags&#34;&gt;GFP flags&lt;/h1&gt;

&lt;p&gt;__GFP_IO: allow disk IO&lt;br /&gt;
__GFP_FS: allow fs operations, depend on io.&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/594725/&#34;&gt;Avoiding memory-allocation deadlocks&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;etc-for-general-idea-of-page-reclaimation-from-brown&#34;&gt;ETC for general idea of page reclaimation from Brown&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/596618/&#34;&gt;Understanding __GFP_FS&lt;/a&gt;&lt;br /&gt;
__GFP_DIRECT_RECLAIM&lt;br /&gt;
__GFP_MEMALLOC allows access to all memory. This should only be used when&lt;br /&gt;
the caller guarantees the allocation will allow more memory to be freed&lt;br /&gt;
very shortly e.g. process exiting or swapping. Users either should&lt;br /&gt;
be the MM or co-ordinating closely with the VM (e.g. swap over NFS).&lt;br /&gt;
Check sk_set_memalloc&lt;br /&gt;
&lt;strong&gt;GFP_KSWAPD_RECLAIM indicates that the caller wants to wake kswapd when&lt;br /&gt;
 * the low watermark is reached and have it reclaim pages until the high&lt;br /&gt;
 * watermark is reached. A caller may wish to clear this flag when fallback&lt;br /&gt;
 * options are available and the reclaim is likely to disrupt the system. The&lt;br /&gt;
 * canonical example is THP allocation where a fallback is cheap but&lt;br /&gt;
 * reclaim/compaction may cause indirect stalls.&lt;br /&gt;
GFP_ATOMIC  (&lt;/strong&gt;GFP_HIGH|&lt;strong&gt;GFP_ATOMIC|&lt;/strong&gt;GFP_KSWAPD_RECLAIM)&lt;br /&gt;
GFP_KERNEL  (__GFP_RECLAIM | __GFP_IO | &lt;strong&gt;GFP_FS)&lt;br /&gt;
GFP_NOWAIT  (&lt;/strong&gt;GFP_KSWAPD_RECLAIM)&lt;br /&gt;
GFP_NOIO    (&lt;strong&gt;GFP_RECLAIM)&lt;br /&gt;
GFP_NOFS    (&lt;/strong&gt;GFP_RECLAIM | __GFP_IO)&lt;/p&gt;

&lt;h2 id=&#34;for-interrupt-handler-and-atomic-context&#34;&gt;For interrupt handler and atomic context&lt;/h2&gt;

&lt;p&gt;commit 0aaa29a56e4fb0fc9e24edb649e2733a672ca099&lt;br /&gt;
Author: Mel Gorman &lt;a href=&#34;mailto:mgorman@techsingularity.net&#34;&gt;mgorman@techsingularity.net&lt;/a&gt;&lt;br /&gt;
Date:   Fri Nov 6 16:28:37 2015 -0800&lt;br /&gt;
    mm, page_alloc: reserve pageblocks for high-order atomic allocations on demand&lt;br /&gt;
gfp_to_alloc_flags&lt;br /&gt;
/*&lt;br /&gt;
 * The caller may dip into page reserves a bit more if the caller&lt;br /&gt;
 * cannot run direct reclaim, or if the caller has realtime scheduling&lt;br /&gt;
 * policy or is asking for &lt;strong&gt;GFP_HIGH memory.  GFP_ATOMIC requests will&lt;br /&gt;
 * set both ALLOC_HARDER (&lt;/strong&gt;GFP_ATOMIC) and ALLOC_HIGH (__GFP_HIGH).&lt;br /&gt;
 */&lt;/p&gt;

&lt;h3 id=&#34;alloc-high&#34;&gt;ALLOC_HIGH:&lt;/h3&gt;

&lt;p&gt;__zone_watermark_ok()&lt;br /&gt;
        if (alloc_flags &amp;amp; ALLOC_HIGH)&lt;br /&gt;
                min -= min / 2;&lt;/p&gt;

&lt;h3 id=&#34;alloc-harder&#34;&gt;ALLOC_HARDER&lt;/h3&gt;

&lt;p&gt;rmqueue()&lt;br /&gt;
if (alloc_flags &amp;amp; ALLOC_HARDER) {&lt;br /&gt;
                        page = __rmqueue_smallest(zone, order, MIGRATE_HIGHATOMIC);&lt;/p&gt;

&lt;h1 id=&#34;page-flags&#34;&gt;Page flags&lt;/h1&gt;

&lt;p&gt;PG_reclaim:&lt;br /&gt;
commit 3b0db538ef6782a1e2a549c68f1605ca8d35dd7e&lt;br /&gt;
Author: Andrew Morton &lt;a href=&#34;mailto:akpm@digeo.com&#34;&gt;akpm@digeo.com&lt;/a&gt;&lt;br /&gt;
Date:   Mon Dec 2 21:31:09 2002 -0800&lt;br /&gt;
    [PATCH] Move reclaimable pages to the tail ofthe inactive list on&lt;br /&gt;
PG_swapcace means page is in the swap cache.&lt;br /&gt;
PG_swapbacked: stack, heap, data segment, anoymous mmap, shmem, it means page is backed by RAM or Swap. It means this page is no real file related(pagecache), reclaim this page should use swap.&lt;br /&gt;
PG_active: active page&lt;br /&gt;
PG_referenced: accessed recently&lt;br /&gt;
PG_lru: page is on the lru linked list&lt;br /&gt;
PG_mlocked: mlock()&lt;br /&gt;
PG_locked in generic_file_buffered_read add_to_page_cache_lru and __SetPageLocked&lt;br /&gt;
check mark_buffer_async_read&lt;br /&gt;
tglx tree&lt;br /&gt;
commit d58e41eec6859e9590f8f70ccdc1d58f4f6a1b84&lt;br /&gt;
Author: Andrew Morton &lt;a href=&#34;mailto:akpm@zip.com.au&#34;&gt;akpm@zip.com.au&lt;/a&gt;&lt;br /&gt;
Date:   Sun May 5 01:10:37 2002 -0700&lt;br /&gt;
    [PATCH] Fix concurrent writepage and readpage&lt;/p&gt;

&lt;h1 id=&#34;page-reference-results&#34;&gt;Page reference results&lt;/h1&gt;

&lt;p&gt;enum page_references {&lt;br /&gt;
        PAGEREF_RECLAIM,    # Try reclaim this page.&lt;br /&gt;
        PAGEREF_RECLAIM_CLEAN,  # Try relcaim this page, if clean.&lt;br /&gt;
&lt;a href=&#34;https://lore.kernel.org/patchwork/patch/189879/&#34;&gt;But you were thinking right, it is exactly what it means!  If the state is PAGEREF_RECLAIM_CLEAN, reclaim the page if it is clean:&lt;/a&gt;&lt;br /&gt;
        PAGEREF_KEEP,       # Keep this page on inactive list.&lt;br /&gt;
        PAGEREF_ACTIVATE,   # Move this page to active list or inevicatble.&lt;br /&gt;
};&lt;/p&gt;

&lt;h1 id=&#34;process-flags&#34;&gt;Process flags&lt;/h1&gt;

&lt;h2 id=&#34;pf-memalloc&#34;&gt;PF_MEMALLOC&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kernel.org/doc/gorman/html/understand/understand009.html&#34;&gt;UVM&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lore.kernel.org/patchwork/cover/178099/&#34;&gt;Kill PF_MEMALLOC abuse&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://stackoverflow.com/a/40899585/1025001&#34;&gt;without being forced to write out dirty pages&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://bbs.chinaunix.net/thread-4078724-1-1.html&#34;&gt;并不是所有进程都有的。kswapd，direct reclaim的process等在回收的时候会设置这个标志&lt;/a&gt;&lt;br /&gt;
check __perform_reclaim&lt;br /&gt;
memalloc_noreclaim_save&lt;br /&gt;
kswapd-&amp;gt; PF_MEMALLOC-&amp;gt; try to pageout some pages -&amp;gt;  allocates some page using alloc_page for pageout -&amp;gt; no memory in lowreserve -&amp;gt; goto slowpath&lt;br /&gt;
        /* Avoid recursion of direct reclaim */&lt;br /&gt;
        if (current-&amp;gt;flags &amp;amp; PF_MEMALLOC)&lt;br /&gt;
                goto nopage;&lt;br /&gt;
otherwise&lt;br /&gt;
    &lt;strong&gt;alloc_pages_direct_reclaim-&amp;gt;&lt;/strong&gt;perform_reclaim-&amp;gt;Set PF_MEMALLOC.&lt;/p&gt;

&lt;h2 id=&#34;gfp-pfmemalloc-flags&#34;&gt;__gfp_pfmemalloc_flags&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;            if (current-&amp;gt;flags &amp;amp; PF_MEMALLOC)
                    return ALLOC_NO_WATERMARKS;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;get-page-from-freelist&#34;&gt;get_page_from_freelist&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;                    if (alloc_flags &amp;amp; ALLOC_NO_WATERMARKS)
                            goto try_this_zone;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;pfmemalloc&#34;&gt;PFMEMALLOC&lt;/h1&gt;

&lt;h2 id=&#34;prep-new-page&#34;&gt;prep_new_page&lt;/h2&gt;

&lt;p&gt;page_is_pfmemalloc&lt;br /&gt;
Example: get_page_from_freelist and __ac_get_obj&lt;br /&gt;
               /*&lt;br /&gt;
                 * page is set pfmemalloc is when ALLOC_NO_WATERMARKS was&lt;br /&gt;
                 * necessary to allocate the page. The expectation is&lt;br /&gt;
                 * that the caller is taking steps that will free more&lt;br /&gt;
                 * memory. The caller should avoid the page being used&lt;br /&gt;
                 * for !PFMEMALLOC purposes.&lt;br /&gt;
                 */&lt;br /&gt;
                if (alloc_flags &amp;amp; ALLOC_NO_WATERMARKS)&lt;br /&gt;
                        set_page_pfmemalloc(page);&lt;br /&gt;
commit c93bdd0e03e848555d144eb44a1f275b871a8dd5&lt;br /&gt;
Author: Mel Gorman &lt;a href=&#34;mailto:mgorman@suse.de&#34;&gt;mgorman@suse.de&lt;/a&gt;&lt;br /&gt;
Date:   Tue Jul 31 16:44:19 2012 -0700&lt;br /&gt;
    netvm: allow skb allocation to use PFMEMALLOC reserves&lt;/p&gt;

&lt;h1 id=&#34;kswapd&#34;&gt;Kswapd&lt;/h1&gt;

&lt;p&gt;pgdat-&amp;gt;kswapd_wait&lt;br /&gt;
It&amp;rsquo;s not peoridic. Check kswapd_try_to_sleep: premature sleep and full sleep.&lt;br /&gt;
&lt;a href=&#34;https://www.kernel.org/doc/gorman/html/understand/understand013.html#toc71&#34;&gt;Historically, kswapd used to wake up every 10 seconds but now it is only woken by the physical page allocator when the pages_low number of free pages in a zone is reached&lt;/a&gt;&lt;br /&gt;
se.sum_exec_runtime                          :             0.036973&lt;br /&gt;
se.avg.last_update_time                      :           1884199936&lt;/p&gt;

&lt;h2 id=&#34;fastpath-boosted-watermark&#34;&gt;Fastpath boosted  watermark&lt;/h2&gt;

&lt;p&gt;ZONE_BOOSTED_WATERMARK&lt;br /&gt;
get_page_from_freelist-&amp;gt;rmqueue-&amp;gt;wakeup_kswapd&lt;br /&gt;
kswapd-&amp;gt;balance_pgdat-&amp;gt;kswapd_shrink_node-&amp;gt;shrink_node&lt;br /&gt;
{&lt;br /&gt;
    shrink_node_memcg-&amp;gt; shrink_list&lt;br /&gt;
    or maybe&lt;br /&gt;
    shrink_slab&lt;br /&gt;
}&lt;/p&gt;

&lt;h2 id=&#34;slowpath-gfp-kswapd-reclaim&#34;&gt;Slowpath: __GFP_KSWAPD_RECLAIM&lt;/h2&gt;

&lt;p&gt;wake_all_kswapds(order, gfp_mask, ac)&lt;/p&gt;

&lt;h2 id=&#34;slowpath-direct-reclaim-synchronous-page-reclaim-throttle-direct-reclaim&#34;&gt;Slowpath: direct reclaim synchronous page reclaim  throttle_direct_reclaim&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;alloc_pages_direct_reclaim-&amp;gt;&lt;/strong&gt;perform_reclaim-&amp;gt;try_to_free_pages-&amp;gt;allow_direct_reclaim-&amp;gt;wake_up_interruptible(&amp;amp;pgdat-&amp;gt;kswapd_wait)&lt;/p&gt;

&lt;h1 id=&#34;fastpath-watermake-low-node-reclaim-or-zone-reclaim&#34;&gt;Fastpath watermake low, node reclaim or zone reclaim&lt;/h1&gt;

&lt;p&gt;Documentation/sysctl/vm.txt&lt;br /&gt;
/proc/sys/vm/zone_reclaim_mode&lt;br /&gt;
get_page_from_freelist-&amp;gt;node_reclaim-&amp;gt;__node_reclaim-&amp;gt;shrink_node&lt;/p&gt;

&lt;h1 id=&#34;slow-path&#34;&gt;Slow path&lt;/h1&gt;

&lt;h2 id=&#34;direct-compact-allocation&#34;&gt;Direct compact allocation&lt;/h2&gt;

&lt;p&gt;__alloc_pages_direct_compact&lt;/p&gt;

&lt;h2 id=&#34;direct-reclaim-allocation&#34;&gt;Direct reclaim allocation&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;alloc_pages_direct_reclaim-&amp;gt;&lt;/strong&gt;perform_reclaim-&amp;gt;try_to_free_pages&lt;br /&gt;
{&lt;br /&gt;
    throttle_direct_reclaim&lt;br /&gt;
    do_try_to_free_pages-&amp;gt; shrink_zones-&amp;gt;mem_cgroup_soft_limit_reclaim -&amp;gt;mem_cgroup_soft_reclaim -&amp;gt;mem_cgroup_shrink_node-&amp;gt;shrink_node&lt;br /&gt;
}&lt;/p&gt;

&lt;h2 id=&#34;direct-compact-allocation-1&#34;&gt;Direct compact allocation&lt;/h2&gt;

&lt;h1 id=&#34;hibernate&#34;&gt;Hibernate&lt;/h1&gt;

&lt;p&gt;hibernate_preallocate_memory-&amp;gt;shrink_all_memory&lt;/p&gt;

&lt;h1 id=&#34;writepage-and-end-page-writeback&#34;&gt;writepage and end_page_writeback&lt;/h1&gt;

&lt;p&gt;Check Locking&lt;/p&gt;

&lt;h1 id=&#34;reclaimable-pages&#34;&gt;Reclaimable pages&lt;/h1&gt;

&lt;p&gt;all pages of a User Mode process are reclaimable except locked.&lt;br /&gt;
Lokced userspace pages:&lt;br /&gt;
1. Temporarily locked pages: PG_locked,&lt;br /&gt;
2. Memory locked pages: VM_LOCKED, &lt;a href=&#34;https://eklitzke.org/mlock-and-mlockall&#34;&gt;Misunderstanding mlock&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;swapbacked-pages&#34;&gt;Swapbacked pages&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Private&lt;br /&gt;
1.1 malloc memory map&lt;br /&gt;
1.2 Dirty file private mapping - data, bbs segments&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Shared - tmpfs:&lt;br /&gt;
2.1 Anonymous shared mapping memory between P&amp;C;&lt;br /&gt;
2.2 System v IPC shared memory.&lt;/p&gt;

&lt;h2 id=&#34;filebacked-pages&#34;&gt;Filebacked pages&lt;/h2&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Private: Clean file private mapping - text segment&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Shared: Shared file mapping memory.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;lru-2q&#34;&gt;LRU-2Q&lt;/h1&gt;

&lt;p&gt;page.lru and struct lruvec&lt;br /&gt;
New page is inserted to head, PG_reclaim page is rotated to the tail.&lt;/p&gt;

&lt;h2 id=&#34;move-lru-page-reclaim-from-zones-to-node&#34;&gt;Move LRU page reclaim from zones to node&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.org/lkml/2015/6/8/298&#34;&gt;1st RFC&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;shrink-active-list&#34;&gt;shrink_active_list&lt;/h2&gt;

&lt;p&gt;lru_to_page(head) (list_entry((head)-&amp;gt;prev, struct page, lru))&lt;/p&gt;

&lt;h2 id=&#34;active-list-and-inactive-list&#34;&gt;active list and inactive list&lt;/h2&gt;

&lt;p&gt;active list: working set; Am of LRU 2Q; how often&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/495543/&#34;&gt;Better active/inactive list balancing&lt;/a&gt;&lt;br /&gt;
mark_page_accessed and called sub-functions.&lt;br /&gt;
active -&amp;gt; inactive head - list_add(&amp;amp;page-&amp;gt;lru, &amp;amp;l_inactive); in shrink_active_list&lt;br /&gt;
inactive -&amp;gt; active head - __activate_page &amp;lt;- mark_page_accessed &amp;lt;- pagecache_get_page or generic_file_buffered_read&lt;br /&gt;
inactive -&amp;gt; inactive tail - rotate_reclaimable_page&lt;/p&gt;

&lt;h1 id=&#34;second-chance&#34;&gt;Second chance&lt;/h1&gt;

&lt;p&gt;commit dfc8d636cdb95f7b792d5ba8c9f3b295809c125d&lt;br /&gt;
Author: Johannes Weiner &lt;a href=&#34;mailto:hannes@cmpxchg.org&#34;&gt;hannes@cmpxchg.org&lt;/a&gt;&lt;br /&gt;
Date:   Fri Mar 5 13:42:19 2010 -0800&lt;br /&gt;
    vmscan: factor out page reference checks&lt;br /&gt;
commit 645747462435d84c6c6a64269ed49cc3015f753d&lt;br /&gt;
Author: Johannes Weiner &lt;a href=&#34;mailto:hannes@cmpxchg.org&#34;&gt;hannes@cmpxchg.org&lt;/a&gt;&lt;br /&gt;
Date:   Fri Mar 5 13:42:22 2010 -0800&lt;br /&gt;
    vmscan: detect mapped file pages used only once&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=eHK749r5RGs&#34;&gt;Second Chance Page Replacement Algorithm&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=DFmsm0J8joY&#34;&gt;Second Chance Page Replacement Algorithms and Clock Page Replacement Algorithms&lt;/a&gt;&lt;br /&gt;
core: page_check_references() in shrink_page_list().&lt;br /&gt;
shrink_active_list for VM_EXEC page.&lt;br /&gt;
core: page_referenced in shrink_active_list&lt;br /&gt;
mark_page_accessed&lt;br /&gt;
{&lt;br /&gt;
        inactive,referenced          -&amp;gt;      active,unreferenced&lt;br /&gt;
        {&lt;br /&gt;
                if !PageLRU - on the pagevec&lt;br /&gt;
                        mm: activate !PageLRU pages on mark_page_accessed if page is on local pagevec - 059285a25f30c13ed4f5d91cecd6094b9b20bb7b&lt;br /&gt;
                        SetPageActive&lt;br /&gt;
                else&lt;br /&gt;
                        activate_page&lt;br /&gt;
        }&lt;br /&gt;
        {in,}active,unreferenced        -&amp;gt;      {in,}active,referenced&lt;br /&gt;
        {&lt;br /&gt;
                SetPageReferenced&lt;br /&gt;
        }&lt;br /&gt;
}&lt;/p&gt;

&lt;h4 id=&#34;active-list&#34;&gt;active list -&amp;gt;&lt;/h4&gt;

&lt;p&gt;if pte with PAGE_ACCESSED - referenced in page_referenced() &amp;amp;&amp;amp; VM_EXEC -&amp;gt; keep it in active list - tail -&amp;gt; head - rotated&lt;br /&gt;
else&lt;br /&gt;
de-activate it to inactive list head&lt;/p&gt;

&lt;h4 id=&#34;inactive-list&#34;&gt;inactive list&lt;/h4&gt;

&lt;p&gt;page from tail page_check_references&lt;br /&gt;
{&lt;br /&gt;
        3 passes:&lt;br /&gt;
        1. hardware pte; use and clear pte; might get reference; second chance.&lt;br /&gt;
        2. software flag: -&amp;gt; RECLAIM Clean page and clear, since dirty page is a good signal that the page was used recently because the flusher threads&lt;br /&gt;
                                clean pages periodically.&lt;br /&gt;
        3. reclaim&lt;br /&gt;
        hardware accessed - if accessed, won&amp;rsquo;t reclaim&lt;br /&gt;
        {&lt;br /&gt;
                PAGEREF_ACTIVATE: incline to activate swapbacked page&lt;br /&gt;
                        PageSwapBacked&lt;br /&gt;
                        referenced_page&lt;br /&gt;
                        referenced_ptes &amp;gt; 1&lt;br /&gt;
                        vm_flags &amp;amp; VM_EXEC&lt;br /&gt;
                PAGEREF_KEEP&lt;br /&gt;
        }&lt;br /&gt;
        else if ?? software accessed - &amp;amp;&amp;amp; dirty won&amp;rsquo;t reclaim&lt;br /&gt;
        {&lt;br /&gt;
                vmscan: detect mapped file pages used only once - 645747462435d84c6c6a64269ed49cc3015f753d&lt;br /&gt;
                vmscan,tmpfs: treat used once pages on tmpfs as used once - 2e30244a7cc1ff09013a1238d415b4076406388e&lt;br /&gt;
                # From above commits: When a page has PG_referenced, shrink_page_list() discards it only if it&lt;br /&gt;
                # is not dirty. &amp;hellip; PG_dirty is a good signal that the page was used recently because&lt;br /&gt;
                # the flusher threads clean pages periodically.  In addition, page writeback&lt;br /&gt;
                # is costlier than simple page discard.&lt;br /&gt;
                #  Firo: not incline to reclaim dirty page.&lt;br /&gt;
                #  Firo: PG_referenced -&amp;gt; PAGEREF_RECLAIM_CLEAN&lt;br /&gt;
                file-backed -&amp;gt; PAGEREF_RECLAIM_CLEAN&lt;br /&gt;
                swapbacked -&amp;gt; PAGEREF_RECLAIM&lt;br /&gt;
        } else&lt;br /&gt;
                PAGEREF_RECLAIM&lt;br /&gt;
}&lt;/p&gt;

&lt;h3 id=&#34;working-set&#34;&gt;Working set&lt;/h3&gt;

&lt;p&gt;mm: thrash detection-based file cache sizing - a528910e12ec7ee203095eb1711468a66b9b60b0&lt;br /&gt;
&lt;a href=&#34;https://lkml.org/lkml/2012/5/1/51&#34;&gt;Not merged - mm: refault distance-based file cache sizing&lt;/a&gt;&lt;br /&gt;
workingset_eviction() and workingset_refault()&lt;br /&gt;
* WSS&lt;br /&gt;
&lt;a href=&#34;https://github.com/brendangregg/wss&#34;&gt;https://github.com/brendangregg/wss&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.10tiao.com/html/606/201807/2664605543/1.html&#34;&gt;http://www.10tiao.com/html/606/201807/2664605543/1.html&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;clock&#34;&gt;Clock ??&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://linux-mm.org/ClockProApproximation&#34;&gt;ClockProApproximation&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/147879/&#34;&gt;A CLOCK-Pro page replacement implementation&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.usenix.org/legacy/publications/library/proceedings/usenix05/tech/general/full_papers/jiang/jiang_html/html.html&#34;&gt;CLOCK-Pro: An Effective Improvement of the CLOCK Replacement&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;other-notes-on-replacement-polices&#34;&gt;Other notes on Replacement polices&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kernel.org/doc/gorman/html/understand/understand013.html&#34;&gt;https://www.kernel.org/doc/gorman/html/understand/understand013.html&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://linux-mm.org/PageReplacementDesign&#34;&gt;https://linux-mm.org/PageReplacementDesign&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://linux-mm.org/PageReplacementDesign&#34;&gt;PageReplacementDesign&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;lumpy-reclaim&#34;&gt;Lumpy reclaim&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.org/lkml/2012/3/28/325&#34;&gt;mm: vmscan: Remove lumpy reclaim&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lore.kernel.org/patchwork/patch/262301/&#34;&gt;mm: vmscan: Remove dead code related to lumpy reclaim waiting on pages under writeback&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;etc-leave-questions-open&#34;&gt;ETC Leave questions open&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;activate writeback pages&lt;br /&gt;
mm: vmscan: move dirty pages out of the way until they&amp;rsquo;re flushed - c55e8d035b28b2867e68b0e2d0eee2c0f1016b43&lt;br /&gt;
Fixing writeback from direct reclaim &lt;a href=&#34;https://lwn.net/Articles/396561/&#34;&gt;https://lwn.net/Articles/396561/&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;shrink-slab-caches&#34;&gt;Shrink slab caches&lt;/h1&gt;

&lt;h2 id=&#34;double-slab-pressure&#34;&gt;double slab pressure&lt;/h2&gt;

&lt;p&gt;tglx tree&lt;br /&gt;
commit b65bbded3935b896d55cb6b3e420a085d3089368&lt;br /&gt;
Author: Andrew Morton &lt;a href=&#34;mailto:akpm@digeo.com&#34;&gt;akpm@digeo.com&lt;/a&gt;&lt;br /&gt;
Date:   Wed Sep 25 07:20:18 2002 -0700&lt;br /&gt;
    [PATCH] slab reclaim balancing&lt;/p&gt;

&lt;h1 id=&#34;oom&#34;&gt;OOM&lt;/h1&gt;

&lt;p&gt;oom_score_adj in Documentation/filesystems/proc.txt&lt;br /&gt;
fs/proc/base.c&lt;br /&gt;
ONE(&amp;ldquo;oom_score&amp;rdquo;,  S_IRUGO, proc_oom_score),&lt;br /&gt;
REG(&amp;ldquo;oom_adj&amp;rdquo;,    S_IRUGO|S_IWUSR, proc_oom_adj_operations),&lt;br /&gt;
REG(&amp;ldquo;oom_score_adj&amp;rdquo;, S_IRUGO|S_IWUSR, proc_oom_score_adj_operations),&lt;br /&gt;
oom_badness&lt;/p&gt;

&lt;h1 id=&#34;suse-page-cache-limit&#34;&gt;SUSE page cache limit&lt;/h1&gt;

&lt;p&gt;Check box/pagecache-limit&lt;/p&gt;

&lt;h1 id=&#34;lqo&#34;&gt;LQO&lt;/h1&gt;

&lt;h2 id=&#34;mapping-is-null&#34;&gt;mapping is NULL?&lt;/h2&gt;

&lt;p&gt;e2be15f6c3eecedfbe1550cca8d72c5057abbbd2&lt;br /&gt;
+               /* Treat this page as congested if underlying BDI is */&lt;br /&gt;
+               mapping = page_mapping(page);&lt;br /&gt;
+               if (mapping &amp;amp;&amp;amp; bdi_write_congested(mapping-&amp;gt;backing_dev_info))&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/384093/&#34;&gt;When writeback goes wrong&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/405076/&#34;&gt;Dynamic writeback throttling&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/396561/&#34;&gt;Fixing writeback from direct reclaim&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
