<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Cs on f(x) </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://firoyang.org/tags/cs/</link>
    <language>en-us</language>
    <author>Firo Yang</author>
    
    <updated>Wed, 02 Jan 2019 00:00:00 UTC</updated>
    
    <item>
      <title>Kernel memory bug - SLAB&#39;s 3 lists are corrupted.</title>
      <link>http://firoyang.org/cs/bug_mm_1/</link>
      <pubDate>Wed, 02 Jan 2019 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/bug_mm_1/</guid>
      <description>

&lt;p&gt;Recently, I was working on a kernel memory bug.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://apibugzilla.suse.com/show_bug.cgi?id=1118875&#34;&gt;https://apibugzilla.suse.com/show_bug.cgi?id=1118875&lt;/a&gt;&lt;br /&gt;
L3: kernel BUG at ../mm/slab.c:2804! bad LRU list and active values in page structs in possible use-after-free&lt;/p&gt;

&lt;p&gt;After digging the binary vmcore file of kdump, I got the following findings.&lt;/p&gt;

&lt;h1 id=&#34;node-0&#34;&gt;Node 0&lt;/h1&gt;

&lt;h2 id=&#34;partial&#34;&gt;Partial&lt;/h2&gt;

&lt;p&gt;list page.lru  -H 0xffff8801a7c01348 -s page.lru,s_mem,active,slab_cache,flags &amp;gt;n0p.log&lt;br /&gt;
n0p -&amp;gt; n0f=0xffff8801a7c01358&lt;/p&gt;

&lt;h2 id=&#34;full&#34;&gt;Full&lt;/h2&gt;

&lt;p&gt;list page.lru  -H 0xffff8801a7c01358 -s page.lru,s_mem,active,slab_cache,flags &amp;gt;n0f.log&lt;br /&gt;
n0f -&amp;gt;&lt;br /&gt;
ffffea0006902380&lt;br /&gt;
    lru = {&lt;br /&gt;
      next = 0xffffea0080ed53e0,&lt;br /&gt;
      prev = 0xffffea00405f8ae0&lt;br /&gt;
    }&lt;br /&gt;
    s_mem = 0xffff8801a408e000&lt;br /&gt;
      active = 16&lt;br /&gt;
    slab_cache = 0xffff8801a7c00400&lt;br /&gt;
  flags = 6755398367314048&lt;br /&gt;
ffffea0080ed53c0&lt;br /&gt;
    lru = {&lt;br /&gt;
      next = 0xffffea00422a34e0,&lt;br /&gt;
      prev = 0xffffea00069023a0&lt;br /&gt;
    }&lt;br /&gt;
    s_mem = 0xffff88203b54f000&lt;br /&gt;
      active = 7&lt;br /&gt;
    slab_cache = 0xffff8801a7c00400&lt;br /&gt;
  flags = 24769796876796032&lt;br /&gt;
&amp;hellip; -&amp;gt; n1f = 0xffff881107c00358&lt;/p&gt;

&lt;h1 id=&#34;node-1&#34;&gt;Node 1&lt;/h1&gt;

&lt;h2 id=&#34;partial-1&#34;&gt;Partial&lt;/h2&gt;

&lt;p&gt;crash&amp;gt; list page.lru  -H 0xffff881107c00348 -s page.lru,s_mem,active,slab_cache,flags &amp;gt;n1p.log&lt;br /&gt;
nip-&amp;gt; SLAB ffffea0043ab74e0 -&amp;gt; 0xffff881107c00348 = n1p&lt;br /&gt;
SLAB ffffea0043ab74e0&amp;rsquo;s prev pointing to 0xffff881107c00358&lt;/p&gt;

&lt;h2 id=&#34;full-1&#34;&gt;Full&lt;/h2&gt;

&lt;p&gt;crash&amp;gt; list page.lru  -H 0xffff881107c00358 -s page.lru,s_mem,active,slab_cache,flags &amp;gt;n1f.log&lt;br /&gt;
n1f-&amp;gt; SLAB ffffea0043ab74e0  -&amp;gt; &amp;hellip; -&amp;gt; 0xffff881107c00348 = n1p&lt;/p&gt;

&lt;p&gt;This issue occured on a NUMA system with 2 memory nodes.&lt;br /&gt;
Both node 0 and node 1&amp;rsquo;s SLAB&amp;rsquo;s partial and full lists were corrupted. After looking into this issue a few days, I talked to Vlastimil Babka.&lt;br /&gt;
He provided a fix for this issue. That is 7810e6781e0fcbca78b91cf65053f895bf59e85f - mm, page_alloc: do not break __ GFP_THISNODE by zonelist reset.&lt;/p&gt;

&lt;p&gt;Now, I have a question: why did I cannot solve this issue?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Memory-ordering model</title>
      <link>http://firoyang.org/cs/consistency_model/</link>
      <pubDate>Sat, 16 Dec 2017 15:46:12 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/consistency_model/</guid>
      <description>

&lt;p&gt;When we are talking on memory model, we are refering memory consistency model or memory ordering model.&lt;/p&gt;

&lt;h1 id=&#34;practices&#34;&gt;Practices&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://preshing.com/20120515/memory-reordering-caught-in-the-act/&#34;&gt;Memory Reordering Caught in the Act&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;memory-model&#34;&gt;Memory model&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://homes.cs.washington.edu/~bornholt/post/memory-models.html#fn:lamport&#34;&gt;Memory Consistency Models: A Primer&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.hpl.hp.com/techreports/Compaq-DEC/WRL-95-7.pdf&#34;&gt;Shared Memory Consistency Models: A Tutorial&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://preshing.com/20120930/weak-vs-strong-memory-models/&#34;&gt;Weak vs. Strong Memory Models&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;x86-memory-model&#34;&gt;x86 memory model&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.06.07c.pdf&#34;&gt;Memory Barriers: a Hardware View for Software Hackers - must read&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://bartoszmilewski.com/2008/11/05/who-ordered-memory-fences-on-an-x86/&#34;&gt;x86 is TSO why it borthers fence?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.cnblogs.com/caidi/p/6708789.html&#34;&gt;共同进入与饥饿&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://stackoverflow.com/questions/27595595/when-are-x86-lfence-sfence-and-mfence-instructions-required&#34;&gt;When are x86 LFENCE, SFENCE and MFENCE instructions required?&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;c11-memory-model&#34;&gt;C11 memory model&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://en.cppreference.com/w/c/atomic/memory_order&#34;&gt;C memory order&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/42967.pdf&#34;&gt;Outlawing Ghosts: Avoiding Out-of-Thin-Air Results&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4375.html&#34;&gt;Out-of-Thin-Air Execution is Vacuous&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.cl.cam.ac.uk/~pes20/weakmemory/&#34;&gt;Relaxed-Memory Concurrency&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.cl.cam.ac.uk/~pes20/cpp/model.pdf&#34;&gt;Mathematizing C++ Concurrency: The Isabelle/HOL model&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;compiler-memory-model&#34;&gt;Compiler memory model&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://preshing.com/20120625/memory-ordering-at-compile-time/&#34;&gt;Memory Ordering at Compile Time&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://blog.regehr.org/archives/232&#34;&gt;A Guide to Undefined Behavior in C and C++, Part 3&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;linux-kernel-memory-model&#34;&gt;Linux kernel memory model&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/718628/&#34;&gt;A formal kernel memory-ordering model&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/720550/&#34;&gt;A formal kernel memory-ordering model (part 2)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4374.html&#34;&gt;Linux-Kernel Memory Model&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://events.linuxfoundation.org/sites/events/files/slides/LinuxMM.2016.09.19a.LCE_.pdf&#34;&gt;Linux-Kernel Memory Ordering: Help Arrives At Last!&lt;/a&gt; and &lt;a href=&#34;https://www.youtube.com/watch?v=ULFytshTvIY&#34;&gt;Talk on youtube on this!&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hello world! a journey to computer science</title>
      <link>http://firoyang.org/cs/hello/</link>
      <pubDate>Thu, 13 Apr 2017 20:42:49 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/hello/</guid>
      <description>

&lt;p&gt;In this series, I will a simple hello world program to explain the every important concept in cmputer science.&lt;br /&gt;
So let&amp;rsquo;s go.&lt;/p&gt;

&lt;p&gt;Do you know vDSO?&lt;br /&gt;
If a C program, gtod, calls the system call gettimeofday in vDSO, how does this program know the address of gettimeofday?&lt;/p&gt;

&lt;p&gt;ldd gtod&lt;br /&gt;
    linux-gate.so.1 (0xf7766000)&lt;br /&gt;
    libdl.so.2 =&amp;gt; /lib/libdl.so.2 (0xf7743000)&lt;br /&gt;
    libc.so.6 =&amp;gt; /lib/libc.so.6 (0xf7568000)&lt;br /&gt;
    /lib/ld-linux.so.2 (0x56639000)&lt;br /&gt;
Check this commit of glibc:&lt;br /&gt;
30e32d23eb06cbeae02e51c7c4df150736dba795&lt;br /&gt;
Set up GLRO(dl_sysinfo_dso) under [NEED_DL_SYSINFO_DSO] as well&lt;br /&gt;
AT_SYSINFO_EHDR&lt;/p&gt;

&lt;p&gt;Gcc 32bit support&lt;br /&gt;
ca677d3c3cd0eba7d1f03092517aea553a0e8569&lt;br /&gt;
Add x86 32 bit vDSO time function support&lt;br /&gt;
kernel&lt;br /&gt;
37c975545ec63320789962bf307f000f08fabd48&lt;/p&gt;

&lt;h1 id=&#34;start-the-program&#34;&gt;start the program&lt;/h1&gt;

&lt;p&gt;sysdeps/x86_64/dl-machine.h: -&amp;gt; _start -&amp;gt;_dl_start-&amp;gt;/elf/dl-sysdep.c:83:_dl_sysdep_start-&amp;gt;dl_main&lt;/p&gt;

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://a3f.at/lists/linkers&#34;&gt;Linkers 20 parts by Gold author Ian Lance Taylor&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/#locating-the-vdso-in-memory&#34;&gt;The Definitive Guide to Linux System Calls&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>IO and events</title>
      <link>http://firoyang.org/cs/io/</link>
      <pubDate>Tue, 04 Apr 2017 20:08:35 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/io/</guid>
      <description>

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/87892/what-is-the-status-of-posix-asynchronous-i-o-aio&#34;&gt;What is the status of POSIX asynchronous I/O AIO&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://stackoverflow.com/questions/5844955/whats-the-difference-between-event-driven-and-asynchronous-between-epoll-and-a&#34;&gt;hat&amp;rsquo;s the difference between event-driven and asynchronous? Between epoll and AIO?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://davmac.org/davpage/linux/async-io.html&#34;&gt;Asynchronous I/O and event notification on linux&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.gnu.org/software/libc/manual/html_node/Asynchronous-I_002fO.html&#34;&gt;Gnu Libc Perform I/O Operations in Parallel&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;really-confuing-conceptions&#34;&gt;Really confuing conceptions&lt;/h1&gt;

&lt;p&gt;What is Asynchronous I/O?&lt;br /&gt;
The onset of I/O is splitted from nuclus.&lt;br /&gt;
First, asynchronous I/O can be happned in UP machine.&lt;br /&gt;
AIO is based on Proactor, more portable.&lt;/p&gt;

&lt;h1 id=&#34;aynchoronous-event-notfication&#34;&gt;Aynchoronous event notfication&lt;/h1&gt;

&lt;p&gt;epoll is based on Reactor pattern.&lt;br /&gt;
signal is based on Observer pattern.&lt;br /&gt;
For the ease of use, the select loop is implemented as an &lt;em&gt;event loop&lt;/em&gt; with callbacks.&lt;br /&gt;
libevent and libev is a well-designed &lt;em&gt;event loop&lt;/em&gt;.Check shadowsocks for using of libev.&lt;/p&gt;

&lt;h1 id=&#34;faq&#34;&gt;FAQ&lt;/h1&gt;

&lt;p&gt;memory-map IO&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Softirq of Linux Kernel</title>
      <link>http://firoyang.org/cs/softirq/</link>
      <pubDate>Mon, 03 Apr 2017 13:09:05 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/softirq/</guid>
      <description>

&lt;p&gt;##softirq&lt;br /&gt;
同一个softirq可以在不同的CPU上同时运行，softirq必须是可重入的。&lt;br /&gt;
* not allow execute nest but can recusive lock:local_bh_disable&lt;br /&gt;
current-&amp;gt;preemt_count + SOFIRQ_OFFSET also disable preempt current process.&lt;br /&gt;
* hardirq on, can&amp;rsquo;t sleep&lt;br /&gt;
* not percpu&lt;/p&gt;

&lt;h2 id=&#34;tasklet-and-kernel-timer-is-based-on-softirq&#34;&gt;tasklet and kernel timer is based on softirq&lt;/h2&gt;

&lt;p&gt;新增softirq, 是要重新编译内核的, 试试tasklet也不错.&lt;br /&gt;
.不允许两个两个相同类型的tasklet同时执行，即使在不同的处理器上&lt;br /&gt;
* First of all, it&amp;rsquo;s a conglomerate of mostly unrelated jobs,&lt;br /&gt;
 which run in the context of a randomly chosen victim&lt;br /&gt;
 w/o the ability to put any control on them. &amp;ndash;Thomas Gleixner&lt;/p&gt;

&lt;p&gt;tasklet different with other softirq is run  signal cpu core&lt;br /&gt;
spinlock_bh wider then spinlock&lt;/p&gt;

&lt;p&gt;###time of softirq&lt;br /&gt;
* follow hardirq, irq_exit()&lt;br /&gt;
* re-enables softirq, local_bh_enable/spin_unlock_bh(); explicity checks executes, netstack/blockIO.&lt;br /&gt;
* ksoftirqd&lt;/p&gt;

&lt;p&gt;###tasklet&lt;br /&gt;
tasklet like a workqueue, sofirq like kthread. that is wonderful, does it?&lt;br /&gt;
tasklet 被__tasklet_schedule到某个cpu的percu 变量tasklet_vec.tail上保证了&lt;br /&gt;
只有一个cpu执行同一时刻.&lt;/p&gt;

&lt;p&gt;#FAQ&lt;br /&gt;
##When to save irq rather than just disable irq&lt;br /&gt;
local_irq_disable() used in the code path that never disabled interrupts.&lt;br /&gt;
local_irq_save(flags) used in the code path that already disabled interrupts.&lt;/p&gt;

&lt;p&gt;##what about irq nested?&lt;br /&gt;
&lt;a href=&#34;http://lwn.net/Articles/380937/&#34;&gt;http://lwn.net/Articles/380937/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://thread.gmane.org/gmane.linux.kernel/1152658&#34;&gt;Deal PF_MEMALLOC in softirq&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>x86 interrupt and exception</title>
      <link>http://firoyang.org/cs/interrupt_and_exception/</link>
      <pubDate>Mon, 03 Apr 2017 13:02:12 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/interrupt_and_exception/</guid>
      <description>

&lt;p&gt;#Interrupt&lt;/p&gt;

&lt;h2 id=&#34;init&#34;&gt;init&lt;/h2&gt;

&lt;p&gt;native_init_IRQ() -&amp;gt;  set_intr_gate(i, irq_entries_start&amp;hellip;&lt;br /&gt;
irq_entries_start define in arch/x86/kernel/entry_32.S&lt;/p&gt;

&lt;p&gt;##Interrupt Context terminology&lt;br /&gt;
* interrupt context - in_irq or in_interrupt&lt;br /&gt;
irq_enter&lt;br /&gt;
* bh context - in_softirq&lt;br /&gt;
local_bh_disable&lt;br /&gt;
__do_softirq -&amp;gt; __local_bh_disable_ip&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Scheduling in operating system</title>
      <link>http://firoyang.org/cs/scheduling/</link>
      <pubDate>Wed, 29 Mar 2017 10:49:04 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/scheduling/</guid>
      <description>

&lt;h1 id=&#34;ref&#34;&gt;ref&lt;/h1&gt;

&lt;p&gt;Process scheduling in Linux &amp;ndash; Volker Seeker from University of Edinburgh&lt;br /&gt;
&lt;a href=&#34;https://tampub.uta.fi/bitstream/handle/10024/96864/GRADU-1428493916.pdf&#34;&gt;A complete guide to Linux process scheduling&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.kernel.org/doc/Documentation/scheduler/sched-design-CFS.txt&#34;&gt;https://www.kernel.org/doc/Documentation/scheduler/sched-design-CFS.txt&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;problems&#34;&gt;Problems&lt;/h1&gt;

&lt;h2 id=&#34;why-scheduling&#34;&gt;Why scheduling?&lt;/h2&gt;

&lt;p&gt;Customers demand multitasking/concurrent&lt;br /&gt;
Processes are blocked&lt;/p&gt;

&lt;h2 id=&#34;fairness&#34;&gt;Fairness&lt;/h2&gt;

&lt;p&gt;Unit: /proc/sys/kernel/sched_min_granularity_ns&lt;/p&gt;

&lt;h1 id=&#34;conceptions&#34;&gt;Conceptions&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://android.googlesource.com/kernel/msm/+/android-msm-bullhead-3.10-marshmallow-dr/Documentation/scheduler/sched-hmp.txt&#34;&gt;Cpu capacity&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;running-compensator-records-the-running-process&#34;&gt;Running Compensator records the running process&lt;/h1&gt;

&lt;p&gt;scheduler_tick&lt;br /&gt;
{&lt;br /&gt;
    update_rq_clock&lt;br /&gt;
    task_tick_fair -&amp;gt; entity_tick&lt;br /&gt;
    {&lt;br /&gt;
        update_curr&lt;br /&gt;
        {&lt;br /&gt;
            sum_exec_runtime - total runtime&lt;br /&gt;
            cfs_rq-&amp;gt;exec_clock - cfs_rq runtime&lt;br /&gt;
            vruntime    - inverse proportion to the weight or priority&lt;br /&gt;
            update_min_vruntime&lt;br /&gt;
            {&lt;br /&gt;
                cfs_rq-&amp;gt;curr, leftmost, min_vruntime, who is min?&lt;br /&gt;
            }&lt;br /&gt;
            cpuacct - cpu sys/user time&lt;br /&gt;
        }&lt;br /&gt;
    }&lt;br /&gt;
}&lt;/p&gt;

&lt;h1 id=&#34;next-pick-next-task-fair&#34;&gt;Next -&amp;gt; pick_next_task_fair&lt;/h1&gt;

&lt;p&gt;put_prev_entity: update_curr; insert into rb-tree;&lt;br /&gt;
pick_next_entity: left most of rb-tree.&lt;br /&gt;
set_next_entity: remove next from tree since it will disturb inserting and deleting when it is being updated.&lt;/p&gt;

&lt;h1 id=&#34;unrunnable&#34;&gt;Unrunnable&lt;/h1&gt;

&lt;p&gt;dequeue_task&lt;/p&gt;

&lt;h1 id=&#34;resuming&#34;&gt;Resuming&lt;/h1&gt;

&lt;p&gt;try_to_wake_up-&amp;gt;ttwu_queue-&amp;gt;ttwu_do_activate-&amp;gt; or local wakeup: schedule-&amp;gt;try_to_wake_up_local-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    ttwu_activate               #=== speical compensation and enqueue rq&lt;br /&gt;
    {&lt;br /&gt;
        activate_task&lt;br /&gt;
        p-&amp;gt;on_rq = TASK_ON_RQ_QUEUED    #=== 1) rq for task; 2)&lt;br /&gt;
    }&lt;br /&gt;
    ttwu_do_wakeup              #=== normal compensation&lt;br /&gt;
    {&lt;br /&gt;
        check_preempt_curr&lt;br /&gt;
        p-&amp;gt;state = TASK_RUNNING;&lt;br /&gt;
    }&lt;br /&gt;
}&lt;/p&gt;

&lt;p&gt;enqueue_task-&amp;gt; place_entity compensation for wakeup process&lt;/p&gt;

&lt;h2 id=&#34;wake-up-a-sleep-task&#34;&gt;wake up a sleep task&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;se-&amp;gt;on_rq &amp;amp; TASK_ON_RQ_QUEUED; deactivate_task set on_rq to 0;
enqueue_task_fair handles group stuff
enqueue_entity deals with sched_entity - uptodate the vruntime, load average, account load numa perfering,
sysctl_sched_latency: the cfs pledge to the pre-existing tasks that they have 6ms to run before new task to run.
try_to_wake_up_local for local task
try_to_wake_up for any task
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;new-task&#34;&gt;New task&lt;/h1&gt;

&lt;p&gt;speical debit compensation: sched_fork-&amp;gt;task_fork_fair-&amp;gt;place_entity - compensation for new process&lt;br /&gt;
normal compensation: wake_up_new_task&lt;br /&gt;
{&lt;br /&gt;
    activate_task               #=== speical compensation&lt;br /&gt;
    check_preempt_curr          #=== normal compensation&lt;br /&gt;
}&lt;/p&gt;

&lt;h1 id=&#34;priority&#34;&gt;Priority&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;weight&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;priority&lt;br /&gt;
DEFAULT_PRIO&lt;br /&gt;
fs/proc/array.c&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;latency&#34;&gt;Latency&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;sched_nr_latency= /proc/sys/kernel/sched_latency_ns / /proc/sys/kernel/sched_min_granularity_ns&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;if running process &amp;gt; sched_nr_latency, latency cannot be ensured. just focus on min granularity&lt;/p&gt;

&lt;h2 id=&#34;lqo&#34;&gt;LQO&lt;/h2&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;is the difference of leftmost and rightmost smaller than sched_min_granularity_ns??&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sched_slice&lt;/p&gt;

&lt;h1 id=&#34;energy&#34;&gt;Energy&lt;/h1&gt;

&lt;p&gt;blocked &amp;amp; schedule&lt;br /&gt;
check preempt &amp;amp; schedule&lt;br /&gt;
check_preempt_tick              # new preempts curr&lt;br /&gt;
{&lt;br /&gt;
curr running time &amp;gt; sched_slice     # enough time to yield.&lt;br /&gt;
curr - leftmost &amp;gt; sched_slice       # nice to others.&lt;br /&gt;
}&lt;br /&gt;
check_preempt_wakeup                # the wakeuped preempts curr&lt;br /&gt;
{&lt;br /&gt;
curr - wakeuped &amp;gt; sysctl_sched_wakeup_granularity;  # pass the wakeup-preempt-delay&lt;br /&gt;
}&lt;/p&gt;

&lt;h1 id=&#34;io-wait&#34;&gt;io wait&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/342378/&#34;&gt;https://lwn.net/Articles/342378/&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;load-avg&#34;&gt;Load avg&lt;/h1&gt;

&lt;p&gt;update_load&lt;em&gt;avg&lt;br /&gt;
&lt;a href=&#34;https://en.wikipedia.org/wiki/Load&#34;&gt;https://en.wikipedia.org/wiki/Load&lt;/a&gt;&lt;/em&gt;(computing)&lt;br /&gt;
Check External links&lt;br /&gt;
calc_load_fold_active&lt;/p&gt;

&lt;h2 id=&#34;etymology-avenrun&#34;&gt;Etymology - avenrun&lt;/h2&gt;

&lt;p&gt;average nr. of running processes during&lt;br /&gt;
&lt;a href=&#34;https://casper.berkeley.edu/svn/trunk/roach/sw/linux/arch/s390/appldata/appldata_os.c&#34;&gt;https://casper.berkeley.edu/svn/trunk/roach/sw/linux/arch/s390/appldata/appldata_os.c&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;lqo-1&#34;&gt;LQO&lt;/h1&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;h_nr_running and throttled&lt;br /&gt;
sched: Implement hierarchical task accounting for SCHED_OTHER - 953bfcd10e6f3697233e8e5128c611d275da39c1&lt;br /&gt;
&lt;a href=&#34;https://groups.google.com/forum/#!topic/linux.kernel/gRzxHclMy50&#34;&gt;https://groups.google.com/forum/#!topic/linux.kernel/gRzxHclMy50&lt;/a&gt;&lt;br /&gt;
&amp;lsquo;root&amp;rsquo;&lt;br /&gt;
\&lt;br /&gt;
&amp;lsquo;A&amp;rsquo;&lt;br /&gt;
/ \&lt;br /&gt;
t1 t2&lt;br /&gt;
root.nr_running := 2&lt;br /&gt;
root.h_nr_running := 2&lt;br /&gt;
Check enqueue_task_fair()&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;group schedule&lt;br /&gt;
&lt;a href=&#34;https://www.kernel.org/doc/Documentation/scheduler/sched-design-CFS.txt&#34;&gt;https://www.kernel.org/doc/Documentation/scheduler/sched-design-CFS.txt&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;idle&lt;br /&gt;
&lt;a href=&#34;https://www.kernel.org/doc/Documentation/scheduler/sched-arch.txt&#34;&gt;https://www.kernel.org/doc/Documentation/scheduler/sched-arch.txt&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/136065/&#34;&gt;improve SMP reschedule and idle routines&lt;/a&gt;&lt;br /&gt;
TIF_POLLING_NRFLAG -&amp;gt; Need-Resched-Flag?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;process migration&lt;br /&gt;
e761b7725234276a802322549cee5255305a0930&lt;br /&gt;
Introduce cpu_active_map and redo sched domain managment&lt;br /&gt;
When to migration&lt;br /&gt;
    sched_setaffinity __set_cpus_allowed_ptr manuly&lt;br /&gt;
    Selecting a new CPU during wak up a sleeper&lt;br /&gt;
    For balancing, selecting CPU during  wake up new process in _do_fork&lt;br /&gt;
    execve&amp;rsquo;s sched_exec&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;shceduler clock&lt;br /&gt;
rq-&amp;gt;clock is nano seconds?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;clock_task and wraps&lt;br /&gt;
fe44d62122829959e960bc699318d58966922a69&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;START_DEBIT&lt;br /&gt;
no standalone commit&lt;br /&gt;
bf0f6f24a1ece8988b243aefe84ee613099a9245&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;why ahead?&lt;br /&gt;
8 /*&lt;br /&gt;
9  * Place new tasks ahead so that they do not starve already running&lt;br /&gt;
10  * tasks&lt;br /&gt;
11  */&lt;br /&gt;
12 SCHED_FEAT(START_DEBIT, true)&lt;br /&gt;
the tree is named timeline&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://lwn.net/Articles/404993/&#34;&gt;Improving scheduler latency &lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;skip next last buddy&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;git-log&#34;&gt;Git log&lt;/h1&gt;

&lt;p&gt;e9c8431185d6c406887190519f6dbdd112641686&lt;br /&gt;
TASK_WAKING; see migrate_task_rq_fair and try_to_wake_up&lt;br /&gt;
88ec22d3edb72b261f8628226cd543589a6d5e1b&lt;br /&gt;
In order to remove the cfs_rq dependency from set_task_cpu() we need to ensure the task is cfs_rq invariant for all callsites.&lt;br /&gt;
2f950354e6d535b892f133d20bd6a8b09430424c&lt;br /&gt;
sched/fair: Fix fairness issue on migration&lt;br /&gt;
&lt;a href=&#34;http://linux.kernel.narkive.com/p15Wmn0i/migrated-cfs-task-getting-an-unfair-advantage&#34;&gt;Migrated CFS task getting an unfair advantage&lt;/a&gt;&lt;br /&gt;
30cfdcfc5f180fc21a3dad6ae3b7b2a9ee112186&lt;br /&gt;
curr was not kept in rb-tree&lt;/p&gt;

&lt;h1 id=&#34;sd&#34;&gt;SD&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/80911/&#34;&gt;Scheduling domains&lt;/a&gt;&lt;br /&gt;
set sd&lt;br /&gt;
kernel_init_freeable-&amp;gt;&lt;br /&gt;
sched_init_smp-&amp;gt;&lt;br /&gt;
init_sched_domains-&amp;gt;build_sched_domains:-&amp;gt;&lt;br /&gt;
&lt;strong&gt;visit_domain_allocation_hell()-&amp;gt;&lt;/strong&gt;sdt_alloc() alloc the sdd-&amp;gt;sg which is used by build groups&lt;br /&gt;
and sg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(); it covered the size of cpumask&lt;br /&gt;
/* Build the groups for the domains */&lt;br /&gt;
detach_destroy_domains&lt;br /&gt;
cpu_attach_domain&lt;/p&gt;

&lt;p&gt;CONFIG_SCHED_MC=y&lt;br /&gt;
static noinline struct sched_domain *                                   &lt;br /&gt;
sd&lt;em&gt;init&lt;/em&gt;##type(struct sched_domain_topology_level *tl, int cpu)         &lt;br /&gt;
{                                                                       &lt;br /&gt;
        struct sched_domain *sd = *per_cpu&lt;em&gt;ptr(tl-&amp;gt;data.sd, cpu);       &lt;br /&gt;
        *sd = SD&lt;/em&gt;##type##_INIT;                                         &lt;br /&gt;
        SD_INIT_NAME(sd, type);                                         &lt;br /&gt;
        sd-&amp;gt;private = &amp;amp;tl-&amp;gt;data;                                        &lt;br /&gt;
        return sd;                                                      &lt;br /&gt;
}&lt;br /&gt;
tl-&amp;gt;mask(cpu)&lt;br /&gt;
static struct sched_domain_topology_level default_topology[] = {&lt;br /&gt;
#ifdef CONFIG_SCHED_SMT&lt;br /&gt;
        { sd_init_SIBLING, cpu_smt_mask, },&lt;br /&gt;
#endif&lt;br /&gt;
#ifdef CONFIG_SCHED_MC&lt;br /&gt;
        { sd_init_MC, cpu_coregroup_mask, },&lt;br /&gt;
#endif&lt;br /&gt;
#ifdef CONFIG_SCHED_BOOK&lt;br /&gt;
        { sd_init_BOOK, cpu_book_mask, },&lt;br /&gt;
#endif&lt;br /&gt;
        { sd_init_CPU, cpu_cpu_mask, },&lt;br /&gt;
        { NULL, },&lt;br /&gt;
};&lt;br /&gt;
CONFIG_CPUSETS=y&lt;br /&gt;
get sd&lt;br /&gt;
idle_balance&lt;br /&gt;
for_each_domain&lt;/p&gt;

&lt;p&gt;panic&lt;br /&gt;
find_busiest_group&lt;br /&gt;
find_next_bit&lt;br /&gt;
__next_cpu&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>System booting</title>
      <link>http://firoyang.org/cs/boot/</link>
      <pubDate>Thu, 12 Nov 2015 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/boot/</guid>
      <description>

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;Documentation/x86/boot.txt&lt;br /&gt;
&lt;a href=&#34;http://linuxdevices.linuxgizmos.com/introducing-initramfs-a-new-model-for-initial-ram-disks-a/&#34;&gt;Introducing initramfs, a new model for initial RAM disks&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://duartes.org/gustavo/blog/post/kernel-boot-process/&#34;&gt;The Kernel Boot Process&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;kernel-boot-process&#34;&gt;kernel boot process&lt;/h1&gt;

&lt;p&gt;arch/x86/boot/header.S::start_of_setup&lt;br /&gt;
arch/x86/boot/main.c::main()&lt;br /&gt;
    arch/x86/boot/memory.c::detect_memory()&lt;br /&gt;
    arch/x86/boot/memory.c::detect_memory_e820() = boot_params.e820_entries&lt;br /&gt;
    &amp;hellip;&lt;br /&gt;
    arch/x86/boot/pm.c::go_to_protected_mode()&lt;br /&gt;
arch/x86/boot/pmjump.S::protected_mode_jump&lt;br /&gt;
arch/x86/kernel/compressed/head_64.S::startup_32&lt;br /&gt;
arch/x86/kernel/compressed/head_64.S::startup_64&lt;br /&gt;
arch/x86/kernel/head_64.S::startup_64&lt;br /&gt;
kernel/main.c::start_kernel()&lt;br /&gt;
    &amp;hellip;&lt;br /&gt;
    arch/x86/kernel/setup_64.c::setup_arch()&lt;br /&gt;
        &amp;hellip;&lt;br /&gt;
        arch/x86/kernel/setup_64.c::memory_setup()&lt;br /&gt;
        arch/x86/kernel/e820_64.c::machine_specific_memory_setup()&lt;br /&gt;
        arch/x86/kernel/e820_64.c::sanitize_e820_map(boot_params.e820_map, &amp;amp;boot_params.e820_entries)&lt;br /&gt;
        &amp;hellip;&lt;br /&gt;
        arch/x86/kernel/e820_64.c::finish_e820_parsing()&lt;br /&gt;
        &amp;hellip;&lt;br /&gt;
        arch/x86/kernel/e820_64.c::e820_register_active_regions()&lt;br /&gt;
        &amp;hellip;&lt;br /&gt;
        arch/x86/kernel/acpi/boot.c::acpi_boot_table_init()&lt;br /&gt;
        arch/x86/kernel/pci-dma.c::dma32_reserve_bootmem()&lt;br /&gt;
        arch/x86/kernel/acpi/sleep.c::acpi_reserve_bootmem()&lt;br /&gt;
        arch/x86/kernel/efi_64.c::efi_reserve_bootmem()&lt;br /&gt;
        &amp;hellip;&lt;br /&gt;
        arch/x86/kernel/acpi/boot.c::acpi_boot_init()&lt;br /&gt;
        &amp;hellip;&lt;br /&gt;
        arch/x86/kernel/e820_64.c::e820_reserve_resources()&lt;br /&gt;
        arch/x86/kernel/e820_64.c::e820_mark_nosave_regions()&lt;br /&gt;
        arch/x86/kernel/e820_64.c::e820_setup_gap()&lt;br /&gt;
        &amp;hellip;&lt;br /&gt;
    }&lt;br /&gt;
    drivers/acpi/bus.c::acpi_early_init()&lt;br /&gt;
    kernel/main.c::rest_init()&lt;br /&gt;
        arch/x86/kernel/process_32.c::kernel_thread(kernel_init, NULL, CLONE_FS | CLONE_SIGHAND);&lt;br /&gt;
}&lt;br /&gt;
kernel/main.c::kernel_init()&lt;br /&gt;
 &amp;hellip;&lt;br /&gt;
 do_basic_setup()&lt;br /&gt;
  &amp;hellip;&lt;br /&gt;
  drivers/base/init.c::driver_init()&lt;br /&gt;
  &amp;hellip;&lt;br /&gt;
  init/main.c::do_initcalls()&lt;br /&gt;
 }&lt;br /&gt;
 &amp;hellip;&lt;br /&gt;
 init/main.c::init_post()&lt;br /&gt;
}&lt;/p&gt;

&lt;h1 id=&#34;reloctaion-for-decompress&#34;&gt;Reloctaion for decompress&lt;/h1&gt;

&lt;p&gt;974f221c84b05b1dc2f5ea50dc16d2a9d1e95eda&lt;br /&gt;
x86/boot: Move compressed kernel to the end of the decompression buffer&lt;/p&gt;

&lt;h1 id=&#34;realmode&#34;&gt;Realmode&lt;/h1&gt;

&lt;p&gt;The first 640KB RAM&lt;br /&gt;
cat /proc/iomem&lt;br /&gt;
00000000-00000fff : reserved&lt;br /&gt;
00001000-000913ff : System RAM&lt;br /&gt;
00091400-0009ffff : reserved&lt;br /&gt;
000a0000-000bffff : PCI Bus 0000:00&lt;br /&gt;
000c0000-000cfdff : Video ROM&lt;br /&gt;
000d0000-000d99ff : Adapter ROM&lt;br /&gt;
000da000-000dafff : Adapter ROM&lt;br /&gt;
000e0000-000fffff : reserved&lt;br /&gt;
  000f0000-000fffff : System ROM&lt;br /&gt;
00100000-bcb01fff : System RAM   # 1MB; Bootloader uses real_to_prot and prot_to_real to load the kernel image to this place.&lt;br /&gt;
  01000000-0183d36c : Kernel code # That&amp;rsquo;s why the kernel was called big kernel.&lt;br /&gt;
  0183d36d-01f42d3f : Kernel data&lt;br /&gt;
  020c1000-02209fff : Kernel bss&lt;/p&gt;

&lt;h1 id=&#34;horrable-commit-description-on-phys-base&#34;&gt;Horrable commit description on phys_base&lt;/h1&gt;

&lt;p&gt;commit 1ab60e0f72f71ec54831e525a3e1154f1c092408&lt;br /&gt;
Author: Vivek Goyal &lt;a href=&#34;mailto:vgoyal@in.ibm.com&#34;&gt;vgoyal@in.ibm.com&lt;/a&gt;&lt;br /&gt;
Date:   Wed May 2 19:27:07 2007 +0200&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[PATCH] x86-64: Relocatable Kernel Support
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;normalize-cs&#34;&gt;Normalize %cs&lt;/h1&gt;

&lt;p&gt;程序的起始地址在链接脚本中被设置为 0，如果 setup 被加载到其他地方(起始地&lt;br /&gt;
址不为 0 的地方)，那么指令里面访问的全局符号都会有重定位的问题。由于 Boot Loader&lt;br /&gt;
跳转到上面这段代码的时候，把 DS 设置为 setup 加载的基地址，而第 17 行访问_end 默认&lt;br /&gt;
是用数据段寄存器 DS 的，所以不会有重定位的问题。但是在 38 行转移指令用的 CS 寄存器，&lt;br /&gt;
而符号 main 的地址是在链接期决定的，现在加载的基地址改变了，那肯定会出问题了。所&lt;br /&gt;
以事先在第 24 行把 CS 设置为和 DS 一样，这样就解决了重定位的问题了。代码的最后跳转&lt;br /&gt;
到了 arch/x86/boot/main.c 中的 main 函数中继续执行。&lt;/p&gt;

&lt;h1 id=&#34;print-with-int-0x10&#34;&gt;print with int $0x10&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/38041478/int-10h-not-working-in-qemu&#34;&gt;https://stackoverflow.com/questions/38041478/int-10h-not-working-in-qemu&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;a20&#34;&gt;A20&lt;/h1&gt;

&lt;p&gt;[Why enable A20 line in Protected Mode?][&lt;a href=&#34;https://stackoverflow.com/questions/33827474/why-enable-a20-line-in-protected-mode&#34;&gt;https://stackoverflow.com/questions/33827474/why-enable-a20-line-in-protected-mode&lt;/a&gt;]&lt;br /&gt;
This gate, (the A20 gate), is controlled by a GPIO pin on the keyboard controller IC. Thus, you need to enable it before going into protected mode. If you didn&amp;rsquo;t, (and say you flat-mapped all 4GB of physical memory), then as Micheal Petch indicated, &amp;ldquo;every odd numbered megabyte region will be inaccessible. So 1mb-2mb will actually reference 0-1mb, 3mb-4mb will reference 2mb-3mb etc.&amp;rdquo; See also:&lt;/p&gt;

&lt;h1 id=&#34;contents&#34;&gt;Contents&lt;/h1&gt;

&lt;p&gt;What basic initializations should be perfomed when power on?&lt;br /&gt;
How do we load the kernel to memory?&lt;br /&gt;
What does kernel do when kernel boot.&lt;br /&gt;
MBR vs BIOS?&lt;br /&gt;
PC vs embedded&lt;br /&gt;
Kernel init&lt;br /&gt;
before start_kernel&lt;br /&gt;
start_kernel&lt;br /&gt;
reset_init &amp;amp; kernel_init&lt;/p&gt;

&lt;h1 id=&#34;boot-and-init&#34;&gt;Boot and init&lt;/h1&gt;

&lt;p&gt;Power button -&amp;gt; cpu reset -&amp;gt; BIOS -&amp;gt; hard drive -&amp;gt; Grub boot.S/MBR aa5a -&amp;gt; Grub diskboot.S -&amp;gt; &amp;hellip; -&amp;gt; The kernel real-mode setup code. _start of arch/x86/boot/header.S&lt;br /&gt;
Aligh register, Stack and BSS for C function to run. -&amp;gt; main-&amp;gt;startup_32-&amp;gt;startup_64-&amp;gt; __START_KERNEL_map-&amp;gt;&amp;hellip; start_kernel&lt;br /&gt;
&lt;a href=&#34;https://github.com/torvalds/linux/blob/master/Documentation/x86/boot.txt#L130&#34;&gt;Kernel legacy boot sector&lt;/a&gt; start form 4d5a of arch/x86/boot/header.S&lt;br /&gt;
is only used by something link &amp;lsquo;qemu-system-x86_64 vmlinuz-3.18-generic&amp;rsquo;. It&amp;rsquo;s obsoleted that is what legacy means.&lt;/p&gt;

&lt;h1 id=&#34;p4080-board&#34;&gt;p4080 Board&lt;/h1&gt;

&lt;p&gt;PBL&lt;br /&gt;
1. initialize I2C, SPI, eLBC, eSDHC.&lt;br /&gt;
2. Load RCW and boot init commands from above.&lt;br /&gt;
3. write date to conf register and memory&lt;/p&gt;

&lt;h1 id=&#34;config&#34;&gt;config&lt;/h1&gt;

&lt;p&gt;CCSRBAR -&amp;gt; CCSR&lt;br /&gt;
default is 0x0_FE00_0000&lt;br /&gt;
CCSRBAR is in CCSR memory. odd. stored in 0(CCSRBAR).&lt;br /&gt;
CCSRBAR always points to itself.&lt;br /&gt;
holdoff&lt;/p&gt;

&lt;h1 id=&#34;u-boot&#34;&gt;u-boot&lt;/h1&gt;

&lt;p&gt;ft_fixup_cpu -&amp;gt; determine_mp_bootpg(NULL) &amp;amp; fdt_add_mem_rsv&lt;/p&gt;

&lt;p&gt;main_loop-&amp;gt; &amp;hellip;-&amp;gt;./common/bootm_os.c:410:&amp;hellip; do_bootm_states-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
bootm_find_other-&amp;gt;bootm_find_ramdisk_fdt-&amp;gt;bootm_find_fdt-&amp;gt;boot_get_fdt&amp;amp;set_working_fdt_addr(0x0200000)-&amp;gt;IMAGE_FORMAT_FIT-&amp;gt;&lt;br /&gt;
&amp;amp;&lt;br /&gt;
boot_fn = bootm_os_get_boot_func(images-&amp;gt;os.os)=[IH_OS_LINUX] =&lt;br /&gt;
&amp;amp;&lt;br /&gt;
boot_selected_os-&amp;gt;boot_fn=do_bootm_linux-&amp;gt;boot_body_linux-&amp;gt;image_setup_linux-&amp;gt;image_setup_libfdt-&amp;gt;&lt;br /&gt;
board/freescale/corenet_ds/corenet_ds.c ft_board_setup-&amp;gt; ft_cpu_setup-&amp;gt;&lt;br /&gt;
}&lt;/p&gt;

&lt;h1 id=&#34;ppc-multicore-booting&#34;&gt;PPC multicore booting&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;There are two possibilites to make secondary cores booting failed.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;There is a bug in the code executed by Secondary cores&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;The spin table address, passed to croe0, is not correct, so we did not really kick the secondary cores.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CCSRBAR&lt;br /&gt;
MPC86xx_MCM_OFFSET&lt;br /&gt;
srio_boot_master_release_slave&lt;/p&gt;

&lt;p&gt;uboot-&amp;gt;&lt;br /&gt;
set the cpu-release-addr at funciton ft_fixup_cpu(), I am not sure.&lt;/p&gt;

&lt;p&gt;core0 run, 2nd cores holdoff&lt;br /&gt;
core0 set BPTR and kick(BRR) 2nd cores, 2nd cores spintable loop in uboot function setup_mp&lt;br /&gt;
core0 -&amp;gt; arch/powerpc/cpu/mpc85xx/start.S-&amp;gt;_start_e500&lt;br /&gt;
board_init_r-&amp;gt;cpu_init_r-&amp;gt; setup_mp-&amp;gt; {&lt;br /&gt;
&lt;strong&gt;bootpg_addr = (u32)virt_to_phys(&amp;amp;&lt;/strong&gt;second_half_boot_page); //Assembly code for put core to spin tablea. Used by __secondary_start_page&lt;br /&gt;
__spin_table_addr = (u32)get_spin_phys_addr();// used by __second_half_boot_page&lt;br /&gt;
bootpg = BPTR = __secondary_start_page&lt;br /&gt;
plat_mp_up-&amp;gt;kick BRR &amp;amp; Boot Space Translation&lt;br /&gt;
}&lt;br /&gt;
2nd cores holdoff -&amp;gt; &lt;strong&gt;secondary_start_page&lt;br /&gt;
kernel-&amp;gt;&lt;br /&gt;
core0 boot kernel, core0 kickoff 2nd cores spintable, triger 2nd core&amp;rsquo;s spin table by writing  the spin table field with the desired address&lt;br /&gt;
2nd cores ePAPR-&amp;gt;spintable-&amp;gt;addr_l=&lt;/strong&gt;early_start-&amp;gt;__secondary_start-&amp;gt;smp_ops-&amp;gt;setup_cpu-&amp;gt;cpu_idle&lt;br /&gt;
arch/powerpc/kernel/head_fsl_booke.S&lt;br /&gt;
U-boot logs:&lt;br /&gt;
Reserving MP boot page to 7ffff000^M^M - &amp;ndash;   -   MP spin table&lt;br /&gt;
address.&lt;br /&gt;
SPAG : fdt_fixup_fman_firmware, 567^M^M&lt;br /&gt;
^M^M&lt;br /&gt;
..r.^M^M&lt;br /&gt;
VDBG : ft_cpu_setup, 737, comment fdt_fixup_memory ^M^M&lt;br /&gt;
VDBG: Secondary cores are not held in reset.^M^M&lt;br /&gt;
Kernel Logs:&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 1 to ack^M^M&lt;br /&gt;
smp: failed starting cpu 1 (rc -2)^M^M&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 2 to ack^M^M&lt;br /&gt;
smp: failed starting cpu 2 (rc -2)^M^M&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 3 to ack^M^M&lt;br /&gt;
smp: failed starting cpu 3 (rc -2)^M^M&lt;br /&gt;
Brought up 1 CPUs^M^M&lt;br /&gt;
devtmpfs: initialized^M^M&lt;/p&gt;

&lt;p&gt;Note that u-boot can&amp;rsquo;t detect  memory above 2G and we need to check&lt;br /&gt;
if kernel is accessing at high mem of 2G or 4G.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Computer architecture</title>
      <link>http://firoyang.org/cs/arch/</link>
      <pubDate>Tue, 13 Oct 2015 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/arch/</guid>
      <description>

&lt;h1 id=&#34;ref&#34;&gt;ref&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://people.cs.clemson.edu/~mark/architects.html&#34;&gt;https://people.cs.clemson.edu/~mark/architects.html&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;asm&#34;&gt;ASM&lt;/h1&gt;

&lt;p&gt;Reference asm global label in C&lt;br /&gt;
char _text[];           x86_64_64;&lt;br /&gt;
unsigned long _text;    x86_64_PC32&lt;br /&gt;
They are different in amrithmatic operstion.&lt;/p&gt;

&lt;p&gt;##Reference&lt;br /&gt;
&lt;a href=&#34;http://people.eecs.berkeley.edu/~rcs/research/interactive_latency.html&#34;&gt;Latency Numbers Every Programmer Should Know&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://youtu.be/cNN_tTXABUA&#34;&gt;How a CPU Works&lt;/a&gt;&lt;br /&gt;
A Symbolic Analysis of Relay and Switching Circuits&lt;br /&gt;
The Mathematical Theory of Communication&lt;br /&gt;
Given a symbol level, the architecture is the description of the system in&lt;br /&gt;
whatever system-description scheme exists next below the symbol level. - Newell, 1990, p. 81&lt;br /&gt;
&lt;a href=&#34;https://news.ycombinator.com/item?id=9844090&#34;&gt;Ask HN: How to learn about the history of computing?&lt;/a&gt;&lt;br /&gt;
《模拟电子技术基础 童诗白 第四版》第一章前半部分&lt;br /&gt;
Structured Computer Organization 6th Edition&lt;br /&gt;
Digital Design and Computer Architecture 2nd Edition&lt;br /&gt;
Computer Organization and Design 5th Edition&lt;br /&gt;
Write Great Code: Volume 1: Understanding the Machine&lt;br /&gt;
See MIPS run&lt;br /&gt;
Intel 64 and IA-32 architectures software developers manual combined volumes 3A, 3B, and 3C: System programming guide&lt;br /&gt;
Microelectronics&lt;/p&gt;

&lt;h2 id=&#34;isa&#34;&gt;ISA&lt;/h2&gt;

&lt;p&gt;model: 1570s, &amp;ldquo;likeness made to scale; architect&amp;rsquo;s set of designs,&amp;rdquo; from Middle French modelle&lt;br /&gt;
Semantics in computer science: In programming language theory, semantics is the field concerned&lt;br /&gt;
with the rigorous mathematical study of the meaning of programming languages.&lt;br /&gt;
Language primitive&lt;br /&gt;
ISA: memory model, registers, data types, instructions, word size(?).&lt;br /&gt;
Memory model: unit of address resolution, word, aligment, address space, addressing mode, memory barrier/memory order primitive&amp;rsquo;s semantics.&lt;br /&gt;
#x86 Interrupt&lt;br /&gt;
If interrupt occured in user mode, then cpu will context swith for potential reschedule.&lt;br /&gt;
The Interrupt Descriptor Table (IDT) is a data structure used by the x86 architecture to implement an interrupt vector table.&lt;br /&gt;
##Hardware interrupts&lt;br /&gt;
are used by devices to communicate that they require attention from the operating system.&lt;br /&gt;
asynchronus&lt;br /&gt;
more details in init_IRQ() or set_irq() in driver.&lt;br /&gt;
##software interrupt&lt;br /&gt;
synchronus&lt;br /&gt;
more details in trap_init().&lt;br /&gt;
* exception or trap&lt;br /&gt;
is caused either by an exceptional condition in the processor itself,&lt;br /&gt;
divide zero painc?&lt;br /&gt;
* special instruction, for example INT 0x80&lt;br /&gt;
or a special instruction in the instruction set which causes an interrupt when it is executed.&lt;/p&gt;

&lt;h1 id=&#34;i-o-ic&#34;&gt;I/O IC&lt;/h1&gt;

&lt;p&gt;serial communication: UART(16550) + RS-232&lt;br /&gt;
parallel communication: SCSI, ISA, ATA, PCI, FSB&lt;/p&gt;

&lt;h1 id=&#34;data-struct-aligment&#34;&gt;Data struct aligment&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.catb.org/esr/structure-packing/&#34;&gt;The Lost Art of C Structure Packing&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://en.wikipedia.org/wiki/Data_structure_alignment#Typical_alignment_of_C_structs_on_x86&#34;&gt;Typical alignment of C structs on x86&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;为什么需要结构体对齐&#34;&gt;为什么需要结构体对齐?&lt;/h2&gt;

&lt;p&gt;struct foo {&lt;br /&gt;
char c;&lt;br /&gt;
int i;};&lt;br /&gt;
如果是32位, cpu 一次取4byte a word 数据.&lt;br /&gt;
如果我们把i的前3byte和c存到一起, 剩下1byte of i自己单独存.&lt;br /&gt;
那么我们访问i这个数据就要读两个4byte a word. 对cpu来说性能损耗.&lt;br /&gt;
如果我们把i单独放到4byte 对齐的地址, 那么我们只需要一次cpu读取.fast!&lt;/p&gt;

&lt;h2 id=&#34;产生非对齐访问的场景&#34;&gt;产生非对齐访问的场景&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Casting variables to types of different lengths, 比如char * 到int *&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Pointer arithmetic followed by access to at least 2 bytes of data , 不太理解.&lt;/p&gt;

&lt;h2 id=&#34;我们做什么&#34;&gt;我们做什么?&lt;/h2&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;什么也不干, 按默认对齐来Natural alignment&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为了不影响性能, 同时减少内存使用, 编程时最好显示reorder.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;get/put_unaligned  to avoid analigned access.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通过attribute aligned指定对齐要求.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;数据要在不同体系, 32/64之间使用, 比如网络,写到disk, 我们必须要attribute packed&lt;br /&gt;
也就是说不对齐, 不同平台对齐可能不同, 我们不能让数据corruption.&lt;/p&gt;

&lt;h2 id=&#34;如果数据不对齐有什么-cpu怎么办&#34;&gt;如果数据不对齐有什么, cpu怎么办?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kernel.org/doc/Documentation/unaligned-memory-access.txt&#34;&gt;必读UNALIGNED MEMORY ACCESSES&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果用了packed, 编译器会生成extra代码阻止非对齐访问, performance loss.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cpu呢? 可能正确处理raise a exception to fix it with performance loss.&lt;/p&gt;

&lt;h2 id=&#34;calculate-the-sizeof-of-aligned-c-struct&#34;&gt;Calculate the sizeof of aligned c struct&lt;/h2&gt;

&lt;p&gt;Data alignment means putting the data at a memory address equal to some multiple of the word size,&lt;br /&gt;
which increases the system&amp;rsquo;s performance due to the way the CPU handles memory.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;find the widest scalar member and attribute( aligned(x)) to determin alignment.&lt;br /&gt;
找到结构体内scalar和attribute最大的对齐要求.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;fill the member to alignement without wrap&lt;br /&gt;
把结构的成员一次填满对齐宽度, 不够的填到下个对齐宽度, 空出来留着padding&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Pading to alignment&lt;br /&gt;
填上所有空.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;endianess&#34;&gt;Endianess&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.yolinux.com/TUTORIALS/Endian-Byte-Order.html&#34;&gt;Endianness: Big and Little Endian Byte Order&lt;/a&gt;&lt;br /&gt;
应该说bit endianess 实际存储只有MSB &amp;hellip; LSB这一种二进制表达形式! 在上面的文章的representtion, 辅证这一点.&lt;br /&gt;
这篇文章&lt;a href=&#34;http://tonybai.com/2013/05/21/talk-about-bitfield-in-c-again/&#34;&gt;再谈C语言位域&lt;/a&gt;,&lt;br /&gt;
之所以输出逆序, 是因为错误里理解了, bit 序. bit 序是cpu 读取的方式, 不是存储的方式!&lt;/p&gt;

&lt;h2 id=&#34;bit-endianness-https-en-wikipedia-org-wiki-bit-numbering&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Bit_numbering&#34;&gt;bit endianness&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;这样就可以更好的理解iphdr:&lt;br /&gt;
#if defined(__LITTLE_ENDIAN_BITFIELD)&lt;br /&gt;
    &lt;strong&gt;u8    ihl:4,&lt;br /&gt;
        version:4;&lt;br /&gt;
#elif defined (&lt;/strong&gt;BIG_ENDIAN_BITFIELD)&lt;br /&gt;
    __u8    version:4,&lt;br /&gt;
        ihl:4;&lt;br /&gt;
#else&lt;br /&gt;
#error  &amp;ldquo;Please fix &lt;asm/byteorder.h&gt;&amp;ldquo;&lt;br /&gt;
#endif&lt;br /&gt;
ipv4 header的拓扑&lt;br /&gt;
version ihl&lt;br /&gt;
0100 0101&lt;br /&gt;
因为le的cpu是 lsb first, 也就是从最左面的1开始读, 所以第一个是ihl&lt;br /&gt;
而be的cpu是 msb first, 从最右开始所以version开头.&lt;br /&gt;
而使用unsigned char ver_ihl&lt;br /&gt;
(ver_ihl &amp;amp; 0xf0)&amp;gt;&amp;gt; 4 = version&lt;br /&gt;
ver_ihl &amp;amp; 0x0f = ihl&lt;br /&gt;
是无关cpu读取顺序的.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Algorithms and data structues</title>
      <link>http://firoyang.org/cs/algorithm/</link>
      <pubDate>Wed, 27 May 2015 12:42:12 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/algorithm/</guid>
      <description>

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://cstheory.stackexchange.com/questions/19759/core-algorithms-deployed#&#34;&gt;Core algorithms deployed&lt;/a&gt;&lt;br /&gt;
Algorithms: Design Techniques and Analysis&lt;br /&gt;
The Algorithm Design Manual 2nd Edition&lt;/p&gt;

&lt;h1 id=&#34;computational-complexity-theory&#34;&gt;Computational complexity theory&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://bigocheatsheet.com/&#34;&gt;http://bigocheatsheet.com/&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;core-conceptions&#34;&gt;Core conceptions&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;representations&lt;br /&gt;
&lt;a href=&#34;https://www.geeksforgeeks.org/binary-tree-array-implementation/&#34;&gt;Linked vs sequential&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ADT vs data structure&lt;br /&gt;
ADT is a data type defined by its behavior.&lt;br /&gt;
&lt;a href=&#34;https://en.wikipedia.org/wiki/Data_type#Abstract_data_types&#34;&gt;Any type that does not specify an implementation is an abstract data type.&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;linked-list&#34;&gt;Linked list&lt;/h1&gt;

&lt;h2 id=&#34;static-linked-list&#34;&gt;Static linked list&lt;/h2&gt;

&lt;p&gt;Reprented in an array.&lt;/p&gt;

&lt;h2 id=&#34;internal-vs-external-liked&#34;&gt;Internal vs external liked&lt;/h2&gt;

&lt;p&gt;Sometimes, SLUB put freelist in object&lt;/p&gt;

&lt;h2 id=&#34;kernel-doubly-linked-list-operations&#34;&gt;kernel doubly linked list operations&lt;/h2&gt;

&lt;h3 id=&#34;add&#34;&gt;add&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;kernel version&lt;br /&gt;
next-&amp;gt;prev = new;&lt;br /&gt;
new-&amp;gt;next = next;&lt;br /&gt;
new-&amp;gt;prev = prev;&lt;br /&gt;
prev-&amp;gt;next = new;&lt;/p&gt;

&lt;h3 id=&#34;delete&#34;&gt;delete&lt;/h3&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;kernel version&lt;br /&gt;
next-&amp;gt;prev = prev;&lt;br /&gt;
WRITE_ONCE(prev-&amp;gt;next, next);&lt;br /&gt;
entry-&amp;gt;next = LIST_POISON1;&lt;br /&gt;
entry-&amp;gt;prev = LIST_POISON2;&lt;/p&gt;

&lt;h1 id=&#34;bl-list&#34;&gt;BL list&lt;/h1&gt;

&lt;p&gt;kernel: add bl_list - 4e35e6070b1ceed89c3bba2af4216c286fb1dafd&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;double-linked-list&#34;&gt;Double linked list&lt;/h1&gt;

&lt;h1 id=&#34;associative-array&#34;&gt;Associative array&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=qTZJLJ3Gm6Q&#34;&gt;Essentials: Brian Kernighan on Associative Arrays - Computerphile&lt;/a&gt;&lt;br /&gt;
vs indexed array&lt;/p&gt;

&lt;h2 id=&#34;associativity&#34;&gt;Associativity&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;trade-off&lt;br /&gt;
a) Checking more places takes more power and chip area,&lt;br /&gt;
b) and potentially more time. On the other hand, caches with more associativity suffer fewer misses&lt;br /&gt;
fully associative - the best miss rates, but practical only for a small number of entries&lt;br /&gt;
N-way set associative cache: 8 is a common choice for later implementations&lt;br /&gt;
direct-mapped cache - if two locations map to the same entry, they may continually knock each other out. anti-fragmantion worsens this case.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;judy-array&#34;&gt;Judy array&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://judy.sourceforge.net/&#34;&gt;http://judy.sourceforge.net/&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;hashtable&#34;&gt;Hashtable&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/510202/&#34;&gt;A generic hash table&lt;/a&gt;&lt;br /&gt;
hash function&lt;/p&gt;

&lt;h1 id=&#34;bst&#34;&gt;BST&lt;/h1&gt;

&lt;p&gt;Pre-order&lt;br /&gt;
In-order traversal&lt;br /&gt;
Post-order&lt;br /&gt;
postfix and prefix and sort&lt;/p&gt;

&lt;h1 id=&#34;graph&#34;&gt;Graph&lt;/h1&gt;

&lt;h1 id=&#34;depth-first-sarch&#34;&gt;Depth first sarch&lt;/h1&gt;

&lt;p&gt;DAG&lt;/p&gt;

&lt;h1 id=&#34;redblack-tree&#34;&gt;Redblack tree&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/count-of-smaller-numbers-after-self/description/&#34;&gt;https://leetcode.com/problems/count-of-smaller-numbers-after-self/description/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://yuex.in/post/2017/08/red-black-tree-in-action.html&#34;&gt;http://yuex.in/post/2017/08/red-black-tree-in-action.html&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;interval-tree-in-kernel&#34;&gt;Interval tree in kernel&lt;/h1&gt;

&lt;p&gt;anonymous page: anon_vma_interval_tree_insert&lt;/p&gt;

&lt;h1 id=&#34;trie&#34;&gt;Trie&lt;/h1&gt;

&lt;p&gt;Trie is prefix tree.&lt;br /&gt;
Trees only store keys.&lt;br /&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=AXjmTQ8LEoI&#34;&gt;Trie Data Structure&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=MC-iQHFdEDI&#34;&gt;Trie with numeric key&lt;/a&gt;&lt;br /&gt;
* terms very confused&lt;br /&gt;
&lt;a href=&#34;https://stackoverflow.com/questions/14708134/what-is-the-difference-between-trie-and-radix-trie-data-structures&#34;&gt;Radix tree vs Trie, check radix meaning&lt;/a&gt;&lt;br /&gt;
Patricia is compact trie or Patricia is radix = 2 trie?&lt;/p&gt;

&lt;h1 id=&#34;radix-tree-in-kernel-not-wikipedia&#34;&gt;Radix tree in kernel not wikipedia&lt;/h1&gt;

&lt;p&gt;page cache: page_cache_tree_insert&lt;br /&gt;
Wikipedia: Radix tree looks like a compact trie.&lt;br /&gt;
Kernel: Radix tree was more like a Multi-level index associative arrya or judy array.&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/175432/&#34;&gt;Trees I: Radix trees&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://events17.linuxfoundation.org/sites/events/files/slides/LinuxConNA2016%20-%20Radix%20Tree.pdf&#34;&gt;Enhancing the Linux Radix Tree&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=v0C9_Fp-co4&#34;&gt;The design and implementation of the XArray&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/688130/&#34;&gt;A multi-order radix tree&lt;/a&gt;&lt;br /&gt;
radix_tree_init_maxnodes(): height is 11 in kernel?&lt;br /&gt;
&lt;strong&gt;radix_tree_create() add one page&lt;/strong&gt;&lt;br /&gt;
radix_tree_lookup_slot: find one page&lt;/p&gt;

&lt;h1 id=&#34;search&#34;&gt;Search&lt;/h1&gt;

&lt;p&gt;Data property: unique key, indexed&lt;br /&gt;
&lt;a href=&#34;https://en.wikipedia.org/wiki/Search_data_structure&#34;&gt;Search data structure&lt;/a&gt;&lt;br /&gt;
Sequencial array: binary search&lt;br /&gt;
Associative array&lt;br /&gt;
BST&lt;br /&gt;
Hashtable&lt;/p&gt;

&lt;h2 id=&#34;which-algorithm&#34;&gt;Which algorithm?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/advantages-of-bst-over-hash-table/&#34;&gt;Advantages of BST over Hash Table&lt;/a&gt;&lt;br /&gt;
1. Can get all keys in sorted order  by just doing in-order traversal of BST&lt;br /&gt;
2. Doing order statistics, finding closest lower and greater elements, doing range  queries  are easy to do with BSTs.&lt;br /&gt;
3. BSTs are easy to implement compared to hashing.&lt;br /&gt;
4. With Self Balancing BSTs, all operations are guarnateed to work in O(logN) time.&lt;/p&gt;

&lt;h1 id=&#34;replacement-polices&#34;&gt;Replacement polices&lt;/h1&gt;

&lt;p&gt;Pseudo-LRU&lt;/p&gt;

&lt;h1 id=&#34;lru&#34;&gt;LRU&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/lru-cache/description/&#34;&gt;Leetcode 146 LRU cache&lt;/a&gt;&lt;br /&gt;
Order items by access times&lt;/p&gt;

&lt;h2 id=&#34;pseudo-lru-2-second-chance-and-queue&#34;&gt;Pseudo LRU/2 - Second chance and queue&lt;/h2&gt;

&lt;p&gt;type: Reclaim&lt;br /&gt;
Order items by enqueueing sequence&lt;br /&gt;
dcache&lt;/p&gt;

&lt;h2 id=&#34;second-chance-and-2q-https-pdfs-semanticscholar-org-d62d-e5f995164fff50f5ce61c0113f6bc9f04225-pdf&#34;&gt;Second chance and &lt;a href=&#34;https://pdfs.semanticscholar.org/d62d/e5f995164fff50f5ce61c0113f6bc9f04225.pdf&#34;&gt;2Q&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Page reclaim algorithm&lt;br /&gt;
type: Reclaim&lt;/p&gt;

&lt;h1 id=&#34;lock&#34;&gt;Lock&lt;/h1&gt;

&lt;p&gt;MCS lock&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Computing Sorcery a sorcerer&#39;s perspective on computer science</title>
      <link>http://firoyang.org/cs/cs/</link>
      <pubDate>Fri, 27 Feb 2015 15:46:14 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/cs/</guid>
      <description>

&lt;p&gt;What&amp;rsquo;s the computer science? Have you ever asked yourself? It&amp;rsquo;s not a science!&lt;br /&gt;
Underlying our approach to this subject is our conviction that “com-&lt;br /&gt;
puter science” is not a science and that its significance has little to do&lt;br /&gt;
with computers. The computer revolution is a revolution in the way we&lt;br /&gt;
think and in the way we express what we think. The essence of this&lt;br /&gt;
change is the emergence of what might best be called procedural epis-&lt;br /&gt;
temology —the study of the structure of knowledge from an imperative&lt;br /&gt;
point of view, as opposed to the more declarative point of view taken&lt;br /&gt;
by classical mathematical subjects. Mathematics provides a framework&lt;br /&gt;
for dealing precisely with notions of “what is.” Computation provides a&lt;br /&gt;
framework for dealing precisely with notions of “how to.”  &amp;ndash; The omnipotent SICP&lt;br /&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=lL4wg6ZAFIM&#34;&gt;Richard Feynman on Computer Science — Talk at Bell Labs (1985)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.gigamonkeys.com/code-reading/&#34;&gt;Reading code? CODE IS NOT LITERATURE&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://plato.stanford.edu/entries/computer-science/&#34;&gt;The Philosophy of Computer Science&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.tuicool.com/articles/YRZvem&#34;&gt;Mort Yao 程序与证明&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.bravegnu.org/gnu-eprog/&#34;&gt;Vijay Kumar B&amp;rsquo;s Embedded Programming with the GNU Toolchain&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;performance/efficiency&lt;br /&gt;
Easy to use&lt;br /&gt;
Security/Protection/isolation&lt;br /&gt;
Reliability&lt;br /&gt;
Energy-efficiency&lt;/p&gt;

&lt;h1 id=&#34;the-abilities-of-computer-science-programmer&#34;&gt;The abilities of Computer science programmer&lt;/h1&gt;

&lt;p&gt;Debugging&lt;br /&gt;
Memory management&lt;/p&gt;

&lt;h1 id=&#34;faq&#34;&gt;FAQ&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.ibm.com/developerworks/library/os-aapseudo1/os-aapseudo1-pdf.pdf&#34;&gt;All about pseudo&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The art of debugging</title>
      <link>http://firoyang.org/cs/debugging/</link>
      <pubDate>Fri, 27 Feb 2015 15:46:14 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/debugging/</guid>
      <description>

&lt;h1 id=&#34;ref&#34;&gt;ref&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=g7Qm0NpPAz4&#34;&gt;https://www.youtube.com/watch?v=g7Qm0NpPAz4&lt;/a&gt;&lt;br /&gt;
Debug hacks: a book on how to debug.&lt;/p&gt;

&lt;h1 id=&#34;boot-issues&#34;&gt;Boot issues&lt;/h1&gt;

&lt;p&gt;debug ignore_loglevel earlyprintk=ttyS0,115200, keep keep_bootcon initcall_debug dyndbg=+plmf&lt;/p&gt;

&lt;h1 id=&#34;lockup&#34;&gt;Lockup&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kernel.org/doc/Documentation/lockup-watchdogs.txt&#34;&gt;kernle doc - Softlockup detector and hardlockup detector&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;oob&#34;&gt;OOB&lt;/h1&gt;

&lt;h2 id=&#34;slub-redzone&#34;&gt;SLUB Redzone&lt;/h2&gt;

&lt;h1 id=&#34;use-after-free&#34;&gt;Use after free&lt;/h1&gt;

&lt;p&gt;Record the owner, who free.&lt;/p&gt;

&lt;h1 id=&#34;deadlock&#34;&gt;Deadlock&lt;/h1&gt;

&lt;p&gt;Lockdep&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/185666/&#34;&gt;The kernel lock validator&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt&#34;&gt;Runtime locking correctness validator&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lkml.org/lkml/2013/2/4/4&#34;&gt;https://lkml.org/lkml/2013/2/4/4&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://bbs.chinaunix.net/thread-4183696-1-1.html&#34;&gt;http://bbs.chinaunix.net/thread-4183696-1-1.html&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;print&#34;&gt;Print&lt;/h1&gt;

&lt;h2 id=&#34;user-mode-print&#34;&gt;User mode print&lt;/h2&gt;

&lt;p&gt;define witcher(fmt, args&amp;hellip;) do{FILE * fdebug=fopen(&amp;ldquo;/tmp/d.log&amp;rdquo;, &amp;ldquo;a+&amp;rdquo;); &lt;br /&gt;
fprintf(fdebug,&amp;ldquo;%s,%s,%d:&amp;ldquo;fmt, &lt;strong&gt;TIME&lt;/strong&gt;, &lt;strong&gt;FUNCTION&lt;/strong&gt;, &lt;strong&gt;LINE&lt;/strong&gt;, ##args);fclose(fdebug);} while(0)&lt;br /&gt;
* make specific&lt;br /&gt;
-s, -n, -p, &amp;ndash;warn-undefined-variables&lt;br /&gt;
$(warning &amp;hellip;)&lt;/p&gt;

&lt;h2 id=&#34;early-print&#34;&gt;Early print&lt;/h2&gt;

&lt;p&gt;putstr&lt;br /&gt;
early_printk&lt;br /&gt;
Linux serial-port driver is interrupt driven, if irq-off console will not work!&lt;/p&gt;

&lt;h2 id=&#34;dynamic-print&#34;&gt;Dynamic print&lt;/h2&gt;

&lt;p&gt;Precondition: CONFIG_DYNAMIC_DEBUG&lt;br /&gt;
How to use it during kernel booting?&lt;br /&gt;
Use boot option:&lt;br /&gt;
dyndbg=&amp;ldquo;file drivers/usb/host/ehci-hcd.c +p; file&lt;br /&gt;
drivers/usb/host/ehci-ppc-of.c +p&amp;rdquo; loglevel=8&lt;br /&gt;
loglevel=8 dyndbg=&amp;ldquo;module ehci_pci +p;&lt;br /&gt;
module ehci_hcd +p; module usbcore +p&amp;rdquo;&lt;br /&gt;
After booting:&lt;br /&gt;
/sys/kernel/debug/dynamic_debug/control&lt;/p&gt;

&lt;h2 id=&#34;dev-print&#34;&gt;Dev print&lt;/h2&gt;

&lt;p&gt;drivers/base/core.c&lt;br /&gt;
define_dev_printk_level&lt;br /&gt;
THese functions are like pr_func&lt;br /&gt;
dev_debug&lt;/p&gt;

&lt;h1 id=&#34;tracing&#34;&gt;Tracing&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kernel.org/doc/html/v4.18/trace/index.html&#34;&gt;Linux Tracing Technologies&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;user-mode-tracing&#34;&gt;User mode tracing&lt;/h2&gt;

&lt;p&gt;ltrace, strace, bash -x&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Abductive_reasoning#Logic-based_abduction&#34;&gt;How does strace work?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;PTRACE_PEEKDATA for showing pointer parameter(e.g. 2nd arg of read)&lt;/p&gt;

&lt;h1 id=&#34;kprobes&#34;&gt;Kprobes&lt;/h1&gt;

&lt;h1 id=&#34;systemtap&#34;&gt;Systemtap&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://yq.aliyun.com/articles/131870&#34;&gt;systemtap脚本分析系统中dentry SLAB占用过高问题&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;config-debug-pagealloc&#34;&gt;CONFIG_DEBUG_PAGEALLOC&lt;/h1&gt;

&lt;p&gt;check_poison_mem in alloc_pages&lt;br /&gt;
free_pages_prepare posion&lt;/p&gt;

&lt;h1 id=&#34;fs&#34;&gt;FS&lt;/h1&gt;

&lt;p&gt;lsof&lt;/p&gt;

&lt;h1 id=&#34;kasan&#34;&gt;Kasan&lt;/h1&gt;

&lt;p&gt;setup_arch-&amp;gt;kasan_init&lt;br /&gt;
&lt;a href=&#34;http://events.linuxfoundation.org/sites/events/files/slides/LinuxCon%20North%20America%202015%20KernelAddressSanitizer.pdf&#34;&gt;KernelAddressSanitizer a fast memory error detector for the Linux kernel&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/zfsonlinux/zfs/pull/4708/commits/01709937be3c28a89eff83e0e657a72826947506&#34;&gt;kasan found stack out of bounds&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/612153/&#34;&gt;lwn The kernel address sanitizer&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lkml.org/lkml/2014/12/3/128&#34;&gt;out of bounds&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;Reverse engineering&lt;br /&gt;
&lt;a href=&#34;https://en.wikipedia.org/wiki/Abductive_reasoning#Logic-based_abduction&#34;&gt;How debuggers work&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;core-dump&#34;&gt;Core dump&lt;/h1&gt;

&lt;p&gt;echo /tmp/core-%e-%p-%s-%c-%P &amp;gt; /proc/sys/kernel/core_pattern&lt;/p&gt;

&lt;h1 id=&#34;ebpf&#34;&gt;eBPF&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/740157/&#34;&gt;https://lwn.net/Articles/740157/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://blog.yadutaf.fr/2016/03/30/turn-any-syscall-into-event-introducing-ebpf-kernel-probes/&#34;&gt;How to turn any syscall into an event: Introducing eBPF Kernel probes&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;gdb&#34;&gt;Gdb&lt;/h1&gt;

&lt;p&gt;signle step instruction&lt;/p&gt;

&lt;h2 id=&#34;debug-glibc&#34;&gt;Debug glibc&lt;/h2&gt;

&lt;p&gt;directory ~/ws/glibc-2.23/libio&lt;br /&gt;
set solib-search-path /usr/lib/debug/lib/x86_64-linux-gnu/&lt;/p&gt;

&lt;h1 id=&#34;info&#34;&gt;info&lt;/h1&gt;

&lt;p&gt;Host OS name and version number.&lt;br /&gt;
I40e driver version number.&lt;br /&gt;
Host OS Linux Kernel log.&lt;br /&gt;
VF driver version number.&lt;br /&gt;
NIC hardware model and PBA number.&lt;br /&gt;
NIC Firmware NVM version number.&lt;/p&gt;

&lt;h1 id=&#34;from-assembly-to-c&#34;&gt;From assembly to C&lt;/h1&gt;

&lt;p&gt;addr2line -f -C -a 0xxxx -e ooo.bin&lt;br /&gt;
addr2line -e vmlinux -i ffffffff81f04b7a ffffffff81508daa&lt;/p&gt;

&lt;h1 id=&#34;from-elf-to-c&#34;&gt;From ELF to C&lt;/h1&gt;

&lt;p&gt;pahole -C &amp;lsquo;block_device&amp;rsquo; vmlinux&lt;/p&gt;

&lt;h1 id=&#34;debugging-and-bug-types&#34;&gt;Debugging and Bug types&lt;/h1&gt;

&lt;p&gt;Does anyone can tell me what is debugging? Debugging is &lt;a href=&#34;https://en.wikipedia.org/wiki/Abductive_reasoning#Logic-based_abduction&#34;&gt;Abductive reasoning&lt;/a&gt;.&lt;br /&gt;
Theory + Observations =&amp;gt; Explanation&lt;/p&gt;

&lt;h1 id=&#34;bug-classifications&#34;&gt;Bug classifications&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.opensourceforu.com/2010/10/joy-of-programming-types-of-bugs&#34;&gt;BUG type of Jim Gray&lt;/a&gt;,除了Bohrbug,其他都不太好解.&lt;br /&gt;
The National Vulnerability Database是一个非常有用的网站, 国内鲜少有人提及.尤其是,&lt;br /&gt;
他的Bug分类方式惊艳无比, 逻辑上非常严密, 就好比数学系统, 由公理系统推导而得.&lt;br /&gt;
NVD的Bug分类也采用类似的构建方式.&lt;a href=&#34;https://nvd.nist.gov/cwe.cfm&#34;&gt;CWE Cross Section Mapped into by NVD&lt;/a&gt;&lt;br /&gt;
涵盖了所有常见的的Bug描述, 而且非常专业.大赞!wikipedia的条目就相形见绌了&lt;br /&gt;
&lt;a href=&#34;https://en.wikipedia.org/wiki/Software_bug#Common_types_of_computer_bugs&#34;&gt;Common types of computer bugs in wikipedia&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;general-debugging-steps&#34;&gt;General debugging steps&lt;/h1&gt;

&lt;p&gt;Debugging的逻辑过程是&lt;a href=&#34;https://en.wikipedia.org/wiki/Abductive_reasoning#Logic-based_abduction&#34;&gt;Abductive reasoning&lt;/a&gt;. 我们以此进行推导.&lt;br /&gt;
T: Theory 也就是我们的background, cs的知识技术, 出问题的程序与代码.&lt;br /&gt;
O: Observations 是Bug发生的现场以及相应的log, 现象.&lt;br /&gt;
E: Explanation 是最终定位的结论.&lt;br /&gt;
E ⊆ T; O ⊆ T; E ⊃ (E ∩ O);&lt;br /&gt;
if E = (E ∩ O); then debugging is done.&lt;br /&gt;
T, E 与 O理论上都是从∅开始,且O =&amp;gt; E;&lt;br /&gt;
E: ∅ -&amp;gt; Bug type(可能经过是多种Bug types的过渡状态) -&amp;gt; Explanation&lt;br /&gt;
很多时候O也会使T扩大.所以O成为debugging的关键.&lt;br /&gt;
下面严格区分T 和 O. 我们得到O就要不断地结合T进行理性分析.&lt;br /&gt;
&amp;gt; Another perespective,&lt;br /&gt;
&amp;gt; the process of debugging is use O to minimize T to E instance.&lt;br /&gt;
&amp;gt; T is solutions space, E &lt;a href=&#34;https://nvd.nist.gov/cwe.cfm#cweIdEntry-CWE-1&#34;&gt;locates&lt;/a&gt; in T. O is the address to find E.&lt;/p&gt;

&lt;p&gt;基于NVD的CWE我们可知, 收集observations 可能是development和deployment的各个节点.&lt;/p&gt;

&lt;h3 id=&#34;get-observations&#34;&gt;Get observations&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;compilation&lt;br /&gt;
make kernel/sched.s V=1&lt;br /&gt;
readelf, objdump&lt;br /&gt;
c++filt&lt;br /&gt;
./scripts/decodecode &amp;lt; Oops.txt&lt;br /&gt;
echo&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;load software&lt;br /&gt;
LD_TRACE_LOADED_OBJECTS=1 git&lt;br /&gt;
ldd /usr/bin/git&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;software imediately stop&lt;br /&gt;
Use atexit() register a stackdump or a wrapped print&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;tips&lt;br /&gt;
If an page oops close to zero, for example 0xfffffff4&lt;br /&gt;
It maybe ERR_PTR(-12);&lt;br /&gt;
&lt;a href=&#34;http://www.stlinux.com/devel/debug/jtag/build?q=node/82&#34;&gt;Tips on debugging optimized code&lt;/a&gt;&lt;br /&gt;
code reordering inlining Optimized-away variables Tailcall optimization&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;oops&lt;br /&gt;
From ASM to c language&lt;br /&gt;
&lt;a href=&#34;http://yarchive.net/comp/linux/oops_decoding.html&#34;&gt;lkml-Linus-Al-Viro-oops-debug&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;asm&lt;/strong&gt;(), 常量, loop codes format, char *, ip&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;一些比较通用的调试工具&#34;&gt;一些比较通用的调试工具&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;gdb&lt;br /&gt;
gdb vmlinux /proc/kcore&lt;br /&gt;
p jiffies_64&lt;br /&gt;
text_addr=/sys/module/char-read-write/sections/.text&lt;br /&gt;
add-symbol-file /home/nkhare/char-read-write.ko $text_addr&lt;br /&gt;
print &amp;amp;((struct kmem_cache *)0)-&amp;gt;offset&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;anti-debugging&#34;&gt;Anti-debugging&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Syntax checking&lt;br /&gt;
gcc -Wall&lt;br /&gt;
bash -n&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;static code analysis&lt;br /&gt;
smatch&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;bug-made-by-me&#34;&gt;BUG made by me&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;print_signal_info wrong pritk parameters position&lt;br /&gt;
    printk(KERN_NOTICE &amp;ldquo;K %d : %d -&amp;gt; %s %d %s %d\n&amp;rdquo;, sig, q-&amp;gt;info.si_code,&lt;br /&gt;
            ss&lt;a href=&#34;http://www.opensourceforu.com/2010/10/joy-of-programming-types-of-bugs&#34;&gt;2&lt;/a&gt;, ss&lt;a href=&#34;https://nvd.nist.gov/cwe.cfm&#34;&gt;3&lt;/a&gt;, task_tgid_vnr(r_t), task_tgid_vnr(r_p));&lt;br /&gt;
Watch compile warning info can be avoid of this bug.&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;spin_lock(sighand) invoke down_sem and cond_resched&amp;hellip;&lt;br /&gt;
__send_signal()&lt;/p&gt;

&lt;h1 id=&#34;examples&#34;&gt;Examples&lt;/h1&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;timer_list-&amp;gt;function = NULL&lt;br /&gt;
我前几天定位了一个Softirq中timer corruption的问题, 现象是timer func是个非法地址.&lt;br /&gt;
首先, 一下子不能确认是由那种Bug type导致的.可能是Improper Restriction of Operations&lt;br /&gt;
within the Bounds of a Memory Buffer 也可能是Use after free. 所以此时debug的关键所在&lt;br /&gt;
就是收集observations,也就是function的名字, 而我遇到的这个问题timer 被完全写坏了.&lt;br /&gt;
可以用ftrace收集所有timer 的地址和function, 再从oops里面得到timer地址,回头找ftrace&lt;br /&gt;
log中记录的function, 从而定位问题. 稍后介绍, 如何通过expect抓屏幕log.&lt;br /&gt;
这个方法没成功, 时候分析知道是因为panic的瞬间出问题的timer的地址和function没来得及&lt;br /&gt;
记录到ftrace.怎么办? 我直接说了, 我想到一个办法, 把timer的空间增大, 增大的空间用来&lt;br /&gt;
保存function,在oops把这块内存打出来. 此法非常有用, timer的function一下子就找到了, 进而&lt;br /&gt;
确认了问题是use after free. 非常开心:-)这里的解释了如何收集observations的技巧.对待use&lt;br /&gt;
after free的问题是够了, 以后用到这类问题基本可以妙解了.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;module text address&lt;br /&gt;
cat /sys/module/wmi/sections/.text&lt;br /&gt;
cat /proc/modules | grep wmi&lt;br /&gt;
int bss_var;&lt;br /&gt;
static int hello_init(void)&lt;br /&gt;
{printk(KERN_ALERT &amp;ldquo;Text location .text(Code Segment):%p\n&amp;rdquo;,hello_init);&lt;br /&gt;
static int data_var=0;&lt;br /&gt;
printk(KERN_ALERT &amp;ldquo;Data Location .data(Data Segment):%p\n&amp;rdquo;,&amp;amp;data_var);&lt;br /&gt;
printk(KERN_ALERT &amp;ldquo;BSS Location: .bss(BSS Segment):%p\n&amp;rdquo;,&amp;amp;bss_var);}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>The art of programming</title>
      <link>http://firoyang.org/cs/programming/</link>
      <pubDate>Fri, 27 Feb 2015 15:46:14 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/programming/</guid>
      <description>

&lt;h1 id=&#34;lqo&#34;&gt;LQO&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;GNU AS&lt;br /&gt;
inline asm &amp;lsquo;=&amp;rsquo;?&lt;br /&gt;
&amp;amp; &lt;a href=&#34;https://stackoverflow.com/questions/45895564/how-does-r-differ-from-r&#34;&gt;https://stackoverflow.com/questions/45895564/how-does-r-differ-from-r&lt;/a&gt;&lt;br /&gt;
&amp;ldquo;memory clobber&amp;rdquo;?&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;cps&#34;&gt;CPS&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://spin.atomicobject.com/2012/11/01/hey-c-is-a-functional-language-too/&#34;&gt;https://spin.atomicobject.com/2012/11/01/hey-c-is-a-functional-language-too/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://en.wikipedia.org/wiki/Direct_style&#34;&gt;https://en.wikipedia.org/wiki/Direct_style&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Category:Programming_principles&#34;&gt;Programming principles&lt;/a&gt;&lt;br /&gt;
programming principles&lt;br /&gt;
High cohesion low coupling&lt;/p&gt;

&lt;h1 id=&#34;computer-programming&#34;&gt;Computer programming&lt;/h1&gt;

&lt;p&gt;编程作为我重要的谋生手段, 有必要审慎的加以考察审视. 程序设计应该包含那些最少的, 必备的, 重要的能力呢?&lt;br /&gt;
&lt;a href=&#34;http://www.cs.princeton.edu/~bwk/tpop.webpage/&#34;&gt;The practice of programming&lt;/a&gt;给出了大概的框架, 但不完整.&lt;br /&gt;
我认为最重要的就是Abstraction and design.&lt;br /&gt;
&lt;a href=&#34;http://www.ccs.neu.edu/home/matthias/HtDP2e/&#34;&gt;How to design programs&lt;/a&gt;还有&lt;a href=&#34;http://sarabander.github.io/sicp/&#34;&gt;SICP&lt;/a&gt;以及Elements of programming.&lt;br /&gt;
其次我们要掌握几门Programming language.&lt;br /&gt;
养成好的Coding style,&lt;br /&gt;
Valid and verification&lt;br /&gt;
Testing&lt;br /&gt;
Debuging&lt;/p&gt;

&lt;h1 id=&#34;files-sytle&#34;&gt;Files sytle&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://lists.kernelnewbies.org/pipermail/kernelnewbies/2012-March/004986.html&#34;&gt;kernel asm/asm-generic&lt;/a&gt;&lt;br /&gt;
asm stands for arch specific macros(FIXME).&lt;/p&gt;

&lt;h1 id=&#34;coding-style&#34;&gt;Coding style&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.gnu.org/prep/standards/standards.html&#34;&gt;GNU Coding Standards&lt;/a&gt;&lt;br /&gt;
比如GNU coding standards, Linux kernel coding style, Shell coding standard&lt;br /&gt;
* Label&lt;br /&gt;
It is considered to be safer that the label reflect what happens at the&lt;br /&gt;
destination, and not the reason for reaching the label. &amp;ndash;Julia&lt;/p&gt;

&lt;h1 id=&#34;verification-and-validation&#34;&gt;Verification and validation&lt;/h1&gt;

&lt;p&gt;抽象的知识来自生活经验的总结, 所以学习抽象知识的重要方向是从实践不断总结抽象.&lt;br /&gt;
programming is a goal-oriented activity&lt;br /&gt;
14.4&lt;br /&gt;
Before attempting to solve a problem, make absolutely sure you  what the problem is.&lt;br /&gt;
14.5&lt;br /&gt;
Before developing a program, make precise and refine the pre/postcondition.&lt;br /&gt;
program -&amp;gt;&lt;br /&gt;
{Q} S {R}: predicte, formal notation&lt;br /&gt;
Q: input asseration&lt;br /&gt;
R: output asseration&lt;br /&gt;
predictes -&amp;gt; asseration&lt;br /&gt;
asseration: a predicate placed in a program is called an asseration.&lt;br /&gt;
Proof outline: a program together with an asseration between each pair of statements&lt;br /&gt;
Program specification ⊃ excution ∪ speed ∪ size&lt;br /&gt;
Instances: summation, squre root approximation, sorting&lt;br /&gt;
command-comment ⊃ all input ∪ output&lt;/p&gt;

&lt;h1 id=&#34;debugging&#34;&gt;Debugging&lt;/h1&gt;

&lt;p&gt;see debugging.md&lt;/p&gt;

&lt;h1 id=&#34;testing&#34;&gt;Testing&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://googletesting.blogspot.com/&#34;&gt;Google testing blog&lt;/a&gt;&lt;br /&gt;
1.Black-box testing test software function.&lt;br /&gt;
2.White-box testing test software internal logic.&lt;/p&gt;

&lt;h1 id=&#34;good-taste&#34;&gt;Good taste&lt;/h1&gt;

&lt;p&gt;remove_list_entry(entry)&lt;br /&gt;
{&lt;br /&gt;
  // The &amp;ldquo;indirect&amp;rdquo; pointer points to the&lt;br /&gt;
  // &lt;em&gt;address&lt;/em&gt; of the thing we&amp;rsquo;ll update&lt;br /&gt;
  indirect = &amp;head;&lt;/p&gt;

&lt;p&gt;// Walk the list, looking for the thing that&lt;br /&gt;
  // points to the entry we want to remove&lt;/p&gt;

&lt;p&gt;while ((*indirect) != entry)&lt;br /&gt;
    indirect = &amp;amp;(*indirect)-&amp;gt;next;&lt;/p&gt;

&lt;p&gt;// .. and just remove it&lt;br /&gt;
  *indirect = entry-&amp;gt;next;&lt;br /&gt;
}&lt;/p&gt;

&lt;p&gt;remove_list_entry(entry)&lt;br /&gt;
{&lt;br /&gt;
  prev = NULL;&lt;br /&gt;
  walk = head;&lt;/p&gt;

&lt;p&gt;// Walk the list&lt;/p&gt;

&lt;p&gt;while (walk != entry) {&lt;br /&gt;
    prev = walk;&lt;br /&gt;
    walk = walk-&amp;gt;next;&lt;br /&gt;
  }&lt;/p&gt;

&lt;p&gt;// Remove the entry by updating the&lt;br /&gt;
  // head or the previous entry&lt;/p&gt;

&lt;p&gt;if (!prev)&lt;br /&gt;
    head = entry-&amp;gt;next;&lt;br /&gt;
  else&lt;br /&gt;
    prev-&amp;gt;head = entry-&amp;gt;next;&lt;br /&gt;
}&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The programming language</title>
      <link>http://firoyang.org/cs/pl/</link>
      <pubDate>Fri, 27 Feb 2015 15:46:14 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/pl/</guid>
      <description>

&lt;h1 id=&#34;data-types&#34;&gt;Data types&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://manybutfinite.com/post/closures-objects-heap/&#34;&gt;Closures, Objects, and the Fauna of the Heap&lt;/a&gt;&lt;br /&gt;
value types and reference types. A value of value type is the actual value. A value of reference type is a reference to another value.&lt;br /&gt;
value types: stack&lt;br /&gt;
reference types: heap&lt;/p&gt;

&lt;h1 id=&#34;scope&#34;&gt;Scope&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Scope_(computer_science)#Lexical_scope_vs._dynamic_scope&#34;&gt;https://en.wikipedia.org/wiki/Scope_(computer_science)#Lexical_scope_vs._dynamic_scope&lt;/a&gt;&lt;br /&gt;
Lexical scope vs. dynamic scope&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.yinwang.org/blog-cn/2016/03/31/no-longer-pl&#34;&gt;我为什么不再做PL人&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html&#34;&gt;Functors, Applicatives, And Monads In Pictures&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://jozefg.bitbucket.org/posts/2015-08-14-learn-tt.html&#34;&gt;Learn Type Theory&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.zhihu.com/question/21843639&#34;&gt;http://www.zhihu.com/question/21843639&lt;/a&gt;&lt;br /&gt;
貌似正则是type 3, c是type2, 范式角度我现在不好理解, 缺乏语言学的知识.&lt;br /&gt;
Programming Language Pragmatics 3rd&lt;br /&gt;
C11&lt;br /&gt;
C Traps and Pitfalls&lt;br /&gt;
Expert C Programming&lt;/p&gt;

&lt;h1 id=&#34;contents&#34;&gt;Contents&lt;/h1&gt;

&lt;p&gt;Programming language theory&lt;br /&gt;
Programming language&lt;/p&gt;

&lt;h1 id=&#34;programming-language-theory&#34;&gt;Programming language theory&lt;/h1&gt;

&lt;p&gt;What is formal language and the relationg between fl and pl?&lt;br /&gt;
Language primitive&lt;/p&gt;

&lt;h2 id=&#34;semantics&#34;&gt;Semantics&lt;/h2&gt;

&lt;h1 id=&#34;c&#34;&gt;C&lt;/h1&gt;

&lt;p&gt;我们还是从使用的角度来看c 语言;&lt;br /&gt;
c语言自身重要基础性质, 我们需要了解.&lt;br /&gt;
除此之外, 我们还要了解一些重要的标准库函数.&lt;br /&gt;
知道这些, 我们就能用c语言.&lt;/p&gt;

&lt;h2 id=&#34;type&#34;&gt;Type&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Object type and function type&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Object &amp;ndash; void, scalar,aggregate types, composite&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Scalar type &amp;ndash; Arithmetic types and pointer types&lt;br /&gt;
&lt;a href=&#34;http://www.techopedia.com/definition/16441/scalar&#34;&gt;What does Scalar mean?&lt;/a&gt;&lt;br /&gt;
scalar 词源上由scale演化而来, scalar type来自scalar processor and vector processor.&lt;br /&gt;
超标量也是来自这里concurrent SISD =&amp;gt;MIMD 所谓的流水线.&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Arithmetic type &amp;ndash; Integer and floating types&lt;/p&gt;

&lt;h2 id=&#34;incomplete-and-complete&#34;&gt;Incomplete and complete&lt;/h2&gt;

&lt;p&gt;void; struct s; union u;&lt;/p&gt;

&lt;h2 id=&#34;conversion&#34;&gt;Conversion&lt;/h2&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;only effect to scalar type data&lt;br /&gt;
error: conversion to non-scalar type requested&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;无符号数 转换成upper rank的有符号数, 还是无符号数, 不管最初是-1!&lt;br /&gt;
unsigned int i = 1; long f = -10;if ( i &amp;gt; f ) printf(&amp;ldquo;ok\n&amp;rdquo;); true 证明确实usigned 向long转换了.&lt;br /&gt;
unsigned int i = -3; long f = -5u;if ( i &amp;gt; f ) printf(&amp;ldquo;ok\n&amp;rdquo;); true&lt;br /&gt;
c11上是ok的!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;做signed 和unsigned 貌似both convert to unsigned gcc才给警告, 否则不给即便是signed和unsigned比较.&lt;/p&gt;

&lt;h2 id=&#34;lvalue-rvalue-modfiable-rvalue&#34;&gt;lvalue rvalue modfiable rvalue&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c&#34;&gt;Understanding lvalues and rvalues in C and C++&lt;/a&gt;&lt;br /&gt;
If a variable/expression  has a address, it&amp;rsquo;s of lvalue.&lt;/p&gt;

&lt;h2 id=&#34;array-decay&#34;&gt;Array decay&lt;/h2&gt;

&lt;p&gt;数组退化的初衷, 可能是K&amp;amp;R当年计算资源紧缺, 导致不允许函数传值copy数组内容.&lt;br /&gt;
总之标准委员会介入之前就决定.&lt;br /&gt;
&lt;a href=&#34;http://bbs.chinaunix.net/thread-1031622-1-1.html&#34;&gt;[C] [原创]数组与指针&amp;mdash;都是&amp;rdquo;退化&amp;rdquo;惹的祸&lt;/a&gt;&lt;br /&gt;
关于char *s错误声明的讲解不错!&lt;br /&gt;
&lt;a href=&#34;http://stackoverflow.com/questions/17752978/exception-to-array-not-decaying-into-a-pointer&#34;&gt;Exception to array not decaying into a pointer?&lt;/a&gt;&lt;br /&gt;
在c11 6.3.2.1 Lvalues, arrays, and function designators第3点说明了&lt;br /&gt;
array不会退化的4种场景. Except when it is&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;the operand of the sizeof operator,&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;the _Alignof operator, or the&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;unary &amp;amp; operator, or&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;is a string literal used to initialize an array, an expression that has type&lt;br /&gt;
‘‘array of type’’ is converted to an expression with type ‘‘pointer to type’’&lt;br /&gt;
that points to the initial element of the array object and is not an lvalue.&lt;br /&gt;
If the array object has register storage class, the behavior is undefined.&lt;br /&gt;
这4种场景之外, 那么array名退化的结果是pointer.&lt;br /&gt;
这个pointer和我们最常用的pointer如int *p有什么区别呢?&lt;br /&gt;
首先array decay是type上的转化array -&amp;gt; pointer.&lt;br /&gt;
其次数组名原来是lvalue -&amp;gt; not an lvalue更谈不上modifiable.&lt;br /&gt;
type: tyepof(array[0]) *&lt;br /&gt;
value: &amp;amp;array[0] or array&lt;br /&gt;
property: not lvalue&lt;br /&gt;
当然这只是c11上的说明, 我们只要明白为什么不能修改一个decay数组名就行了.&lt;br /&gt;
实现的个人猜测是: 根据lvalue的定义decay后数组名还是lvalue, 只不过一直都不是modifiable.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为什么作为函数形参的数组名可以++, 而作为变量的数组名就不可以.&lt;br /&gt;
因为形参数组名被当初pointer处理modifiable lvalue, 而实参数组名只是传值而已.&lt;br /&gt;
而普通数组名是一个lvalue,不能修改.&lt;/p&gt;

&lt;h3 id=&#34;why-innermost-dimension-can-be-omit-in-array&#34;&gt;Why innermost dimension can be omit in array&lt;/h3&gt;

&lt;p&gt;用不到.&lt;br /&gt;
In essence, all arrays in C are one-dimensional.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Because the array will decay to pointer and to calculate offset to&lt;br /&gt;
the elements of the array you do not need to know the innermost dimension.&lt;/p&gt;

&lt;p&gt;Compiler has to know by how much to increment the pointer when&lt;br /&gt;
indexing on the first dimension for example. So if an int array is named a,&lt;/p&gt;

&lt;h2 id=&#34;integer-promotion&#34;&gt;Integer Promotion&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.idryman.org/blog/2012/11/21/integer-promotion/&#34;&gt;Deep C: Integer Promotion&lt;/a&gt;&lt;br /&gt;
* &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/fc9te331.aspx&#34;&gt;Integral Promotions&lt;/a&gt;&lt;br /&gt;
0xF int&lt;br /&gt;
0xFFFFFFFF unsigned int&lt;/p&gt;

&lt;h2 id=&#34;scopes-of-identifiers&#34;&gt;Scopes of identifiers&lt;/h2&gt;

&lt;p&gt;For each different entity that an identifier designates, the identifier is visible (i.e., can be used) only within a region of program text called its scope.&lt;br /&gt;
* four kinds of scopes: function, file, block, and function prototype&lt;/p&gt;

&lt;h2 id=&#34;linkages-of-identifiers&#34;&gt;linkages of identifiers&lt;/h2&gt;

&lt;p&gt;An identifier declared in different scopes or in the same scope more than once can be&lt;br /&gt;
made to refer to the same object or function by a process called linkage.&lt;br /&gt;
* There are three kinds of linkage: external, internal, and none.&lt;br /&gt;
* There is no linkage between different identifiers.&lt;br /&gt;
* external linkage&lt;br /&gt;
In the set of translation units and libraries that constitutes an entire program, each&lt;br /&gt;
declaration of a particular identifier with external linkage denotes the same object or&lt;br /&gt;
function. &amp;ndash;c11&lt;/p&gt;

&lt;p&gt;If the name has external linkage,&lt;br /&gt;
the entity that name denotes may be referred to from another translation unit&lt;br /&gt;
using a distinct declaration for that same name,&lt;br /&gt;
and from other scopes within the same translation unit using distinct declarations. &amp;ndash;wikipedia&lt;br /&gt;
* Internal linkage&lt;br /&gt;
Within one translation unit, each declaration of an identifier with internal&lt;br /&gt;
linkage denotes the same object or function. &amp;ndash;c11&lt;/p&gt;

&lt;p&gt;Were the name given internal linkage,&lt;br /&gt;
such a declaration would denote a distinct entity, although using the same name,&lt;br /&gt;
but its entity could be referred to by distinct declarations within the same translation unit.  &amp;ndash;wikipedia&lt;br /&gt;
* No linkage&lt;br /&gt;
Each declaration of an identifier with no linkage denotes a unique entity. &amp;ndash;c11&lt;br /&gt;
A name that has no linkage at all cannot be referred to from declarations in different scopes,&lt;br /&gt;
not even from within the same translation unit. &amp;ndash;wikipedia&lt;/p&gt;

&lt;h2 id=&#34;name-spaces-of-identifiers&#34;&gt;Name spaces of identifiers&lt;/h2&gt;

&lt;h2 id=&#34;storage-durations-of-objects&#34;&gt;Storage durations of objects&lt;/h2&gt;

&lt;p&gt;An object has a storage duration that determines its lifetime.&lt;br /&gt;
There are four storage durations: static, thread, automatic, and allocated.&lt;br /&gt;
The lifetime of an object is the portion of program execution during which storage is&lt;br /&gt;
guaranteed to be reserved for it.&lt;br /&gt;
In book 21st Century C, it was named memory mode.&lt;br /&gt;
* static storage duration&lt;br /&gt;
An object whose identifier is declared without the storage-class specifier _Thread_local,&lt;br /&gt;
and either with external or internal linkage or with the storage-class specifier static(for no linkage &amp;ndash;firo),&lt;br /&gt;
has static storage duration.&lt;/p&gt;

&lt;p&gt;Its lifetime is the entire execution of the program and its stored value is initialized only once,&lt;br /&gt;
prior to program startup.&lt;br /&gt;
* automatic storage duration&lt;br /&gt;
An object whose identifier is declared with no linkage and without the storage-class&lt;br /&gt;
specifier static has automatic storage duration, as do some compound literals.&lt;br /&gt;
* alloced storage duration&lt;br /&gt;
The lifetime of an allocated object extends from the allocation until the deallocation.&lt;br /&gt;
* Thread storage duration&lt;br /&gt;
details in c11&lt;/p&gt;

&lt;h2 id=&#34;alignment-of-objects&#34;&gt;Alignment of objects&lt;/h2&gt;

&lt;p&gt;An alignment is an implementation-defined integer value representing the number of bytes between&lt;br /&gt;
successive addresses at which a given object can be allocated.&lt;br /&gt;
More deatils in cs.md&lt;/p&gt;

&lt;h2 id=&#34;declarations&#34;&gt;Declarations&lt;/h2&gt;

&lt;p&gt;A declaration specifies the interpretation and attributes of a set of identifiers.&lt;br /&gt;
A definition of an identifier is a declaration for that identifier that:&lt;br /&gt;
for an object, causes storage to be reserved for that object;&lt;br /&gt;
for a function, includes the function body;&lt;br /&gt;
for an enumeration constant, is the (only) declaration of the identifier;&lt;br /&gt;
for a typedef name, is the first (or only) declaration of the identifier.&lt;br /&gt;
The declaration specifiers consist of a sequence of specifiers that indicate the linkage,&lt;br /&gt;
storage duration, and part of the type of the entities that the declarators denote.&lt;/p&gt;

&lt;h2 id=&#34;marco&#34;&gt;Marco&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/huyansoft/article/details/2484297&#34;&gt;如果#操作符出现在对象宏的替换列表中,则仅作为一个普通字符,不具有下述含义&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;expressions&#34;&gt;Expressions&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;cast&lt;br /&gt;
A cast does not yield an lvalue.&lt;/p&gt;

&lt;h2 id=&#34;lexical-element&#34;&gt;Lexical element&lt;/h2&gt;

&lt;h3 id=&#34;character-constants&#34;&gt;Character constants&lt;/h3&gt;

&lt;p&gt;An integer character constant has type int.&lt;/p&gt;

&lt;h2 id=&#34;lexical-pitfall&#34;&gt;lexical pitfall&lt;/h2&gt;

&lt;h2 id=&#34;greedy-lexical-analysis&#34;&gt;Greedy lexical analysis&lt;/h2&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Write tokens with blank!&lt;br /&gt;
x = y/&lt;em&gt;p;  /&lt;/em&gt; oops, hidden error.*/&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Associative&lt;br /&gt;
You donot need to remember it! Just use it!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Precedence&lt;br /&gt;
Need to remember, but if you not sure, parenthess.&lt;/p&gt;

&lt;h2 id=&#34;inline-和宏的区别&#34;&gt;inline 和宏的区别&lt;/h2&gt;

&lt;p&gt;inline的好处与坏处&lt;br /&gt;
没有调用的开销效率很高, 但是调试代码复杂了, 内链函数的实现是拷贝副本消耗内存.&lt;br /&gt;
inline有类型检测, 宏没有.&lt;/p&gt;

&lt;h2 id=&#34;c-standard-library&#34;&gt;C standard library&lt;/h2&gt;

&lt;h2 id=&#34;faq&#34;&gt;FAQ&lt;/h2&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Logical operation with signed value? x86!&lt;br /&gt;
int c = 0xFFFFFFFF;  int d = c &amp;gt;&amp;gt; 31; =&amp;gt; d == f;&lt;br /&gt;
unsigned c = 0xFFFFFFFF;  int d = c &amp;gt;&amp;gt; 31; d!= f;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;shift beyond bits long?&lt;br /&gt;
c &amp;gt;&amp;gt; 296 == c &amp;gt;&amp;gt; 8&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;变量同名不同类型不同文件, 通过extern, 否则就是multiple definition&lt;br /&gt;
这是c语言最为迷糊的地方.简单说来类似union, 具体我也不清楚.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;所有名字引用同一个object&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不同文件中不同类型的sizeof和当前文件类型一直.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;c-standard-library-1&#34;&gt;C standard library&lt;/h1&gt;

&lt;p&gt;NULL?&lt;/p&gt;

&lt;h2 id=&#34;string-handling&#34;&gt;String handling&lt;/h2&gt;

&lt;p&gt;kernel/lib/string.c&lt;br /&gt;
* Copying functions&lt;br /&gt;
memcpy: dest&lt;br /&gt;
memmove: dest&lt;br /&gt;
strcpy: dest, 拷贝\0&lt;br /&gt;
strncpy: dest, if src_len &amp;gt;= n; 0 NULL, if src _len &amp;lt; n; (n - len) NULL;&lt;br /&gt;
strlcpy: src_len, mini(n -1, src_len -1) + \0, src_len 用你返回啊!&lt;br /&gt;
* Concatenation functions&lt;br /&gt;
strcat: dest, overwrite dest \0 with src util src \0&lt;br /&gt;
strncat: dest, 末尾一定有\0&lt;br /&gt;
* Comparison functions&lt;br /&gt;
memcmp: 差值,&lt;br /&gt;
strcmp: -1, 0, 1, 如果整个s1都比完了NULL or &amp;ndash;n ==0 for strncmp, return 0&lt;br /&gt;
* Search functions&lt;br /&gt;
memchr, NULL or p;&lt;br /&gt;
strchr,ditto, 到\0返回NUll&lt;br /&gt;
strrchr,ditto, last occurence.&lt;br /&gt;
strspn: s1开始有多少在s2中.&lt;br /&gt;
strcspn: s1开始有多少不在s2中.&lt;br /&gt;
strpbrk: s2中第一次出现的位置&lt;br /&gt;
strstr: 找子串, 用memcmp&lt;/p&gt;

&lt;p&gt;#Wildcards&lt;br /&gt;
&lt;a href=&#34;http://whatis.techtarget.com/definition/wildcard-character&#34;&gt;A wildcard character is a type of meta character&lt;/a&gt;&lt;br /&gt;
##Type&lt;/p&gt;

&lt;h3 id=&#34;standard-wildcards-globbing-patterns&#34;&gt;Standard Wildcards (globbing patterns)&lt;/h3&gt;

&lt;p&gt;File and directory patterns&lt;br /&gt;
?: must stand for a character&lt;br /&gt;
* Regular expression&lt;br /&gt;
* SQL&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The computing processes</title>
      <link>http://firoyang.org/cs/process/</link>
      <pubDate>Fri, 27 Feb 2015 15:46:12 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/process/</guid>
      <description>

&lt;h1 id=&#34;processes&#34;&gt;Processes&lt;/h1&gt;

&lt;h2 id=&#34;instructions&#34;&gt;Instructions&lt;/h2&gt;

&lt;p&gt;opcode,&lt;br /&gt;
registers and RAM&lt;/p&gt;

&lt;h2 id=&#34;subroutine-and-procedure&#34;&gt;Subroutine and procedure&lt;/h2&gt;

&lt;p&gt;a group of instructions&lt;br /&gt;
stack&lt;/p&gt;

&lt;h2 id=&#34;interrupt-handler&#34;&gt;interrupt handler&lt;/h2&gt;

&lt;p&gt;procdure + optional own stack&lt;/p&gt;

&lt;h2 id=&#34;softirq-handler&#34;&gt;softirq handler&lt;/h2&gt;

&lt;p&gt;procdure + optional own stack&lt;/p&gt;

&lt;h2 id=&#34;kernel-thread&#34;&gt;kernel thread&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://courses.cs.vt.edu/cs5204/fall09-kafura/Presentations/Threads-VS-Events.pdf&#34;&gt;thread vs event&lt;/a&gt;&lt;br /&gt;
change of processes: associate change structure with a object and has more states; event-driven -&amp;gt; schedule&lt;br /&gt;
space: +kernel address space, more kind of resource space&lt;br /&gt;
change: implict changings.&lt;/p&gt;

&lt;h2 id=&#34;process-horizantal&#34;&gt;process(horizantal)&lt;/h2&gt;

&lt;p&gt;change: linkage of user space code&lt;br /&gt;
space: whole address space&lt;/p&gt;

&lt;h2 id=&#34;thread&#34;&gt;thread&lt;/h2&gt;

&lt;p&gt;share process address space&lt;br /&gt;
tls&lt;br /&gt;
&lt;a href=&#34;http://www.maxwellxxx.com/TLS&#34;&gt;Linux线程TLS（Thread-Local Storage）相关 GS段寄存器作用&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;usage&#34;&gt;usage&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.quora.com/What-is-the-relation-between-the-number-of-threads-and-the-number-of-CPU-cores&#34;&gt;https://www.quora.com/What-is-the-relation-between-the-number-of-threads-and-the-number-of-CPU-cores&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;change-of-processes&#34;&gt;Change of processes&lt;/h1&gt;

&lt;h2 id=&#34;instructions-1&#34;&gt;Instructions&lt;/h2&gt;

&lt;p&gt;pc + 1&lt;/p&gt;

&lt;h2 id=&#34;subroutine-and-procedure-1&#34;&gt;Subroutine and procedure&lt;/h2&gt;

&lt;p&gt;save: push pc + 1; optional caller saved registers&lt;br /&gt;
entry: save rbp; callee saved registers&lt;br /&gt;
return: mov rbp -&amp;gt; rsp; pop rbp; ret&lt;/p&gt;

&lt;h2 id=&#34;softirq&#34;&gt;softirq&lt;/h2&gt;

&lt;h2 id=&#34;system-call&#34;&gt;system call&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/&#34;&gt;The Definitive Guide to Linux System Calls&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://groups.google.com/forum/#!topic/comp.arch/CjDs4MJCBow%5B1-25%5D&#34;&gt;SYSENTER/SYSEXIT vs.SYSCALL/SYSRET&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://arkanis.de/weblog/2017-01-05-measurements-of-system-call-performance-and-overhead&#34;&gt;Measurements of system call performance and overhead&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://reverseengineering.stackexchange.com/a/16511/16996&#34;&gt;AMD vs Intel and syscall vs sysenter&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.codeguru.com/cpp/misc/misc/system/article.php/c8223/System-Call-Optimization-with-the-SYSENTER-Instruction.htm&#34;&gt;System Call Optimization with the SYSENTER Instruction&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://articles.manugarg.com/systemcallinlinux2_6.html&#34;&gt;Sysenter Based System Call Mechanism in Linux 2.6&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.kernel.org/doc/Documentation/x86/entry_64.txt&#34;&gt;kernel documentation&lt;/a&gt;&lt;br /&gt;
Meltdown and Spectre&lt;/p&gt;

&lt;h3 id=&#34;syscall&#34;&gt;syscall&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;save: pc + 1, old rsp, registers&lt;br /&gt;
pc + 1-&amp;gt; RCX&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;entry: pc&lt;br /&gt;
IA32_LSTAR -&amp;gt; pc&lt;/p&gt;

&lt;h3 id=&#34;kernel-implementations&#34;&gt;kernel implementations&lt;/h3&gt;

&lt;p&gt;64-bit long mode: syscall; check syscall_init&lt;br /&gt;
64-bit compatible kernel: sysenter, syscall, or int 0x80; check __kernel_vsyscall and def_idts&lt;br /&gt;
??32-bit kernel: int 0x80, sysenter;&lt;/p&gt;

&lt;h3 id=&#34;vdso-and-vsyscall&#34;&gt;vDSO and vsyscall&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/446528/&#34;&gt;On vsyscalls and the vDSO&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://blog.tinola.com/?e=5&#34;&gt;linux syscalls on x86 64&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;64-bit without COMPAT&lt;em&gt;32&lt;/em&gt;/compatible kernel&lt;br /&gt;
./int80&lt;br /&gt;
[  730.583700] traps: int80[1697] general protection ip:4000c4 sp:7ffd84b59730 error:402 in int80[400000+1000]&lt;br /&gt;
Segmentation fault (core dumped)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;64-bit syscall&lt;br /&gt;
syscall.S&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;signal&#34;&gt;signal&lt;/h2&gt;

&lt;h2 id=&#34;interrupt&#34;&gt;interrupt&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://people.cs.clemson.edu/~mark/interrupts.html&#34;&gt;history of interrupts&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://virtualirfan.com/history-of-interrupts&#34;&gt;Another History of interrupts with video&lt;/a&gt;&lt;br /&gt;
Interrupts: asynonymous(passively received), external&lt;br /&gt;
Exception: synonymous(actively detected), internal&lt;br /&gt;
Software interrupts: is a trap. int/int3, into, bound.&lt;br /&gt;
IPI:&lt;br /&gt;
&lt;a href=&#34;http://wangcong.org/2012/06/01/-e4-b8-ba-e4-bb-80-e4-b9-88linux-e5-86-85-e6-a0-b8-e4-b8-8d-e5-85-81-e8-ae-b8-e5-9c-a8-e4-b8-ad-e6-96-ad-e4-b8-ad-e4-bc-91-e7-9c-a0-ef-bc-9f/&#34;&gt;为什么Linux内核不允许在中断中休眠&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;hardlockup&#34;&gt;Hardlockup&lt;/h3&gt;

&lt;p&gt;www.kernel.org/doc/Documentation/lockup-watchdogs.txt&lt;/p&gt;

&lt;h3 id=&#34;mask-exception&#34;&gt;Mask exception&lt;/h3&gt;

&lt;p&gt;RF in EFLAGS for masking #DB&lt;br /&gt;
SS &amp;amp; SP&lt;/p&gt;

&lt;h2 id=&#34;exception&#34;&gt;exception&lt;/h2&gt;

&lt;h2 id=&#34;thread-switch&#34;&gt;Thread switch&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lwn.net/Articles/520227/&#34;&gt;Al Viro&amp;rsquo;s new execve/kernel_thread design&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;call-jump-ret-0100301bfdf56a2a370c7157b5ab0fbf9313e1cd&#34;&gt;call+jump+ret - 0100301bfdf56a2a370c7157b5ab0fbf9313e1cd&lt;/h3&gt;

&lt;p&gt;((last) = __switch_to_asm((prev), (next)));             #=====&amp;gt; call&lt;/p&gt;

&lt;p&gt;jmp     __switch_to                         #=====&amp;gt; jmp + ret&lt;/p&gt;

&lt;h3 id=&#34;old-version-switch-to-push-jmp-ret&#34;&gt;Old version switch_to - push+jmp+ret&lt;/h3&gt;

&lt;p&gt;switch_to&lt;br /&gt;
-       asm volatile(&amp;ldquo;pushl %%ebp\n\t&amp;rdquo;          /* save    EBP   &lt;em&gt;/     &lt;br /&gt;
-                    &amp;ldquo;movl %%esp,%[prev_sp]\n\t&amp;rdquo;        /&lt;/em&gt; save    ESP   &lt;em&gt;/ \   #=====&amp;gt;PREV: Save ESP into task struct thread.&lt;br /&gt;
-                    &amp;ldquo;movl %[next_sp],%%esp\n\t&amp;rdquo;        /&lt;/em&gt; restore ESP   &lt;em&gt;/ \   #=====&amp;gt;NEXT: Setup stack for linkage from task struct thread.&lt;br /&gt;
-                    &amp;ldquo;movl $1f,%[prev_ip]\n\t&amp;rdquo;  /&lt;/em&gt; save    EIP   &lt;em&gt;/     \   #=====&amp;gt;PREV: Save PC into task sturct thread.&lt;br /&gt;
-                    &amp;ldquo;pushl %[next_ip]\n\t&amp;rdquo;     /&lt;/em&gt; restore EIP   &lt;em&gt;/     \   #=====&amp;gt;NEXT: push - Store PC on stack from task struct thread;&lt;br /&gt;
-                    &amp;ldquo;jmp __switch_to\n&amp;rdquo;        /&lt;/em&gt; regparm call  &lt;em&gt;/     \   #=====&amp;gt;NEXT: jmp + ret - Return and restore PC.&lt;br /&gt;
-                    &amp;ldquo;1:\t&amp;rdquo;                                             &lt;br /&gt;
-                    &amp;ldquo;popl %%ebp\n\t&amp;rdquo;           /&lt;/em&gt; restore EBP   &lt;em&gt;/     &lt;br /&gt;
-                                                                       &lt;br /&gt;
-                    /&lt;/em&gt; output parameters &lt;em&gt;/                            &lt;br /&gt;
-                    : [prev_sp] &amp;ldquo;=m&amp;rdquo; (prev-&amp;gt;thread.sp),                &lt;br /&gt;
-                      [prev_ip] &amp;ldquo;=m&amp;rdquo; (prev-&amp;gt;thread.ip),                &lt;br /&gt;
-                      &amp;ldquo;=a&amp;rdquo; (last),                                     &lt;br /&gt;
-                                                                       &lt;br /&gt;
-                      /&lt;/em&gt; clobbered output registers: &lt;em&gt;/                &lt;br /&gt;
-                      &amp;ldquo;=b&amp;rdquo; (ebx), &amp;ldquo;=c&amp;rdquo; (ecx), &amp;ldquo;=d&amp;rdquo; (edx),              &lt;br /&gt;
-                      &amp;ldquo;=S&amp;rdquo; (esi), &amp;ldquo;=D&amp;rdquo; (edi)                           &lt;br /&gt;
-                      /&lt;/em&gt; input parameters: */                          &lt;br /&gt;
-                    : [next_sp]  &amp;ldquo;m&amp;rdquo; (next-&amp;gt;thread.sp),                &lt;br /&gt;
-                      [next_ip]  &amp;ldquo;m&amp;rdquo; (next-&amp;gt;thread.ip),                &lt;br /&gt;
&lt;a href=&#34;https://stackoverflow.com/questions/15019986/why-does-switch-to-use-pushjmpret-to-change-eip-instead-of-jmp-directly/15024312&#34;&gt;Why does switch_to use push+jmp+ret to change EIP, instead of jmp directly?&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;kernel-thread-1&#34;&gt;Kernel thread&lt;/h2&gt;

&lt;p&gt;kernel_thread-&amp;gt;kthread-&amp;gt;do_exit&lt;/p&gt;

&lt;h2 id=&#34;task-switching&#34;&gt;Task switching&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://lkml.org/lkml/2016/3/21/517&#34;&gt;https://lkml.org/lkml/2016/3/21/517&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;dbg-softlockup&#34;&gt;DBG: Softlockup&lt;/h3&gt;

&lt;p&gt; ps aux | grep watchdog&lt;br /&gt;
root        13  0.0  0.0      0     0 ?        S    08:23   0:00 [watchdog/0]&lt;br /&gt;
root        16  0.0  0.0      0     0 ?        S    08:23   0:00 [watchdog/1]&lt;br /&gt;
root        22  0.0  0.0      0     0 ?        S    08:23   0:00 [watchdog/2]&lt;br /&gt;
root        28  0.0  0.0      0     0 ?        S    08:23   0:00 [watchdog/3]&lt;/p&gt;

&lt;h3 id=&#34;dbg-hung-tasks-bugs&#34;&gt;DBG: Hung tasks bugs&lt;/h3&gt;

&lt;h4 id=&#34;think-for-myself&#34;&gt;think for myself&lt;/h4&gt;

&lt;p&gt;A kernel bug casuse task to be stuck in &amp;ldquo;D&amp;rdquo; state indefinitely.&lt;br /&gt;
1. A D state task wait list.&lt;br /&gt;
2. Hung task timeout.&lt;br /&gt;
3. Timestamp on adding task to &amp;ldquo;D&amp;rdquo; state wait list.&lt;br /&gt;
4. Kernel thread for detecting hung tasks - schedule timeout; why kthread?&lt;/p&gt;

&lt;h5 id=&#34;problems&#34;&gt;Problems&lt;/h5&gt;

&lt;p&gt;How could I find all the D state tasks?&lt;br /&gt;
1. kernel must use specific functions to put D-task on wait list.&lt;br /&gt;
2. Embeded codes into specific functions to catch &amp;rsquo;D&amp;rsquo; state tasks and put them in the wait list for Hung tasks detecting.&lt;/p&gt;

&lt;h4 id=&#34;kernel-implemention&#34;&gt;Kernel Implemention&lt;/h4&gt;

&lt;p&gt;DETECT_HUNG_TASK&lt;br /&gt;
kernel/hung_task.c&lt;br /&gt;
check_hung_uninterruptible_tasks&lt;br /&gt;
* diffeneces&lt;br /&gt;
1: kenrel task list - init_task.tasks and p-&amp;gt;signal-&amp;gt;thread_head in copy_process&lt;br /&gt;
3: t-&amp;gt;nvcsw + t-&amp;gt;nivcsw, t-&amp;gt;last_switch_count and timeout&lt;br /&gt;
cat /proc/self/status | grep ctxt_switches&lt;/p&gt;

&lt;h3 id=&#34;preemption&#34;&gt;Preemption&lt;/h3&gt;

&lt;h4 id=&#34;user-preemption-linux-kernel-user-mode-is-always-user-preemption&#34;&gt;User preemption - Linux kernel user mode is always User preemption.&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;When returning to user-space from a system call.&lt;br /&gt;
syscall_return_slowpath&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;When returning to user-space from an interrupt hander.&lt;br /&gt;
retint_user-&amp;gt;prepare_exit_to_usermode&lt;/p&gt;

&lt;h4 id=&#34;linux-kernel-kernel-mode-is-coppertive-when-config-preempt-is-not-set&#34;&gt;Linux kernel kernel mode is coppertive when CONFIG_PREEMPT is not set.&lt;/h4&gt;

&lt;p&gt;bloked (which results in a call to schedule())&lt;br /&gt;
If a task in the kernel explicitly calls schedule() it&amp;rsquo;s involuntary!!!&lt;/p&gt;

&lt;h4 id=&#34;linux-kernel-kernel-mode-is-coppertive-preemptive-when-config-preempt-is-set&#34;&gt;Linux kernel kernel mode is coppertive + preemptive when CONFIG_PREEMPT is set.&lt;/h4&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;When an interrupt handler exits, before returning to kernel-space.&lt;br /&gt;
retint_kernel-&amp;gt;preempt_schedule_irq-&amp;gt;cond_resched&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;need_resched - When kernel code becomes preemptible again.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;set_tsk_need_resched() in resched_curr&lt;br /&gt;
tick: check_preempt_tick or entity_tick&lt;br /&gt;
fork: wake_up_new_task-&amp;gt;check_preempt_curr-&amp;gt;check_preempt_wakeup&lt;br /&gt;
wakeup: check_preempt_wakeup&lt;br /&gt;
&amp;hellip;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;if (need_resched()) cond_resched();&lt;/p&gt;

&lt;h4 id=&#34;lqo&#34;&gt;LQO&lt;/h4&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;if (!preempt &amp;amp;&amp;amp; prev-&amp;gt;state)in __schedule why prev-&amp;gt;state?&lt;br /&gt;
it&amp;rsquo;s because of need_resched&lt;br /&gt;
?? schedule_idle&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;lqo-1&#34;&gt;LQO&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;canary&lt;br /&gt;
&lt;a href=&#34;https://my.oschina.net/macwe/blog/610357&#34;&gt;https://my.oschina.net/macwe/blog/610357&lt;/a&gt;&lt;br /&gt;
boot_init_stack_canary&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;bug??&lt;br /&gt;
__do_softirq&lt;br /&gt;
258         pending = local_softirq_pending();&lt;br /&gt;
259         account_irq_enter_time(current);&lt;br /&gt;
260&lt;br /&gt;
261         __local_bh_disable_ip(_RET&lt;em&gt;IP&lt;/em&gt;, SOFTIRQ_OFFSET);&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;os presentations&lt;br /&gt;
&lt;a href=&#34;http://courses.cs.vt.edu/cs5204/fall09-kafura/Presentations/&#34;&gt;http://courses.cs.vt.edu/cs5204/fall09-kafura/Presentations/&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;procedure-and-subroutine-and-linkage-method&#34;&gt;Procedure and subroutine and linkage method&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://people.cs.clemson.edu/~mark/subroutines.html&#34;&gt;https://people.cs.clemson.edu/~mark/subroutines.html&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://en.wikipedia.org/wiki/Subroutine&#34;&gt;https://en.wikipedia.org/wiki/Subroutine&lt;/a&gt;&lt;br /&gt;
* 1945 Turing on subroutines in &lt;a href=&#34;http://www.alanturing.net/turing_archive/archive/p/p01/P01-011.html&#34;&gt;Proposed electronic calculator.&lt;/a&gt;&lt;br /&gt;
In Chapter 6. Outline of Logical Control.&lt;br /&gt;
We also wish to be able to arrange for the splitting up of operations into&amp;hellip;&lt;br /&gt;
When we wish to start on a subsidiary operation we need only make a note&lt;br /&gt;
of where we left off the major operation&amp;hellip;&lt;br /&gt;
* 1952 &lt;a href=&#34;http://www.laputan.org/pub/papers/wheeler.pdf&#34;&gt;The use of sub-routines in programmes&lt;/a&gt;&lt;br /&gt;
The above remarks may be summarized by saying sub-routines are very useful — although not absolutely necessary — and that the prime objectives to be born in mind when constructing them are simplicity of use, correctness of codes and accuracy of description. All complexities should—if possible—be buried out of sight.&lt;br /&gt;
* 1960 &lt;a href=&#34;https://link.springer.com/article/10.1007%2FBF01386232&#34;&gt;Dijkstra, E. W. (1960). &amp;ldquo;Recursive Programming&amp;rdquo;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;linkage&#34;&gt;linkage&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Link_register&#34;&gt;https://en.wikipedia.org/wiki/Link_register&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;structred-programming&#34;&gt;Structred programming&lt;/h1&gt;

&lt;p&gt;Structured Programming - Dijkstra&lt;/p&gt;

&lt;h1 id=&#34;kthread&#34;&gt;kthread&lt;/h1&gt;

&lt;h2 id=&#34;resource&#34;&gt;resource&lt;/h2&gt;

&lt;h2 id=&#34;change&#34;&gt;Change&lt;/h2&gt;

&lt;p&gt;Periodical: schedule_timeout&lt;br /&gt;
Demand:&lt;/p&gt;

&lt;h2 id=&#34;inter-process-info&#34;&gt;inter-process info&lt;/h2&gt;

&lt;h1 id=&#34;call-stack&#34;&gt;Call stack&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Call_stack#Functions_of_the_call_stack&#34;&gt;https://en.wikipedia.org/wiki/Call_stack#Functions_of_the_call_stack&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://dl.acm.org/citation.cfm?id=2716018#.W5zV9yqRi-c.twitter&#34;&gt;https://dl.acm.org/citation.cfm?id=2716018#.W5zV9yqRi-c.twitter&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;fork-a-new-process&#34;&gt;Fork a new process&lt;/h1&gt;

&lt;p&gt;What does the child process need from parent?&lt;br /&gt;
    sched_fork: setup schduling stuff&lt;br /&gt;
    memory: copy parent&amp;rsquo;s mm&lt;br /&gt;
How to share memory stuff with parent process?&lt;br /&gt;
    Linux use COW technique to do this.&lt;br /&gt;
    How does COW work?&lt;br /&gt;
    Why does Linux just share page?&lt;br /&gt;
How to diverge the child execution flow from parent?&lt;br /&gt;
    what is the first instruction executed by the child process?&lt;/p&gt;

&lt;h1 id=&#34;insepct-process-status&#34;&gt;Insepct process status&lt;/h1&gt;

&lt;p&gt;do_task_stat&lt;br /&gt;
Kernel mapping: tgid_base_stuff show_map_vma&lt;/p&gt;

&lt;h1 id=&#34;protection&#34;&gt;Protection&lt;/h1&gt;

&lt;p&gt;3A: Chaper 5&lt;/p&gt;

&lt;h1 id=&#34;faq&#34;&gt;FAQ&lt;/h1&gt;

&lt;p&gt;Check glibc sysdeps/unix/sysv/linux/x86_64/clone.S for creating a new thread.&lt;/p&gt;

&lt;h2 id=&#34;idle-kernel-stack&#34;&gt;idle kernel stack&lt;/h2&gt;

&lt;p&gt;master idle进程的kernel stack在init/init_task.c:init_thread_union&lt;br /&gt;
其他进程的kernel stack是fork产生.&lt;br /&gt;
this_cpu_write(kernel_stack,(unsigned long)task_stack_page(next_p) +THREAD_SIZE);&lt;br /&gt;
this_cpu_write(cpu_current_top_of_stack,(unsigned long)task_stack_page(next_p) +THREAD_SIZE);&lt;br /&gt;
主处理器上的idle由原始进程(pid=0)演变而来。从处理器上的idle由init进程fork得到，但是它们的pid都为0 init_idle.&lt;br /&gt;
Deamonize&lt;/p&gt;

&lt;h1 id=&#34;zombie-process&#34;&gt;Zombie process&lt;/h1&gt;

&lt;h2 id=&#34;defunct&#34;&gt;&lt;defunct&gt;&lt;/h2&gt;

&lt;p&gt;forked child not reaped by parent will hooked in process list.&lt;br /&gt;
if parent was killed and exit &lt;defunct&gt; will repaped.&lt;br /&gt;
&lt;defunct&gt;表明父活着, 但不收尸.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
