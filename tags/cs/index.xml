<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Cs on f(x) </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://firoyang.org/tags/cs/</link>
    <language>en-us</language>
    <author>Firo Yang</author>
    
    <updated>Thu, 13 Apr 2017 20:42:49 CST</updated>
    
    <item>
      <title>Hello world! a journey to computer science</title>
      <link>http://firoyang.org/cs/hello/</link>
      <pubDate>Thu, 13 Apr 2017 20:42:49 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/hello/</guid>
      <description>

&lt;p&gt;In this series, I will a simple hello world program to explain the every important concept in cmputer science.&lt;br /&gt;
So let&amp;rsquo;s go.&lt;/p&gt;

&lt;p&gt;Do you know vDSO?&lt;br /&gt;
If a C program, gtod, calls the system call gettimeofday in vDSO, how does this program know the address of gettimeofday?&lt;/p&gt;

&lt;p&gt;ldd gtod&lt;br /&gt;
    linux-gate.so.1 (0xf7766000)&lt;br /&gt;
    libdl.so.2 =&amp;gt; /lib/libdl.so.2 (0xf7743000)&lt;br /&gt;
    libc.so.6 =&amp;gt; /lib/libc.so.6 (0xf7568000)&lt;br /&gt;
    /lib/ld-linux.so.2 (0x56639000)&lt;br /&gt;
Check this commit of glibc:&lt;br /&gt;
30e32d23eb06cbeae02e51c7c4df150736dba795&lt;br /&gt;
Set up GLRO(dl_sysinfo_dso) under [NEED_DL_SYSINFO_DSO] as well&lt;br /&gt;
AT_SYSINFO_EHDR&lt;/p&gt;

&lt;p&gt;Gcc 32bit support&lt;br /&gt;
ca677d3c3cd0eba7d1f03092517aea553a0e8569&lt;br /&gt;
Add x86 32 bit vDSO time function support&lt;br /&gt;
kernel&lt;br /&gt;
37c975545ec63320789962bf307f000f08fabd48&lt;/p&gt;

&lt;h1 id=&#34;start-the-program&#34;&gt;start the program&lt;/h1&gt;

&lt;p&gt;sysdeps/x86_64/dl-machine.h: -&amp;gt; _start -&amp;gt;_dl_start-&amp;gt;/elf/dl-sysdep.c:83:_dl_sysdep_start-&amp;gt;dl_main&lt;/p&gt;

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://a3f.at/lists/linkers&#34;&gt;Linkers 20 parts by Gold author Ian Lance Taylor&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/#locating-the-vdso-in-memory&#34;&gt;The Definitive Guide to Linux System Calls&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kernel debugging primer</title>
      <link>http://firoyang.org/cs/kernel_dbg/</link>
      <pubDate>Wed, 05 Apr 2017 14:45:21 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/kernel_dbg/</guid>
      <description>

&lt;h1 id=&#34;debug-boot-problem&#34;&gt;Debug boot problem&lt;/h1&gt;

&lt;p&gt;debug ignore_loglevel earlyprintk=ttyS0,115200,keep keep_bootcon initcall_debug dyndbg=+plmf&lt;/p&gt;

&lt;h1 id=&#34;dynamic-debug&#34;&gt;Dynamic debug&lt;/h1&gt;

&lt;p&gt;Precondition: CONFIG_DYNAMIC_DEBUG&lt;br /&gt;
How to use it during kernel booting?&lt;br /&gt;
Use boot option:&lt;br /&gt;
dyndbg=&amp;ldquo;file drivers/usb/host/ehci-hcd.c +p; file&lt;br /&gt;
drivers/usb/host/ehci-ppc-of.c +p&amp;rdquo; loglevel=8&lt;br /&gt;
loglevel=8 dyndbg=&amp;ldquo;module ehci_pci +p;&lt;br /&gt;
module ehci_hcd +p; module usbcore +p&amp;rdquo;&lt;br /&gt;
After booting:&lt;br /&gt;
/sys/kernel/debug/dynamic_debug/control&lt;/p&gt;

&lt;h1 id=&#34;dev-print-functions&#34;&gt;Dev print functions&lt;/h1&gt;

&lt;p&gt;drivers/base/core.c&lt;br /&gt;
define_dev_printk_level&lt;br /&gt;
THese functions are like pr_func&lt;/p&gt;

&lt;h1 id=&#34;oops&#34;&gt;oops&lt;/h1&gt;

&lt;p&gt;Kernel oops relates to invalid memory access, including sigev and sigbus.&lt;br /&gt;
&lt;a href=&#34;https://www.kernel.org/doc/Documentation/oops-tracing.txt&#34;&gt;kernel oops tracing&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://vegardno.blogspot.com/2016/08/sync-debug.html?m=1&#34;&gt;Debugging a kernel crash found by syzkaller&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;lockup&#34;&gt;lockup&lt;/h1&gt;

&lt;p&gt;phenomenon: LOCKUP_DETECTOR&lt;br /&gt;
&lt;a href=&#34;https://www.kernel.org/doc/Documentation/lockup-watchdogs.txt&#34;&gt;kernle doc - Softlockup detector and hardlockup detector&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.av8n.com/computer/htm/kernel-lockup.htm&#34;&gt;Debugging Linux Kernel Lockup / Panic / Oops&lt;/a&gt;&lt;br /&gt;
Causes: deadlock, hardware, irqoff and loop&lt;/p&gt;

&lt;h1 id=&#34;hung-task&#34;&gt;hung task&lt;/h1&gt;

&lt;p&gt;phenomenon: DETECT_HUNG_TASK&lt;br /&gt;
Includes the interruptable task.&lt;br /&gt;
Causes: deadlock, race condition&lt;/p&gt;

&lt;h1 id=&#34;kprobes&#34;&gt;kprobes&lt;/h1&gt;

&lt;h1 id=&#34;deadlock&#34;&gt;deadlock&lt;/h1&gt;

&lt;p&gt;Lockdep&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/185666/&#34;&gt;The kernel lock validator&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt&#34;&gt;Runtime locking correctness validator&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lkml.org/lkml/2013/2/4/4&#34;&gt;https://lkml.org/lkml/2013/2/4/4&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://bbs.chinaunix.net/thread-4183696-1-1.html&#34;&gt;http://bbs.chinaunix.net/thread-4183696-1-1.html&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;kasan&#34;&gt;kasan&lt;/h1&gt;

&lt;p&gt;setup_arch-&amp;gt;kasan_init&lt;br /&gt;
&lt;a href=&#34;http://events.linuxfoundation.org/sites/events/files/slides/LinuxCon%20North%20America%202015%20KernelAddressSanitizer.pdf&#34;&gt;KernelAddressSanitizer a fast memory error detector for the Linux kernel&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/zfsonlinux/zfs/pull/4708/commits/01709937be3c28a89eff83e0e657a72826947506&#34;&gt;kasan found stack out of bounds&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/612153/&#34;&gt;lwn The kernel address sanitizer&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lkml.org/lkml/2014/12/3/128&#34;&gt;out of bounds&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;config-debug-pagealloc&#34;&gt;CONFIG_DEBUG_PAGEALLOC&lt;/h1&gt;

&lt;p&gt;check_poison_mem in alloc_pages&lt;br /&gt;
free_pages_prepare posion&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>IO and events</title>
      <link>http://firoyang.org/cs/io/</link>
      <pubDate>Tue, 04 Apr 2017 20:08:35 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/io/</guid>
      <description>

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/87892/what-is-the-status-of-posix-asynchronous-i-o-aio&#34;&gt;What is the status of POSIX asynchronous I/O AIO&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://stackoverflow.com/questions/5844955/whats-the-difference-between-event-driven-and-asynchronous-between-epoll-and-a&#34;&gt;hat&amp;rsquo;s the difference between event-driven and asynchronous? Between epoll and AIO?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://davmac.org/davpage/linux/async-io.html&#34;&gt;Asynchronous I/O and event notification on linux&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.gnu.org/software/libc/manual/html_node/Asynchronous-I_002fO.html&#34;&gt;Gnu Libc Perform I/O Operations in Parallel&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;really-confuing-conceptions&#34;&gt;Really confuing conceptions&lt;/h1&gt;

&lt;p&gt;What is Asynchronous I/O?&lt;br /&gt;
The onset of I/O is splitted from nuclus.&lt;br /&gt;
First, asynchronous I/O can be happned in UP machine.&lt;br /&gt;
AIO is based on Proactor, more portable.&lt;/p&gt;

&lt;h1 id=&#34;aynchoronous-event-notfication&#34;&gt;Aynchoronous event notfication&lt;/h1&gt;

&lt;p&gt;epoll is based on Reactor pattern.&lt;br /&gt;
signal is based on Observer pattern.&lt;br /&gt;
For the ease of use, the select loop is implemented as an &lt;em&gt;event loop&lt;/em&gt; with callbacks.&lt;br /&gt;
libevent and libev is a well-designed &lt;em&gt;event loop&lt;/em&gt;.Check shadowsocks for using of libev.&lt;/p&gt;

&lt;h1 id=&#34;faq&#34;&gt;FAQ&lt;/h1&gt;

&lt;p&gt;memory-map IO&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Softirq of Linux Kernel</title>
      <link>http://firoyang.org/cs/softirq/</link>
      <pubDate>Mon, 03 Apr 2017 13:09:05 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/softirq/</guid>
      <description>

&lt;p&gt;##softirq&lt;br /&gt;
同一个softirq可以在不同的CPU上同时运行，softirq必须是可重入的。&lt;br /&gt;
* not allow execute nest but can recusive lock:local_bh_disable&lt;br /&gt;
current-&amp;gt;preemt_count + SOFIRQ_OFFSET also disable preempt current process.&lt;br /&gt;
* hardirq on, can&amp;rsquo;t sleep&lt;br /&gt;
* not percpu&lt;/p&gt;

&lt;h2 id=&#34;tasklet-and-kernel-timer-is-based-on-softirq&#34;&gt;tasklet and kernel timer is based on softirq&lt;/h2&gt;

&lt;p&gt;新增softirq, 是要重新编译内核的, 试试tasklet也不错.&lt;br /&gt;
.不允许两个两个相同类型的tasklet同时执行，即使在不同的处理器上&lt;br /&gt;
* First of all, it&amp;rsquo;s a conglomerate of mostly unrelated jobs,&lt;br /&gt;
 which run in the context of a randomly chosen victim&lt;br /&gt;
 w/o the ability to put any control on them. &amp;ndash;Thomas Gleixner&lt;/p&gt;

&lt;p&gt;tasklet different with other softirq is run  signal cpu core&lt;br /&gt;
spinlock_bh wider then spinlock&lt;/p&gt;

&lt;p&gt;###time of softirq&lt;br /&gt;
* follow hardirq, irq_exit()&lt;br /&gt;
* re-enables softirq, local_bh_enable/spin_unlock_bh(); explicity checks executes, netstack/blockIO.&lt;br /&gt;
* ksoftirqd&lt;/p&gt;

&lt;p&gt;###tasklet&lt;br /&gt;
tasklet like a workqueue, sofirq like kthread. that is wonderful, does it?&lt;br /&gt;
tasklet 被__tasklet_schedule到某个cpu的percu 变量tasklet_vec.tail上保证了&lt;br /&gt;
只有一个cpu执行同一时刻.&lt;/p&gt;

&lt;p&gt;#FAQ&lt;br /&gt;
##When to save irq rather than just disable irq&lt;br /&gt;
local_irq_disable() used in the code path that never disabled interrupts.&lt;br /&gt;
local_irq_save(flags) used in the code path that already disabled interrupts.&lt;/p&gt;

&lt;p&gt;##what about irq nested?&lt;br /&gt;
&lt;a href=&#34;http://lwn.net/Articles/380937/&#34;&gt;http://lwn.net/Articles/380937/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://thread.gmane.org/gmane.linux.kernel/1152658&#34;&gt;Deal PF_MEMALLOC in softirq&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Interrupt and exception</title>
      <link>http://firoyang.org/cs/interrupt_and_exception/</link>
      <pubDate>Mon, 03 Apr 2017 13:02:12 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/interrupt_and_exception/</guid>
      <description>

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.exploit-db.com/papers/13146/&#34;&gt;Obtain sys_call_table on amd64 &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;#Interrupt&lt;/p&gt;

&lt;h2 id=&#34;init&#34;&gt;init&lt;/h2&gt;

&lt;p&gt;native_init_IRQ()-&amp;gt;  set_intr_gate(i, irq_entries_start&amp;hellip;&lt;br /&gt;
irq_entries_start define in arch/x86/kernel/entry_32.S&lt;/p&gt;

&lt;p&gt;##Interrupt Context terminology&lt;br /&gt;
* in_irq&lt;br /&gt;
in __irq_enter I found preempt_count_add(HARDIRQ_OFFSET) only in here!&lt;br /&gt;
+irq disable 部设计preempt_cout&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;in_softirq&lt;br /&gt;
should rename to in_softirq_or_bh_disable()&lt;br /&gt;
local_bh_disable use SOFTIRQ_DISABLE_OFFSET  (2 * SOFTIRQ_OFFSET)&lt;br /&gt;
__do_softirq use __local_bh_disable_ip(_RET&lt;em&gt;IP&lt;/em&gt;, SOFTIRQ_OFFSET), damn it!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;in_interrupt&lt;br /&gt;
一种是irq路径上的do_softirq, 即in_serving_softirq&lt;br /&gt;
+local_bh_disbale()&lt;br /&gt;
//not in softirq context!!!&lt;br /&gt;
+local_bh_enable()&lt;br /&gt;
硬中断呢?&lt;br /&gt;
do_IRQ,肯定是.&lt;br /&gt;
local_irq_disable,不是, 但是no operation with preempt_count() 这种情况x86 in_interrupt是无感的.use irqs_disabled to check&lt;br /&gt;
[Question about in_interrupt() semantics with regard to softirqs]()&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;#FAQ&lt;br /&gt;
##When to save irq rather than just disable irq&lt;br /&gt;
local_irq_disable() used in the code path that never disabled interrupts.&lt;br /&gt;
local_irq_save(flags) used in the code path that already disabled interrupts.&lt;/p&gt;

&lt;p&gt;##what about irq nested?&lt;br /&gt;
&lt;a href=&#34;http://lwn.net/Articles/380937/&#34;&gt;http://lwn.net/Articles/380937/&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;triggering-a-gp-exception&#34;&gt;Triggering a #GP exception&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://wiki.osdev.org/Exceptions&#34;&gt;Exceptions&lt;/a&gt;&lt;br /&gt;
if you do lidt in userspace program, you will receive SIGSEGV with si_code 128(somewhere of kernel).&lt;br /&gt;
But with the dmesg traps: int0x80[15066] general protection ip:4000c7 sp:7ffc8706cdf0 error:0 in int0x80[400000+1000] form do_general_protection.&lt;br /&gt;
Privilege instructions in V3a chapter 5 Protection&lt;br /&gt;
.data&lt;br /&gt;
    .quad msg&lt;/p&gt;

&lt;p&gt;msg:&lt;br /&gt;
    .ascii &amp;ldquo;Hello, world!\n&amp;rdquo;&lt;br /&gt;
    len = . - msg&lt;br /&gt;
saved_idt:&lt;br /&gt;
        .long 0,0&lt;/p&gt;

&lt;p&gt;.text&lt;br /&gt;
    .global _start&lt;/p&gt;

&lt;p&gt;_start:&lt;br /&gt;
    movl  $4, %eax&lt;br /&gt;
    movl  $1, %ebx&lt;br /&gt;
    movl  $msg, %ecx&lt;br /&gt;
    sidt  saved_idt&lt;br /&gt;
    lidt  saved_idt  ;===============&amp;gt; crashed at here&lt;br /&gt;
    movl  $len, %edx&lt;br /&gt;
    int   $0x80&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;movl  $1, %eax
xorl  %ebx, %ebx 
int   $0x80
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Scheduling in operating system</title>
      <link>http://firoyang.org/cs/scheduling/</link>
      <pubDate>Wed, 29 Mar 2017 10:49:04 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/scheduling/</guid>
      <description>

&lt;p&gt;Customer demand -&amp;gt; multitasking/concurrent&lt;br /&gt;
Some other issues arise from multitasking/concurrent.&lt;br /&gt;
Scheduling is used to implement the multitasking/concurrent and solve the arose issues.&lt;br /&gt;
Questions we need to solve:&lt;br /&gt;
1. how to switch to the context of the next process?&lt;br /&gt;
    context_switch&lt;br /&gt;
2. how to determine the next process? Fairness?&lt;br /&gt;
2.1 There should be many shcheduling algorithms; how to manage them?&lt;br /&gt;
    sched_class&lt;br /&gt;
2.2 where to keep/find the processes?&lt;br /&gt;
    All the ruunale process are put in cpu_rq, but they are in different places rt_rq, dl_rq, cfs_rq, stop, idle.&lt;br /&gt;
    Why different palces? Simple.&lt;br /&gt;
2.3 If we use CFS algoritm, how does it work?&lt;br /&gt;
    The core source code of CFS is the members of fair_sched_class&lt;br /&gt;
    The main idea of CFS is compensating the process which is deficient of running CPU time.&lt;br /&gt;
    CFS use vruntime to reflect the CPU time a process used.&lt;br /&gt;
    But what makes CFS complex? Two points:&lt;br /&gt;
    a. CFS is compatiable with the traditional priority(the nice value).&lt;br /&gt;
    b. make the vruntime suitable. For example, what&amp;rsquo;s the vrumtime of a new process?&lt;br /&gt;
3. when to perform shcheduling?&lt;br /&gt;
    new task, task dies&lt;br /&gt;
    exception, interrupt&lt;br /&gt;
    preempt_schedule_irq&lt;br /&gt;
    retint_kernel; kernel preempt&lt;br /&gt;
3.1 Scheduling timer&lt;br /&gt;
alloc_intr_gate(LOCAL_TIMER_VECTOR, apic_timer_interrupt);&lt;br /&gt;
apic_timer_interrupt smp_apic_timer_interrupt local_apic_timer_interrupt&lt;br /&gt;
tick_handle_periodic -&amp;gt; tick_periodic-&amp;gt; scheduler_tick -&amp;gt; tick_periodic -&amp;gt;.task_tick= task_tick_fair,&lt;br /&gt;
4. States and actions&lt;br /&gt;
4.1 wake up a sleep task&lt;br /&gt;
    not runnable -&amp;gt; activate_task -&amp;gt; runnable -&amp;gt;deactivate_task-&amp;gt; not runnable&lt;br /&gt;
    se-&amp;gt;on_rq &amp;amp; TASK_ON_RQ_QUEUED; deactivate_task set on_rq to 0;&lt;br /&gt;
    enqueue_task_fair handles group stuff&lt;br /&gt;
    enqueue_entity deals with sched_entity - uptodate the vruntime, load average, account load numa perfering,&lt;br /&gt;
    sysctl_sched_latency: the cfs pledge to the pre-existing tasks that they have 6ms to run before new task to run.&lt;br /&gt;
    try_to_wake_up_local for local task&lt;br /&gt;
    try_to_wake_up for any task&lt;br /&gt;
4.2 Choses a entity&lt;br /&gt;
    set_next_entity is, actually, setup the next entity being running. remove entity from rb-tree.&lt;br /&gt;
4.3 What about a new task&lt;br /&gt;
4.4 process migration&lt;br /&gt;
e761b7725234276a802322549cee5255305a0930&lt;br /&gt;
Introduce cpu_active_map and redo sched domain managment&lt;br /&gt;
    When to migration&lt;br /&gt;
        sched_setaffinity __set_cpus_allowed_ptr manuly&lt;br /&gt;
        Selecting a new CPU during wak up a sleeper&lt;br /&gt;
        For balancing, selecting CPU during  wake up new process in _do_fork&lt;br /&gt;
        execve&amp;rsquo;s sched_exec&lt;/p&gt;

&lt;p&gt;4.x worker&lt;br /&gt;
    sleep -&amp;gt; waking -&amp;gt; woken&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;how to deal with load balancing of multiple CPU?&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;how to control the cost of scheduling.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;git-log&#34;&gt;Git log&lt;/h1&gt;

&lt;p&gt;e9c8431185d6c406887190519f6dbdd112641686&lt;br /&gt;
TASK_WAKING; see migrate_task_rq_fair and try_to_wake_up&lt;br /&gt;
88ec22d3edb72b261f8628226cd543589a6d5e1b&lt;br /&gt;
In order to remove the cfs_rq dependency from set_task_cpu() we need to ensure the task is cfs_rq invariant for all callsites.&lt;br /&gt;
2f950354e6d535b892f133d20bd6a8b09430424c&lt;br /&gt;
sched/fair: Fix fairness issue on migration&lt;br /&gt;
&lt;a href=&#34;http://linux.kernel.narkive.com/p15Wmn0i/migrated-cfs-task-getting-an-unfair-advantage&#34;&gt;Migrated CFS task getting an unfair advantage&lt;/a&gt;&lt;br /&gt;
30cfdcfc5f180fc21a3dad6ae3b7b2a9ee112186&lt;br /&gt;
curr was not kept in rb-tree&lt;/p&gt;

&lt;p&gt;##Preemption&lt;br /&gt;
* Linux kernel user mode is always User preemption.&lt;br /&gt;
When returning to user-space from a system call.&lt;br /&gt;
When returning to user-space from an interrupt hander.&lt;br /&gt;
* Linux kernel kernel mode is coppertive when CONFIG_PREEMPT is not set.&lt;br /&gt;
If a task in the kernel explicitly calls schedule()&lt;br /&gt;
If a task in the kernel blocked (which results in a all to schedule())&lt;br /&gt;
* Linux kernel kernel mode is coppertive + preemptive when CONFIG_PREEMPT is set.&lt;br /&gt;
schedule + blcoked&lt;br /&gt;
When an interrupt handler exits, before returning to kernel-space.&lt;br /&gt;
When kernel code becomes preemptible again.&lt;/p&gt;

&lt;h1 id=&#34;faq&#34;&gt;FAQ&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://wangcong.org/2012/06/01/-e4-b8-ba-e4-bb-80-e4-b9-88linux-e5-86-85-e6-a0-b8-e4-b8-8d-e5-85-81-e8-ae-b8-e5-9c-a8-e4-b8-ad-e6-96-ad-e4-b8-ad-e4-bc-91-e7-9c-a0-ef-bc-9f/&#34;&gt;为什么Linux内核不允许在中断中休眠&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>System booting</title>
      <link>http://firoyang.org/cs/boot/</link>
      <pubDate>Thu, 12 Nov 2015 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/boot/</guid>
      <description>

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://linuxdevices.linuxgizmos.com/introducing-initramfs-a-new-model-for-initial-ram-disks-a/&#34;&gt;Article: Introducing initramfs, a new model for initial RAM disks&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;contents&#34;&gt;Contents&lt;/h1&gt;

&lt;p&gt;What basic initializations should be perfomed when power on?&lt;br /&gt;
How do we load the kernel to memory?&lt;br /&gt;
What does kernel do when kernel boot.&lt;br /&gt;
MBR vs BIOS?&lt;br /&gt;
PC vs embedded&lt;br /&gt;
Kernel init&lt;br /&gt;
before start_kernel&lt;br /&gt;
start_kernel&lt;br /&gt;
reset_init &amp;amp; kernel_init&lt;/p&gt;

&lt;h1 id=&#34;boot-and-init&#34;&gt;Boot and init&lt;/h1&gt;

&lt;p&gt;Power button -&amp;gt; cpu reset -&amp;gt; BIOS -&amp;gt; hard drive -&amp;gt; Grub boot.S/MBR aa5a -&amp;gt; Grub diskboot.S -&amp;gt; &amp;hellip; -&amp;gt; The kernel real-mode setup code. _start of arch/x86/boot/header.S&lt;br /&gt;
Aligh register, Stack and BSS for C function to run. -&amp;gt; main-&amp;gt;startup_32-&amp;gt;startup_64-&amp;gt; __START_KERNEL_map-&amp;gt;&amp;hellip; start_kernel&lt;br /&gt;
&lt;a href=&#34;https://github.com/torvalds/linux/blob/master/Documentation/x86/boot.txt#L130&#34;&gt;Kernel legacy boot sector&lt;/a&gt; start form 4d5a of arch/x86/boot/header.S&lt;br /&gt;
is only used by something link &amp;lsquo;qemu-system-x86_64 vmlinuz-3.18-generic&amp;rsquo;. It&amp;rsquo;s obsoleted that is what legacy means.&lt;/p&gt;

&lt;h1 id=&#34;p4080-board&#34;&gt;p4080 Board&lt;/h1&gt;

&lt;p&gt;PBL&lt;br /&gt;
1. initialize I2C, SPI, eLBC, eSDHC.&lt;br /&gt;
2. Load RCW and boot init commands from above.&lt;br /&gt;
3. write date to conf register and memory&lt;/p&gt;

&lt;h1 id=&#34;config&#34;&gt;config&lt;/h1&gt;

&lt;p&gt;CCSRBAR -&amp;gt; CCSR&lt;br /&gt;
default is 0x0_FE00_0000&lt;br /&gt;
CCSRBAR is in CCSR memory. odd. stored in 0(CCSRBAR).&lt;br /&gt;
CCSRBAR always points to itself.&lt;br /&gt;
holdoff&lt;/p&gt;

&lt;h1 id=&#34;u-boot&#34;&gt;u-boot&lt;/h1&gt;

&lt;p&gt;ft_fixup_cpu -&amp;gt; determine_mp_bootpg(NULL) &amp;amp; fdt_add_mem_rsv&lt;/p&gt;

&lt;p&gt;main_loop-&amp;gt; &amp;hellip;-&amp;gt;./common/bootm_os.c:410:&amp;hellip; do_bootm_states-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
bootm_find_other-&amp;gt;bootm_find_ramdisk_fdt-&amp;gt;bootm_find_fdt-&amp;gt;boot_get_fdt&amp;amp;set_working_fdt_addr(0x0200000)-&amp;gt;IMAGE_FORMAT_FIT-&amp;gt;&lt;br /&gt;
&amp;amp;&lt;br /&gt;
boot_fn = bootm_os_get_boot_func(images-&amp;gt;os.os)=[IH_OS_LINUX] =&lt;br /&gt;
&amp;amp;&lt;br /&gt;
boot_selected_os-&amp;gt;boot_fn=do_bootm_linux-&amp;gt;boot_body_linux-&amp;gt;image_setup_linux-&amp;gt;image_setup_libfdt-&amp;gt;&lt;br /&gt;
board/freescale/corenet_ds/corenet_ds.c ft_board_setup-&amp;gt; ft_cpu_setup-&amp;gt;&lt;br /&gt;
}&lt;/p&gt;

&lt;h1 id=&#34;ppc-multicore-booting&#34;&gt;PPC multicore booting&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;There are two possibilites to make secondary cores booting failed.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;There is a bug in the code executed by Secondary cores&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;The spin table address, passed to croe0, is not correct, so we did not really kick the secondary cores.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CCSRBAR&lt;br /&gt;
MPC86xx_MCM_OFFSET&lt;br /&gt;
srio_boot_master_release_slave&lt;/p&gt;

&lt;p&gt;uboot-&amp;gt;&lt;br /&gt;
set the cpu-release-addr at funciton ft_fixup_cpu(), I am not sure.&lt;/p&gt;

&lt;p&gt;core0 run, 2nd cores holdoff&lt;br /&gt;
core0 set BPTR and kick(BRR) 2nd cores, 2nd cores spintable loop in uboot function setup_mp&lt;br /&gt;
core0 -&amp;gt; arch/powerpc/cpu/mpc85xx/start.S-&amp;gt;_start_e500&lt;br /&gt;
board_init_r-&amp;gt;cpu_init_r-&amp;gt; setup_mp-&amp;gt; {&lt;br /&gt;
&lt;strong&gt;bootpg_addr = (u32)virt_to_phys(&amp;amp;&lt;/strong&gt;second_half_boot_page); //Assembly code for put core to spin tablea. Used by __secondary_start_page&lt;br /&gt;
__spin_table_addr = (u32)get_spin_phys_addr();// used by __second_half_boot_page&lt;br /&gt;
bootpg = BPTR = __secondary_start_page&lt;br /&gt;
plat_mp_up-&amp;gt;kick BRR &amp;amp; Boot Space Translation&lt;br /&gt;
}&lt;br /&gt;
2nd cores holdoff -&amp;gt; &lt;strong&gt;secondary_start_page&lt;br /&gt;
kernel-&amp;gt;&lt;br /&gt;
core0 boot kernel, core0 kickoff 2nd cores spintable, triger 2nd core&amp;rsquo;s spin table by writing  the spin table field with the desired address&lt;br /&gt;
2nd cores ePAPR-&amp;gt;spintable-&amp;gt;addr_l=&lt;/strong&gt;early_start-&amp;gt;__secondary_start-&amp;gt;smp_ops-&amp;gt;setup_cpu-&amp;gt;cpu_idle&lt;br /&gt;
arch/powerpc/kernel/head_fsl_booke.S&lt;br /&gt;
U-boot logs:&lt;br /&gt;
Reserving MP boot page to 7ffff000^M^M - &amp;ndash;   -   MP spin table&lt;br /&gt;
address.&lt;br /&gt;
SPAG : fdt_fixup_fman_firmware, 567^M^M&lt;br /&gt;
^M^M&lt;br /&gt;
..r.^M^M&lt;br /&gt;
VDBG : ft_cpu_setup, 737, comment fdt_fixup_memory ^M^M&lt;br /&gt;
VDBG: Secondary cores are not held in reset.^M^M&lt;br /&gt;
Kernel Logs:&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 1 to ack^M^M&lt;br /&gt;
smp: failed starting cpu 1 (rc -2)^M^M&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 2 to ack^M^M&lt;br /&gt;
smp: failed starting cpu 2 (rc -2)^M^M&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 3 to ack^M^M&lt;br /&gt;
smp: failed starting cpu 3 (rc -2)^M^M&lt;br /&gt;
Brought up 1 CPUs^M^M&lt;br /&gt;
devtmpfs: initialized^M^M&lt;/p&gt;

&lt;p&gt;Note that u-boot can&amp;rsquo;t detect  memory above 2G and we need to check&lt;br /&gt;
if kernel is accessing at high mem of 2G or 4G.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Computer architecture</title>
      <link>http://firoyang.org/cs/arch/</link>
      <pubDate>Tue, 13 Oct 2015 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/arch/</guid>
      <description>

&lt;p&gt;##Reference&lt;br /&gt;
&lt;a href=&#34;http://people.eecs.berkeley.edu/~rcs/research/interactive_latency.html&#34;&gt;Latency Numbers Every Programmer Should Know&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://youtu.be/cNN_tTXABUA&#34;&gt;How a CPU Works&lt;/a&gt;&lt;br /&gt;
A Symbolic Analysis of Relay and Switching Circuits&lt;br /&gt;
The Mathematical Theory of Communication&lt;br /&gt;
Given a symbol level, the architecture is the description of the system in&lt;br /&gt;
whatever system-description scheme exists next below the symbol level. - Newell, 1990, p. 81&lt;br /&gt;
&lt;a href=&#34;https://news.ycombinator.com/item?id=9844090&#34;&gt;Ask HN: How to learn about the history of computing?&lt;/a&gt;&lt;br /&gt;
《模拟电子技术基础 童诗白 第四版》第一章前半部分&lt;br /&gt;
Structured Computer Organization 6th Edition&lt;br /&gt;
Digital Design and Computer Architecture 2nd Edition&lt;br /&gt;
Computer Organization and Design 5th Edition&lt;br /&gt;
Write Great Code: Volume 1: Understanding the Machine&lt;br /&gt;
See MIPS run&lt;br /&gt;
Intel 64 and IA-32 architectures software developers manual combined volumes 3A, 3B, and 3C: System programming guide&lt;br /&gt;
Microelectronics&lt;/p&gt;

&lt;h2 id=&#34;isa&#34;&gt;ISA&lt;/h2&gt;

&lt;p&gt;model: 1570s, &amp;ldquo;likeness made to scale; architect&amp;rsquo;s set of designs,&amp;rdquo; from Middle French modelle&lt;br /&gt;
Semantics in computer science: In programming language theory, semantics is the field concerned&lt;br /&gt;
with the rigorous mathematical study of the meaning of programming languages.&lt;br /&gt;
Language primitive&lt;br /&gt;
ISA: memory model, registers, data types, instructions, word size(?).&lt;br /&gt;
Memory model: unit of address resolution, word, aligment, address space, addressing mode, memory barrier/memory order primitive&amp;rsquo;s semantics.&lt;br /&gt;
#x86 Interrupt&lt;br /&gt;
If interrupt occured in user mode, then cpu will context swith for potential reschedule.&lt;br /&gt;
The Interrupt Descriptor Table (IDT) is a data structure used by the x86 architecture to implement an interrupt vector table.&lt;br /&gt;
##Hardware interrupts&lt;br /&gt;
are used by devices to communicate that they require attention from the operating system.&lt;br /&gt;
asynchronus&lt;br /&gt;
more details in init_IRQ() or set_irq() in driver.&lt;br /&gt;
##software interrupt&lt;br /&gt;
synchronus&lt;br /&gt;
more details in trap_init().&lt;br /&gt;
* exception or trap&lt;br /&gt;
is caused either by an exceptional condition in the processor itself,&lt;br /&gt;
divide zero painc?&lt;br /&gt;
* special instruction, for example INT 0x80&lt;br /&gt;
or a special instruction in the instruction set which causes an interrupt when it is executed.&lt;/p&gt;

&lt;h1 id=&#34;i-o-ic&#34;&gt;I/O IC&lt;/h1&gt;

&lt;p&gt;serial communication: UART(16550) + RS-232&lt;br /&gt;
parallel communication: SCSI, ISA, ATA, PCI, FSB&lt;/p&gt;

&lt;h1 id=&#34;data-struct-aligment&#34;&gt;Data struct aligment&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.catb.org/esr/structure-packing/&#34;&gt;The Lost Art of C Structure Packing&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://en.wikipedia.org/wiki/Data_structure_alignment#Typical_alignment_of_C_structs_on_x86&#34;&gt;Typical alignment of C structs on x86&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;为什么需要结构体对齐&#34;&gt;为什么需要结构体对齐?&lt;/h2&gt;

&lt;p&gt;struct foo {&lt;br /&gt;
char c;&lt;br /&gt;
int i;};&lt;br /&gt;
如果是32位, cpu 一次取4byte a word 数据.&lt;br /&gt;
如果我们把i的前3byte和c存到一起, 剩下1byte of i自己单独存.&lt;br /&gt;
那么我们访问i这个数据就要读两个4byte a word. 对cpu来说性能损耗.&lt;br /&gt;
如果我们把i单独放到4byte 对齐的地址, 那么我们只需要一次cpu读取.fast!&lt;/p&gt;

&lt;h2 id=&#34;产生非对齐访问的场景&#34;&gt;产生非对齐访问的场景&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Casting variables to types of different lengths, 比如char * 到int *&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Pointer arithmetic followed by access to at least 2 bytes of data , 不太理解.&lt;/p&gt;

&lt;h2 id=&#34;我们做什么&#34;&gt;我们做什么?&lt;/h2&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;什么也不干, 按默认对齐来Natural alignment&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为了不影响性能, 同时减少内存使用, 编程时最好显示reorder.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;get/put_unaligned  to avoid analigned access.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通过attribute aligned指定对齐要求.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;数据要在不同体系, 32/64之间使用, 比如网络,写到disk, 我们必须要attribute packed&lt;br /&gt;
也就是说不对齐, 不同平台对齐可能不同, 我们不能让数据corruption.&lt;/p&gt;

&lt;h2 id=&#34;如果数据不对齐有什么-cpu怎么办&#34;&gt;如果数据不对齐有什么, cpu怎么办?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kernel.org/doc/Documentation/unaligned-memory-access.txt&#34;&gt;必读UNALIGNED MEMORY ACCESSES&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果用了packed, 编译器会生成extra代码阻止非对齐访问, performance loss.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cpu呢? 可能正确处理raise a exception to fix it with performance loss.&lt;/p&gt;

&lt;h2 id=&#34;calculate-the-sizeof-of-aligned-c-struct&#34;&gt;Calculate the sizeof of aligned c struct&lt;/h2&gt;

&lt;p&gt;Data alignment means putting the data at a memory address equal to some multiple of the word size,&lt;br /&gt;
which increases the system&amp;rsquo;s performance due to the way the CPU handles memory.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;find the widest scalar member and attribute( aligned(x)) to determin alignment.&lt;br /&gt;
找到结构体内scalar和attribute最大的对齐要求.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;fill the member to alignement without wrap&lt;br /&gt;
把结构的成员一次填满对齐宽度, 不够的填到下个对齐宽度, 空出来留着padding&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Pading to alignment&lt;br /&gt;
填上所有空.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;endianess&#34;&gt;Endianess&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.yolinux.com/TUTORIALS/Endian-Byte-Order.html&#34;&gt;Endianness: Big and Little Endian Byte Order&lt;/a&gt;&lt;br /&gt;
应该说bit endianess 实际存储只有MSB &amp;hellip; LSB这一种二进制表达形式! 在上面的文章的representtion, 辅证这一点.&lt;br /&gt;
这篇文章&lt;a href=&#34;http://tonybai.com/2013/05/21/talk-about-bitfield-in-c-again/&#34;&gt;再谈C语言位域&lt;/a&gt;,&lt;br /&gt;
之所以输出逆序, 是因为错误里理解了, bit 序. bit 序是cpu 读取的方式, 不是存储的方式!&lt;br /&gt;
* &lt;a href=&#34;https://en.wikipedia.org/wiki/Bit_numbering&#34;&gt;bit endianness&lt;/a&gt;&lt;br /&gt;
这样就可以更好的理解iphdr:&lt;br /&gt;
#if defined(__LITTLE_ENDIAN_BITFIELD)&lt;br /&gt;
    &lt;strong&gt;u8    ihl:4,&lt;br /&gt;
        version:4;&lt;br /&gt;
#elif defined (&lt;/strong&gt;BIG_ENDIAN_BITFIELD)&lt;br /&gt;
    __u8    version:4,&lt;br /&gt;
        ihl:4;&lt;br /&gt;
#else&lt;br /&gt;
#error  &amp;ldquo;Please fix &lt;asm/byteorder.h&gt;&amp;ldquo;&lt;br /&gt;
#endif&lt;br /&gt;
ipv4 header的拓扑&lt;br /&gt;
version ihl&lt;br /&gt;
0100 0101&lt;br /&gt;
因为le的cpu是 lsb first, 也就是从最左面的1开始读, 所以第一个是ihl&lt;br /&gt;
而be的cpu是 msb first, 从最右开始所以version开头.&lt;br /&gt;
而使用unsigned char ver_ihl&lt;br /&gt;
(ver_ihl &amp;amp; 0xf0)&amp;gt;&amp;gt; 4 = version&lt;br /&gt;
ver_ihl &amp;amp; 0x0f = ihl&lt;br /&gt;
是无关cpu读取顺序的.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Algorithms and data structues</title>
      <link>http://firoyang.org/cs/algorithm/</link>
      <pubDate>Wed, 27 May 2015 12:42:12 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/algorithm/</guid>
      <description>

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://cstheory.stackexchange.com/questions/19759/core-algorithms-deployed#&#34;&gt;Core algorithms deployed&lt;/a&gt;&lt;br /&gt;
Algorithms: Design Techniques and Analysis&lt;br /&gt;
The Algorithm Design Manual 2nd Edition&lt;/p&gt;

&lt;h1 id=&#34;世界本源-the-origin-of-the-world-l-origine-du-monde&#34;&gt;世界本源, the origin of the world, L&amp;rsquo;Origine du monde&lt;/h1&gt;

&lt;p&gt;being(4), abyss(0)&lt;br /&gt;
material(1) change, quality, quantity, relation, space, time&lt;br /&gt;
process(2), tansfer, truth, signifier(3), bijection, Causality, structure&lt;br /&gt;
connectivity&lt;/p&gt;

&lt;h1 id=&#34;排序算法的分析&#34;&gt;排序算法的分析&lt;/h1&gt;

&lt;p&gt;排序的结果全序.&lt;br /&gt;
在确定排序的思想/算法后, 排序的过程是从无序to 有序的过程.&lt;br /&gt;
我们排序的过程等价成一次算术运算.&lt;br /&gt;
每一次, 在特定的算法下, 数据有序度增加or不增加, 但不减少.&lt;br /&gt;
我们把有序度看成一个quantity.那么此时排序的过程等价于有序度增加的过程.&lt;br /&gt;
怎么定义有序度set内元素构成=&amp;lt;就是一度粗有序度. 严谨的连续元素构成=&amp;lt;关系.&lt;br /&gt;
比如1 2 3 4 5 , bold order:4 + 3+ 2 +1; 严谨有序度:４&lt;/p&gt;

&lt;p&gt;也就是一个算法, 对如3 2 5 4 1. bo:2 + 2 ; 严谨有序度:0&lt;br /&gt;
bo: 2+2 to 10&lt;br /&gt;
严谨: 0 to 4&lt;br /&gt;
就算完成.此时我们没做一次排序, 都在做加法运算.只是每一步转换成一个变量了.&lt;br /&gt;
这似乎对我们理解sorting起不了多大的帮助.&lt;br /&gt;
直觉应该没错.确实不应该关心过程, 而应该关系变化本身, process不等于变化本身.&lt;br /&gt;
只是process是变化的动力, 却不是原因.变化的因果并不是恒定不变的.process成了变化的&lt;br /&gt;
结果了, 因为要这样所以才有了process, 不是这个process才怎么怎么了.&lt;br /&gt;
这样我们知道从raw set to ordered set, 这个过程, 一定可以有多个sort algorithms来完成.&lt;br /&gt;
那么选取哪个sort algorithm就是有改变的形式决定的.&lt;br /&gt;
所以我们依然在探讨结构上的变化. 而不是纯粹的process过程.&lt;br /&gt;
比如先确定边界元素的有序度, 从一边向另一边逐渐演化. 这就是selection sort.&lt;br /&gt;
注意!我们通过等价变换causlity, 原来近乎process主导的问题变为了, quantity structure渐变的问题了.&lt;br /&gt;
原来是伸手不见五指的变, 现在是看的见有形的变.&lt;br /&gt;
再看其他的算法, 比如我们想确定由中间quantity发起向两侧的有序变化, 就是快排.快排为什么快?&lt;br /&gt;
但是我们发现, 这种有中间发起的有序度变多的过程, 有两个疑点.&lt;br /&gt;
1. 这个所谓中间值是我们随机指定的, 几乎不可能是真正意义上的&amp;rdquo;中间值&amp;rdquo;.&lt;br /&gt;
2. 也是疑惑最大, 这种中起的有序度变化, 严格有序度不像边沿变化那样连续, 但是关于所谓中间值的bold order&lt;br /&gt;
确是丝毫没有耗损的! 也就是bold order是非常细腻的, 而Strict order, 是非常粗野的.&lt;br /&gt;
我们可以武断地下个定论, 满足严格有序的算法效率差!后面会给出严谨的证明.&lt;br /&gt;
我们继续, 另外务必注意, 我们这里没有任何关于已知算法的信息.&lt;br /&gt;
已知的各种算法是就是符号系统里面的signifier, 在我们分析的过程中纯粹的就是个名字而已.&lt;br /&gt;
更可怜的是, 这个名字是我们从signified推出来的.&lt;br /&gt;
我们现在已经推出了冒泡, 选择, 快排 三种算法了.&lt;br /&gt;
另外还有merge sort, heap sort, insertion sort, shell sort.&lt;br /&gt;
我只是看了merge sort之后的名字了, 具体的算法, 内容我都忘了(刻意不去想).&lt;br /&gt;
现在看了quick sort确认的是任意一点为为核心的orderness的增多过程. 增加的形式由中间开启.topdown.可以强调中间的含义.&lt;br /&gt;
insertion sort是select的一个generalize的版本, 他不强求strict order的满足. 也是有一边向另一边的orderness增多过程.&lt;br /&gt;
merge sort: 从全部的个体单元开始的开始有序度增多, bottomup过程.不强加中间的含义.&lt;br /&gt;
构成了以raw 元素为开始的, 从东南西北开始的四面埋伏是的有序度增多过程.&lt;br /&gt;
看来我的感觉没错.&lt;br /&gt;
算法的分析就结束了, 意外的收获颇多.本以为行不通的.&lt;/p&gt;

&lt;h1 id=&#34;查找算法的分析-searching-algorithm&#34;&gt;查找算法的分析 searching algorithm&lt;/h1&gt;

&lt;p&gt;搜索的效率完全在于搜索路径的长短.&lt;br /&gt;
查找是在a set of objects, 找到特定的目标. the structure of the set of objects可能是任意的.&lt;br /&gt;
计算机中如线性的linked list, array, tree, graph. structure并不只是量之间的quality, relation.&lt;br /&gt;
还包括了, change, 即operation, access/get也是一种change, 效果是没有change.&lt;br /&gt;
那么What is the form causality of searching?上面分析sorting的时候, 我们没有分析sorting算法的效率.&lt;br /&gt;
因为排序的form是orderness, 不是效率. 当然效率也很重要.&lt;br /&gt;
而查找算法,直观上要比sorting要简单, 他只关心特定的目标, 找到or not found.&lt;br /&gt;
但是有一点, 我们是万分确信的. 那就是类似sorting, searching的目的也是确定的, 也就是目的因的存在.&lt;br /&gt;
我们通过类似蒙太奇的手法, 去从差异中需找这种量. 寻找一些差异来自于我们找到target的最终结果和每步尝试之间.&lt;br /&gt;
每一步, 我们都比上一步离target更近了. 我想这是searching的form之一.&lt;br /&gt;
我定义为reachness(我瞎起的). 我们知道在特定的算法确定的情况下, 在特定的数据结构下(也就是搜寻的具体空间),&lt;br /&gt;
reachness这个quantity用来刻画我们searching的process, 因为算法确定, 数据结构确定, 没有数据的update.&lt;br /&gt;
那么我们前后两次searching到同一个target的reachness是一样的!没有差异, 我们不能仅仅用他来区分不同的searching process.&lt;br /&gt;
那么我们如何用这个reachness刻画不同searching algorithm呢?在说一次,&lt;br /&gt;
 我们分析过程不关心算法的效率(这种马后炮式的分析,很无聊, 但巨大现实意义), 不属于本次的topic!&lt;br /&gt;
我们的目的是为了理解区分而刻画不同的searching algorithm.实际上在上面分析排序算法的过程中我们隐式的分析对象就是数据结构,&lt;br /&gt;
不过我们忽视了他的存在. 我们分析的内容是确定的:&lt;br /&gt;
数据有序, 能显著减少搜索的空间? 为什么有序order的数据, 就能减少搜索的次数呢?&lt;br /&gt;
a) 查找本身就是做order判断.&lt;br /&gt;
b)  而有序的数据潜在做完了判断.&lt;br /&gt;
也就是还有一个判断读的问题 or orderness. 那么final reachness的最大值就是描述在不同的数据结构中, 得到target经历的quantity.&lt;br /&gt;
if orderness = 0. every structure&amp;rsquo;s final reachness = max space.&lt;br /&gt;
else final reachness &amp;lt; max space; // maybe half of max space&lt;br /&gt;
那么树形结构和linear 结构有什么区别呢? 结构上的已经清楚了.实际上, 我们知道计算机中树就是用linear实现的.&lt;br /&gt;
无序的链表和无序的tree是一样的.可以说无序的树是无意义的.&lt;br /&gt;
树是链表的超集. 有什么事树可以, 链表不可以.二分查找和二叉树查找是一样的.&lt;br /&gt;
但是二分只能应用到array上. 主要是因为没办法找到中间点.如果我们加个指针指向有序链表中间向他变成了什么?&lt;br /&gt;
没错树, 这应该就是树的重要本质了, accessable &amp;ldquo;中间&amp;rdquo;的quantity.除了叶节点职位的quantity都是内部&amp;rdquo;中间&amp;rdquo;quantity.&lt;br /&gt;
tree的两个后继则是边缘的一种展示.相比链表, 我们能第一时间知道正set of quantities的中间quantities.&lt;br /&gt;
实际上, 顺着middle pointer我们能够找到所有的interior middle quantities; 意外吧. 但是我们想知道其他的&lt;br /&gt;
中间节点时间耗费就是增多了.比如2049个节点. dfs只要最多8次就能找到任意&amp;rdquo;interior middle pointer&amp;rdquo;可是link list&lt;br /&gt;
全是512次啊tree有效的控制了reachness. 当然树是完全平衡的二叉树.&lt;br /&gt;
我现在到底在说什么呢? 我们试图用reachness和orderness描述tree, 我们辨析了tree和链表在reachness上的差异, 前提full order.&lt;br /&gt;
tree毫无疑问有link list来的.也就是说我们现在把searching 等价成了tree的结构.&lt;br /&gt;
那么维持reachness在较低值就是算法优劣关键. 那么如何保持reachness最小, 也就是orderness最大.&lt;br /&gt;
是什么让tree在reachness比link list优势这么大? 是存在于tree中隐式的判断.链式是一点点线性的变化, 而tree中的隐式判断确实二分的.&lt;br /&gt;
orderness小于1的tree没有意义.&lt;br /&gt;
记下来看看:avl tree, redblack tree, treap, splay tree, Size Balanced Tree, B-tree, B+ tree. but Trie or 霍夫曼树.&lt;br /&gt;
也就是说我们现在要考察这些tree structure. 基本考察完, 我的算法就同了. 后面还有DP, 贪婪, 数值, PNP之类都是思想了.&lt;br /&gt;
所以基本上本周5能把algorithm, 完事, 周6 设计模式. 周日开始sicp.&lt;br /&gt;
开始, 树结构的分析, 因为尽管是有形的visible structure, 我们依然无法给霍夫曼树和red black一个合理分析视角,&lt;br /&gt;
根本原因就是他们的form causality or 目的因不同.由上面可知orderness和reachness是我门刻画binary balance tree的quantities.&lt;br /&gt;
我们前面也分析了如何从link list到链表. 确定小, 中, 大,即 left, root, right这种模式下所有set of quantities的构成tree有多种可能.&lt;br /&gt;
如 1 2 3 4 5; left subtree 可以是 NULL, 1, 2, 还可以是1, 2, NULL.常见的旋转可以打到前者的情况. or不旋转:&lt;br /&gt;
5是root. 之后3是left 也是subtree的root, 1是left, 4是right,  1是root 2是right.&lt;br /&gt;
有序的link list和二叉树在插入删除是都做order判断调整, 由此一点我们不能判断出书有效的. 那什么是树比link list有效的呢?当然前提是&lt;br /&gt;
整个set 是order的.对1 2 3 4 5, reachness可能是5也可能是3. 对与1024个数据可能是1024, 可能是9.&lt;br /&gt;
树的高度height能有效衡量reachness.现在我们知道了, avl, red black, trap, splay这些tree的目标都是height的最小化.&lt;br /&gt;
但同时, 我们也知道height是一个描述最终结果.并不是process quantity. 我们找到与process动态同步的quantity.&lt;br /&gt;
这个process准确说就是构建balance tree的过程. 那么这个量就是描述balance tree.如 1 2 3 4 5 6 7 8 9, 5做root,&lt;br /&gt;
1 2 3 4 全是left child, 6 7 8 9全是right child. 二叉树的最raw的形态应该是link list那种.也就是说除了leaf node, 每个node至少&lt;br /&gt;
和两个node相连.也就是天然的形态. 那么我们把同时连着两个的node的connectivity作为1. 反之为0.链表起始是right side tree,&lt;br /&gt;
我的天, 这样链表的connectivity就是0啊.比如1,2,3,4,5,6,7的connectivity在0~3, 这是strict connectivity.那么bold connectivity就是&lt;br /&gt;
只要有连着就行link list对于1 to 7 这种情况是6.和二叉树没差. 比如 1 2 3 4 5. connectivity是1 or 2对search是没有影响的.&lt;br /&gt;
饶了一圈发现还是height最好用.那如何保证height最小. 看来还差树的form是保证height=(logN+1向上取整)&lt;br /&gt;
现在searching问题就转换成了二叉树构造的问题了.成了一个动态的过程了.&lt;br /&gt;
我们现在完全不考虑算法实现. 只是单纯的考虑一个过程前后两个state的差异, 类似蒙太奇手法.&lt;br /&gt;
重点是确认前后的两个state是什么? 前一个状态是raw, 我们不关心具体什么, 因为他可以是二叉树可能存在的各种状态.那么后一个状态呢?&lt;br /&gt;
我们期望的是什么. 我们可以为binary tree的各种形态用数值量化表示. 我们不用complete binary tree来表示理性的便于搜索的二叉树.&lt;br /&gt;
因为在最右在层, leaf node是否连续, 对searching的worst-case time O(log n) 没影响.所以我们叫piled tree.&lt;/p&gt;

&lt;p&gt;如果存在3个点向来的情况就认为 connectivity is 1。整个树的connectivity 是每个点的加和结果。&lt;br /&gt;
比如1到7的set那么max connectivity&lt;br /&gt;
4&lt;br /&gt;
&lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;5&lt;/sub&gt;&lt;br /&gt;
&lt;sup&gt;13&lt;/sup&gt;&amp;frasl;&lt;sub&gt;67&lt;/sub&gt;&lt;br /&gt;
所以是3这种情况也就是最有利于searching的。&lt;br /&gt;
同样1到7。&lt;br /&gt;
4&lt;br /&gt;
&lt;sup&gt;3&lt;/sup&gt;&amp;frasl;&lt;sub&gt;5&lt;/sub&gt;&lt;br /&gt;
&lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;67&lt;/sub&gt;&lt;br /&gt;
2&lt;br /&gt;
这种情况connectivity不是max，是2。也对应不是对searching最优的结构。&lt;br /&gt;
how to prove the consistency between connectivity and searching effiency？&lt;br /&gt;
Delay this job to future。&lt;br /&gt;
So oncemore we transfer our hunting target to how to build a  binary tree that with max connectivity.&lt;br /&gt;
In other words, all the popular self banlancing tree inherit this intrsic.&lt;br /&gt;
what we can do to modify the structure of  binary searching tree.&lt;br /&gt;
1 link  or unlink&lt;br /&gt;
2 counterclockwise weight inreasing&lt;br /&gt;
3 right shift(left roation); left shift(right roation)&lt;br /&gt;
4 只有insert和delete会影响.&lt;br /&gt;
尝试这却理解redblack tree.&lt;br /&gt;
逐一分析性质:&lt;br /&gt;
分出red black, 根叶都是黑.&lt;br /&gt;
red node不联通.&lt;br /&gt;
每个路径上黑node个数相同.&lt;br /&gt;
如果对于特定数量的nodes, 我们确认他能构成一定数量对应height在log(N+1), 也就是最优的searching.&lt;br /&gt;
所以说specific number nodes可以组成很多种binary searching tree.按照node的height在log(N+1)的数量.&lt;br /&gt;
avl 要严格rb-tree.这就是bst的form. 我们来总结下.&lt;br /&gt;
numbers of node &amp;lt; log(N +1) 取上.&lt;br /&gt;
那么rb是如何保证logN呢?&lt;br /&gt;
一个潜在的性质是插入是红.红永远小于黑,&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://gregfjohnson.com/cgi-bin/redblackbuilder&#34;&gt;http://gregfjohnson.com/cgi-bin/redblackbuilder&lt;/a&gt; 生成1 2 3 4 5 6逐一插入的算法.&lt;br /&gt;
                                                                             2  (b)&lt;br /&gt;
                                                                               |&lt;br /&gt;
                                                                   +&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&amp;mdash;&amp;mdash;&amp;mdash;-+&lt;br /&gt;
                                                                   |                      |&lt;br /&gt;
                                                                 1  (b)                 4  &amp;reg;&lt;br /&gt;
                                                                                          |&lt;br /&gt;
                                                                                  +&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;-+&lt;br /&gt;
                                                                                  |               |&lt;br /&gt;
                                                                                3  (b)          5  (b)&lt;br /&gt;
                                                                                                  |&lt;br /&gt;
                                                                                                  +&amp;mdash;-+&lt;br /&gt;
                                                                                                       |&lt;br /&gt;
                                                                                                     6  &amp;reg;&lt;br /&gt;
insert 7:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                                                                         2  (b)                                 
                                                                           |                                    
                                                              +------------+------------+                       
                                                              |                         |                       
                                                            1  (b)                    4  (r)                    
                                                                                        |                       
                                                                             +----------+----------+            
                                                                             |                     |            
                                                                           3  (b)                6  (b)         
                                                                                                   |            
                                                                                            +------+------+     
                                                                                            |             |     
                                                                                          5  (r)        7  (r) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;insert 8:&lt;br /&gt;
                                                                             4  (b)&lt;br /&gt;
                                                                               |&lt;br /&gt;
                                                                 +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&lt;br /&gt;
                                                                 |                            |&lt;br /&gt;
                                                               2  &amp;reg;                       6  &amp;reg;&lt;br /&gt;
                                                                 |                            |&lt;br /&gt;
                                                          +&amp;mdash;&amp;mdash;+&amp;mdash;&amp;mdash;+             +&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;-+&lt;br /&gt;
                                                          |             |             |               |&lt;br /&gt;
                                                        1  (b)        3  (b)        5  (b)          7  (b)&lt;br /&gt;
                                                                                                      |&lt;br /&gt;
                                                                                                      +&amp;mdash;-+&lt;br /&gt;
                                                                                                           |&lt;br /&gt;
                                                                                                         8  &amp;reg;&lt;br /&gt;
从6和7我们能看出来rb tree不是严格小于log(N+1) 分别有1和2个node height超过(logN+1), 第一个插入的是4那么就能保证complete了.&lt;br /&gt;
那么rb tree是如何保证每条路径上黑node相同呢?貌似是个副产品.可是非常重要.&lt;br /&gt;
如果父和叔都是r, 都变b, 祖父r.&lt;br /&gt;
如果叔是黑, 父黑, 祖父r. 父变root.&lt;br /&gt;
删除:&lt;br /&gt;
要复杂很多.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Computer science a kernel programmer&#39;s perspective</title>
      <link>http://firoyang.org/cs/cs/</link>
      <pubDate>Fri, 27 Feb 2015 15:46:14 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/cs/</guid>
      <description>

&lt;p&gt;What&amp;rsquo;s the computer science? Have ever asked yourself? It&amp;rsquo;s not a science!&lt;br /&gt;
&lt;a href=&#34;https://www.youtube.com/watch?v=lL4wg6ZAFIM&#34;&gt;Richard Feynman on Computer Science — Talk at Bell Labs (1985)&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.tuicool.com/articles/YRZvem&#34;&gt;Mort Yao 程序与证明&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.bravegnu.org/gnu-eprog/&#34;&gt;Vijay Kumar B&amp;rsquo;s Embedded Programming with the GNU Toolchain&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;components-of-cs&#34;&gt;Components of cs&lt;/h1&gt;

&lt;p&gt;design(pattern) and algorithm, programming(debugging, hacking)&lt;br /&gt;
pl,assembly, compile(gcc), link, load(cll)&lt;br /&gt;
process, quantaties, order(synchronization)&lt;br /&gt;
turing, arch, os(boot, console, fedora, fs, process, mm, pm, time, virt, synchronization)&lt;br /&gt;
math, logic, electronics&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;OS Service&lt;/th&gt;
&lt;th&gt;Hardware Support&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Protection&lt;/td&gt;
&lt;td&gt;Kernel/user mode, protected instructions, base/limit registers&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Interrupts&lt;/td&gt;
&lt;td&gt;Interrupt vectors&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;System calls&lt;/td&gt;
&lt;td&gt;Trap instructions and trap vectors&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;I/O&lt;/td&gt;
&lt;td&gt;Interrupts and memory mapping&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Scheduling, error recovery,accounting&lt;/td&gt;
&lt;td&gt;Timer&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Synchronization&lt;/td&gt;
&lt;td&gt;Atomic instructions&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Virtual memory&lt;/td&gt;
&lt;td&gt;Translation look-aside buffers&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;form&lt;/td&gt;
&lt;td&gt;os&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;mdash;&amp;ndash;&lt;/td&gt;
&lt;td&gt;&amp;mdash;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;change, computation, transfer .&lt;/td&gt;
&lt;td&gt;instructions(memory,IO), Process, interrupt&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;relation, order&lt;/td&gt;
&lt;td&gt;synchronization/atomic, scheduling, interrupt&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;quantaties, state&lt;/td&gt;
&lt;td&gt;fs, memory, device, driver&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;the-advert-of-new-world-origin-performance&#34;&gt;the advert of new world origin - performance&lt;/h1&gt;

&lt;p&gt;cache: in order to improve performace, cache tries to reduce the access time of transfer of future.&lt;br /&gt;
buffer: What does buffer do? temporary(Not future) place for data,reducing access time of transfer and&lt;br /&gt;
maybe effiency of quantaties/times of transfer. 是确定的行为, 不同与cache的统计学原理.&lt;br /&gt;
time-sharing: multi-task from batch processing&lt;br /&gt;
prallel process: increas quantanties of process.&lt;/p&gt;

&lt;p&gt;现在我们以新的视角看待os演化过程， 即以process/change， quantaties/state， relation/order这些natural origin为wilds，&lt;br /&gt;
辅以will意志的origin:&lt;br /&gt;
performance/efficiency&lt;br /&gt;
Easy to use&lt;br /&gt;
Security/Protection/isolation&lt;br /&gt;
Reliability&lt;br /&gt;
Energy-efficiency&lt;/p&gt;

&lt;h1 id=&#34;kerenl&#34;&gt;kerenl&lt;/h1&gt;

&lt;p&gt;General subsystem: schedule, memory, fork, lock, vfs. April 4, 8 days&lt;br /&gt;
Network + redhat requirements. 8 days&lt;br /&gt;
KVM. source code level and hands-on lkml&lt;/p&gt;

&lt;h1 id=&#34;faq&#34;&gt;FAQ&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.ibm.com/developerworks/library/os-aapseudo1/os-aapseudo1-pdf.pdf&#34;&gt;All about pseudo&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The art of debugging</title>
      <link>http://firoyang.org/cs/debugging/</link>
      <pubDate>Fri, 27 Feb 2015 15:46:14 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/debugging/</guid>
      <description>

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;Reverse engineering&lt;br /&gt;
&lt;a href=&#34;https://en.wikipedia.org/wiki/Abductive_reasoning#Logic-based_abduction&#34;&gt;How debuggers work&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;info&#34;&gt;info&lt;/h1&gt;

&lt;p&gt;Host OS name and version number.&lt;br /&gt;
I40e driver version number.&lt;br /&gt;
Host OS Linux Kernel log.&lt;br /&gt;
VF driver version number.&lt;br /&gt;
NIC hardware model and PBA number.&lt;br /&gt;
NIC Firmware NVM version number.&lt;/p&gt;

&lt;h1 id=&#34;core-pattern&#34;&gt;Core pattern&lt;/h1&gt;

&lt;p&gt;echo /tmp/core-%e-%p-%s-%c-%P &amp;gt; /proc/sys/kernel/core_pattern&lt;/p&gt;

&lt;h1 id=&#34;from-assembly-to-c&#34;&gt;From assembly to C&lt;/h1&gt;

&lt;p&gt;addr2line -f -C -a 0xxxx -e ooo.bin&lt;br /&gt;
addr2line -e vmlinux -i ffffffff81f04b7a ffffffff81508daa&lt;/p&gt;

&lt;h1 id=&#34;from-elf-to-c&#34;&gt;From ELF to C&lt;/h1&gt;

&lt;p&gt;pahole -C &amp;lsquo;block_device&amp;rsquo; vmlinux&lt;/p&gt;

&lt;h1 id=&#34;debugging-and-bug-types&#34;&gt;Debugging and Bug types&lt;/h1&gt;

&lt;p&gt;Does anyone can tell me what is debugging? Debugging is &lt;a href=&#34;https://en.wikipedia.org/wiki/Abductive_reasoning#Logic-based_abduction&#34;&gt;Abductive reasoning&lt;/a&gt;.&lt;br /&gt;
Theory + Observations =&amp;gt; Explanation&lt;/p&gt;

&lt;h1 id=&#34;bug-classifications&#34;&gt;Bug classifications&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.opensourceforu.com/2010/10/joy-of-programming-types-of-bugs&#34;&gt;BUG type of Jim Gray&lt;/a&gt;,除了Bohrbug,其他都不太好解.&lt;br /&gt;
The National Vulnerability Database是一个非常有用的网站, 国内鲜少有人提及.尤其是,&lt;br /&gt;
他的Bug分类方式惊艳无比, 逻辑上非常严密, 就好比数学系统, 由公理系统推导而得.&lt;br /&gt;
NVD的Bug分类也采用类似的构建方式.&lt;a href=&#34;https://nvd.nist.gov/cwe.cfm&#34;&gt;CWE Cross Section Mapped into by NVD&lt;/a&gt;&lt;br /&gt;
涵盖了所有常见的的Bug描述, 而且非常专业.大赞!wikipedia的条目就相形见绌了&lt;br /&gt;
&lt;a href=&#34;https://en.wikipedia.org/wiki/Software_bug#Common_types_of_computer_bugs&#34;&gt;Common types of computer bugs in wikipedia&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;use-after-free&#34;&gt;use after free&lt;/h1&gt;

&lt;p&gt;record the owner, who free.&lt;/p&gt;

&lt;h1 id=&#34;general-debugging-steps&#34;&gt;General debugging steps&lt;/h1&gt;

&lt;p&gt;Debugging的逻辑过程是&lt;a href=&#34;https://en.wikipedia.org/wiki/Abductive_reasoning#Logic-based_abduction&#34;&gt;Abductive reasoning&lt;/a&gt;. 我们以此进行推导.&lt;br /&gt;
T: Theory 也就是我们的background, cs的知识技术, 出问题的程序与代码.&lt;br /&gt;
O: Observations 是Bug发生的现场以及相应的log, 现象.&lt;br /&gt;
E: Explanation 是最终定位的结论.&lt;br /&gt;
E ⊆ T; O ⊆ T; E ⊃ (E ∩ O);&lt;br /&gt;
if E = (E ∩ O); then debugging is done.&lt;br /&gt;
T, E 与 O理论上都是从∅开始,且O =&amp;gt; E;&lt;br /&gt;
E: ∅ -&amp;gt; Bug type(可能经过是多种Bug types的过渡状态) -&amp;gt; Explanation&lt;br /&gt;
很多时候O也会使T扩大.所以O成为debugging的关键.&lt;br /&gt;
下面严格区分T 和 O. 我们得到O就要不断地结合T进行理性分析.&lt;br /&gt;
&amp;gt; Another perespective,&lt;br /&gt;
&amp;gt; the process of debugging is use O to minimize T to E instance.&lt;br /&gt;
&amp;gt; T is solutions space, E &lt;a href=&#34;https://nvd.nist.gov/cwe.cfm#cweIdEntry-CWE-1&#34;&gt;locates&lt;/a&gt; in T. O is the address to find E.&lt;/p&gt;

&lt;p&gt;基于NVD的CWE我们可知, 收集observations 可能是development和deployment的各个节点.&lt;/p&gt;

&lt;h3 id=&#34;get-observations&#34;&gt;Get observations&lt;/h3&gt;

&lt;p&gt;首先我们要理清中间的各个流程, 以及相关的observations:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;coding&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;compilation&lt;br /&gt;
make kernel/sched.s V=1&lt;br /&gt;
readelf, objdump&lt;br /&gt;
c++filt&lt;br /&gt;
./scripts/decodecode &amp;lt; Oops.txt&lt;br /&gt;
echo&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;load software&lt;br /&gt;
LD_TRACE_LOADED_OBJECTS=1 git&lt;br /&gt;
ldd /usr/bin/git&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;software running&lt;br /&gt;
&amp;gt; #define debugme(fmt, args&amp;hellip;) do{FILE *fdebug=fopen(&amp;ldquo;/tmp/d.log&amp;rdquo;, &amp;ldquo;a+&amp;rdquo;); &lt;br /&gt;
&amp;gt; fprintf(fdebug,&amp;ldquo;%s,%s,%d:&amp;ldquo;fmt, &lt;strong&gt;TIME&lt;/strong&gt;, &lt;strong&gt;FUNCTION&lt;/strong&gt;, &lt;strong&gt;LINE&lt;/strong&gt;, ##args);fclose(fdebug);} while(0)&lt;br /&gt;
lsof, ltrace, strace, bash -x, coredump&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;kernel specific&lt;br /&gt;
putstr early_printk vs printk pr_debug vs dev_debug dump_stack&lt;br /&gt;
Linux serial-port driver is interrupt driven, if irq-off console will not work!&lt;br /&gt;
how to use serial-port addr&lt;br /&gt;
ioctl/netlink, SysRq, ftrace expect,kgtp, lockdep, kdump, kgdboc&lt;br /&gt;
print signal This is just a hiwifi wonderful kernel patch #931&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;network specific&lt;br /&gt;
tcpdump netstat iptables wireshark&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;u-boot&lt;br /&gt;
print_tlb&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;make specific&lt;br /&gt;
-s, -n, -p, &amp;ndash;warn-undefined-variables&lt;br /&gt;
$(warning &amp;hellip;)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;有的类型的Bug会阻止我们收集observations&lt;br /&gt;
这时候就要增加observations,让我们能收集到. 比如use after free, buffer errors.&lt;br /&gt;
这时要扩大目标struct的大小, 把observations加进去.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;software imediately stop&lt;br /&gt;
Use atexit() register a stackdump or a wrapped print&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;inference&#34;&gt;Inference&lt;/h1&gt;

&lt;p&gt;From observatons to source code/mind&lt;br /&gt;
追BUG实际上就是, 找关联度最高的.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;tips&lt;br /&gt;
If an page oops close to zero, for example 0xfffffff4&lt;br /&gt;
It maybe ERR_PTR(-12);&lt;br /&gt;
&lt;a href=&#34;http://www.stlinux.com/devel/debug/jtag/build?q=node/82&#34;&gt;Tips on debugging optimized code&lt;/a&gt;&lt;br /&gt;
code reordering inlining Optimized-away variables Tailcall optimization&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;oops&lt;br /&gt;
From ASM to c language&lt;br /&gt;
&lt;a href=&#34;http://yarchive.net/comp/linux/oops_decoding.html&#34;&gt;lkml-Linus-Al-Viro-oops-debug&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;asm&lt;/strong&gt;(), 常量, loop codes format, char *, ip&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;一些比较通用的调试工具&#34;&gt;一些比较通用的调试工具&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;gdb&lt;br /&gt;
gdb vmlinux /proc/kcore&lt;br /&gt;
p jiffies_64&lt;br /&gt;
text_addr=/sys/module/char-read-write/sections/.text&lt;br /&gt;
add-symbol-file /home/nkhare/char-read-write.ko $text_addr&lt;br /&gt;
print &amp;amp;((struct kmem_cache *)0)-&amp;gt;offset&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;anti-debugging&#34;&gt;Anti-debugging&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Syntax checking&lt;br /&gt;
gcc -Wall&lt;br /&gt;
bash -n&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;static code analysis&lt;br /&gt;
smatch&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;bug-made-by-me&#34;&gt;BUG made by me&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;print_signal_info wrong pritk parameters position&lt;br /&gt;
    printk(KERN_NOTICE &amp;ldquo;K %d : %d -&amp;gt; %s %d %s %d\n&amp;rdquo;, sig, q-&amp;gt;info.si_code,&lt;br /&gt;
            ss&lt;a href=&#34;http://www.opensourceforu.com/2010/10/joy-of-programming-types-of-bugs&#34;&gt;2&lt;/a&gt;, ss&lt;a href=&#34;https://nvd.nist.gov/cwe.cfm&#34;&gt;3&lt;/a&gt;, task_tgid_vnr(r_t), task_tgid_vnr(r_p));&lt;br /&gt;
Watch compile warning info can be avoid of this bug.&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;spin_lock(sighand) invoke down_sem and cond_resched&amp;hellip;&lt;br /&gt;
__send_signal()&lt;/p&gt;

&lt;h1 id=&#34;examples&#34;&gt;Examples&lt;/h1&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;timer_list-&amp;gt;function = NULL&lt;br /&gt;
我前几天定位了一个Softirq中timer corruption的问题, 现象是timer func是个非法地址.&lt;br /&gt;
首先, 一下子不能确认是由那种Bug type导致的.可能是Improper Restriction of Operations&lt;br /&gt;
within the Bounds of a Memory Buffer 也可能是Use after free. 所以此时debug的关键所在&lt;br /&gt;
就是收集observations,也就是function的名字, 而我遇到的这个问题timer 被完全写坏了.&lt;br /&gt;
可以用ftrace收集所有timer 的地址和function, 再从oops里面得到timer地址,回头找ftrace&lt;br /&gt;
log中记录的function, 从而定位问题. 稍后介绍, 如何通过expect抓屏幕log.&lt;br /&gt;
这个方法没成功, 时候分析知道是因为panic的瞬间出问题的timer的地址和function没来得及&lt;br /&gt;
记录到ftrace.怎么办? 我直接说了, 我想到一个办法, 把timer的空间增大, 增大的空间用来&lt;br /&gt;
保存function,在oops把这块内存打出来. 此法非常有用, timer的function一下子就找到了, 进而&lt;br /&gt;
确认了问题是use after free. 非常开心:-)这里的解释了如何收集observations的技巧.对待use&lt;br /&gt;
after free的问题是够了, 以后用到这类问题基本可以妙解了.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;module text address&lt;br /&gt;
cat /sys/module/wmi/sections/.text&lt;br /&gt;
cat /proc/modules | grep wmi&lt;br /&gt;
int bss_var;&lt;br /&gt;
static int hello_init(void)&lt;br /&gt;
{printk(KERN_ALERT &amp;ldquo;Text location .text(Code Segment):%p\n&amp;rdquo;,hello_init);&lt;br /&gt;
static int data_var=0;&lt;br /&gt;
printk(KERN_ALERT &amp;ldquo;Data Location .data(Data Segment):%p\n&amp;rdquo;,&amp;amp;data_var);&lt;br /&gt;
printk(KERN_ALERT &amp;ldquo;BSS Location: .bss(BSS Segment):%p\n&amp;rdquo;,&amp;amp;bss_var);}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;debug-glibc&#34;&gt;Debug glibc&lt;/h1&gt;

&lt;p&gt;directory ~/ws/glibc-2.23/libio&lt;br /&gt;
set solib-search-path /usr/lib/debug/lib/x86_64-linux-gnu/&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The art of programming</title>
      <link>http://firoyang.org/cs/programming/</link>
      <pubDate>Fri, 27 Feb 2015 15:46:14 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/programming/</guid>
      <description>

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Category:Programming_principles&#34;&gt;Programming principles&lt;/a&gt;&lt;br /&gt;
programming principles&lt;br /&gt;
High cohesion low coupling&lt;/p&gt;

&lt;h1 id=&#34;computer-programming&#34;&gt;Computer programming&lt;/h1&gt;

&lt;p&gt;编程作为我重要的谋生手段, 有必要审慎的加以考察审视. 程序设计应该包含那些最少的, 必备的, 重要的能力呢?&lt;br /&gt;
&lt;a href=&#34;http://www.cs.princeton.edu/~bwk/tpop.webpage/&#34;&gt;The practice of programming&lt;/a&gt;给出了大概的框架, 但不完整.&lt;br /&gt;
我认为最重要的就是Abstraction and design.&lt;br /&gt;
&lt;a href=&#34;http://www.ccs.neu.edu/home/matthias/HtDP2e/&#34;&gt;How to design programs&lt;/a&gt;还有&lt;a href=&#34;http://sarabander.github.io/sicp/&#34;&gt;SICP&lt;/a&gt;以及Elements of programming.&lt;br /&gt;
其次我们要掌握几门Programming language.&lt;br /&gt;
养成好的Coding style,&lt;br /&gt;
Valid and verification&lt;br /&gt;
Testing&lt;br /&gt;
Debuging&lt;/p&gt;

&lt;h1 id=&#34;files-sytle&#34;&gt;Files sytle&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://lists.kernelnewbies.org/pipermail/kernelnewbies/2012-March/004986.html&#34;&gt;kernel asm/asm-generic&lt;/a&gt;&lt;br /&gt;
asm stands for arch specific macros(FIXME).&lt;/p&gt;

&lt;h1 id=&#34;coding-style&#34;&gt;Coding style&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.gnu.org/prep/standards/standards.html&#34;&gt;GNU Coding Standards&lt;/a&gt;&lt;br /&gt;
比如GNU coding standards, Linux kernel coding style, Shell coding standard&lt;br /&gt;
* Label&lt;br /&gt;
It is considered to be safer that the label reflect what happens at the&lt;br /&gt;
destination, and not the reason for reaching the label. &amp;ndash;Julia&lt;/p&gt;

&lt;h1 id=&#34;verification-and-validation&#34;&gt;Verification and validation&lt;/h1&gt;

&lt;p&gt;抽象的知识来自生活经验的总结, 所以学习抽象知识的重要方向是从实践不断总结抽象.&lt;br /&gt;
programming is a goal-oriented activity&lt;br /&gt;
14.4&lt;br /&gt;
Before attempting to solve a problem, make absolutely sure you  what the problem is.&lt;br /&gt;
14.5&lt;br /&gt;
Before developing a program, make precise and refine the pre/postcondition.&lt;br /&gt;
program -&amp;gt;&lt;br /&gt;
{Q} S {R}: predicte, formal notation&lt;br /&gt;
Q: input asseration&lt;br /&gt;
R: output asseration&lt;br /&gt;
predictes -&amp;gt; asseration&lt;br /&gt;
asseration: a predicate placed in a program is called an asseration.&lt;br /&gt;
Proof outline: a program together with an asseration between each pair of statements&lt;br /&gt;
Program specification ⊃ excution ∪ speed ∪ size&lt;br /&gt;
Instances: summation, squre root approximation, sorting&lt;br /&gt;
command-comment ⊃ all input ∪ output&lt;/p&gt;

&lt;h1 id=&#34;debugging&#34;&gt;Debugging&lt;/h1&gt;

&lt;p&gt;see debugging.md&lt;/p&gt;

&lt;h1 id=&#34;testing&#34;&gt;Testing&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://googletesting.blogspot.com/&#34;&gt;Google testing blog&lt;/a&gt;&lt;br /&gt;
1.Black-box testing test software function.&lt;br /&gt;
2.White-box testing test software internal logic.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The programming language</title>
      <link>http://firoyang.org/cs/pl/</link>
      <pubDate>Fri, 27 Feb 2015 15:46:14 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/pl/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://www.yinwang.org/blog-cn/2016/03/31/no-longer-pl&#34;&gt;我为什么不再做PL人&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html&#34;&gt;Functors, Applicatives, And Monads In Pictures&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://jozefg.bitbucket.org/posts/2015-08-14-learn-tt.html&#34;&gt;Learn Type Theory&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;∅ ⊢ pl&lt;br /&gt;
scope: The set of expressions for which a binding defines a name is called the scope of that name.&lt;/p&gt;

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.zhihu.com/question/21843639&#34;&gt;http://www.zhihu.com/question/21843639&lt;/a&gt;&lt;br /&gt;
貌似正则是type 3, c是type2, 范式角度我现在不好理解, 缺乏语言学的知识.&lt;br /&gt;
Programming Language Pragmatics 3rd&lt;br /&gt;
C11&lt;br /&gt;
C Traps and Pitfalls&lt;br /&gt;
Expert C Programming&lt;/p&gt;

&lt;h1 id=&#34;contents&#34;&gt;Contents&lt;/h1&gt;

&lt;p&gt;Programming language theory&lt;br /&gt;
Programming language&lt;/p&gt;

&lt;h1 id=&#34;programming-language-theory&#34;&gt;Programming language theory&lt;/h1&gt;

&lt;p&gt;What is formal language and the relationg between fl and pl?&lt;br /&gt;
Language primitive&lt;/p&gt;

&lt;h2 id=&#34;semantics&#34;&gt;Semantics&lt;/h2&gt;

&lt;h1 id=&#34;c&#34;&gt;C&lt;/h1&gt;

&lt;p&gt;我们还是从使用的角度来看c 语言;&lt;br /&gt;
c语言自身重要基础性质, 我们需要了解.&lt;br /&gt;
除此之外, 我们还要了解一些重要的标准库函数.&lt;br /&gt;
知道这些, 我们就能用c语言.&lt;/p&gt;

&lt;h2 id=&#34;type&#34;&gt;Type&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Object type and function type&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Object &amp;ndash; void, scalar,aggregate types, composite&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Scalar type &amp;ndash; Arithmetic types and pointer types&lt;br /&gt;
&lt;a href=&#34;http://www.techopedia.com/definition/16441/scalar&#34;&gt;What does Scalar mean?&lt;/a&gt;&lt;br /&gt;
scalar 词源上由scale演化而来, scalar type来自scalar processor and vector processor.&lt;br /&gt;
超标量也是来自这里concurrent SISD =&amp;gt;MIMD 所谓的流水线.&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Arithmetic type &amp;ndash; Integer and floating types&lt;/p&gt;

&lt;h2 id=&#34;incomplete-and-complete&#34;&gt;Incomplete and complete&lt;/h2&gt;

&lt;p&gt;void; struct s; union u;&lt;/p&gt;

&lt;h2 id=&#34;conversion&#34;&gt;Conversion&lt;/h2&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;only effect to scalar type data&lt;br /&gt;
error: conversion to non-scalar type requested&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;无符号数 转换成upper rank的有符号数, 还是无符号数, 不管最初是-1!&lt;br /&gt;
unsigned int i = 1; long f = -10;if ( i &amp;gt; f ) printf(&amp;ldquo;ok\n&amp;rdquo;); true 证明确实usigned 向long转换了.&lt;br /&gt;
unsigned int i = -3; long f = -5u;if ( i &amp;gt; f ) printf(&amp;ldquo;ok\n&amp;rdquo;); true&lt;br /&gt;
c11上是ok的!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;做signed 和unsigned 貌似both convert to unsigned gcc才给警告, 否则不给即便是signed和unsigned比较.&lt;/p&gt;

&lt;h2 id=&#34;lvalue-rvalue-modfiable-rvalue&#34;&gt;lvalue rvalue modfiable rvalue&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c&#34;&gt;Understanding lvalues and rvalues in C and C++&lt;/a&gt;&lt;br /&gt;
If a variable/expression  has a address, it&amp;rsquo;s of lvalue.&lt;/p&gt;

&lt;h2 id=&#34;array-decay&#34;&gt;Array decay&lt;/h2&gt;

&lt;p&gt;数组退化的初衷, 可能是K&amp;amp;R当年计算资源紧缺, 导致不允许函数传值copy数组内容.&lt;br /&gt;
总之标准委员会介入之前就决定.&lt;br /&gt;
&lt;a href=&#34;http://bbs.chinaunix.net/thread-1031622-1-1.html&#34;&gt;[C] [原创]数组与指针&amp;mdash;都是&amp;rdquo;退化&amp;rdquo;惹的祸&lt;/a&gt;&lt;br /&gt;
关于char *s错误声明的讲解不错!&lt;br /&gt;
&lt;a href=&#34;http://stackoverflow.com/questions/17752978/exception-to-array-not-decaying-into-a-pointer&#34;&gt;Exception to array not decaying into a pointer?&lt;/a&gt;&lt;br /&gt;
在c11 6.3.2.1 Lvalues, arrays, and function designators第3点说明了&lt;br /&gt;
array不会退化的4种场景. Except when it is&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;the operand of the sizeof operator,&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;the _Alignof operator, or the&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;unary &amp;amp; operator, or&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;is a string literal used to initialize an array, an expression that has type&lt;br /&gt;
‘‘array of type’’ is converted to an expression with type ‘‘pointer to type’’&lt;br /&gt;
that points to the initial element of the array object and is not an lvalue.&lt;br /&gt;
If the array object has register storage class, the behavior is undefined.&lt;br /&gt;
这4种场景之外, 那么array名退化的结果是pointer.&lt;br /&gt;
这个pointer和我们最常用的pointer如int *p有什么区别呢?&lt;br /&gt;
首先array decay是type上的转化array -&amp;gt; pointer.&lt;br /&gt;
其次数组名原来是lvalue -&amp;gt; not an lvalue更谈不上modifiable.&lt;br /&gt;
type: tyepof(array[0]) *&lt;br /&gt;
value: &amp;amp;array[0] or array&lt;br /&gt;
property: not lvalue&lt;br /&gt;
当然这只是c11上的说明, 我们只要明白为什么不能修改一个decay数组名就行了.&lt;br /&gt;
实现的个人猜测是: 根据lvalue的定义decay后数组名还是lvalue, 只不过一直都不是modifiable.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为什么作为函数形参的数组名可以++, 而作为变量的数组名就不可以.&lt;br /&gt;
因为形参数组名被当初pointer处理modifiable lvalue, 而实参数组名只是传值而已.&lt;br /&gt;
而普通数组名是一个lvalue,不能修改.&lt;/p&gt;

&lt;h3 id=&#34;why-innermost-dimension-can-be-omit-in-array&#34;&gt;Why innermost dimension can be omit in array&lt;/h3&gt;

&lt;p&gt;用不到.&lt;br /&gt;
In essence, all arrays in C are one-dimensional.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Because the array will decay to pointer and to calculate offset to&lt;br /&gt;
the elements of the array you do not need to know the innermost dimension.&lt;/p&gt;

&lt;p&gt;Compiler has to know by how much to increment the pointer when&lt;br /&gt;
indexing on the first dimension for example. So if an int array is named a,&lt;/p&gt;

&lt;h2 id=&#34;integer-promotion&#34;&gt;Integer Promotion&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.idryman.org/blog/2012/11/21/integer-promotion/&#34;&gt;Deep C: Integer Promotion&lt;/a&gt;&lt;br /&gt;
* &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/fc9te331.aspx&#34;&gt;Integral Promotions&lt;/a&gt;&lt;br /&gt;
0xF int&lt;br /&gt;
0xFFFFFFFF unsigned int&lt;/p&gt;

&lt;h2 id=&#34;scopes-of-identifiers&#34;&gt;Scopes of identifiers&lt;/h2&gt;

&lt;p&gt;For each different entity that an identifier designates, the identifier is visible (i.e., can be&lt;br /&gt;
used) only within a region of program text called its scope.&lt;br /&gt;
* four kinds of scopes: function, file, block, and function prototype&lt;br /&gt;
If the declarator or type specifier that declares the identifier&lt;br /&gt;
appears outside of any block or list of parameters, the identifier has file scope, which&lt;br /&gt;
terminates at the end of the translation unit.&lt;/p&gt;

&lt;p&gt;If the declarator or type specifier that&lt;br /&gt;
declares the identifier appears inside a block or within the list of parameter declarations in&lt;br /&gt;
a function definition, the identifier has block scope, which terminates at the end of the&lt;br /&gt;
associated block.&lt;/p&gt;

&lt;p&gt;If the declarator or type specifier that declares the identifier appears&lt;br /&gt;
within the list of parameter declarations in a function prototype (not part of a function&lt;br /&gt;
definition), the identifier has function prototype scope, which terminates at the end of the&lt;br /&gt;
function declarator.&lt;/p&gt;

&lt;p&gt;If an identifier designates two different entities in the same name&lt;br /&gt;
space, the scopes might overlap.&lt;/p&gt;

&lt;h2 id=&#34;linkages-of-identifiers&#34;&gt;linkages of identifiers&lt;/h2&gt;

&lt;p&gt;An identifier declared in different scopes or in the same scope more than once can be&lt;br /&gt;
made to refer to the same object or function by a process called linkage.&lt;br /&gt;
* There are three kinds of linkage: external, internal, and none.&lt;br /&gt;
* There is no linkage between different identifiers.&lt;br /&gt;
* external linkage&lt;br /&gt;
In the set of translation units and libraries that constitutes an entire program, each&lt;br /&gt;
declaration of a particular identifier with external linkage denotes the same object or&lt;br /&gt;
function. &amp;ndash;c11&lt;/p&gt;

&lt;p&gt;If the name has external linkage,&lt;br /&gt;
the entity that name denotes may be referred to from another translation unit&lt;br /&gt;
using a distinct declaration for that same name,&lt;br /&gt;
and from other scopes within the same translation unit using distinct declarations. &amp;ndash;wikipedia&lt;br /&gt;
* Internal linkage&lt;br /&gt;
Within one translation unit, each declaration of an identifier with internal&lt;br /&gt;
linkage denotes the same object or function. &amp;ndash;c11&lt;/p&gt;

&lt;p&gt;Were the name given internal linkage,&lt;br /&gt;
such a declaration would denote a distinct entity, although using the same name,&lt;br /&gt;
but its entity could be referred to by distinct declarations within the same translation unit.  &amp;ndash;wikipedia&lt;br /&gt;
* No linkage&lt;br /&gt;
Each declaration of an identifier with no linkage denotes a unique entity. &amp;ndash;c11&lt;br /&gt;
A name that has no linkage at all cannot be referred to from declarations in different scopes,&lt;br /&gt;
not even from within the same translation unit. &amp;ndash;wikipedia&lt;/p&gt;

&lt;h2 id=&#34;name-spaces-of-identifiers&#34;&gt;Name spaces of identifiers&lt;/h2&gt;

&lt;h2 id=&#34;storage-durations-of-objects&#34;&gt;Storage durations of objects&lt;/h2&gt;

&lt;p&gt;An object has a storage duration that determines its lifetime.&lt;br /&gt;
There are four storage durations: static, thread, automatic, and allocated.&lt;br /&gt;
The lifetime of an object is the portion of program execution during which storage is&lt;br /&gt;
guaranteed to be reserved for it.&lt;br /&gt;
In book 21st Century C, it was named memory mode.&lt;br /&gt;
* static storage duration&lt;br /&gt;
An object whose identifier is declared without the storage-class specifier _Thread_local,&lt;br /&gt;
and either with external or internal linkage or with the storage-class specifier static(for no linkage &amp;ndash;firo),&lt;br /&gt;
has static storage duration.&lt;/p&gt;

&lt;p&gt;Its lifetime is the entire execution of the program and its stored value is initialized only once,&lt;br /&gt;
prior to program startup.&lt;br /&gt;
* automatic storage duration&lt;br /&gt;
An object whose identifier is declared with no linkage and without the storage-class&lt;br /&gt;
specifier static has automatic storage duration, as do some compound literals.&lt;br /&gt;
* alloced storage duration&lt;br /&gt;
The lifetime of an allocated object extends from the allocation until the deallocation.&lt;br /&gt;
* Thread storage duration&lt;br /&gt;
details in c11&lt;/p&gt;

&lt;h2 id=&#34;alignment-of-objects&#34;&gt;Alignment of objects&lt;/h2&gt;

&lt;p&gt;An alignment is an implementation-defined integer value representing the number of bytes between&lt;br /&gt;
successive addresses at which a given object can be allocated.&lt;br /&gt;
More deatils in cs.md&lt;/p&gt;

&lt;h2 id=&#34;declarations&#34;&gt;Declarations&lt;/h2&gt;

&lt;p&gt;A declaration specifies the interpretation and attributes of a set of identifiers.&lt;br /&gt;
A definition of an identifier is a declaration for that identifier that:&lt;br /&gt;
for an object, causes storage to be reserved for that object;&lt;br /&gt;
for a function, includes the function body;&lt;br /&gt;
for an enumeration constant, is the (only) declaration of the identifier;&lt;br /&gt;
for a typedef name, is the first (or only) declaration of the identifier.&lt;br /&gt;
The declaration specifiers consist of a sequence of specifiers that indicate the linkage,&lt;br /&gt;
storage duration, and part of the type of the entities that the declarators denote.&lt;/p&gt;

&lt;h2 id=&#34;marco&#34;&gt;Marco&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/huyansoft/article/details/2484297&#34;&gt;如果#操作符出现在对象宏的替换列表中,则仅作为一个普通字符,不具有下述含义&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;expressions&#34;&gt;Expressions&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;cast&lt;br /&gt;
A cast does not yield an lvalue.&lt;/p&gt;

&lt;h2 id=&#34;lexical-element&#34;&gt;Lexical element&lt;/h2&gt;

&lt;h3 id=&#34;character-constants&#34;&gt;Character constants&lt;/h3&gt;

&lt;p&gt;An integer character constant has type int.&lt;/p&gt;

&lt;h2 id=&#34;lexical-pitfall&#34;&gt;lexical pitfall&lt;/h2&gt;

&lt;h2 id=&#34;greedy-lexical-analysis&#34;&gt;Greedy lexical analysis&lt;/h2&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Write tokens with blank!&lt;br /&gt;
x = y/&lt;em&gt;p;  /&lt;/em&gt; oops, hidden error.*/&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Associative&lt;br /&gt;
You donot need to remember it! Just use it!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Precedence&lt;br /&gt;
Need to remember, but if you not sure, parenthess.&lt;/p&gt;

&lt;h2 id=&#34;inline-和宏的区别&#34;&gt;inline 和宏的区别&lt;/h2&gt;

&lt;p&gt;inline的好处与坏处&lt;br /&gt;
没有调用的开销效率很高, 但是调试代码复杂了, 内链函数的实现是拷贝副本消耗内存.&lt;br /&gt;
inline有类型检测, 宏没有.&lt;/p&gt;

&lt;h2 id=&#34;c-standard-library&#34;&gt;C standard library&lt;/h2&gt;

&lt;h2 id=&#34;faq&#34;&gt;FAQ&lt;/h2&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Logical operation with signed value? x86!&lt;br /&gt;
int c = 0xFFFFFFFF;  int d = c &amp;gt;&amp;gt; 31; =&amp;gt; d == f;&lt;br /&gt;
unsigned c = 0xFFFFFFFF;  int d = c &amp;gt;&amp;gt; 31; d!= f;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;shift beyond bits long?&lt;br /&gt;
c &amp;gt;&amp;gt; 296 == c &amp;gt;&amp;gt; 8&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;变量同名不同类型不同文件, 通过extern, 否则就是multiple definition&lt;br /&gt;
这是c语言最为迷糊的地方.简单说来类似union, 具体我也不清楚.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;所有名字引用同一个object&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不同文件中不同类型的sizeof和当前文件类型一直.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;c-standard-library-1&#34;&gt;C standard library&lt;/h1&gt;

&lt;p&gt;NULL?&lt;/p&gt;

&lt;h2 id=&#34;string-handling&#34;&gt;String handling&lt;/h2&gt;

&lt;p&gt;kernel/lib/string.c&lt;br /&gt;
* Copying functions&lt;br /&gt;
memcpy: dest&lt;br /&gt;
memmove: dest&lt;br /&gt;
strcpy: dest, 拷贝\0&lt;br /&gt;
strncpy: dest, if src_len &amp;gt;= n; 0 NULL, if src _len &amp;lt; n; (n - len) NULL;&lt;br /&gt;
strlcpy: src_len, mini(n -1, src_len -1) + \0, src_len 用你返回啊!&lt;br /&gt;
* Concatenation functions&lt;br /&gt;
strcat: dest, overwrite dest \0 with src util src \0&lt;br /&gt;
strncat: dest, 末尾一定有\0&lt;br /&gt;
* Comparison functions&lt;br /&gt;
memcmp: 差值,&lt;br /&gt;
strcmp: -1, 0, 1, 如果整个s1都比完了NULL or &amp;ndash;n ==0 for strncmp, return 0&lt;br /&gt;
* Search functions&lt;br /&gt;
memchr, NULL or p;&lt;br /&gt;
strchr,ditto, 到\0返回NUll&lt;br /&gt;
strrchr,ditto, last occurence.&lt;br /&gt;
strspn: s1开始有多少在s2中.&lt;br /&gt;
strcspn: s1开始有多少不在s2中.&lt;br /&gt;
strpbrk: s2中第一次出现的位置&lt;br /&gt;
strstr: 找子串, 用memcmp&lt;/p&gt;

&lt;h1 id=&#34;asm-in-c-code&#34;&gt;ASM in c code&lt;/h1&gt;

&lt;p&gt;c语言嵌入汇编这不是c语言的特性是编译器的feature.&lt;br /&gt;
&lt;a href=&#34;https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html#Using-Assembly-Language-with-C&#34;&gt;How to Use Inline Assembly Language in C Code&lt;/a&gt;&lt;br /&gt;
#MIPS&lt;br /&gt;
bdi 4, 8 delay solt&lt;br /&gt;
mips instruction size is fixed, 32bit, 4byte.&lt;br /&gt;
instruction address:  instrction in hex formate    instruction in string formate, 260&lt;br /&gt;
8002c28c:   8c440104    lw  a0,260(v0)&lt;br /&gt;
##ASM codes Fixme&lt;br /&gt;
move &amp;lt;-&lt;br /&gt;
j long jump&lt;br /&gt;
b short jump&lt;br /&gt;
a0, a1&amp;hellip;99% is parameters.&lt;br /&gt;
##lwr &amp;amp; lwl&lt;br /&gt;
load a word&lt;br /&gt;
different with endianess&lt;br /&gt;
register 63&amp;hellip;..32&amp;hellip;&amp;hellip;0&lt;br /&gt;
big endian: lwl high bits in b + 0&lt;br /&gt;
little endian: lwl high in b + off&lt;br /&gt;
向中心&lt;/p&gt;

&lt;h1 id=&#34;x86&#34;&gt;x86&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://heather.cs.ucdavis.edu/~matloff/50/PLN/lock.pdf&#34;&gt;Intel’s ‘cmpxchg’ instruction&lt;/a&gt;&lt;br /&gt;
eax: e stand for 32&lt;br /&gt;
rax: r stand for 64&lt;br /&gt;
&lt;a href=&#34;http://x86.renejeschke.de/html/file_module_x86_id_159.html&#34;&gt;lock prefix in x86&lt;/a&gt;&lt;br /&gt;
the lock prefix make instruction atomic!&lt;/p&gt;

&lt;h2 id=&#34;registers-purpose&#34;&gt;registers&amp;rsquo; purpose&lt;/h2&gt;

&lt;h2 id=&#34;register&#34;&gt;Register&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;gs&lt;br /&gt;
The linux kernel uses GS to access cpu-specific memory.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;gdtr&lt;br /&gt;
GDT&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;tr&lt;br /&gt;
TSS addressing&lt;br /&gt;
#Wildcards&lt;br /&gt;
&lt;a href=&#34;http://whatis.techtarget.com/definition/wildcard-character&#34;&gt;A wildcard character is a type of meta character&lt;/a&gt;&lt;br /&gt;
##Type&lt;/p&gt;

&lt;h3 id=&#34;standard-wildcards-globbing-patterns&#34;&gt;Standard Wildcards (globbing patterns)&lt;/h3&gt;

&lt;p&gt;File and directory patterns&lt;br /&gt;
?: must stand for a character&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Regular expression&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;SQL&lt;br /&gt;
#Shell&lt;/p&gt;

&lt;h2 id=&#34;test&#34;&gt;test&lt;/h2&gt;

&lt;h3 id=&#34;n-is-not-equivalent-to-z&#34;&gt;-n is not equivalent to ! -z&lt;/h3&gt;

&lt;p&gt;Be caution! just juse -z and !-z&lt;/p&gt;

&lt;h2 id=&#34;ls&#34;&gt;ls&lt;/h2&gt;

&lt;p&gt;-l: show hardlinks of file/dir in 2nd column&lt;br /&gt;
drwsrwsr-T: T stand for sticky bit no other execution bit&lt;br /&gt;
##eval&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;create variable name&lt;br /&gt;
&lt;strong&gt;var=&amp;ldquo;name&amp;rdquo;&lt;br /&gt;
eval &amp;ldquo;export &amp;ndash; \&amp;ldquo;$&lt;/strong&gt;var=firo\&amp;ldquo;&amp;rdquo;&lt;br /&gt;
set | grep firo&lt;br /&gt;
__var=&amp;lsquo;name&amp;rsquo;&lt;br /&gt;
bbb=&amp;lsquo;firo&amp;rsquo;&lt;br /&gt;
##expr&lt;br /&gt;
expr &amp;ldquo;$name&amp;rdquo; : &amp;lsquo;(.*).conf&amp;rsquo;&lt;br /&gt;
##find&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;find symbols in object&lt;br /&gt;
find . -name &amp;lsquo;a.out&amp;rsquo; -exec nm -D {} \; -print&lt;br /&gt;
find . -name &amp;lsquo;*.o&amp;rsquo; -print0 | xargs -0 nm -A | egrep &amp;lsquo; (i|y)$&amp;rsquo;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;rm&lt;br /&gt;
find . -name ‘your_pattern*’ -exec rm -f {} \;&lt;br /&gt;
find . -name ‘your_pattern*’ -delete&lt;/p&gt;

&lt;h2 id=&#34;grep&#34;&gt;grep&lt;/h2&gt;

&lt;p&gt;-c: count of match&lt;br /&gt;
##pipe&lt;br /&gt;
find . -type d | while read d; do cnt=$(ls $d | grep tgz | wc -l); echo &amp;ldquo;$cnt $d&amp;rdquo;; done | sort -n &amp;gt;stat&lt;br /&gt;
#AWK&lt;br /&gt;
netstat -n | awk &amp;lsquo;/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}&amp;rsquo;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>The computational process</title>
      <link>http://firoyang.org/cs/process/</link>
      <pubDate>Fri, 27 Feb 2015 15:46:12 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/process/</guid>
      <description>

&lt;h1 id=&#34;fork-a-new-process&#34;&gt;Fork a new process&lt;/h1&gt;

&lt;p&gt;What does the child process need from parent?&lt;br /&gt;
    sched_fork: setup schduling stuff&lt;br /&gt;
    memory: copy parent&amp;rsquo;s mm&lt;br /&gt;
How to share memory stuff with parent process?&lt;br /&gt;
    Linux use COW technique to do this.&lt;br /&gt;
    How does COW work?&lt;br /&gt;
    Why does Linux just share page?&lt;br /&gt;
How to diverge the child execution flow from parent?&lt;br /&gt;
    what is the first instruction executed by the child process?&lt;/p&gt;

&lt;h1 id=&#34;insepct-process-status&#34;&gt;Insepct process status&lt;/h1&gt;

&lt;p&gt;do_task_stat&lt;br /&gt;
Kernel mapping: tgid_base_stuff show_map_vma&lt;/p&gt;

&lt;h1 id=&#34;protection&#34;&gt;Protection&lt;/h1&gt;

&lt;p&gt;3A: Chaper 5&lt;/p&gt;

&lt;h1 id=&#34;faq&#34;&gt;FAQ&lt;/h1&gt;

&lt;p&gt;Check glibc sysdeps/unix/sysv/linux/x86_64/clone.S for creating a new thread.&lt;/p&gt;

&lt;h2 id=&#34;idle-kernel-stack&#34;&gt;idle kernel stack&lt;/h2&gt;

&lt;p&gt;master idle进程的kernel stack在init/init_task.c:init_thread_union&lt;br /&gt;
其他进程的kernel stack是fork产生.&lt;br /&gt;
this_cpu_write(kernel_stack,(unsigned long)task_stack_page(next_p) +THREAD_SIZE);&lt;br /&gt;
this_cpu_write(cpu_current_top_of_stack,(unsigned long)task_stack_page(next_p) +THREAD_SIZE);&lt;br /&gt;
主处理器上的idle由原始进程(pid=0)演变而来。从处理器上的idle由init进程fork得到，但是它们的pid都为0 init_idle.&lt;br /&gt;
Deamonize&lt;/p&gt;

&lt;h1 id=&#34;zombie-process&#34;&gt;Zombie process&lt;/h1&gt;

&lt;h2 id=&#34;defunct&#34;&gt;&lt;defunct&gt;&lt;/h2&gt;

&lt;p&gt;forked child not reaped by parent will hooked in process list.&lt;br /&gt;
if parent was killed and exit &lt;defunct&gt; will repaped.&lt;br /&gt;
&lt;defunct&gt;表明父活着, 但不收尸.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
