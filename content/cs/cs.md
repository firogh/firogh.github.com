---
tags: cs
title: Computer science a kernel programmer's perspective
date: 2015-02-27 15:46:14
category: cs
---
# Reference
[Code The Hidden Language of Computer Hardware and Software](http://book.douban.com/subject/1494026/)
[Google groups](https://groups.google.com/forum/#!topic/comp.arch/XsW0QfVYgg4)
For programming reference programming.md
Graphviz + CodeViz
[Vijay Kumar B's Embedded Programming with the GNU Toolchain](http://www.bravegnu.org/gnu-eprog/)
# Contents of computer science
What is the address.
Is the address generated by compiler physical or virtual?
What's the difference between eprom falsh ssd?
What is UART USB serial/prallel port
How to find UART prot to print log?
programming
compile
computer
Interface
# Interface
ABI: calling convetion
# System boot

# terminal
NS16550_putc

# Layers of computer
Applications
Operating system
ISA
Micro-architecture
Logical gate
Digital circuits
Analog circuits
Electronic component
Physics
# 计算机科学启示录
计算机是人与世界的一种关系.
人<-> Computer <-> 世界.
人意志->思维逻辑->电信号->物理世界
人类的思维语言->人->计算机语言->编译器->机器语言->Microarchitecture(datapath, control unit)logic 电路->模拟电路电信号->物理世界.
思维->电信号, 外部世界的改变(for good life)
人类物理世界->思维世界-> 物理世界
人类思维与语言, 计算机语言, 数字电路, 模拟电路, 世界.
每一个sensation都有自己的内部规则, "语言",pattern, paradigm, theory. 这是他们不同的地方.
作为程序员要理解认知这每一种paradigm, 似乎需要寻找到一种通用的语言, 来更好的理解他们. 有必要吗?
当然逻辑思维好的人, 容易看到问题的本质. 数学和逻辑, 严密且语法简单适用其他paradigm的表述.
语言总归是用来表述的媒介, 重要的还是内容. 统一的语言更容易看到联系, 相似的逻辑.
也就是说, 有意识的用数学和逻辑表示pattern.
Two point:
不同sensation level之间的抽象类比, 方向人->物理世界.
不同sensation level不同or相同的抽象. 具体的形而下->形而上数学与逻辑
# OS
## Process management
进程的定义和PCB，进程和线程的区别，进程的三个基本状态及它们之间的转换关系，进程的同步，竞争和死锁，进程间通信
###Representation 
* Program memory
Stack(User/Kernel)
Heap
Data segment(data/bss)
Code segment
* PCB
Resource
Processor Context
Process state
###daemonize
http://fixunix.com/unix/84640-daemon-controlling-terminal.html
## Memory managerment
分页式管理，分段式管理，虚拟内存的概念，页面置换算法，内存分配算法
### Paging
paging is one of the memory management schemes by which 
a computer stores and retrieves data from the secondary storage for use in main memory.
* Page fault
###Page replacement algorithm
OPT
FIFO
Second-chance
LRU
### x86 memory segmentation
linux 基本不用
[Linux中的段](http://oss.org.cn/kernel-book/ch02/2.3.7.htm)
* GDT
* TSS
[Use of TSS in Linux](https://en.wikipedia.org/wiki/Task_state_segment#Use_of_TSS_in_Linux)
* Linear address
### [Virtual memory](https://en.wikipedia.org/wiki/Virtual_memory#Paged_virtual_memory)
It maps memory addresses used by a program, called virtual addresses, into physical addresses in computer memory.
* Logic/Virtual address
* Page table
### Memory allocation
* Buddy memory allocation. 
* Slab allocation/Memory Pool
## Device management
中断的概念，中断处理，I/O控制方式，缓冲区管理，设备驱动，磁盘调度和高速缓存
### Low I/O type
* Programmed I/O/Polling
* DMA
* Interrupt I/O
* Channel I/O
### I/O scheduling
Elevator algorithm
###Asynchronous I/O NEED CLEAN
* synchronous I/O multiplexing and I/O event notification facility
select/poll/epoll
For the ease of use, the select loop is implemented as an *event loop* with callbacks.
libevent and libev is a well-designed *event loop*.Check shadowsocks for using of libev.
##File formate
ELF -- ELF executable and linkable format.
Used for Relocatable file(object file, kernel moudle), Executable file, Dynamic library, Core dump. 
###Relocatable file(object file, kernel module)
ELF header.
Sections.
Section header table.
### Executeable file, dynamic library
ELF header.
Program header table.
Segments.
Section header table.
.symtab, Symbol table store index of string
.strtab, String table is a array of all strings split by \0
.hash, utiliy for quire symbols
.shstrtab, Section header string table store section name for ELF,like .text, .data...
## File system 
文件的概念，文件的管理，文件系统
## System calls
系统调用的概念，系统调用的处理，系统调用类型
#I/O
CPU and main memory is the brain of a computer.
Any transfer of information to or from the CPU/memory combo, for example by reading data from a disk drive, is considered I/O. 
##CPU-device I/O
### Memory-mapped I/O
ioremap: physical address->logical address, simlar to vmalloc except we need not page.
### Ported-mapped I/O
##Non CPU-device I/O
### I/O channels
## 同步与异步IO
今天我们要辨析一下同步和异步IO. 我们先解释最基础的概念, 之后用生活化的例子
完成认知.
首先是blocking 和 non-blocking这两个概念. 这两个概念实质上是和IO没有关系.
他们是在说, 比如读数据, 如果没有数据我该怎么办. 也就是说, 他是在IO不存的时候,
在语义上才是有效, 如果你要读的数据始终存在, 那么你还会考虑阻塞与不阻塞的问题吗?
那你应该考虑什么? 同步还是异步IO, 倒地什么是同步或者异步呢?
英文synchronous, syn 和chronous构成, syn是在一起的意思而chronous是时间的意思.
也就是说在一个时间点上在一起, 那么是谁和谁在意一起呢?其中一个是IO可以肯定, 另外一个
就是执行IO的发起者, 通常也就是进程. 简单说来这个IO是由进程执行的.
那么异步IO呢, asynchronous是a + synchronous. a表否定, 我们知道在IO进行的过程中我们的
进程是始终存在的, 也就是说IO 和进程共享着相同的时间进度, 但是却不在一起.也就是说,
IO不是由我们的进程完成而是别的进程完成, 是谁呢,是内核线程.
那么我们就知道只有linux上的aio是符合异步IO的标准, 而多路复用, 如epoll返回是我们和IO是在
一起, 我们要调用read之类的完成他.
下面用一个生活化的例子, 说明下linux下的IO.
比如你要买<百年孤独> 还要买件衬衫, 你会怎么买
你要先去书店, 如果店家没有货, 如果一个小时后货补齐了你可以等,
长点你就不愿意等了. 也就是阻塞和不阻塞.之后你要去衣服点.也是同样.
假如都没货, 你有等不下去, 怎么办? 你又不能一会儿去这家问下书怎么样? 一会儿去衣服店询问.
这太累人了. 最好的方式, 你告诉店家我要什么, 到货了给我打个电话, 我在过来.
这就是io多路复用. 可是还有更高明的方法, 没错就是京东了, 我网上下订单, 第二天直接送到家了.
京东, 为什么成功? 你知道了吧.用户省心啊.对应异步io
##Interface
[Methods for designing a CPU's I/O interface generally fall into one of the following categories:](http://www.cs.uwm.edu/classes/cs458/Lecture/HTML/ch11s02.html)
Completely separate memory and I/O. buses DMA?
Common buses, separate control lines. Port-I/O
Common buses and control line. Memroy-maped I/O
###Higher level implemention
device or partion of device/memory -> file 
io -> stream
####[stream](https://en.wikipedia.org/wiki/Stream_(computing))
* [Standard streams](https://en.wikipedia.org/wiki/Standard_streams)
interface is stdio library or the kernel version.
* codata
#Buffer
a data buffer (or just buffer) is a region of a physical memory storage 
used to temporarily store data while it is being moved from one place to another.
* Page cache, Buffer head
* Pipe
# Data struct aligment
[The Lost Art of C Structure Packing](http://www.catb.org/esr/structure-packing/)
[Typical alignment of C structs on x86](http://en.wikipedia.org/wiki/Data_structure_alignment#Typical_alignment_of_C_structs_on_x86)
## 为什么需要结构体对齐?
struct foo {
char c;
int i;};
如果是32位, cpu 一次取4byte a word 数据.
如果我们把i的前3byte和c存到一起, 剩下1byte of i自己单独存.
那么我们访问i这个数据就要读两个4byte a word. 对cpu来说性能损耗.
如果我们把i单独放到4byte 对齐的地址, 那么我们只需要一次cpu读取.fast!
## 产生非对齐访问的场景
 1. Casting variables to types of different lengths, 比如char * 到int *
 2. Pointer arithmetic followed by access to at least 2 bytes of data , 不太理解.
## 我们做什么?
* 什么也不干, 按默认对齐来Natural alignment
* 为了不影响性能, 同时减少内存使用, 编程时最好显示reorder.
* get/put_unaligned  to avoid analigned access.
* 通过attribute aligned指定对齐要求.
* 数据要在不同体系, 32/64之间使用, 比如网络,写到disk, 我们必须要attribute packed
也就是说不对齐, 不同平台对齐可能不同, 我们不能让数据corruption.
## 如果数据不对齐有什么, cpu怎么办?
[必读UNALIGNED MEMORY ACCESSES](https://www.kernel.org/doc/Documentation/unaligned-memory-access.txt)
1. 如果用了packed, 编译器会生成extra代码阻止非对齐访问, performance loss.
2. cpu呢? 可能正确处理raise a exception to fix it with performance loss.
## Calculate the sizeof of aligned c struct
Data alignment means putting the data at a memory address equal to some multiple of the word size, 
which increases the system's performance due to the way the CPU handles memory.
1. find the widest scalar member and attribute( aligned(x)) to determin alignment.
找到结构体内scalar和attribute最大的对齐要求.
2. fill the member to alignement without wrap
把结构的成员一次填满对齐宽度, 不够的填到下个对齐宽度, 空出来留着padding
3. pading to alignment
填上所有空.
## 关于kernel中put/get_unaligned实现
access_ok, do nothing in essence
byteshift, 移位每次访问u8, 
packed_struct: 交给gcc
memove, byte-wise copy
## Faq
* How does gcc attribute((aligned)) work?
struct S1 { short f; short f1; short f2;char a; char c;} __attribute__ ((aligned ));
sizeof S1 = 16 in 64-bit
* In what situation can unaligned accesss make a kernel panic?
may be arch/mips/kernel/unaligned.c
# Scheduling
## Process scheduler
## Network scheduler
## I/O scheduling
# Endianess
[Endianness: Big and Little Endian Byte Order](http://www.yolinux.com/TUTORIALS/Endian-Byte-Order.html)
应该说bit endianess 实际存储只有MSB ... LSB这一种二进制表达形式! 在上面的文章的representtion, 辅证这一点.
这篇文章[再谈C语言位域](http://tonybai.com/2013/05/21/talk-about-bitfield-in-c-again/), 
之所以输出逆序, 是因为错误里理解了, bit 序. bit 序是cpu 读取的方式, 不是存储的方式!
* [bit endianness](https://en.wikipedia.org/wiki/Bit_numbering)
这样就可以更好的理解iphdr:
\#if defined(__LITTLE_ENDIAN_BITFIELD)
    __u8    ihl:4,
        version:4;
\#elif defined (__BIG_ENDIAN_BITFIELD)
    __u8    version:4,
        ihl:4;
\#else
\#error  "Please fix <asm/byteorder.h>"
\#endif
ipv4 header的拓扑
version ihl
0100 0101
因为le的cpu是 lsb first, 也就是从最左面的1开始读, 所以第一个是ihl
而be的cpu是 msb first, 从最右开始所以version开头.
而使用unsigned char ver_ihl
(ver_ihl & 0xf0)>> 4 = version
ver_ihl & 0x0f = ihl
是无关cpu读取顺序的.
### Endianess in build
cpu -> toolchain
ar71xx big
ralink little
# Introdution
我们先看ISA. 我们都知道语言有个范式, 汇编语言的范式是什么呢?
http://www.zhihu.com/question/21843639
貌似正则是type 3, c是type2, 范式角度我现在不好理解, 缺乏语言学的知识.
换个角度理解, [低级语言与硬件结构的关系](http://202.116.24.124/computer/content/theory/web/Chap04/4.1.3.HTM)
