
 <!DOCTYPE HTML>
<html lang="en-US">
<head>
  <meta charset="UTF-8">
  
    <title>btrfs | Hot sexy girls</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="Firo Yang">
    
    <meta name="description" content="int __btrfs_cow_block(struct btrfs_trans_handle trans, struct btrfs_root root,                 struct extent_buffer buf,                 struct extent">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">

</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="Hot sexy girls" title="Hot sexy girls"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Hot sexy girls">Hot sexy girls</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:firoyang.org">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/02/27/kernel/btrfs/" title="btrfs" itemprop="url">btrfs</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://firoyang.org" title="Firo Yang">Firo Yang</a>
    </p>
  <p class="article-time">
    <time datetime="2015-02-27T07:46:12.000Z" itemprop="datePublished">Feb 27 2015</time>
    Updated:<time datetime="2015-02-28T08:40:54.000Z" itemprop="dateModified">Feb 28 2015</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		
		</div>
		
		<p>int __btrfs_cow_block(struct btrfs_trans_handle <em>trans, struct btrfs_root </em>root,<br>                 struct extent_buffer <em>buf,<br>                 struct extent_buffer </em>parent, int parent_slot,<br>                 struct extent_buffer <em>*cow_ret,<br>                 u64 search_start, u64 empty_size)<br>{<br>    struct extent_buffer </em>cow;<br>    struct btrfs_disk_key disk_key;<br>    int level;</p>
<pre><code>WARN_ON(root<span class="variable">-&gt;ref_cows</span> &amp;&amp; trans<span class="variable">-&gt;transid</span> !=
    root<span class="variable">-&gt;fs_info</span><span class="variable">-&gt;running_transaction</span><span class="variable">-&gt;transid</span>);
WARN_ON(root<span class="variable">-&gt;ref_cows</span> &amp;&amp; trans<span class="variable">-&gt;transid</span> != root<span class="variable">-&gt;last_trans</span>);

level = btrfs_header_level(buf);
<span class="comment">//就像我说的这里level是0.</span>

<span class="comment">//为什么要获得这个叶子结点的第一个item的key呢？第一个是由0来索引的，即偏移量为0.</span>
<span class="keyword">if</span> (level == <span class="number">0</span>)
    btrfs_item_key(buf, &amp;disk_key, <span class="number">0</span>);
<span class="keyword">else</span>
    btrfs_node_key(buf, &amp;disk_key, <span class="number">0</span>);

<span class="comment">//从函数的名字上分析我们可以知道，它是用来获得一个空闲的block区在硬盘上。</span>
<span class="comment">//而这里的search_start is a hint。他是由我们即将提交的这个leaf在硬盘的开始位置，按G对齐后的值。</span>
<span class="comment">//empty_size 亦为0. </span>
cow = btrfs_alloc_free_block(trans, root, buf<span class="variable">-&gt;len</span>,
                 root<span class="variable">-&gt;root_key</span>.objectid, &amp;disk_key,
                 level, search_start, empty_size);
<span class="keyword">if</span> (IS_ERR(cow))
    <span class="keyword">return</span> PTR_ERR(cow);

copy_extent_buffer(cow, buf, <span class="number">0</span>, <span class="number">0</span>, cow<span class="variable">-&gt;len</span>);
btrfs_set_header_bytenr(cow, cow<span class="variable">-&gt;start</span>);
btrfs_set_header_generation(cow, trans<span class="variable">-&gt;transid</span>);
btrfs_set_header_backref_rev(cow, BTRFS_MIXED_BACKREF_REV);
btrfs_clear_header_flag(cow, BTRFS_HEADER_FLAG_WRITTEN |
                 BTRFS_HEADER_FLAG_RELOC);
<span class="keyword">if</span> (root<span class="variable">-&gt;root_key</span>.objectid == BTRFS_TREE_RELOC_OBJECTID)
    btrfs_set_header_flag(cow, BTRFS_HEADER_FLAG_RELOC);
<span class="keyword">else</span>
    btrfs_set_header_owner(cow, root<span class="variable">-&gt;root_key</span>.objectid);

write_extent_buffer(cow, root<span class="variable">-&gt;fs_info</span><span class="variable">-&gt;fsid</span>,
            (unsigned long)btrfs_header_fsid(cow),
            BTRFS_FSID_SIZE);

WARN_ON(btrfs_header_generation(buf) &gt; trans<span class="variable">-&gt;transid</span>);

update_ref_for_cow(trans, root, buf, cow);

<span class="keyword">if</span> (buf == root<span class="variable">-&gt;node</span>) {
    root<span class="variable">-&gt;node</span> = cow;
    extent_buffer_get(cow);

    btrfs_free_extent(trans, root, buf<span class="variable">-&gt;start</span>, buf<span class="variable">-&gt;len</span>,
              <span class="number">0</span>, root<span class="variable">-&gt;root_key</span>.objectid, level, <span class="number">0</span>);
    free_extent_buffer(buf);
    add_root_to_dirty_list(root);
} <span class="keyword">else</span> {
    btrfs_set_node_blockptr(<span class="keyword">parent</span>, parent_slot,
                cow<span class="variable">-&gt;start</span>);
    WARN_ON(trans<span class="variable">-&gt;transid</span> == <span class="number">0</span>);
    btrfs_set_node_ptr_generation(<span class="keyword">parent</span>, parent_slot,
                      trans<span class="variable">-&gt;transid</span>);
    btrfs_mark_buffer_dirty(<span class="keyword">parent</span>);
    WARN_ON(btrfs_header_generation(<span class="keyword">parent</span>) != trans<span class="variable">-&gt;transid</span>);

    btrfs_free_extent(trans, root, buf<span class="variable">-&gt;start</span>, buf<span class="variable">-&gt;len</span>,
              <span class="number">0</span>, root<span class="variable">-&gt;root_key</span>.objectid, level, <span class="number">1</span>);
}
free_extent_buffer(buf);
btrfs_mark_buffer_dirty(cow);
*cow_ret = cow;
<span class="keyword">return</span> <span class="number">0</span>;
</code></pre><p>}</p>
<p>struct extent_buffer <em>btrfs_alloc_free_block(struct btrfs_trans_handle </em>trans,<br>                    struct btrfs_root <em>root,<br>                    u32 blocksize, u64 root_objectid,<br>                    struct btrfs_disk_key </em>key, int level,<br>                    u64 hint, u64 empty_size)<br>{<br>    struct btrfs_key ins;<br>    int ret;<br>    struct extent_buffer *buf;</p>
<pre><code><span class="comment">//我们也能看到这里的参数&amp;ins，是用来做返回值的，且是btrfs_key.</span>
<span class="comment">//至于返回的是什么，我们跳进去看一看。我猜这就是这个新的block插入位置的key值。</span>
ret = alloc_tree_block(trans, root, blocksize, root_objectid,trans-&gt;transid, <span class="number">0</span>, key, level,empty_size, hint, (<span class="keyword">u64</span>)-<span class="number">1</span>, &amp;ins);
<span class="keyword">if</span> (ret) {
    BUG_ON(ret &gt; <span class="number">0</span>);
    <span class="keyword">return</span> ERR_PTR(ret);
}

buf = btrfs_find_create_tree_block(root, ins.objectid, blocksize);
<span class="keyword">if</span> (!buf) {
    btrfs_free_extent(trans, root, ins.objectid, ins.offset, <span class="number">0</span>, root-&gt;root_key.objectid, level, <span class="number">0</span>);
    BUG_ON(<span class="number">1</span>);
    <span class="keyword">return</span> ERR_PTR(-ENOMEM);
}
btrfs_set_buffer_uptodate(buf);
trans-&gt;blocks_used++;

<span class="keyword">return</span> buf;
</code></pre><p>}</p>
<p>static int alloc_tree_block(struct btrfs_trans_handle <em>trans,struct btrfs_root </em>root, u64 num_bytes, u64 root_objectid, u64 generation,<br>        u64 flags, struct btrfs_disk_key <em>key,int level, u64 empty_size, u64 hint_byte,u64 search_end, struct btrfs_key </em>ins)<br>{<br>    //蛋疼的参数呀，12个之多~~<br>    int ret;<br>    //真正蛋疼的地方。这个reserve 什么意思呢？是保留，预留的意思，为什么而留呢？<br>    //推测1disk预留一定的空间，这个比较不靠谱。推测2为这个block所留的，也就是，多分配出来的为这个block。<br>    //推测3这个reserve就是表示我们要预先保留numbytes 大小的extent。<br>    //0表示不是data block group。大致意思就是标识这个extent所属的区域不是data block group。I am not sure.<br>    //这些组是存在于RAM中。<br>    ret = btrfs_reserve_extent(trans, root, num_bytes, empty_size,hint_byte, search_end, ins, 0);<br>    BUG_ON(ret);</p>
<pre><code><span class="keyword">if</span> (root_objectid == BTRFS_EXTENT_TREE_OBJECTID) {
    <span class="keyword">struct</span> pending_extent_op *extent_op;

    extent_op = kmalloc(<span class="keyword">sizeof</span>(*extent_op), GFP_NOFS);
    BUG_ON(!extent_op);

    extent_op-&gt;<span class="keyword">type</span> = PENDING_EXTENT_INSERT;
    extent_op-&gt;bytenr = ins-&gt;objectid;
    extent_op-&gt;num_bytes = ins-&gt;offset;
    extent_op-&gt;level = level;
    extent_op-&gt;flags = flags;
    memcpy(&amp;extent_op-&gt;key, key, <span class="keyword">sizeof</span>(*key));

    set_extent_bits(&amp;root-&gt;fs_info-&gt;extent_ins, ins-&gt;objectid,
            ins-&gt;objectid + ins-&gt;offset - <span class="number">1</span>,
            EXTENT_LOCKED, GFP_NOFS);
    set_state_private(&amp;root-&gt;fs_info-&gt;extent_ins,
              ins-&gt;objectid, (unsigned long)extent_op);
} <span class="keyword">else</span> {
    ret = alloc_reserved_tree_block(trans, root, root_objectid,
                    generation, flags,
                    key, level, ins);
    finish_current_insert(trans, root-&gt;fs_info-&gt;extent_root);
    del_pending_extents(trans, root-&gt;fs_info-&gt;extent_root);
}
<span class="keyword">return</span> ret;
</code></pre><p>}</p>
<p>static int btrfs_reserve_extent(struct btrfs_trans_handle <em>trans,struct btrfs_root </em>root,u64 num_bytes, u64 empty_size,<br>                u64 hint_byte, u64 search_end,struct btrfs_key <em>ins, int data)<br>{<br>    int ret;<br>    u64 search_start = 0;<br>    u64 alloc_profile;<br>    struct btrfs_fs_info </em>info = root-&gt;fs_info;</p>
<pre><code><span class="comment">//这个只有在btrfs convert时候才会被初始化，这里我们掠过~~</span>
<span class="keyword">if</span> (info<span class="subst">-&gt;</span>extent_ops) {
    struct btrfs_extent_ops <span class="subst">*</span>ops <span class="subst">=</span> info<span class="subst">-&gt;</span>extent_ops;
    ret <span class="subst">=</span> ops<span class="subst">-&gt;</span>alloc_extent(root, num_bytes, hint_byte, ins);
    BUG_ON(ret);
    goto found;
}

<span class="comment">//data_alloc_profile = (u64)-1; 这个就像mask</span>
<span class="comment">//avail_data_alloc_bits 就是raid1 ，raid10 ，raid0 ,dup这些的bit位，是由我们传入的参数确定。也是u64类型。这个才是威力所在。</span>
<span class="keyword">if</span> (<span class="built_in">data</span>) { <span class="comment">//上面传下来这里是0.</span>
    alloc_profile <span class="subst">=</span> info<span class="subst">-&gt;</span>avail_data_alloc_bits <span class="subst">&amp;</span>
                info<span class="subst">-&gt;</span>data_alloc_profile;
    <span class="comment">//所以这个data里面包含的就是两种类别的组第一种是raid1,dup这些用于管理的组类；</span>
    <span class="comment">//第二种就是数据实际用途的组类比如，data，metadata，system</span>
    <span class="built_in">data</span> <span class="subst">=</span> BTRFS_BLOCK_GROUP_DATA <span class="subst">|</span> alloc_profile;
} <span class="keyword">else</span> <span class="keyword">if</span> ((info<span class="subst">-&gt;</span>system_allocs <span class="subst">&gt;</span> <span class="number">0</span> <span class="subst">||</span> root <span class="subst">==</span> info<span class="subst">-&gt;</span>chunk_root) <span class="subst">&amp;&amp;</span>info<span class="subst">-&gt;</span>system_allocs <span class="subst">&gt;=</span> <span class="number">0</span>) {
    <span class="comment">//system_allocs 这个在make_root_dir 里面设置为1在创建system block group，创建完之后就设置为0</span>
    <span class="comment">//那么这个system allocs到底是什么意思。它好象是用来标识是否在创建system block group.</span>
    <span class="comment">//所以这个ifcase的解释就是：（当然这是主观的推测）</span>
    <span class="comment">//1 如果system block group正在创建 则system_allocs为1,我想创建的步骤中肯定有一步调用这个函数了，呃。。我没找到。</span>
    <span class="comment">//2 如果system block group创建完成 system_allocs 为0,则不会满足。也就是说不用创建system block group.</span>
    <span class="comment">//3 如果这次创建的是chunk root的system block group就通过。</span>
    <span class="comment">//同样avail_system_alloc_bits 也是raid1 raid0 raid10 dup 等</span>
    <span class="comment">//system_alloc_profile 依然是u64-1</span>
    alloc_profile <span class="subst">=</span> info<span class="subst">-&gt;</span>avail_system_alloc_bits <span class="subst">&amp;</span> info<span class="subst">-&gt;</span>system_alloc_profile;
    <span class="built_in">data</span> <span class="subst">=</span> BTRFS_BLOCK_GROUP_SYSTEM <span class="subst">|</span> alloc_profile;
} <span class="keyword">else</span> {<span class="comment">//这次调用就是这里了。</span>
    <span class="comment">//显然如果前两个 system 和 data 都失败了，这就应该是 metadata。</span>
    alloc_profile <span class="subst">=</span> info<span class="subst">-&gt;</span>avail_metadata_alloc_bits <span class="subst">&amp;</span> <span class="comment">//同上</span>
                info<span class="subst">-&gt;</span>metadata_alloc_profile; <span class="comment">//(u64)-1</span>
    <span class="built_in">data</span> <span class="subst">=</span> BTRFS_BLOCK_GROUP_METADATA <span class="subst">|</span> alloc_profile;
}
<span class="comment">//__setup_root()设置为0</span>
<span class="comment">//btrfs_read_fs_root_no_cache设置为1</span>
<span class="comment">//这里的值为0,我是用if和printk判断出来的。</span>
<span class="keyword">if</span> (root<span class="subst">-&gt;</span>ref_cows) {
    <span class="keyword">if</span> (<span class="subst">!</span>(<span class="built_in">data</span> <span class="subst">&amp;</span> BTRFS_BLOCK_GROUP_METADATA)) {
        ret <span class="subst">=</span> do_chunk_alloc(trans, root<span class="subst">-&gt;</span>fs_info<span class="subst">-&gt;</span>extent_root,
                     num_bytes,
                     BTRFS_BLOCK_GROUP_METADATA);
        BUG_ON(ret);
    }
    ret <span class="subst">=</span> do_chunk_alloc(trans, root<span class="subst">-&gt;</span>fs_info<span class="subst">-&gt;</span>extent_root,
                 num_bytes <span class="subst">+</span> <span class="number">2</span> <span class="subst">*</span> <span class="number">1024</span> <span class="subst">*</span> <span class="number">1024</span>, <span class="built_in">data</span>);
    BUG_ON(ret);
}

WARN_ON(num_bytes <span class="subst">&lt;</span> root<span class="subst">-&gt;</span>sectorsize);
<span class="comment">//很显然这是reserve的核心.</span>
<span class="comment">//这个函数的用途就是找到一个空闲的范围extent.</span>
ret <span class="subst">=</span> find_free_extent(trans, root, num_bytes, empty_size,
               search_start, search_end, hint_byte, ins,
               trans<span class="subst">-&gt;</span>alloc_exclude_start,
               trans<span class="subst">-&gt;</span>alloc_exclude_nr, <span class="built_in">data</span>);
BUG_ON(ret);
</code></pre><p>found:<br>    clear_extent_dirty(&amp;root-&gt;fs_info-&gt;free_space_cache,<br>               ins-&gt;objectid, ins-&gt;objectid + ins-&gt;offset - 1,<br>               GFP_NOFS);<br>    return ret;<br>}</p>
<p>/*</p>
<ul>
<li>walks the btree of allocated extents and find a hole of a given size.</li>
<li>The key ins is changed to record the hole:</li>
<li>ins-&gt;objectid == block start</li>
<li>ins-&gt;flags = BTRFS_EXTENT_ITEM_KEY</li>
<li>ins-&gt;offset == number of blocks</li>
<li><p>Any available blocks before search_start are skipped.<br><em>/<br>static int noinline find_free_extent(struct btrfs_trans_handle </em>trans, struct btrfs_root *orig_root, u64 num_bytes, u64 empty_size,</p>
<pre><code>      <span class="keyword">u64</span> search_start, <span class="keyword">u64</span> search_end,<span class="keyword">u64</span> hint_byte, <span class="keyword">struct</span> btrfs_key *ins,<span class="keyword">u64</span> exclude_start, <span class="keyword">u64</span> exclude_nr,<span class="keyword">int</span> data)
</code></pre><p>{<br> //大致意思基本可以理解，日后必定细看。<br> int ret;<br> u64 orig_search_start = search_start;<br> struct btrfs_root <em> root = orig_root-&gt;fs_info-&gt;extent_root;<br> struct btrfs_fs_info </em>info = root-&gt;fs_info;<br> u64 total_needed = num_bytes;<br> struct btrfs_block_group_cache *block_group;<br> int full_scan = 0;<br> int wrapped = 0;</p>
<p> WARN_ON(num_bytes &lt; root-&gt;sectorsize);<br> btrfs_set_key_type(ins, BTRFS_EXTENT_ITEM_KEY);<br> //这的含义很显然，为了加快搜索先从hint 开始，失败了再从search start 即0，再找。<br> if (hint_byte) {</p>
<pre><code> block_group = btrfs_lookup_first_block_group(info, hint_byte);
 <span class="keyword">if</span> (!block_group)
     hint_byte = search_start;// <span class="number">0</span>
 //<span class="typedef"><span class="keyword">data</span>为<span class="type">METADATA</span>，</span>
 block_group = btrfs_find_block_group(root, block_group,hint_byte, <span class="typedef"><span class="keyword">data</span>, 1);</span>
</code></pre><p> } else {</p>
<pre><code> //trans-&gt;block_group 赋值为<span class="type">NULL</span>。
 block_group = btrfs_find_block_group(root,trans-&gt;block_group,search_start, <span class="typedef"><span class="keyword">data</span>, 1);</span>
</code></pre><p> }</p>
<p> total_needed += empty_size;</p>
</li>
</ul>
<p>check_failed:<br>    if (!block_group) {<br>        block_group = btrfs_lookup_first_block_group(info,<br>                                 search_start);<br>        if (!block_group)<br>            block_group = btrfs_lookup_first_block_group(info,<br>                               orig_search_start);<br>    }<br>    ret = find_search_start(root, &amp;block_group, &amp;search_start,<br>                total_needed, data);<br>    if (ret)<br>        goto error;</p>
<pre><code>search_start = stripe_align(root, search_start);
ins<span class="variable">-&gt;objectid</span> = search_start;
ins<span class="variable">-&gt;offset</span> = num_bytes;

<span class="keyword">if</span> (ins<span class="variable">-&gt;objectid</span> + num_bytes &gt;
    block_group<span class="variable">-&gt;key</span>.objectid + block_group<span class="variable">-&gt;key</span>.offset) {
    search_start = block_group<span class="variable">-&gt;key</span>.objectid +
        block_group<span class="variable">-&gt;key</span>.offset;
    <span class="keyword">goto</span> new_group;
}

<span class="keyword">if</span> (test_range_bit(&amp;info<span class="variable">-&gt;extent_ins</span>, ins<span class="variable">-&gt;objectid</span>,
           ins<span class="variable">-&gt;objectid</span> + num_bytes -<span class="number">1</span>, EXTENT_LOCKED, <span class="number">0</span>)) {
    search_start = ins<span class="variable">-&gt;objectid</span> + num_bytes;
    <span class="keyword">goto</span> new_group;
}

<span class="keyword">if</span> (test_range_bit(&amp;info<span class="variable">-&gt;pinned_extents</span>, ins<span class="variable">-&gt;objectid</span>,
           ins<span class="variable">-&gt;objectid</span> + num_bytes -<span class="number">1</span>, EXTENT_DIRTY, <span class="number">0</span>)) {
    search_start = ins<span class="variable">-&gt;objectid</span> + num_bytes;
    <span class="keyword">goto</span> new_group;
}

<span class="keyword">if</span> (exclude_nr &gt; <span class="number">0</span> &amp;&amp; (ins<span class="variable">-&gt;objectid</span> + num_bytes &gt; exclude_start &amp;&amp;
    ins<span class="variable">-&gt;objectid</span> &lt; exclude_start + exclude_nr)) {
    search_start = exclude_start + exclude_nr;
    <span class="keyword">goto</span> new_group;
}

<span class="keyword">if</span> (!(data &amp; BTRFS_BLOCK_GROUP_DATA)) {
    block_group = btrfs_lookup_block_group(info, ins<span class="variable">-&gt;objectid</span>);
    <span class="keyword">if</span> (block_group)
        trans<span class="variable">-&gt;block_group</span> = block_group;
}
ins<span class="variable">-&gt;offset</span> = num_bytes;
<span class="keyword">return</span> <span class="number">0</span>;
</code></pre><p>new_group:<br>    block_group = btrfs_lookup_first_block_group(info, search_start);<br>    if (!block_group) {<br>        search_start = orig_search_start;<br>        if (full_scan) {<br>            ret = -ENOSPC;<br>            goto error;<br>        }<br>        if (wrapped) {<br>            if (!full_scan)<br>                total_needed -= empty_size;<br>            full_scan = 1;<br>        } else<br>            wrapped = 1;<br>    }<br>    cond_resched();<br>    block_group = btrfs_find_block_group(root, block_group,<br>                         search_start, data, 0);<br>    goto check_failed;</p>
<p>error:<br>    return ret;<br>}</p>
<p>struct btrfs_block_group_cache <em>btrfs_lookup_first_block_group(struct btrfs_fs_info </em>info,u64 bytenr)<br>{<br>    struct extent_io_tree <em>block_group_cache;<br>    struct btrfs_block_group_cache </em>block_group = NULL;<br>    u64 ptr;<br>    u64 start;<br>    u64 end;<br>    int ret;<br>    //任何一个group的开始位置应该是在super block的后面。<br>    bytenr = max_t(u64, bytenr,BTRFS_SUPER_INFO_OFFSET + BTRFS_SUPER_INFO_SIZE);<br>    //info的block_group_cache 的cache_tree(就是rb root而已)类型的state-&gt;rb_root找到 rb_node,在用container of由rb node找到 extent_state<br>    //而extent_state中private成员，就有我们要找的真.btrfs_block_group_cache!!!<br>    block_group_cache = &amp;info-&gt;block_group_cache;<br>    //用指针参数返回找到的第一个extent的start 和end。<br>    ret = find_first_extent_bit(block_group_cache, bytenr, &amp;start, &amp;end,BLOCK_GROUP_DATA | BLOCK_GROUP_METADATA |BLOCK_GROUP_SYSTEM);<br>    if (ret) {<br>        return NULL;<br>    }<br>    //上面返回的start<br>    //我觉得这个函数和上面的功能上有重复,在extent_state的private成员保存了btrfs_block_group_cache.h<br>    ret = get_state_private(block_group_cache, start, &amp;ptr);<br>    if (ret)<br>        return NULL;<br>    block_group = (struct btrfs_block_group_cache *)(unsigned long)ptr;<br>    return block_group;<br>}</p>
<p>int find_first_extent_bit(struct extent_io_tree <em>tree, u64 start,u64 </em>start_ret, u64 <em>end_ret, int bits)<br>{<br>    struct cache_extent </em>node;<br>    struct extent_state *state;<br>    int ret = 1;</p>
<pre><code><span class="comment">/*
 * this search will find all the extents that end after
 * our range starts.
 */</span>
<span class="comment">//就像英文注释所说的那样，这个函数就是简单的调用rb search 搜索rb树找到结束于start之后的所有extent</span>
<span class="comment">//当然这些extent都是缓存在我们info block_group_cache的state这棵树上。</span>
<span class="comment">//很有必要来分析一下extent_state.</span>
<span class="comment">//在 fsinfo-&gt;block_group_cache也就是extent_io_tree中有两个cache_tree,一个state，buffer。</span>
<span class="comment">//我们现在已经知道了这个extent_state-&gt;state应该是记录了data metadata system之中的一个。</span>
<span class="comment">//上面传过来的参数是data metadata system的或结果。用意显然就是为了找到一个extent就行。</span>
node = find_first_cache_extent(&amp;tree-&gt;state, start);
<span class="keyword">if</span> (!node)
    goto out;

<span class="keyword">while</span>(<span class="number">1</span>) {
    state = container_of(node, <span class="keyword">struct</span> extent_state, cache_node);
    <span class="keyword">if</span> (state-&gt;end &gt;= start &amp;&amp; (state-&gt;state &amp; bits)) {<span class="comment">//找到了非空的extent。</span>
        *start_ret = state-&gt;start;
        *end_ret = state-&gt;end;
        ret = <span class="number">0</span>;
        <span class="keyword">break</span>;
    }
    node = next_cache_extent(node);
    <span class="keyword">if</span> (!node)
        <span class="keyword">break</span>;
}
</code></pre><p>out:<br>    return ret;<br>}</p>
<p>//我越发地觉得这个函数，实在冗长~~<br>//简而言之，这个函数就是通过对info block_group_cache 进行rb式的搜索，逐个group测试data bit位和剩余空间。<br>//返回找到组，类型btrfs_block_group_cache<br>struct btrfs_block_group_cache <em>btrfs_find_block_group(struct btrfs_root </em>root, struct btrfs_block_group_cache <em>hint, u64 search_start,<br>                         int data, int owner)<br>{<br>    struct btrfs_block_group_cache </em>cache;<br>    struct extent_io_tree <em>block_group_cache;<br>    struct btrfs_block_group_cache </em>found_group = NULL;<br>    struct btrfs_fs_info *info = root-&gt;fs_info;<br>    u64 used;<br>    u64 last = 0;<br>    u64 hint_last;<br>    u64 start;<br>    u64 end;<br>    u64 free_check;<br>    u64 ptr;<br>    int bit;<br>    int ret;<br>    int full_search = 0;<br>    int factor = 10;</p>
<pre><code>block_group_cache <span class="subst">=</span> <span class="subst">&amp;</span>info<span class="subst">-&gt;</span>block_group_cache;

<span class="keyword">if</span> (<span class="subst">!</span>owner)
    factor <span class="subst">=</span> <span class="number">10</span>;

bit <span class="subst">=</span> block_group_state_bits(<span class="built_in">data</span>);

<span class="keyword">if</span> (search_start) {<span class="comment">//这次是0</span>
    struct btrfs_block_group_cache <span class="subst">*</span>shint;
    <span class="comment">//之前的那个函数。</span>
    shint <span class="subst">=</span> btrfs_lookup_block_group(info, search_start);
    <span class="keyword">if</span> (shint <span class="subst">&amp;&amp;</span> <span class="subst">!</span>shint<span class="subst">-&gt;</span>ro <span class="subst">&amp;&amp;</span> block_group_bits(shint, <span class="built_in">data</span>)) {
        <span class="comment">//blcok group item</span>
        used <span class="subst">=</span> btrfs_block_group_used(<span class="subst">&amp;</span>shint<span class="subst">-&gt;</span>item);
        <span class="comment">//pinned 在btrfs_read_block_groups设置为0.</span>
        <span class="comment">//key.offset is meaning of size.</span>
        <span class="comment">//if 是这个group尚有剩余空间。</span>
        <span class="keyword">if</span> (used <span class="subst">+</span> shint<span class="subst">-&gt;</span>pinned <span class="subst">&lt;</span> div_factor(shint<span class="subst">-&gt;</span>key<span class="built_in">.</span>offset, factor)) {
            <span class="keyword">return</span> shint;
        }
    }
}
<span class="comment">//这次调用hint也是NULL</span>
<span class="comment">//bits测试很重要</span>
<span class="keyword">if</span> (hint <span class="subst">&amp;&amp;</span> <span class="subst">!</span>hint<span class="subst">-&gt;</span>ro <span class="subst">&amp;&amp;</span> block_group_bits(hint, <span class="built_in">data</span>)) {
    used <span class="subst">=</span> btrfs_block_group_used(<span class="subst">&amp;</span>hint<span class="subst">-&gt;</span>item);
    <span class="comment">//如果group尚有空间。</span>
    <span class="keyword">if</span> (used <span class="subst">+</span> hint<span class="subst">-&gt;</span>pinned <span class="subst">&lt;</span> div_factor(hint<span class="subst">-&gt;</span>key<span class="built_in">.</span>offset, factor)) {
        <span class="keyword">return</span> hint;
    }
    last <span class="subst">=</span> hint<span class="subst">-&gt;</span>key<span class="built_in">.</span>objectid <span class="subst">+</span> hint<span class="subst">-&gt;</span>key<span class="built_in">.</span>offset;
    hint_last <span class="subst">=</span> last;
} <span class="keyword">else</span> {
    <span class="comment">//如果提供了hint,btrfs_block_group_cache</span>
    <span class="keyword">if</span> (hint)
        hint_last <span class="subst">=</span> <span class="keyword">max</span>(hint<span class="subst">-&gt;</span>key<span class="built_in">.</span>objectid, search_start);
    <span class="keyword">else</span>
        hint_last <span class="subst">=</span> search_start;

    last <span class="subst">=</span> hint_last;
}
</code></pre><p>again:<br>    while(1) {<br>        ret = find_first_extent_bit(block_group_cache, last,<br>                        &amp;start, &amp;end, bit);<br>        if (ret)<br>            break;</p>
<pre><code>    ret <span class="subst">=</span> get_state_private(block_group_cache, start, <span class="subst">&amp;</span>ptr);
    <span class="keyword">if</span> (ret)
        break;

    <span class="keyword">cache</span> <span class="subst">=</span> (struct btrfs_block_group_cache <span class="subst">*</span>)(unsigned long)ptr;
    <span class="comment">//new last~~</span>
    last <span class="subst">=</span> <span class="keyword">cache</span><span class="subst">-&gt;</span>key<span class="built_in">.</span>objectid <span class="subst">+</span> <span class="keyword">cache</span><span class="subst">-&gt;</span>key<span class="built_in">.</span>offset;
    used <span class="subst">=</span> btrfs_block_group_used(<span class="subst">&amp;</span><span class="keyword">cache</span><span class="subst">-&gt;</span>item);
    <span class="comment">//依靠data里面的bit位来确定我们需要哪个group。 </span>
    <span class="keyword">if</span> (<span class="subst">!</span><span class="keyword">cache</span><span class="subst">-&gt;</span>ro <span class="subst">&amp;&amp;</span> block_group_bits(<span class="keyword">cache</span>, <span class="built_in">data</span>)) {
        <span class="comment">//随意检索？</span>
        <span class="keyword">if</span> (full_search)
            free_check <span class="subst">=</span> <span class="keyword">cache</span><span class="subst">-&gt;</span>key<span class="built_in">.</span>offset;
        <span class="keyword">else</span>
            free_check <span class="subst">=</span> div_factor(<span class="keyword">cache</span><span class="subst">-&gt;</span>key<span class="built_in">.</span>offset,factor);
        <span class="keyword">if</span> (used <span class="subst">+</span> <span class="keyword">cache</span><span class="subst">-&gt;</span>pinned <span class="subst">&lt;</span> free_check) {
            <span class="comment">//有剩余空间，满足</span>
            found_group <span class="subst">=</span> <span class="keyword">cache</span>;
            goto found;
        }
    }
    cond_resched();
}
<span class="keyword">if</span> (<span class="subst">!</span>full_search) {
    last <span class="subst">=</span> search_start;
    full_search <span class="subst">=</span> <span class="number">1</span>;
    goto again;
}
</code></pre><p>found:<br>    return found_group;<br>}</p>
<p>//在free_space_cahe 中记录空闲空间<br>//在从头至尾找到一个num大的空间 返回这个空间的start。<br>static int noinline find_search_start(struct btrfs_root <em>root,struct btrfs_block_group_cache **cache_ret,u64 </em>start_ret, int num, int data)<br>{<br>    int ret;<br>    struct btrfs_block_group_cache <em>cache = </em>cache_ret;<br>    u64 last;<br>    u64 start = 0;<br>    u64 end = 0;<br>    u64 search_start = *start_ret;<br>    int wrapped = 0;</p>
<pre><code><span class="keyword">if</span> (!cache) {
    <span class="keyword">goto</span> <span class="keyword">out</span>;
}
</code></pre><p>again:<br>    //从函数名字可知就是把找到的这个group缓存到free space cache~~具体进去看看。<br>    ret = cache_block_group(root, cache);<br>    if (ret)<br>        goto out;</p>
<pre><code>last <span class="subst">=</span> <span class="keyword">max</span>(search_start, <span class="keyword">cache</span><span class="subst">-&gt;</span>key<span class="built_in">.</span>objectid);
<span class="keyword">if</span> (<span class="keyword">cache</span><span class="subst">-&gt;</span>ro <span class="subst">||</span> <span class="subst">!</span>block_group_bits(<span class="keyword">cache</span>, <span class="built_in">data</span>)) {
    goto new_group;
}

<span class="keyword">while</span>(<span class="number">1</span>) {
    ret <span class="subst">=</span> find_first_extent_bit(<span class="subst">&amp;</span>root<span class="subst">-&gt;</span>fs_info<span class="subst">-&gt;</span>free_space_cache,last, <span class="subst">&amp;</span>start, <span class="subst">&amp;</span>end, EXTENT_DIRTY);
    <span class="keyword">if</span> (ret) {
        goto new_group;
    }

    start <span class="subst">=</span> <span class="keyword">max</span>(last, start);
    last <span class="subst">=</span> end <span class="subst">+</span> <span class="number">1</span>;
    <span class="keyword">if</span> (last <span class="subst">-</span> start <span class="subst">&lt;</span> num) {
        continue;
    }
    <span class="keyword">if</span> (start <span class="subst">+</span> num <span class="subst">&gt;</span> <span class="keyword">cache</span><span class="subst">-&gt;</span>key<span class="built_in">.</span>objectid <span class="subst">+</span> <span class="keyword">cache</span><span class="subst">-&gt;</span>key<span class="built_in">.</span>offset) {
        goto new_group;
    }
    <span class="subst">*</span>start_ret <span class="subst">=</span> start;
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>out:<br>    cache = btrfs_lookup_block_group(root-&gt;fs_info, search_start);<br>    if (!cache) {<br>        printk(“Unable to find block group for %llu\n”,<br>            (unsigned long long)search_start);<br>        WARN_ON(1);<br>    }<br>    return -ENOSPC;</p>
<p>new_group:<br>    last = cache-&gt;key.objectid + cache-&gt;key.offset;<br>wrapped:<br>    cache = btrfs_lookup_first_block_group(root-&gt;fs_info, last);<br>    if (!cache) {<br>no_cache:<br>        if (!wrapped) {<br>            wrapped = 1;<br>            last = search_start;<br>            goto wrapped;<br>        }<br>        goto out;<br>    }<br>    cache = btrfs_find_block_group(root, cache, last, data, 0);<br>    cache = btrfs_find_block_group(root, cache, last, data, 0);<br>    if (!cache)<br>        goto no_cache;</p>
<pre><code>*cache_ret = <span class="operator"><span class="keyword">cache</span>;</span>
goto again;
</code></pre><p>}</p>
<p>//Just cache block group~~<br>static int cache_block_group(struct btrfs_root <em>root,struct btrfs_block_group_cache </em>block_group)<br>{<br>    struct btrfs_path <em>path;<br>    int ret;<br>    struct btrfs_key key;<br>    struct extent_buffer </em>leaf;<br>    struct extent_io_tree *free_space_cache;<br>    int slot;<br>    u64 last;<br>    u64 hole_size;</p>
<pre><code><span class="keyword">if</span> (!block_group)
    <span class="keyword">return</span> <span class="number">0</span>;
<span class="comment">//we will record the blcok or extent in extent_root.</span>
root = root<span class="variable">-&gt;fs_info</span><span class="variable">-&gt;extent_root</span>;
<span class="comment">//I think it also used to cache allocate.</span>
free_space_cache = &amp;root<span class="variable">-&gt;fs_info</span><span class="variable">-&gt;free_space_cache</span>;

<span class="comment">//already cached?</span>
<span class="keyword">if</span> (block_group<span class="variable">-&gt;cached</span>)
    <span class="keyword">return</span> <span class="number">0</span>;

path = btrfs_alloc_path();
<span class="keyword">if</span> (!path)
    <span class="keyword">return</span> -ENOMEM;

path<span class="variable">-&gt;reada</span> = <span class="number">2</span>;
<span class="comment">//以防万一</span>
last = max_t(u64, block_group<span class="variable">-&gt;key</span>.objectid, BTRFS_SUPER_INFO_OFFSET);
<span class="comment">//start address</span>
key.objectid = last;
key.offset = <span class="number">0</span>;
btrfs_set_key_type(&amp;key, BTRFS_EXTENT_ITEM_KEY);
<span class="comment">//在extent_root中找到这个group，相近的item。</span>
ret = btrfs_search_slot(<span class="keyword">NULL</span>, root, &amp;key, path, <span class="number">0</span>, <span class="number">0</span>);
<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)
    <span class="keyword">goto</span> err;

<span class="keyword">while</span>(<span class="number">1</span>) {
    leaf = path<span class="variable">-&gt;nodes</span>[<span class="number">0</span>];
    slot = path<span class="variable">-&gt;slots</span>[<span class="number">0</span>];
    <span class="comment">//和下面的slots[0]++有关系，因为while的原因。</span>
    <span class="keyword">if</span> (slot &gt;= btrfs_header_nritems(leaf)) {
        ret = btrfs_next_leaf(root, path);
        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)
            <span class="keyword">goto</span> err;
        <span class="keyword">if</span> (ret == <span class="number">0</span>) {
            <span class="keyword">continue</span>;
        } <span class="keyword">else</span> {
            <span class="keyword">break</span>;
        }
    }
    得到我们找到的extent tree中的那个item的key。
    btrfs_item_key_to_cpu(leaf, &amp;key, slot);
    <span class="comment">//保证我们找到的item应该在我们想要的组里面。这个组是上面确定的。</span>
    <span class="keyword">if</span> (key.objectid &lt; block_group<span class="variable">-&gt;key</span>.objectid) {
        <span class="keyword">goto</span> next;
    }
    <span class="comment">//超出了整个group的大小。</span>
    <span class="keyword">if</span> (key.objectid &gt;= block_group<span class="variable">-&gt;key</span>.objectid +
        block_group<span class="variable">-&gt;key</span>.offset) {
        <span class="keyword">break</span>;
    }
    <span class="comment">//进一步，验证这个item是否是一个extent item，因为从下面可知他是slots++ 一个个递加找到的，所以可能会遇到BLOCK GROUP item.</span>
    <span class="keyword">if</span> (btrfs_key_type(&amp;key) == BTRFS_EXTENT_ITEM_KEY) {
        <span class="comment">//如果是extent item ，计算和上一个item 之间的空间。</span>
        <span class="keyword">if</span> (key.objectid &gt; last) {
            hole_size = key.objectid - last;
            <span class="comment">//记录下这个空洞的大小到 info-&gt;free_space_cache-&gt;state ,cache_tree 类型。</span>
            <span class="comment">//通过rb node 实际上链入的extent_state</span>
            set_extent_dirty(free_space_cache, last,last + hole_size - <span class="number">1</span>,GFP_NOFS);
        }
        last = key.objectid + key.offset;
    }
</code></pre><p>next:<br>        path-&gt;slots[0]++;<br>    }<br>    //最后一个item的end address 还在block group end address之内。<br>    if (block_group-&gt;key.objectid + block_group-&gt;key.offset &gt; last) {<br>        //从最后一个item的结束位置到group结束的位置之间的空洞。<br>        hole_size = block_group-&gt;key.objectid + block_group-&gt;key.offset - last;<br>        //把这个空洞也记录到free space cache中。<br>        set_extent_dirty(free_space_cache, last, last + hole_size - 1, GFP_NOFS);<br>    }<br>    //我们先通过函数名猜功能，应该是从free space cache 中移除sb的内容<br>    remove_sb_from_cache(root, block_group);<br>    block_group-&gt;cached = 1;<br>err:<br>    btrfs_free_path(path);<br>    return 0;<br>}</p>
<p>static int remove_sb_from_cache(struct btrfs_root <em>root,struct btrfs_block_group_cache </em>cache)<br>{<br>    u64 bytenr;<br>    u64 <em>logical;<br>    int stripe_len;<br>    int i, nr, ret;<br>    struct extent_io_tree </em>free_space_cache;</p>
<pre><code>free_space_cache = &amp;root-&gt;fs_info-&gt;free_space_cache;
<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BTRFS_SUPER_MIRROR_MAX; i++) {
    bytenr = btrfs_sb_offset(i);
    <span class="comment">//mapping tree is just a encapsulation of cache_tree, simply, rb root</span>
    <span class="comment">//我想这个函数的主要功能时记录中的disk地址。</span>
    <span class="comment">//这个phusical 和logical中，logical 应是之加入raid 策略后的地址。</span>
    ret = btrfs_rmap_block(&amp;root-&gt;fs_info-&gt;mapping_tree,cache-&gt;key.objectid, bytenr, <span class="number">0</span>,&amp;logical, &amp;nr, &amp;stripe_len);
    BUG_ON(ret);
    <span class="keyword">while</span> (nr--) {
        clear_extent_dirty(free_space_cache, logical[nr],
            logical[nr] + stripe_len - <span class="number">1</span>, GFP_NOFS);
    }
    kfree(logical);
}
<span class="keyword">return</span> <span class="number">0</span>;
</code></pre><p>}</p>
<p>//首先解析函数的参数的用途：<br>//map_tree:就是 fs_info的mapping_tree<br>//chunk_start:block group 的start位置，in disk。<br>//physical:btrfs sb 的offset 第一个64k，第二个是64M 第三个是128M。in disk。<br>//devid：0<br>//logical：return the logical address<br>//nraddrs：for return value，combined with logical，used to indicate array index<br>//stripe_len:for return value，条带长度。<br>//关于条带的几个参数含义仍然需要进一步，确定。<br>int btrfs_rmap_block(struct btrfs_mapping_tree <em>map_tree,u64 chunk_start, u64 physical, u64 devid,u64 **logical, int </em>naddrs, int <em>stripe_len)<br>{<br>    struct cache_extent </em>ce;<br>    struct map_lookup <em>map;<br>    u64 </em>buf;<br>    u64 bytenr;<br>    u64 length;<br>    u64 stripe_nr;<br>    int i, j, nr = 0;<br>    //<br>    ce = find_first_cache_extent(&amp;map_tree-&gt;cache_tree, chunk_start);<br>    BUG_ON(!ce);</p>
<pre><code><span class="variable">map =</span> container_of(ce, struct map_lookup, ce);

//这个size应该是整个条带的大小，包括了作备份那部分重复的大小。
<span class="variable">length =</span> ce-&gt;size;
//raid <span class="number">0</span> 是striped，即num_stripes; raid1是备份,sub_stripes <span class="keyword">in</span> raid10
//length 是不考虑任何raid策略时，一次操作读写大小。
<span class="keyword">if</span> (<span class="built_in">map</span>-&gt;type &amp; BTRFS_BLOCK_GROUP_RAID10)
    <span class="variable">length =</span> ce-&gt;size / (<span class="built_in">map</span>-&gt;num_stripes / <span class="built_in">map</span>-&gt;sub_stripes);
<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;type &amp; BTRFS_BLOCK_GROUP_RAID0)
    <span class="variable">length =</span> ce-&gt;size / <span class="built_in">map</span>-&gt;num_stripes;

<span class="variable">buf =</span> kzalloc(sizeof(u64) * <span class="built_in">map</span>-&gt;num_stripes, GFP_NOFS);

for (<span class="variable">i =</span> <span class="number">0</span>; i &lt; <span class="built_in">map</span>-&gt;num_stripes; i++) {
    <span class="keyword">if</span> (devid &amp;&amp; <span class="built_in">map</span>-&gt;stripes[i].dev-&gt;devid != devid)
        continue;
    //这个stripe是否包含super block <span class="keyword">in</span> disk
    <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;stripes[i].physical &gt; physical ||
        <span class="built_in">map</span>-&gt;stripes[i].physical + length &lt;= physical)
        continue;
    //superblock 所在的 stripe 编号或数量。
    <span class="variable">stripe_nr =</span> (physical - <span class="built_in">map</span>-&gt;stripes[i].physical) /
            <span class="built_in">map</span>-&gt;stripe_len;

    <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;type &amp; BTRFS_BLOCK_GROUP_RAID10) {
        <span class="variable">stripe_nr =</span> (stripe_nr * <span class="built_in">map</span>-&gt;num_stripes + i) /
                <span class="built_in">map</span>-&gt;sub_stripes;
    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;type &amp; BTRFS_BLOCK_GROUP_RAID0) {
        <span class="variable">stripe_nr =</span> stripe_nr * <span class="built_in">map</span>-&gt;num_stripes + i;
    }
    <span class="variable">bytenr =</span> ce-&gt;start + stripe_nr * <span class="built_in">map</span>-&gt;stripe_len;
    for (<span class="variable">j =</span> <span class="number">0</span>; j &lt; nr; j++) {
        <span class="keyword">if</span> (buf[j] == bytenr)
            break;
    }
    <span class="keyword">if</span> (<span class="variable">j =</span>= nr)
        buf[nr++] = bytenr;
}

*<span class="variable">logical =</span> buf;
*<span class="variable">naddrs =</span> nr;
*<span class="variable">stripe_len =</span> <span class="built_in">map</span>-&gt;stripe_len;

return <span class="number">0</span>;
</code></pre><p>}</p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/kernel/">kernel</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/kernel/">kernel</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://firoyang.org/2015/02/27/kernel/btrfs/" data-title="btrfs | Hot sexy girls" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/02/27/kernel/bug/" title="bug">
  <strong>PREVIOUS:</strong><br/>
  <span>
  bug</span>
</a>
</div>


<div class="next">
<a href="/2015/02/27/kernel/activites/"  title="kernel activites">
 <strong>NEXT:</strong><br/> 
 <span>kernel activites
</span>
</a>
</div>

</nav>

	


<section id="comments">
  <div id="disqus_thread">
   <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
  
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
			<li><a href="/categories/akasha/" title="akasha">akasha<sup>4</sup></a></li>
		
			<li><a href="/categories/cogito/" title="cogito">cogito<sup>1</sup></a></li>
		
			<li><a href="/categories/cs/" title="cs">cs<sup>10</sup></a></li>
		
			<li><a href="/categories/fedora/" title="fedora">fedora<sup>1</sup></a></li>
		
			<li><a href="/categories/firo/" title="firo">firo<sup>2</sup></a></li>
		
			<li><a href="/categories/golden-time/" title="golden-time">golden-time<sup>2</sup></a></li>
		
			<li><a href="/categories/kernel/" title="kernel">kernel<sup>24</sup></a></li>
		
			<li><a href="/categories/laughing-man/" title="laughing-man">laughing-man<sup>1</sup></a></li>
		
			<li><a href="/categories/literature/" title="literature">literature<sup>1</sup></a></li>
		
			<li><a href="/categories/net/" title="net">net<sup>8</sup></a></li>
		
			<li><a href="/categories/philosophy/" title="philosophy">philosophy<sup>1</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			<li><a href="/tags/akasha/" title="akasha">akasha<sup>3</sup></a></li>
		
			<li><a href="/tags/cs/" title="cs">cs<sup>9</sup></a></li>
		
			<li><a href="/tags/fedora/" title="fedora">fedora<sup>1</sup></a></li>
		
			<li><a href="/tags/firo/" title="firo">firo<sup>1</sup></a></li>
		
			<li><a href="/tags/golden-time/" title="golden-time">golden-time<sup>2</sup></a></li>
		
			<li><a href="/tags/kernel/" title="kernel">kernel<sup>17</sup></a></li>
		
			<li><a href="/tags/laughing-man/" title="laughing-man">laughing-man<sup>1</sup></a></li>
		
			<li><a href="/tags/net/" title="net">net<sup>7</sup></a></li>
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
      <li><a href="http://ifind.cc" target="_blank" title="Jiangchang shun">江长顺</a></li>
      <li><a href="http://lisuyong.com" target="_blank" title="Li su yong">李素颙</a></li>
      <li><a href="http://hexo.io" target="_blank" title="Hexo">Hexo</a></li>
    </ul>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<div class="social-font clearfix">
		
		
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2015 
		
		<a href="http://firoyang.org" target="_blank" title="Firo Yang">Firo Yang</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>







<script>
  var disqus_shortname = 'firoyang';
  
  var disqus_url = 'http://firoyang.org/2015/02/27/kernel/btrfs/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


  </body>
</html>
