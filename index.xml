<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title> on Firo Notes </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://firoyang.org/</link>
    <language>en-us</language>
    <author>Firo Yang</author>
    
    <updated>Sat, 27 Feb 2016 22:12:11 CST</updated>
    
    <item>
      <title>杂记于蓝星花园</title>
      <link>http://firoyang.org/firo/n1/</link>
      <pubDate>Sat, 27 Feb 2016 22:12:11 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/firo/n1/</guid>
      <description>&lt;p&gt;我和这个国家的矛盾最终演变成不可调和的地步. 我已无法在北京生存了, 国内其他的城市对我来说也一样.&lt;br /&gt;
于是, 我已走头无路, 只剩出国这一条路了.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The map of Knowledges</title>
      <link>http://firoyang.org/philosophy/knowledge_map/</link>
      <pubDate>Wed, 17 Feb 2016 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/philosophy/knowledge_map/</guid>
      <description>

&lt;h1 id=&#34;根据依赖关系组织-展示的知识:260b1b4cb8a9fd578dd92738bfffb93b&#34;&gt;根据依赖关系组织, 展示的知识&lt;/h1&gt;

&lt;p&gt;知识之间都是相互依赖的.&lt;br /&gt;
Logic&lt;br /&gt;
Language&lt;br /&gt;
Mathematics&lt;br /&gt;
Programming&lt;/p&gt;

&lt;p&gt;English&lt;br /&gt;
Hibert提出23个问题. turing machine 是为了解决数学可判定性问题.&lt;br /&gt;
由此导致CS的蓬勃发展.&lt;/p&gt;

&lt;p&gt;Class of knowledge&lt;br /&gt;
Raw knowledge, which exists in live, is real, leisure, scattered, low chance to learn.&lt;br /&gt;
Raw knowledge need lots of time to learn.&lt;br /&gt;
Artificial knowledge&lt;br /&gt;
linear enumerate knowledge: only for searching.&lt;/p&gt;

&lt;p&gt;Phased objectives of learning knowledge&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>奔腾年代</title>
      <link>http://firoyang.org/cs/golden_age_of_cs/</link>
      <pubDate>Tue, 05 Jan 2016 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/golden_age_of_cs/</guid>
      <description>&lt;p&gt;计算机的奔腾年代&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The common cognition language</title>
      <link>http://firoyang.org/philosophy/ccl/</link>
      <pubDate>Sun, 13 Dec 2015 03:27:16 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/philosophy/ccl/</guid>
      <description>&lt;p&gt;What&amp;rsquo;s the orgnaiszations of knowledge?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Console and TTY</title>
      <link>http://firoyang.org/kernel/console/</link>
      <pubDate>Sat, 05 Dec 2015 14:06:29 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/kernel/console/</guid>
      <description>

&lt;p&gt;343 line&lt;br /&gt;
1. /dev/console 指向正在运行的tty 和tty0 一样ttyN not pts, console 佬变.&lt;br /&gt;
2. /dev/tty 一直指向所在的那个不变.&lt;/p&gt;

&lt;h1 id=&#34;about-the-design:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;About the design&lt;/h1&gt;

&lt;p&gt;Why dose we use /dev/xxx to represent the &amp;ldquo;tty&amp;rdquo; device?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The whole point with &amp;ldquo;everything is a file&amp;rdquo; is not that you have some random filename (indeed, sockets and pipes show that &amp;ldquo;file&amp;rdquo; and &amp;ldquo;filename&amp;rdquo;&amp;gt; have nothing to do with each other), but the fact that you can use common tools to operate on different things. &amp;ndash; Linus&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So we got the key point!&lt;br /&gt;
In order to use the common tools, file ops and vfs layer, the tty device is &amp;ldquo;abstructed&amp;rdquo; to&lt;br /&gt;
files by us. Addnationaly, we must assurance that is the files is &lt;em&gt;different&lt;/em&gt;. What does&lt;br /&gt;
the word &amp;ldquo;dirrerent&amp;rdquo; means is not that you have some random different filename, but the&lt;br /&gt;
fact that you can access the real device through the different.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Wikipedia:&lt;br /&gt;
In mathematics, injections, surjections and bijections are classes of functions distinguished by the manner in which arguments (input expression&amp;gt; s from the domain) and images (output expressions from the codomain) are related or mapped to each other.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I got an insight that abstruction is a non-injective, right?&lt;br /&gt;
But non-injective may not be a anstruction.&lt;br /&gt;
An asbstruction should come from manipulating different objects.&lt;br /&gt;
Non-injective, 多对一; Multiplex, 一对多.&lt;br /&gt;
So we can use mathematical language to describe the linux subsystem.&lt;br /&gt;
From real life device to a filesystem file.&lt;br /&gt;
* Abstruction: Non-injective, Multiplex(not partial function).&lt;br /&gt;
* Jection num: injective, or non-jective, or multiplex; Jection level: domain set and codoain set!&lt;br /&gt;
Abstruction -&amp;gt; Control abstruction and data abstruction -&amp;gt; Abstruction layer&lt;/p&gt;

&lt;p&gt;软件设计的两个主要目的.&lt;br /&gt;
1. 简化, 易用,易操作, 如computer architecture, tty subsystem. 抽象.&lt;br /&gt;
2. Separation of concerns, modular(abstruciton in layer), 笛卡尔划分的思想&lt;/p&gt;

&lt;h1 id=&#34;tty-struct-disc-data:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;tty_struct-&amp;gt;disc_data&lt;/h1&gt;

&lt;p&gt;tty_init_dev-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    initialize_tty_struct-&amp;gt;tty_ldisc_init&lt;br /&gt;
    tty_ldisc_setup-&amp;gt;tty_ldisc_open-&amp;gt;n_tty_open-&amp;gt; tty-&amp;gt;disc_data = ldata;&lt;br /&gt;
}&lt;br /&gt;
sys_vhangup-&amp;gt;tty_vhangup_self-&amp;gt;__tty_hangup-&amp;gt;tty_ldisc_hangup-&amp;gt;tty_ldisc_reinit&lt;br /&gt;
vfs_write-&amp;gt;redirected_tty_write-&amp;gt;tty_write-&amp;gt;n_tty_write-&amp;gt;process_output&lt;/p&gt;

&lt;h1 id=&#34;early-con:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;early_con&lt;/h1&gt;

&lt;p&gt;EARLYCON_DECLARE(uart8250, early_serial8250_setup); EARLYCON_DECLARE(uart, early_serial8250_setup);&lt;br /&gt;
setup_earlycon-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    parse_options-&amp;gt;&lt;br /&gt;
    {&lt;br /&gt;
        parse earlycon_device-&amp;gt;port-&amp;gt;uartclk and&lt;br /&gt;
        earlycon_device-&amp;gt;baud&lt;br /&gt;
    }&lt;br /&gt;
    setup = early_serial8250_setup-&amp;gt; init_port(device);&lt;br /&gt;
    register_console(early_console_dev.con)&lt;br /&gt;
}&lt;/p&gt;

&lt;h1 id=&#34;earlyprintk:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;earlyprintk&lt;/h1&gt;

&lt;p&gt;early_param(&amp;ldquo;earlyprintk&amp;rdquo;, setup_early_printk)-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    early_serial_init-&amp;gt;&lt;br /&gt;
    {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;}
early_console_register(&amp;amp;early_serial_console, keep);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;h1 id=&#34;cpu-hotplug:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;cpu hotplug&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;onset&lt;br /&gt;
static struct smp_hotplug_thread softirq_threads {&lt;br /&gt;
.thread_fn              = run_ksoftirqd&lt;br /&gt;
};&lt;br /&gt;
early_initcall(spawn_ksoftirqd)-&amp;gt;mpboot_register_percpu_thread(&amp;amp;softirq_threads)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;nucles onset&lt;br /&gt;
suspend_enter-&amp;gt;enable_nonboot_cpus-&amp;gt;_cpu_up-&amp;gt;smpboot_create_threads-&amp;gt;&lt;strong&gt;smpboot_create_thread(&amp;amp;hotplug_threads)-&amp;gt;&lt;br /&gt;
kthread_create_on_cpu(smpboot_thread_fn-&amp;gt; ht-&amp;gt;thread_fn(td-&amp;gt;cpu)= run_ksoftirqd-&amp;gt;&lt;/strong&gt;do_softirq-&amp;gt;h-&amp;gt;action(h) = run_timer_softirq-&amp;gt;&lt;br /&gt;
__run_timers-&amp;gt;call_timer_fn)&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;vt 就是个tty也有tty_driver 叫console_driver.&lt;/p&gt;

&lt;h1 id=&#34;reference:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;Reference&lt;/h1&gt;

&lt;h1 id=&#34;contents:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;Contents&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://superuser.com/questions/144666/what-is-the-difference-between-shell-console-and-terminal&#34;&gt;What is the difference between shell, console, and terminal?&lt;/a&gt;&lt;br /&gt;
What does console do in kernel or u-boot?&lt;br /&gt;
Linux console?&lt;br /&gt;
Computer terminal: keyboard + dispaly&lt;br /&gt;
Terminal emulator:&lt;/p&gt;

&lt;h1 id=&#34;get-a-glance-on-u-boot:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;get a glance on u-boot&lt;/h1&gt;

&lt;p&gt;start.S:board_init_r&lt;br /&gt;
init_sequence_f: -&amp;gt;init_baud_rate; serial_init; console_init_f&lt;br /&gt;
serial_init -&amp;gt;&amp;amp;eserial1_device-&amp;gt;start=eserial##port##_init-&amp;gt;NS16550_init: UART divisor init.&lt;br /&gt;
Firstly, the struct of serial define some input and output funtion.&lt;br /&gt;
It&amp;rsquo;s basic function of serial, put or get!&lt;br /&gt;
console_init_f: just gd-&amp;gt;have_console = 1;&lt;br /&gt;
init_sequence_r: stdio_init_tables,initr_serial, stdio_add_devices, console_init_r,&lt;br /&gt;
initr_serial: just register &amp;amp;eserial1_device to serial_devices&lt;br /&gt;
stdio_add_devices: drv_system_init, serial_stdio_init&lt;br /&gt;
drv_system_init: register default serial dev to devs.list.&lt;br /&gt;
serial_stdio_init: register &amp;amp;eserial1_device to devs.list. Duplicate, but serial dev &amp;ldquo;eserial0&amp;rdquo;  and system &amp;ldquo;serial&amp;rdquo;.&lt;br /&gt;
console_init_r: console_doenv -&amp;gt;console_setfile:stdio_devices[file(0/1/2)] = dev; actually, dev is &amp;ldquo;serial&amp;rdquo;, but they may be KBD!&lt;br /&gt;
看来console的真正作用就是在serial和kbd中选择一个, 可能多选iomux?&lt;br /&gt;
main_loop:cli_loop: getc!&lt;/p&gt;

&lt;h1 id=&#34;what-is-platform-device-or-driver:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;what is platform device or driver?&lt;/h1&gt;

&lt;h1 id=&#34;a-reallife-serial8250:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;A reallife serial8250&lt;/h1&gt;

&lt;p&gt;drivers/tty/serial/8250/8250_boca.c:plat_serial8250_port&lt;br /&gt;
module_init-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    serial8250_init-&amp;gt;serial8250_isa_init_ports-&amp;gt;serial8250_ports[i].port.ops = &amp;amp;serial8250_pops; //insidious&lt;br /&gt;
    boca_init-&amp;gt;platform_device_register(&amp;amp;boca_device); //register platform device and data.&lt;br /&gt;
}&lt;br /&gt;
* uart_port-&amp;gt;tty_port&lt;/p&gt;

&lt;p&gt;serial8250_probe(plat_serial8250_port)-&amp;gt;serial8250_register_8250_port(uart_8250_port)-&amp;gt;&lt;br /&gt;
uart_add_one_port(&amp;amp;serial8250_reg, &amp;amp;uart-&amp;gt;port=uart_port)-&amp;gt;&lt;br /&gt;
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uart_configure_port-&amp;gt;
{
    port-&amp;gt;ops-&amp;gt;config_port(port, flags)=serial8250_config_port
    if post is console and not registered; register!
    we know that uport-&amp;gt;cons = drv-&amp;gt;cons; what is the relation to registering about up-&amp;gt;cons.
    why we register it? where does drv-&amp;gt;cons come from?
    //这个uart_driver drv就是serial8250_reg, 我们也就知道了
    // console是设备的一种天生能力. 能否使用, 只关乎你是否想用, 就是配置相关的config SERIAL8250_CONSOLE
    // con_driver is the backends, vga, dummy/serial?, fb. 
}
tty_port_register_device_attr-&amp;gt;
{
    //tty_driver  tty_port
    tty_port_link_device
    tty_register_device_attr
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;h1 id=&#34;simple-conceptions:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;Simple conceptions&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.linusakesson.net/programming/tty/&#34;&gt;You must read this -&amp;gt; The TTY demystified&lt;/a&gt;&lt;br /&gt;
System consoles are generalized to computer terminals, which are abstracted respectively by virtual consoles and terminal emulators.&lt;br /&gt;
        UART&lt;br /&gt;
        Line displine + TTY(pts, dummy/serial, kbd+vga/fb)&lt;br /&gt;
* System console&lt;br /&gt;
Virtual termial, Terminal emulator/telnet/ssh -&amp;gt; pts ,Physical terminal&lt;br /&gt;
You need at least one virtual terminal device in order to make use of your keyboard and monitor.&lt;br /&gt;
VT combine keyboard and display see con_init&lt;br /&gt;
con_init init a virtual terminal like gnome-terminal but in kernel.&lt;br /&gt;
con_init mainly init display.&lt;br /&gt;
vty_init mainly init kbd&lt;br /&gt;
They all can be system console.(Exception pts??), if you enable it.&lt;br /&gt;
Console is the entry of linux system.&lt;br /&gt;
* Console driver &amp;ndash; banckends of  console&lt;br /&gt;
struct console 指定了console的结构.&lt;br /&gt;
* Console config&lt;br /&gt;
If I disable CONFIG_SERIAL8250_CONSOLE(enable vt console), then no booting log and I can not login system.&lt;br /&gt;
If I disable CONFIG_VT_CONSOLE(enable serail console, /dev/console point to ttyS0 see show_cons_active), no booting log but I can lgin system.&lt;br /&gt;
How to explain this phenomena?&lt;br /&gt;
From show_cons_active, we know /dev/console should come from console_drivers.&lt;br /&gt;
/dev/console is really the pointer.&lt;br /&gt;
Now, let&amp;rsquo;s inspect open /dev/console.&lt;br /&gt;
* Open /dev/console&lt;br /&gt;
Fisrt, it&amp;rsquo;s the very last place of booting kernel.&lt;br /&gt;
start_kernel-&amp;gt;rest_init-&amp;gt;kernel_init-&amp;gt;kernel_init_freeable-&amp;gt;sys_open((const char __user *) &amp;ldquo;/dev/console&amp;rdquo;, O_RDWR, 0)-&amp;gt;&amp;hellip;-&amp;gt;&lt;br /&gt;
console_fops-&amp;gt;tty_open-&amp;gt;&lt;br /&gt;
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Sitiuations: disbale VT CONSOLE byt enable SERIAL8250_CONSOLE.
// This function work only for /dev/tty
// ls -l /dev/tty
// crw-rw-rw- 1 root tty 5, 0 Dec 10 10:24 /dev/tty
tty_open_current_tty-&amp;gt;
{
    /dev/console is 5:1, just return NULL
}
//This index should be Ctrl + Alt + Fn??
// tty_struct is corresponding virtual console, or just console??
// lookup tty_driver. It looks like lookup a inode, right?
tty_lookup_driver-&amp;gt;
{
    // Find a tty_driver by device() in console_drivers.
    // So we know, got a console, then got a tty_driver, right?
    // Where do the components of console_drivers come form?
    // At present, we should have only serial8250_console because 
    // console vt_console_driver is disabled by us! But tty_driver console_driver
    // still do exist!So console and tty is really separated!
    // When we init vt, we get the tty_driver console_driver with con_ops type of tty_operations.
    // tty_drivers have the same major with /dev/tty0!
    // char_dev -&amp;gt; tty_driver int vty_init, not disable.
    // vt console---^
    console_device-&amp;gt;c-&amp;gt;device(c, index)
    // What about serial8250_console?
    // Where is the tty_driver of serial8250_console?
    // console-&amp;gt;data = uart_driver-&amp;gt;tty_driver.
    // We got another scene : uart-&amp;gt;tty
    // serial8250 console-&amp;gt;data-^
    // serial&#39;s tty_driver alloced in serial8250_init with uart_ops.
    // vt&#39;s tty_driver alloced in vty_init.
    // We summarize these:
    // uart_driver serial8250_reg &amp;lt;-&amp;gt;  vc dev or /dev/tty*
    // serial tty driver &amp;lt;-&amp;gt; vt tty driver 
    // fs:vty_init &amp;lt;-&amp;gt; module:serial8250_init
    // tty driver ops con_ops &amp;lt;-&amp;gt; uart_ops
    // vt use major to connect tty and  vc dev
    // serial use major and -&amp;gt; to connect tty and uart_driver
    // It seems that uart and tty has a strong relationship, yet vt.
    // Ok... we got tty driver.
    // If we disable vt console, then here is the serial8250 tty_driver.
}
// Lookup for tty_struct
tty_driver_lookup_tty -&amp;gt;
{
    //tty_struct is alloced in init function alloc_tty_driver.
    // ttys, termios, ports, cdevs.
    // ttys was used by tty_standard_install then tty_driver_install_tty 
    // then tty_init_dev then ok we return to tty open. So this is the start place.

    So we know tty_driver-&amp;gt;ttys[*] must be NULL.
}
tty_init_dev-&amp;gt;
{
    // tty_driver likes a process, ttys like the files, tty_struct like a file!
    // So we know a tty_struct is a tty file.
    // tty_driver much like a inode
    //So tty_struct-&amp;gt;ops = tty_driver-&amp;gt;ops = &amp;amp; uart_ops
    alloc_tty_struct-&amp;gt;tty-&amp;gt;ops = driver-&amp;gt;ops;
    tty_driver_install_tty(driver, tty_struct)-&amp;gt; tty_standard_install-&amp;gt;driver-&amp;gt;ttys[tty-&amp;gt;index] = tty;
}
// Ok... We got a tty_struct.
// Add /dev/console to tty_struct-&amp;gt;tty_files
tty_add_file
// At present, what have we done?
// open(/dev/console)-&amp;gt;console_drivers-&amp;gt;console-&amp;gt;tty_driver-&amp;gt;tty_struct, right?

tty-&amp;gt;ops-&amp;gt;open(tty, filp)-&amp;gt;//ops = &amp;amp;uart_ops
{
    uart_ops-&amp;gt;open = uart_open-&amp;gt;
    {
        uart-&amp;gt; tty struct
        struct uart_driver *drv = (struct uart_driver *)tty-&amp;gt;driver-&amp;gt;driver_state;
        struct uart_state *state = drv-&amp;gt;state + line; //uart_state
        tty-&amp;gt;driver_data = state;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
// At present, we understand the flow of open /dev/console to serial console&lt;/p&gt;

&lt;h1 id=&#34;what-about-opening-dev-console-to-vt-console:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;What about opening /dev/console to vt console&lt;/h1&gt;

&lt;p&gt;sys_open(/dev/console)-&amp;gt; &amp;hellip; tty_open -&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    tty_lookup_driver-&amp;gt; get tty_driver=console_driver,&lt;br /&gt;
    Through the name console_driver, we know, vt tty_driver is the defaut driver of console!&lt;br /&gt;
    // 同时, 我们也应该知道所谓的kernel的system console 是你只要enable了先关的config CONFIG_VT_CONSOLE and CONFIG_SERIAL_8250_CONSOLE.&lt;br /&gt;
    // system console就有了, printk也就有了归处. In other words, you registered, you got printed&lt;br /&gt;
    // In theory, you should be able to input something, like sysrq, I maybe test tomorrow.&lt;br /&gt;
    // 那么在kernel_init中sys_open又是什么鬼呢?&lt;br /&gt;
    // dev/tty 是专门真对进程的, 就是进程之前打开了一个tty就存在singnal里, 这个dev/tty就是取出来的.&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;h1 id=&#34;总结下-打开-dev-console-会从console-drivers-最终到达tty-driver:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;总结下, 打开/dev/console, 会从console_drivers, 最终到达tty_driver.&lt;/h1&gt;

&lt;h1 id=&#34;这和-dev-tty-dev-ttys-从tty-drivers-差不多:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;这和/dev/tty* /dev/ttyS* 从tty_drivers, 差不多.&lt;/h1&gt;

&lt;p&gt;// 这么输出为什么不会打窜了?&lt;br /&gt;
// How ctrl alt Fn work?&lt;br /&gt;
// echo xxx /dev/tty in serial tty_lookup_driver&lt;br /&gt;
// 另一个问题, serial 的terminal?&lt;/p&gt;

&lt;h1 id=&#34;the-perspective:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;The perspective&lt;/h1&gt;

&lt;p&gt;/dev/*&lt;br /&gt;
vfs&lt;br /&gt;
chrdev&lt;br /&gt;
tty_fops&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;gt;tty core&lt;br /&gt;
    ld_ops &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;&amp;gt; tty line discipline(for read, write)&lt;br /&gt;
tty_driver con_ops/uart_ops&amp;mdash;&amp;mdash;&amp;ndash;&amp;gt; tty driver and tty_operations&lt;br /&gt;
HW&lt;br /&gt;
There are three different types of tty drivers: console, serial port, and pty.&lt;br /&gt;
serial8250_default_handle_irq&lt;br /&gt;
UART console&lt;br /&gt;
              |&amp;mdash;- Virtual terminal &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; VT console&lt;br /&gt;
              |                 | &amp;ndash; VT console&lt;br /&gt;
              |&amp;mdash;-&lt;br /&gt;
        Terminal&amp;ndash;|&lt;br /&gt;
              |&amp;mdash;-&lt;/p&gt;

&lt;h1 id=&#34;what-about-console:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;What about console?&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;early_con&lt;br /&gt;
start_kernel or setup_arch(arm)-&amp;gt;parse_early_param-&amp;gt;do_early_param-&amp;gt;p-&amp;gt;setup_func()= setup_early_printk-&amp;gt;register_console&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;vga_con&lt;br /&gt;
start_kerenl-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
// All about vga console&lt;br /&gt;
set_arch-&amp;gt; conswitchp = &amp;amp;vga_con; or conswitchp = &amp;amp;dummy_con;&lt;br /&gt;
console_init-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
        tty_ldisc_begin-&amp;gt;tty_register_ldisc(N_TTY, &amp;amp;tty_ldisc_N_TTY);&lt;br /&gt;
    console_initcall(con_init);&lt;br /&gt;
console_initcall(serial8250_console_init)&lt;br /&gt;
    con_init-&amp;gt;&lt;br /&gt;
    {&lt;br /&gt;
        // vc-&amp;gt;vc_sw-&amp;gt;con_putcs is DUMMY&lt;br /&gt;
        //内存映射64KB or 32KB的VGA区域. 启动VGA&lt;br /&gt;
        conswitchp-&amp;gt;con_startup = vgacon_startup -&amp;gt;vga_vram_base = VGA_MAP_MEM(vga_vram_base, vga_vram_size);&lt;br /&gt;
        con_driver_map[0~MAX_NR_CONSOLES] = conswitchp; //空间换时间&lt;br /&gt;
        // 核心内容!&lt;br /&gt;
        for (currcons = 0; currcons &amp;lt; MIN_NR_CONSOLES; currcons++) {&lt;br /&gt;
            // 给vc_cons[currcons].d分配内存&lt;br /&gt;
            vc_cons[currcons].d = vc = kzalloc(sizeof(struct vc_data), GFP_NOWAIT);&lt;br /&gt;
            INIT_WORK(&amp;amp;vc_cons[currcons].SAK_work, vc_SAK);&lt;br /&gt;
            //初始化vc_cons[currcons].d&lt;br /&gt;
            tty_port_init(&amp;amp;vc-&amp;gt;port);&lt;br /&gt;
            // 继续初始化, 主要是确定screenbuf size&lt;br /&gt;
            visual_init(vc, currcons, 1);&lt;br /&gt;
            // 给vc_screenbuf分配内存&lt;br /&gt;
            vc-&amp;gt;vc_screenbuf = kzalloc(vc-&amp;gt;vc_screenbuf_size, GFP_NOWAIT);&lt;br /&gt;
            vc_init(vc, vc-&amp;gt;vc_rows, vc-&amp;gt;vc_cols,&lt;br /&gt;
                currcons || !vc-&amp;gt;vc_sw-&amp;gt;con_save_screen);&lt;br /&gt;
        }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    [    0.000000] Console: colour VGA+ 80x25
    register_console(&amp;amp;vt_console_driver);//vt_console can use vgacon writing.
}
serial8250_console_init-&amp;gt;register_console(&amp;amp;serial8250_console) to console_drivers; exclusive_console.
[    0.000000] console [tty0] enabled
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
module_init(serial8250_init);??&lt;br /&gt;
}&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;fbcon&lt;br /&gt;
register_framebuffer-&amp;gt; do_take_over_console -&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
do_register_con_driver-&amp;gt;csw-&amp;gt;con_startup();registered_con_driver&lt;br /&gt;
do_bind_con_driver -&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    [    3.882220] Console: switching to colour dummy device 80x25&lt;br /&gt;
    [    4.720732] Console: switching to colour frame buffer device 170x48&lt;br /&gt;
}&lt;br /&gt;
}&lt;/p&gt;

&lt;h2 id=&#34;vga-text-console-printk-write:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;VGA text console printk &amp;amp; write&lt;/h2&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;kernel space&lt;br /&gt;
printk-&amp;gt; &amp;hellip;-&amp;gt;log_buf&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;userspace for ttyN&lt;br /&gt;
tty_fops-&amp;gt;write=tty_write-&amp;gt; tty_ldisc_N_TTY-&amp;gt;write=n_tty_write-&amp;gt; tty_driver-&amp;gt;ops=con_ops-&amp;gt;write=con_write-&amp;gt;do_con_write&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;agent&lt;br /&gt;
console_drivers-&amp;gt;vt_console_driver-&amp;gt;serial8250_console-&amp;gt;NULL&lt;br /&gt;
console_unlock-&amp;gt;..-&amp;gt;__call_console_drivers-&amp;gt; console_drivers-&amp;gt;write = vt_console_print&lt;br /&gt;
{&lt;br /&gt;
//保存到screen buf, vga_con也什么不做啊.&lt;br /&gt;
scr_writew((vc-&amp;gt;vc_attr &amp;lt;&amp;lt; 8) + c, (unsigned short *)vc-&amp;gt;vc_pos);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;h1 id=&#34;what-about-tty:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;What about tty&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;onset&lt;br /&gt;
console_init-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
tty_ldisc_begin-&amp;gt;tty_register_ldisc(N_TTY, &amp;amp;tty_ldisc_N_TTY);&lt;br /&gt;
console_initcall(con_init);&lt;br /&gt;
console_initcall(serial8250_console_init)&lt;br /&gt;
}&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;N_TTY:&lt;a href=&#34;http://www.linux.it/~rubini/docs/serial/serial.html&#34;&gt;Serial Drivers by Alessandro Rubini&lt;/a&gt;&lt;br /&gt;
fs_initcall:chr_dev_init-&amp;gt;drivers/tty/tty_io.c: tty_init-&amp;gt;&lt;br /&gt;
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* /dev/tty0 = /dev/console console_ops */
/* /dev/tty = the /dev/ttyN whererun echo /dev/tty tty_ops */

//&amp;quot;/dev/tty&amp;quot;,
cdev_init(&amp;amp;tty_cdev, &amp;amp;tty_fops);
&amp;quot;/dev/console&amp;quot;
cdev_init(&amp;amp;console_cdev, &amp;amp;console_fops);
vty_init-&amp;gt;
{
    //&amp;quot;dev/tty0&amp;quot;    
    cdev_init(&amp;amp;vc0_cdev, console_fops); 
    //&amp;quot;/dev/ttyN&amp;quot;
    tty_register_driver-&amp;gt;
    {
        // What does tty_register_driver do ?
        // Alloc and register chr dev region.
        // Add cdev with tty_ops and above region.
        // Register tty device
        // Why do we register tty devices?
        // These devices must be used in some place.
        // After registering itself, the driver registers the devices it controls through the tty_register_device function. 
        // 原来是把major 和minor做成dev_t放到driver-&amp;gt;cdevs[index].dev里面了.
        // 也就是说driver-&amp;gt;cdevs[index]就是tty driver控制的device啊, 怪不得cdev_init(&amp;amp;driver-&amp;gt;cdevs[index], &amp;amp;tty_fops);
        // 那么看来用到的时候就是open了, 竟然没有不过有个tty_get_device用了tty_class
        // tty_register_device_attr-&amp;gt;device_register-&amp;gt;device_add-&amp;gt;klist_add_tail(&amp;amp;dev-&amp;gt;knode_class,&amp;amp;dev-&amp;gt;class-&amp;gt;p-&amp;gt;klist_devices)
        // 果然是在open tty-&amp;gt;dev = tty_get_device(tty);在alloc_tty_struct
        // 不知道这个tty-&amp;gt;dev在哪里用, 不管他了.
        tty_register_device(_attr) -&amp;gt;tty_cdev_add-&amp;gt; cdev_init(&amp;amp;driver-&amp;gt;cdevs[index], &amp;amp;tty_fops);
    }
    kbd_init
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
device_init:serial8250_init-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    // In this function we decide &amp;ldquo;/dev/ttyS*&amp;rdquo;&lt;br /&gt;
    // dmesg |grep Serial&lt;br /&gt;
    // [    0.696341] Serial: &lt;sup&gt;8250&lt;/sup&gt;&amp;frasl;&lt;sub&gt;16550&lt;/sub&gt; driver, 32 ports, IRQ sharing enabled&lt;br /&gt;
    // serial8250.c -&amp;gt; tty_io.c&lt;br /&gt;
    serial8250_reg.nr = UART_NR;&lt;br /&gt;
    ret = uart_register_driver(&amp;amp;serial8250_reg);&lt;br /&gt;
    tty_driver set to uart_driver by uart_register_driver -&amp;gt;&lt;br /&gt;
    {&lt;br /&gt;
        drv-&amp;gt;state = kzalloc        //uart_state&lt;br /&gt;
        normal-&amp;gt;driver_state    = drv; //args struct uart_driver *drv = &amp;amp;serial8250_reg&lt;br /&gt;
        tty_set_operations(normal, &amp;amp;uart_ops);&lt;br /&gt;
        struct tty_port &lt;em&gt;port = &amp;amp;state-&amp;gt;port&lt;br /&gt;
        tty_port_init(port);&lt;br /&gt;
        port-&amp;gt;ops = &amp;amp;uart_port_ops; //tty_port&lt;br /&gt;
        // We register &amp;ldquo;/dev/ttyS&lt;/em&gt;&amp;rdquo; files here.&lt;br /&gt;
        static struct uart_driver serial8250_reg = {&lt;br /&gt;
            .owner                  = THIS_MODULE,&lt;br /&gt;
            .driver_name            = &amp;ldquo;serial&amp;rdquo;,&lt;br /&gt;
            .dev_name               = &amp;ldquo;ttyS&amp;rdquo;,&lt;br /&gt;
            .major                  = TTY_MAJOR,&lt;br /&gt;
            .minor                  = 64,&lt;br /&gt;
            .cons                   = SERIAL8250_CONSOLE,&lt;br /&gt;
        };&lt;br /&gt;
        retval = tty_register_driver(normal); -&amp;gt; register_chrdev_region(dev, driver-&amp;gt;num, driver-&amp;gt;name) //32, ttyS?*? should be tty_ops&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;}
serial8250_register_ports(&amp;amp;serial8250_reg, &amp;amp;serial8250_isa_devs-&amp;gt;dev);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
* nucleus&lt;br /&gt;
tty_write-&amp;gt;ld-&amp;gt;ops-&amp;gt;write=n_tty_write-&amp;gt;(tty_struct tty-&amp;gt;ops-&amp;gt;write)=uart_write-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    struct uart_state *state = tty-&amp;gt;driver_data;&lt;br /&gt;
    port = state-&amp;gt;uart_port;&lt;br /&gt;
    circ = &amp;amp;state-&amp;gt;xmit;&lt;br /&gt;
    memcpy(circ-&amp;gt;buf + circ-&amp;gt;head, buf, c);&lt;br /&gt;
    uart_start-&amp;gt;__uart_start-&amp;gt;(uart_port-&amp;gt;ops-&amp;gt;start_tx(port)); //&amp;amp;uart_port_ops ?? uart_ops??&lt;br /&gt;
}&lt;/p&gt;

&lt;h1 id=&#34;what-about-pseudoterminal:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;What about Pseudoterminal&lt;/h1&gt;

&lt;p&gt;/dev/ptmx is the &amp;ldquo;pseudo-terminal master multiplexer&amp;rdquo;. from wikipedia&lt;br /&gt;
static struct tty_driver *ptm_driver;&lt;br /&gt;
static struct tty_driver *pts_driver;&lt;br /&gt;
module_init(pty_init)-&amp;gt;unix98_pty_init-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    tty_set_operations(ptm_driver, &amp;amp;ptm_unix98_ops);&lt;br /&gt;
    tty_register_driver(ptm_driver)&lt;br /&gt;
    tty_set_operations(pts_driver, &amp;amp;pty_unix98_ops);&lt;br /&gt;
    tty_register_driver(pts_driver)&lt;br /&gt;
    ptmx_fops = tty_fops;&lt;br /&gt;
    ptmx_fops.open = ptmx_open;&lt;br /&gt;
    cdev_init(&amp;amp;ptmx_cdev, &amp;amp;ptmx_fops);&lt;br /&gt;
}&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;How to use ptmx?&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;tty-drivers:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;tty drivers&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;cat /proc/tty/drivers&lt;br /&gt;
/dev/tty             /dev/tty        5       0 system:/dev/tty&lt;br /&gt;
/dev/console         /dev/console    5       1 system:console&lt;br /&gt;
/dev/ptmx            /dev/ptmx       5       2 system&lt;br /&gt;
/dev/vc/0            /dev/vc/0       4       0 system:vtmaster&lt;br /&gt;
usbserial            /dev/ttyUSB   188 0-511 serial&lt;br /&gt;
serial               /dev/ttyS       4 64-95 serial&lt;br /&gt;
pty_slave            /dev/pts      136 0-1048575 pty:slave&lt;br /&gt;
pty_master           /dev/ptm      128 0-1048575 pty:master&lt;br /&gt;
unknown              /dev/tty        4 1-63 console&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;question:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;Question?&lt;/h1&gt;

&lt;p&gt;what is /dev/vcs?&lt;/p&gt;

&lt;h1 id=&#34;backup:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;Backup&lt;/h1&gt;

&lt;p&gt;./drivers//tty/vt/vt.c:3042:        register_chrdev_region(MKDEV(TTY_MAJOR, 0), 1, &amp;ldquo;/dev/vc/0&amp;rdquo;) &amp;lt; 0)&lt;br /&gt;
./drivers//tty/vt/vc_screen.c:644:  if (register_chrdev(VCS_MAJOR, &amp;ldquo;vcs&amp;rdquo;, &amp;amp;vcs_fops))&lt;br /&gt;
./drivers//tty/tty_io.c:3377:       error = register_chrdev_region(dev, driver-&amp;gt;num, driver-&amp;gt;name);&lt;br /&gt;
./drivers//tty/tty_io.c:3414:   unregister_chrdev_region(dev, driver-&amp;gt;num);&lt;br /&gt;
./drivers//tty/tty_io.c:3430:   unregister_chrdev_region(MKDEV(driver-&amp;gt;major, driver-&amp;gt;minor_start),&lt;br /&gt;
./drivers//tty/tty_io.c:3607:       register_chrdev_region(MKDEV(TTYAUX_MAJOR, 0), 1, &amp;ldquo;/dev/tty&amp;rdquo;) &amp;lt; 0)&lt;br /&gt;
./drivers//tty/tty_io.c:3613:       register_chrdev_region(MKDEV(TTYAUX_MAJOR, 1), 1, &amp;ldquo;/dev/console&amp;rdquo;) &amp;lt; 0)&lt;br /&gt;
./drivers//tty/pty.c:841:       register_chrdev_region(MKDEV(TTYAUX_MAJOR, 2), 1, &amp;ldquo;/dev/ptmx&amp;rdquo;) &amp;lt; 0)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>System booting</title>
      <link>http://firoyang.org/cs/boot/</link>
      <pubDate>Thu, 12 Nov 2015 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/boot/</guid>
      <description>

&lt;h1 id=&#34;reference:4ccc61562af88da39fe562fcf76d50be&#34;&gt;Reference&lt;/h1&gt;

&lt;h1 id=&#34;contents:4ccc61562af88da39fe562fcf76d50be&#34;&gt;Contents&lt;/h1&gt;

&lt;p&gt;What basic initializations should be perfomed when power on?&lt;br /&gt;
How do we load the kernel to memory?&lt;br /&gt;
What does kernel do when kernel boot.&lt;br /&gt;
MBR vs BIOS?&lt;br /&gt;
PC vs embedded&lt;br /&gt;
Kernel init&lt;br /&gt;
before start_kernel&lt;br /&gt;
start_kernel&lt;br /&gt;
reset_init &amp;amp; kernel_init&lt;/p&gt;

&lt;h1 id=&#34;p4080-board:4ccc61562af88da39fe562fcf76d50be&#34;&gt;p4080 Board&lt;/h1&gt;

&lt;p&gt;PBL&lt;br /&gt;
1. initialize I2C, SPI, eLBC, eSDHC.&lt;br /&gt;
2. Load RCW and boot init commands from above.&lt;br /&gt;
3. write date to conf register and memory&lt;/p&gt;

&lt;h1 id=&#34;config:4ccc61562af88da39fe562fcf76d50be&#34;&gt;config&lt;/h1&gt;

&lt;p&gt;CCSRBAR -&amp;gt; CCSR&lt;br /&gt;
default is 0x0_FE00_0000&lt;br /&gt;
CCSRBAR is in CCSR memory. odd. stored in 0(CCSRBAR).&lt;br /&gt;
CCSRBAR always points to itself.&lt;br /&gt;
holdoff&lt;/p&gt;

&lt;h1 id=&#34;u-boot:4ccc61562af88da39fe562fcf76d50be&#34;&gt;u-boot&lt;/h1&gt;

&lt;p&gt;ft_fixup_cpu -&amp;gt; determine_mp_bootpg(NULL) &amp;amp; fdt_add_mem_rsv&lt;/p&gt;

&lt;p&gt;main_loop-&amp;gt; &amp;hellip;-&amp;gt;./common/bootm_os.c:410:&amp;hellip; do_bootm_states-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
bootm_find_other-&amp;gt;bootm_find_ramdisk_fdt-&amp;gt;bootm_find_fdt-&amp;gt;boot_get_fdt&amp;amp;set_working_fdt_addr(0x0200000)-&amp;gt;IMAGE_FORMAT_FIT-&amp;gt;&lt;br /&gt;
&amp;amp;&lt;br /&gt;
boot_fn = bootm_os_get_boot_func(images-&amp;gt;os.os)=[IH_OS_LINUX] =&lt;br /&gt;
&amp;amp;&lt;br /&gt;
boot_selected_os-&amp;gt;boot_fn=do_bootm_linux-&amp;gt;boot_body_linux-&amp;gt;image_setup_linux-&amp;gt;image_setup_libfdt-&amp;gt;&lt;br /&gt;
board/freescale/corenet_ds/corenet_ds.c ft_board_setup-&amp;gt; ft_cpu_setup-&amp;gt;&lt;br /&gt;
}&lt;/p&gt;

&lt;h1 id=&#34;ppc-multicore-booting:4ccc61562af88da39fe562fcf76d50be&#34;&gt;PPC multicore booting&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;There are two possibilites to make secondary cores booting failed.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;There is a bug in the code executed by Secondary cores&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;The spin table address, passed to croe0, is not correct, so we did not really kick the secondary cores.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CCSRBAR&lt;br /&gt;
MPC86xx_MCM_OFFSET&lt;br /&gt;
srio_boot_master_release_slave&lt;/p&gt;

&lt;p&gt;uboot-&amp;gt;&lt;br /&gt;
set the cpu-release-addr at funciton ft_fixup_cpu(), I am not sure.&lt;/p&gt;

&lt;p&gt;core0 run, 2nd cores holdoff&lt;br /&gt;
core0 set BPTR and kick(BRR) 2nd cores, 2nd cores spintable loop in uboot function setup_mp&lt;br /&gt;
core0 -&amp;gt; arch/powerpc/cpu/mpc85xx/start.S-&amp;gt;_start_e500&lt;br /&gt;
board_init_r-&amp;gt;cpu_init_r-&amp;gt; setup_mp-&amp;gt; {&lt;br /&gt;
&lt;strong&gt;bootpg_addr = (u32)virt_to_phys(&amp;amp;&lt;/strong&gt;second_half_boot_page); //Assembly code for put core to spin tablea. Used by __secondary_start_page&lt;br /&gt;
__spin_table_addr = (u32)get_spin_phys_addr();// used by __second_half_boot_page&lt;br /&gt;
bootpg = BPTR = __secondary_start_page&lt;br /&gt;
plat_mp_up-&amp;gt;kick BRR &amp;amp; Boot Space Translation&lt;br /&gt;
}&lt;br /&gt;
2nd cores holdoff -&amp;gt; &lt;strong&gt;secondary_start_page&lt;br /&gt;
kernel-&amp;gt;&lt;br /&gt;
core0 boot kernel, core0 kickoff 2nd cores spintable, triger 2nd core&amp;rsquo;s spin table by writing  the spin table field with the desired address&lt;br /&gt;
2nd cores ePAPR-&amp;gt;spintable-&amp;gt;addr_l=&lt;/strong&gt;early_start-&amp;gt;__secondary_start-&amp;gt;smp_ops-&amp;gt;setup_cpu-&amp;gt;cpu_idle&lt;br /&gt;
arch/powerpc/kernel/head_fsl_booke.S&lt;br /&gt;
U-boot logs:&lt;br /&gt;
Reserving MP boot page to 7ffff000^M^M - &amp;ndash;   -   MP spin table&lt;br /&gt;
address.&lt;br /&gt;
SPAG : fdt_fixup_fman_firmware, 567^M^M&lt;br /&gt;
^M^M&lt;br /&gt;
..r.^M^M&lt;br /&gt;
VDBG : ft_cpu_setup, 737, comment fdt_fixup_memory ^M^M&lt;br /&gt;
VDBG: Secondary cores are not held in reset.^M^M&lt;br /&gt;
Kernel Logs:&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 1 to ack^M^M&lt;br /&gt;
smp: failed starting cpu 1 (rc -2)^M^M&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 2 to ack^M^M&lt;br /&gt;
smp: failed starting cpu 2 (rc -2)^M^M&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 3 to ack^M^M&lt;br /&gt;
smp: failed starting cpu 3 (rc -2)^M^M&lt;br /&gt;
Brought up 1 CPUs^M^M&lt;br /&gt;
devtmpfs: initialized^M^M&lt;/p&gt;

&lt;p&gt;Note that u-boot can&amp;rsquo;t detect  memory above 2G and we need to check&lt;br /&gt;
if kernel is accessing at high mem of 2G or 4G.&lt;/p&gt;

&lt;p&gt;Here are the logs..&lt;/p&gt;

&lt;p&gt;I printed pa in %lx since the outout of &lt;strong&gt;pa(&lt;/strong&gt;early_start) is in long unsigned int.&lt;/p&gt;

&lt;p&gt;Firo:cpu nr1 release addr c3fe352c, spin_table c000003f, ioremmappable 0&lt;br /&gt;
Firo: kernel origin spin tbale addr_l a63b2000, pir 57cc802, resv 480000, r3 3ae000, pa 50&lt;br /&gt;
Firo: kernel update spin tbale addr_l 50, pir 1, resv 480000, r3 3ae000&lt;br /&gt;
Firo: kernel timeout spin tbale addr_l 50, pir 1, resv 480000, r3 3ae000&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 1 to ack&lt;br /&gt;
smp: failed starting cpu 1 (rc -2)&lt;br /&gt;
Firo:cpu nr2 release addr c3fe3740, spin_table c000007f, ioremmappable 0&lt;br /&gt;
Firo: kernel origin spin tbale addr_l a654e7af, pir a654e780, resv 387cf99a, r3 3408200, pa 50&lt;br /&gt;
Firo: kernel update spin tbale addr_l 50, pir 2, resv 387cf99a, r3 3408200&lt;br /&gt;
Firo: kernel timeout spin tbale addr_l 50, pir 2, resv 387cf99a, r3 3408200&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 2 to ack&lt;br /&gt;
smp: failed starting cpu 2 (rc -2)&lt;br /&gt;
Firo:cpu nr3 release addr c3fe3954, spin_table c00000bf, ioremmappable 0&lt;br /&gt;
Firo: kernel origin spin tbale addr_l 247cf09a, pir 7cf19b, resv a664e740, r3 3e7cf19a, pa 50&lt;br /&gt;
Firo: kernel update spin tbale addr_l 50, pir 3, resv a664e740, r3 3e7cf19a&lt;br /&gt;
Firo: kernel timeout spin tbale addr_l 50, pir 3, resv a664e740, r3 3e7cf19a&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 3 to ack&lt;br /&gt;
smp: failed starting cpu 3 (rc -2)&lt;br /&gt;
I don’t see the following print in u-boot..&lt;br /&gt;
 69                                 fdt_setprop(blob, off, &amp;ldquo;cpu-release-addr&amp;rdquo;,&lt;br /&gt;
 70                                                 &amp;amp;val, sizeof(val));&lt;br /&gt;
+ printf(&amp;ldquo;Firo u-boot:cpu release addr %p, value %x\n&amp;rdquo;, &amp;amp;val, val);&lt;/p&gt;

&lt;p&gt;Firo:cpu nr1 release addr c3fe352c, spin_table c000003f, ioremmappable 0&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 1 to ack&lt;br /&gt;
smp: failed starting cpu 1 (rc -2)&lt;br /&gt;
Firo:cpu nr2 release addr c3fe3740, spin_table c000007f, ioremmappable 0&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 2 to ack&lt;br /&gt;
smp: failed starting cpu 2 (rc -2)&lt;br /&gt;
Firo:cpu nr3 release addr c3fe3954, spin_table c00000bf, ioremmappable 0&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 3 to ack&lt;br /&gt;
smp: failed starting cpu 3 (rc -2)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Light camera action - compile link load</title>
      <link>http://firoyang.org/cs/build/</link>
      <pubDate>Sun, 25 Oct 2015 01:46:28 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/build/</guid>
      <description>

&lt;h1 id=&#34;reference:aba878e576894cc4457876fdf276811e&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.tenouk.com/ModuleW.html&#34;&gt;compiler, assembler, linker and loader: a brief story&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;contents:aba878e576894cc4457876fdf276811e&#34;&gt;Contents&lt;/h1&gt;

&lt;p&gt;Why complier can manipulate the address of vriables?&lt;br /&gt;
What is the address in lds(??) file?&lt;/p&gt;

&lt;h1 id=&#34;build-automation:aba878e576894cc4457876fdf276811e&#34;&gt;Build automation&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Make&lt;br /&gt;
make cynthia&lt;/p&gt;

&lt;h2 id=&#34;kbuild:aba878e576894cc4457876fdf276811e&#34;&gt;kbuild&lt;/h2&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;if no .config, every config tools make a .config from scrach!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;oldconfig just for new moduels patch merged in trunk. This no any relations to .config.old and /boot/config.x.y.z&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;make localmodconfig will reduce many unused kernel config.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;make bzImage  #kmods will not build that configured with M!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;make modules_install INSTALL_MOD_PATH=/home/firo/kmods&lt;/p&gt;

&lt;h2 id=&#34;yocto:aba878e576894cc4457876fdf276811e&#34;&gt;yocto&lt;/h2&gt;

&lt;p&gt;make ARCH=arm menuconfig&lt;br /&gt;
##build signle kernel module&lt;br /&gt;
make menuconfig&lt;br /&gt;
make oldconfig &amp;amp;&amp;amp; make prepare&lt;br /&gt;
make -C $(pwd) M=/home/firo/linux/fs/ext3 modules V=1&lt;br /&gt;
make ARCH=arm CROSS_COMPILE=/usr/bin/arm-linux-gnu- drivers/pcmcia/sa11xx_base.o&lt;/p&gt;

&lt;h1 id=&#34;compile-construction:aba878e576894cc4457876fdf276811e&#34;&gt;Compile construction&lt;/h1&gt;

&lt;p&gt;Understand pl deeply&lt;br /&gt;
how to translate it into machine code for specific CPU&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;gcc&lt;br /&gt;
-E -S -c&lt;br /&gt;
-I -L -l&lt;br /&gt;
-ansi&lt;br /&gt;
-fsyntax-only&lt;br /&gt;
-Werror&lt;br /&gt;
-save-temps&lt;br /&gt;
-H: show all header used&lt;br /&gt;
-v&lt;br /&gt;
-Wall&lt;br /&gt;
-fPIC: for shared library&lt;br /&gt;
-Q: print function and statisc?&lt;br /&gt;
-Wextra: 用处不大.&lt;br /&gt;
-U: undefine a preprocessor macro.&lt;br /&gt;
-pipe: make compilation faster, replace xx.S with |&lt;br /&gt;
-Wpadded: we can rearrange the fields of structure to make the structure smaller&lt;br /&gt;
-time&lt;br /&gt;
-x c: c language&lt;br /&gt;
-: stdin&lt;br /&gt;
asmlinkage&lt;br /&gt;
However, for C functions invoked from assembly code,&lt;br /&gt;
we should explicitly declare the function&amp;rsquo;s calling convention,&lt;br /&gt;
because the parameter passing code in assembly side has been fixed.&lt;br /&gt;
Show all predefined macros for your compiler&lt;br /&gt;
gcc -dM -E -x c /dev/null&lt;br /&gt;
##&lt;a href=&#34;http://www.stlinux.com/devel/debug/jtag/build?q=node/82&#34;&gt;Generating optimized code&lt;/a&gt;&lt;br /&gt;
##Symbol table&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;System.map less&lt;br /&gt;
When you compile the kernel&lt;br /&gt;
nm vmlinux&lt;br /&gt;
readelf -s&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;/proc/kallsyms&lt;/p&gt;

&lt;h1 id=&#34;link:aba878e576894cc4457876fdf276811e&#34;&gt;Link&lt;/h1&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;GNU ld&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;gold&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>My reading list of computer science</title>
      <link>http://firoyang.org/review/reading_list/</link>
      <pubDate>Wed, 14 Oct 2015 14:09:57 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/review/reading_list/</guid>
      <description>

&lt;p&gt;I think you should check my The Organization of Knowledgs&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Programming:&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&#34;http://sarabander.github.io/sicp/&#34;&gt;SICP&lt;/a&gt;&lt;br /&gt;
The science of programming&lt;/p&gt;

&lt;h1 id=&#34;computer-science:0d6d2ff91b088c0d630e79146323ef87&#34;&gt;Computer science&lt;/h1&gt;

&lt;p&gt;Code: The hidden language of computer hardware and software&lt;br /&gt;
Digital Design and Computer Architecture 2nd Edition&lt;/p&gt;

&lt;p&gt;未看口碑好:&lt;br /&gt;
Computer Organization and Design, Fifth Edition&lt;br /&gt;
ARM System-on-Chip Architecture (2nd Edition)&lt;/p&gt;

&lt;h1 id=&#34;philosophy:0d6d2ff91b088c0d630e79146323ef87&#34;&gt;Philosophy&lt;/h1&gt;

&lt;p&gt;普通认识论 &amp;ndash; Moritz Schlick&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Computer architecture</title>
      <link>http://firoyang.org/cs/arch/</link>
      <pubDate>Tue, 13 Oct 2015 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/arch/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Linux time subsystem</title>
      <link>http://firoyang.org/kernel/time/</link>
      <pubDate>Tue, 22 Sep 2015 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/kernel/time/</guid>
      <description>

&lt;p&gt;我写作的主要目的是理清基本概念与原理, 而非实现,细节这一类.&lt;/p&gt;

&lt;p&gt;时间是人类发明出来的概念, Kant也认为时间是心智概念.&lt;br /&gt;
一百年前的世界和现在有什么不同呢?这个提问揭示生活中时间最重要的用途,&lt;br /&gt;
*标记*某中状态下的世界. 所谓的过去世界不过是世界的一个个连续状态&lt;br /&gt;
那么时空穿越, 就变成了保住项少龙这个肉身不变, 世界的其他部分完全&lt;br /&gt;
转变到过去的某一个状态. 而所谓现在世界就被抹杀了.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The future is already here – it&#39;s just not evenly distributed.
                        — William Gibson
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;人想回到&amp;rdquo;过去&amp;rdquo;多半源于情感因素, 而想去&amp;rdquo;未来&amp;rdquo;则是因为&amp;rdquo;物质&amp;rdquo;的缘故.&lt;br /&gt;
想象下中国的未来50年, 很可能是现在美国or西欧现在的样子.虽然中西虽然处在&lt;br /&gt;
时间概念上相同的现在, 而物质世界确实&amp;rdquo;过去&amp;rdquo;和&amp;rdquo;未来&amp;rdquo;之差.&lt;/p&gt;

&lt;p&gt;比如我们下周而要开会, 那么此时下周二就是有意识的规划未来, 时间依然是标记.&lt;br /&gt;
UTC/GMT&lt;br /&gt;
Based on caesium microwave atomic clock&lt;br /&gt;
Leap second&lt;/p&gt;

&lt;h2 id=&#34;genus-differentia-definition:eefdcd66b28c2b86ef84bba398f2d59a&#34;&gt;Genus-differentia definition&lt;/h2&gt;

&lt;p&gt;interrupt, clock event,  clock source, tick, timer, timekeeping, gettimeofday.&lt;/p&gt;

&lt;h2 id=&#34;功用定义:eefdcd66b28c2b86ef84bba398f2d59a&#34;&gt;功用定义&lt;/h2&gt;

&lt;p&gt;获取时间&lt;br /&gt;
timer&lt;br /&gt;
sleep ?&lt;br /&gt;
update sched info&lt;/p&gt;

&lt;h2 id=&#34;发生定义-设计-etymology-history-operational-definition:eefdcd66b28c2b86ef84bba398f2d59a&#34;&gt;发生定义/设计   etymology, history Operational definition&lt;/h2&gt;

&lt;p&gt;timekeeping/计时:时刻．&lt;br /&gt;
clock source: 时间之源, 表针之力.&lt;br /&gt;
clock event: 闹铃之力, 经过tick展现能力.&lt;br /&gt;
tick: timer的中断事件叫tick, tick device产生tick, 可以说tick决定了clock_event event_handler进而决定了, clock_event行为.&lt;br /&gt;
tickless:&lt;br /&gt;
for timer: use HW timer one shot, set next.&lt;br /&gt;
for update time: in above HW timer, not good&lt;br /&gt;
for sched: for priority distributed in time slice, use timer.&lt;br /&gt;
dynamic tick/no HZ:&lt;br /&gt;
No HZ in idle&lt;br /&gt;
No HZ while only 1 process running for HPC.&lt;br /&gt;
tick devies 就是clock event包了层虎皮.&lt;br /&gt;
tick broadcast framework:  based on tick device&lt;br /&gt;
clock: 可记录时间, 表盘.利用timekeeping&lt;br /&gt;
timer: use clock. what about timer_list?&lt;br /&gt;
timer_list: do in softirq&lt;br /&gt;
* timekeeping aspect&lt;br /&gt;
onset: start_kernel -&amp;gt; timekeeping_init &amp;amp; time_init &amp;amp;(rest_init-&amp;gt; kernel_init-&amp;gt; \&lt;br /&gt;
kernel_init_freeable-&amp;gt;do_basic_setup-&amp;gt;do_initcalls&amp;ndash;device_initcall(init_clocksource_sysfs))&lt;br /&gt;
nucleus:used by clock see init_posix_timers and update_wall_time and sys_time&lt;br /&gt;
coda:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;clock source aspect&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;tick device layer aspect&lt;br /&gt;
per_cpu(tick_cpu_device, cpu)&lt;br /&gt;
onset: time_init-&amp;gt;mach-&amp;gt;init_time-&amp;gt;&amp;hellip;clockevents_register_device-&amp;gt;tick_check_new_device&lt;br /&gt;
nucleus: a38x_timer_interrupt-&amp;gt;a38x_clkevt.event_handler&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;tick broadcast framework&lt;br /&gt;
onset:&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;clock aspect&lt;br /&gt;
k_clock&lt;br /&gt;
onset:init_posix_timers &amp;amp; init_posix_cpu_timers&lt;br /&gt;
nucleus: 用户-&amp;gt; posix_clock-&amp;gt;timepkeeping-&amp;gt;clock_socurce&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;timer aspect&lt;br /&gt;
onset: open_softirq(HRTIMER_SOFTIRQ, run_hrtimer_softirq);&lt;br /&gt;
nucleus: common_timer_set&lt;br /&gt;
hrtimer_interrupt | (tick_handle_periodic-&amp;gt; tick_periodic-&amp;gt; update_process_times-&amp;gt;run_local_timers-&amp;gt;hrtimer_run_queues)-&amp;gt;__run_hrtimer-&amp;gt;timer.function = posix_timer_fn;(set in common_timer_set)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;计算机概念&lt;br /&gt;
system clock CLOCK_REALTIME CLOCK_MONOTONIC&lt;br /&gt;
time.h time_t=tm=timeval=timespec calendar time  clock_t&lt;/p&gt;

&lt;p&gt;clock event -&amp;gt; tick device-&amp;gt; handle function&lt;br /&gt;
clock event 相较于timer更为抽象, timer 是一种用途,timer 通过clock event来实现功能,&lt;br /&gt;
clock event 通过timer来体现自己, timer面向使用者的onset,&lt;br /&gt;
而clock event 则是偏向于nucleus and coda.&lt;br /&gt;
timer: 标记不能立即执行的变化.&lt;br /&gt;
clock source: 用一些整型抽象一个过程, 对于时间来说, 简直是完美的抽象.&lt;br /&gt;
* kernel requirement&lt;br /&gt;
linux的时间子系统要求硬件timer提供下面两种能力：&lt;br /&gt;
一是free running的counter，此外需要能够在指定的counter值上产生中断的能力。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Quantitative congnition - The philosophy on which I live</title>
      <link>http://firoyang.org/philosophy/philosophy/</link>
      <pubDate>Sun, 13 Sep 2015 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/philosophy/philosophy/</guid>
      <description>

&lt;p&gt;我正在常识建立一套量化认知体系. 为什么要做这件事? 无论是之于生命个体还是整个人类社会的演化总是依凭着对世界更深入,&lt;br /&gt;
更全面的认知. ? 正如Schlick 在General Theory of Knowledge 所言&amp;hellip; 而这种认知本身是什么呢? 在哲学上,&lt;br /&gt;
Epistemology专门研究这个问题. 而我继续前人的工作.&lt;br /&gt;
在过往的不断尝试中, 我体验与感悟到了, 这个世界很复杂, 不能有一些简单的规则来理解透.&lt;br /&gt;
多种不同的角度, 往往是理解事物最合宜的方法.&lt;/p&gt;

&lt;h1 id=&#34;framework-architecture-oracle-machine-万物皆备于我:007041aa20bf44bd43eba68b5f650c57&#34;&gt;Framework architecture: oracle-machine, 万物皆备于我&lt;/h1&gt;

&lt;p&gt;收集全面, 专业, 多样的书籍,论文等资料, 当然, 还会不断的学习实践过程中收集.&lt;br /&gt;
基于收集到的信息进行,分析.建立阶段性的理性状态和可接受的状态.&lt;br /&gt;
根据不同的状态, 定义问题(往往多个问题)&lt;br /&gt;
选取总结找到解决问题的模式过程(往往多种方法)&lt;br /&gt;
建立一个真实的实践环境, 在其中不断实践,体验.成长的主要步骤.&lt;br /&gt;
认识缺陷, 发现反馈不足, 尝试收集资料, 分析, 找寻方法, 实践,修正缺陷, 解决问题.成长.&lt;/p&gt;

&lt;h1 id=&#34;原则:007041aa20bf44bd43eba68b5f650c57&#34;&gt;原则&lt;/h1&gt;

&lt;p&gt;Reflexivity &amp;ndash; Soros&lt;br /&gt;
从实际问题触发, 实际的topic.&lt;br /&gt;
直达最可能的地方, 答案, 要事第一.&lt;br /&gt;
有机的知识.&lt;br /&gt;
将语言还原为日常生活及其形式.&amp;ndash; 维特根斯坦&lt;br /&gt;
Zeroness, 自己思考. 不要上来就读or做, 你要思考这个过程.&amp;ndash; Firo&lt;br /&gt;
方法简单容易, 方便证明是否有效&lt;br /&gt;
世界总是转换,不稳定,不确定.&lt;br /&gt;
Completeness, consistency, validity, soundness. &amp;ndash; Logic&lt;br /&gt;
Falsifiability可证伪性 &amp;ndash; Popper&lt;br /&gt;
批判性, 你所学的一切都是暂时性的,任何所学都有改口 驳斥 质疑的余地 &amp;ndash;Aaron Swartz,25:20&lt;br /&gt;
对于学习的知识上, 方法要做到知识之间的联系, 转换关系.&lt;br /&gt;
认知的缺陷, imperfect-understand, 彻底可错性. &amp;ndash;Firo Soros Popper&lt;/p&gt;

&lt;h1 id=&#34;收集:007041aa20bf44bd43eba68b5f650c57&#34;&gt;收集&lt;/h1&gt;

&lt;h1 id=&#34;分析:007041aa20bf44bd43eba68b5f650c57&#34;&gt;分析&lt;/h1&gt;

&lt;p&gt;Autonomous Change-of-state calculus &amp;ndash;Firo-Von Wright’s approach&lt;/p&gt;

&lt;p&gt;骨架和肉分析法 &amp;ndash; Firo&lt;/p&gt;

&lt;p&gt;祖孙的方法”   the genetic method &amp;ndash; 胡适,杜威&lt;br /&gt;
Why? How? What? Good and bad?&lt;/p&gt;

&lt;p&gt;从结构角度, 往往并不是所有简单元素都可以组合成复杂元素. 这也整个结构的缩影.&lt;br /&gt;
特别是简单元素和由简单元素合成的复杂元素却是平级的, 复合元素也成为了&amp;rdquo;简单元素&amp;rdquo;, 独立, 完整, 不可或缺的元素.&lt;br /&gt;
对于但从简单元素角度看, 有点哥德尔不完备定理的感觉.&lt;br /&gt;
比如英语的Collocation, 并不是掌握了基础就掌握了一切.&lt;/p&gt;

&lt;p&gt;从时间角度&lt;/p&gt;

&lt;p&gt;最重要的是什么呢?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;analysis computer program&lt;br /&gt;
init onset, running nuclus, exit coda&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;阶段目标与问题定义:007041aa20bf44bd43eba68b5f650c57&#34;&gt;阶段目标与问题定义&lt;/h1&gt;

&lt;p&gt;The phrased objectives&lt;br /&gt;
What is the important, foundation, most useful, minimal cached? &amp;ndash; Firo&lt;/p&gt;

&lt;p&gt;内涵定义: Genus-differentia definition 属加种差定义: 发生定义(设计), 关系定义, 功用定义, 摹状定义&lt;br /&gt;
充要定义, Real and nominal definitions&lt;br /&gt;
Classes of extensional definitions: enumerative definition&lt;br /&gt;
&lt;a href=&#34;http://plato.stanford.edu/entries/definitions/&#34;&gt;Definitions Stanford Encyclopedia of Philosophy&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;模式过程:007041aa20bf44bd43eba68b5f650c57&#34;&gt;模式过程&lt;/h1&gt;

&lt;p&gt;反射理论作为开始, 有机知识作为结果, feedback update 作为机制.&lt;br /&gt;
工作生活中的决断都现实的真实反馈而做出的.&lt;br /&gt;
费曼技巧可以部分地用来生成有机知识.&lt;br /&gt;
缺陷反馈更新, 可以以假设-验证的方式进行.假设自己全会了, 去想象那种感觉, 之后去实践验证.从而得出缺陷. 修补缺陷.&lt;br /&gt;
Experiential Learning, 两个难点, 实践的范围强度和谕示机.&lt;/p&gt;

&lt;p&gt;去看看别人怎么做的, 什么应该做, 什么不应该做.&lt;/p&gt;

&lt;p&gt;Divide every question into manageable parts. &amp;ndash; Descartes&lt;br /&gt;
Begin with the simplest issues and ascend to the more complex. &amp;ndash; Descartes&lt;br /&gt;
Review frequently enough to retain the whole argument at once &amp;ndash; Descartes&lt;br /&gt;
Accept as true only what is indubitable. &amp;ndash; Descartes&lt;/p&gt;

&lt;h1 id=&#34;实践:007041aa20bf44bd43eba68b5f650c57&#34;&gt;实践&lt;/h1&gt;

&lt;p&gt;建立一个全面的wilds环境, 在这个环境下生存!&lt;br /&gt;
活下去!&lt;/p&gt;

&lt;h1 id=&#34;反馈缺陷:007041aa20bf44bd43eba68b5f650c57&#34;&gt;反馈缺陷&lt;/h1&gt;

&lt;h1 id=&#34;本体系自身的反馈:007041aa20bf44bd43eba68b5f650c57&#34;&gt;本体系自身的反馈&lt;/h1&gt;

&lt;p&gt;成长来自实践, 以及认识缺陷并加以改正.&lt;br /&gt;
不断的实践和改正缺陷才是提高能力的核心!&lt;br /&gt;
很多时候, 依靠现在的经验学识不能找到完整的方法, 需要不断的调整.&lt;br /&gt;
学会认识自己的无力.&lt;br /&gt;
问题总是复杂的, 解决方法总是简单的.  &amp;ndash;xiaolai.li&lt;br /&gt;
反射理论, 反射的对象不是其他, 正是现实!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2016年4月第一周</title>
      <link>http://firoyang.org/lyubishchev/day-2016-04-07/</link>
      <pubDate>Tue, 25 Aug 2015 15:46:11 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/lyubishchev/day-2016-04-07/</guid>
      <description>&lt;p&gt;The man who staring at the abyss.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Firo</title>
      <link>http://firoyang.org/firo/firo/</link>
      <pubDate>Tue, 25 Aug 2015 15:46:11 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/firo/firo/</guid>
      <description>&lt;p&gt;一个人应该与外界的应该保持什么样的关系? 每个人都应该有自己的回答, 而且答案不一而终.&lt;br /&gt;
正是这种关系成就了我们的一生.个体如何确定这种关系,或者说如何确定一种合理的生存状态?&lt;br /&gt;
对于人类丰富, 无止尽的欲望而言, 很难给出统一的答案.然而这并不妨碍我们找到理想的状态.&lt;br /&gt;
简单说来, 两点; 那些来自内心的, 原始的, 本能的愿望正是我们生活的方向, 不应被忽视, 反而&lt;br /&gt;
要经常回忆起来, 并视若内心的珍宝一样对待; 另外, 我们应该做的是弥补生活中的不足, 以此来&lt;br /&gt;
向理想中的生活不断的迈进, 而不是沉醉于对理想的执着与等待中. 从实实在在的生活不足开始,&lt;br /&gt;
这才是真实的, 是你的生活.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;生活不在别处, 正是当下此地.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于世界一部分的个体, 充分的认识世界的运作机制, 成为确定自己生活状态的前提. 对于普通人&lt;br /&gt;
而言, 这似乎无从下手. 尤其是对于处在巨大生存压力下的人, 无暇顾及这般如同象牙塔式的问题?&lt;br /&gt;
我想这正是他们生活悲剧的根源之一. 对于了解这个世界, 实际上要简单许多. 我想, 只要你有意识&lt;br /&gt;
地在遇到困惑, 疑问, 艰难, 令人不适的生活的时候, 寻找这些问题背后的原因的时候, 答案便会出现.&lt;br /&gt;
而答案就是一种关系, 因果律. 同时连带得出关系的主客体. 比如, 49年后, 中国人都有一个潜在&lt;br /&gt;
的伟大的身份, 社会主义建造者.这是个体和国家之间的某种答案,在我出生之时, 变自动获得这种身份.&lt;br /&gt;
直到我意识到这种身份的存在时, 我毫不犹豫的放弃了它.因为我并不是一个社会主义者,&lt;br /&gt;
我打心眼里抵触社会主义, 我很难想象他的存在, 同时那样的社会对我来说是一种无声的恐惧,&lt;br /&gt;
因为他偏离人性的核心, 那样的社会下的生活, 我一点也不期待, 我已体验过了.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;显然, 在人与世界的诸多联系中, 有一些是被他人赋予, 而那些强制赋予的很多都成了枷锁.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于确定生命个体的合理生存状态, 可以看成找到你与世界现有的关系以及想要的某种关系.&lt;br /&gt;
首先, 我们要理清那些重要的关系. 可以说我的哲学就是建立在关系之上, 也就是因果律.&lt;br /&gt;
人总生活在关系中, 我认为下面的关系很重要.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;从个人角度, 越靠近真实, 越靠近真实, 不靠近就会远离. 这也是因果律的体现.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;即便你找不到期待中的生活状态，你也活在关系中, 这也是最基本的．&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;人生没有目标, 也要好好活着!&lt;br /&gt;
所有人都是某些东西的奴隶 &amp;ndash; 进击的巨人&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其他的规律：&lt;/p&gt;

&lt;p&gt;＞正反合&lt;br /&gt;
&amp;gt; 完整的逻辑,包含不存在&lt;br /&gt;
&amp;gt; 生活就是同傻逼的战争!&lt;br /&gt;
&amp;gt; 每个人都有自己内心的弱点, 不必害怕他们.&lt;br /&gt;
&amp;gt; 生长需要滋润.&lt;br /&gt;
&amp;gt; 成长开始于注意到缺陷, 疑问&lt;br /&gt;
&amp;gt; 很多时候其实我们的忙碌都是做着自己并不在乎的事情！&lt;br /&gt;
&amp;gt; 生命所不能承受之轻!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>My Career</title>
      <link>http://firoyang.org/firo/career/</link>
      <pubDate>Sun, 26 Jul 2015 15:46:11 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/firo/career/</guid>
      <description>

&lt;p&gt;无论是位高权重的政治家, 富贵显荣的商人, 亦或是蝇营狗苟的市侩之人等等, 所有芸芸众生&lt;br /&gt;
每日莫不是为了谋生而奔走. 长久的活着是一种负担.&lt;br /&gt;
忙碌的生活, 难以审视自己的人生. 今天坐下来, 谈谈这个话题.&lt;/p&gt;

&lt;p&gt;毫无已问, 从小到大, 即便是为曾到达的未来, 工作都占据了我们据大多数时间, 当然X二代&lt;br /&gt;
不在此列. 在这个社会, 即便每日辛劳的工作, 绝大多数人, 依然连自己卑微的梦想都无法实现.&lt;br /&gt;
今天, 我不谈政治层面的原因. 只想从个人角度, 去剖析人与工作之间的关系.&lt;/p&gt;

&lt;p&gt;英文&lt;a href=&#34;https://en.wikipedia.org/wiki/Career&#34;&gt;career&lt;/a&gt;, 在维基给出了基本的解释:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A career is an individual&#39;s journey through learning, work and other aspects of life.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;词源上是由马车引出的人生之路的涵义. 而中文, 生涯出自《庄子·养生主》：“吾生也有涯，而知也无涯。”&lt;br /&gt;
我们今天主要谈两个问题, 人生的马车和人生的&amp;rdquo;涯&amp;rdquo;.&lt;br /&gt;
我的职业生涯始于大学, 童年时期热爱电子游戏, 导致大学选择了计算机科学这个行业. 到今天整整过去了&lt;br /&gt;
7个年头, 不短了. 本人只敢自称勤奋之人, 大学伊始至今, 绝大多数时光都在勤奋治学, 未曾懈怠.&lt;br /&gt;
大学毕业三年, 依然没有实现自己当初的愿望, a remote kernel hacker. 这个目标完全是个人喜好, 性格使然.&lt;br /&gt;
同时也受限于我个人的视野.&lt;br /&gt;
1. 我喜欢自由, 所以不希望自己被束缚在办公室里面, 我期望那种一边旅行一边工作的生活.&lt;br /&gt;
所以纯个人脑力的工作是我的第一选择, programmer, 作家,都在此列, 而且我也很喜欢且擅长这样的工作.&lt;br /&gt;
2. 我喜欢开放的东西, 开源的软件就成了我的选择, kernel, openstack, 都是那时的选择.&lt;br /&gt;
3. 我喜欢有挑战的事情, 11年一起在sina实习的同学, 现在是openstack的remote开发者了,&lt;br /&gt;
当初我们一起去的, 我最后选择了kernel, 源于我认为kernel会更靠近计算机科学.&lt;br /&gt;
我对web相关的技术有偏见,觉得缺乏深度且很多与用户体验相关.&lt;br /&gt;
其实很多&lt;a href=&#34;http://careers.stackoverflow.com/jobs/remote&#34;&gt;职位&lt;/a&gt;都是可以remote的不限于open source的, 而且相对于&lt;br /&gt;
kernel和openstack的remote工作机会更多.&lt;br /&gt;
4. 我认为社会风气不好, 会对计算机这个行业有影响, 我更侧重选择纯技术的方向, 原理web, 具体业务.&lt;br /&gt;
这就是当时的思考, 当初的视野太狭隘了,主观臆断太严重.&lt;br /&gt;
这个时候薪资都不在考虑之列, 以为做喜欢的事就很开心了.&lt;br /&gt;
大学4年都在逃课, 专业知识, 都是仿照MIT和Computer ScienceCurriculum 2008自己设计出来的.&lt;br /&gt;
大学一年级, 看各种游戏的书,&lt;br /&gt;
大学二年级做机器人的比赛还有和艺术学院合作的事情,&lt;br /&gt;
大二下学期开始基础linux,看apue 还有unp这些书, 开始搞搜索引擎&lt;br /&gt;
大三的时候看了csapp, 还有组合数学&lt;br /&gt;
大四上学期基本上没干什么事, 10月份就去sina实习了, 下学期开始看内核.&lt;br /&gt;
虽然一直都很忙, 但是没学到什么东西.&lt;br /&gt;
我放弃了sina的offer, 毕业(12年7月)后整整有一年时间没有工作了.&lt;br /&gt;
一直到次年13年的9月才开始去极路由工作.到今年15年5月离职.&lt;br /&gt;
现在以外包的形式在windriver的ccm team 工作.&lt;br /&gt;
这就是我职业生涯的7年时光, 过得很坎坷.&lt;/p&gt;

&lt;h1 id=&#34;work-style:7e6e72851422b97b7259805ca91208dc&#34;&gt;Work style&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Plan the day.&lt;br /&gt;
What need to do.&lt;br /&gt;
Prioritization.&lt;br /&gt;
Focus on.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;yet-another-plan:7e6e72851422b97b7259805ca91208dc&#34;&gt;Yet another plan&lt;/h1&gt;

&lt;p&gt;English&lt;br /&gt;
Kernel patches 500 commits&lt;br /&gt;
Work achievement&lt;br /&gt;
Problem solving/pattern&lt;br /&gt;
FIXME in knowledge_map.md&lt;br /&gt;
Passport H1B Offer&lt;/p&gt;

&lt;h1 id=&#34;interview:7e6e72851422b97b7259805ca91208dc&#34;&gt;Interview&lt;/h1&gt;

&lt;h2 id=&#34;关于薪资问题:7e6e72851422b97b7259805ca91208dc&#34;&gt;关于薪资问题&lt;/h2&gt;

&lt;p&gt;全面回答包括股票期权.&lt;br /&gt;
real background.&lt;br /&gt;
期望的薪资别说太低, 往上也别说的太死, 比预期要高.&lt;br /&gt;
说更关注职业发展.&lt;/p&gt;

&lt;h2 id=&#34;想面试公司提出的问题:7e6e72851422b97b7259805ca91208dc&#34;&gt;想面试公司提出的问题&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;NO1. 我所应聘的这个职位为什么会出现空缺？&lt;br /&gt;
如果空, 空多长时间, 因为什么原因空的.&lt;br /&gt;
如果这个职位是新近才出现的，或许你就拥有了一个理想的、开辟属于自己的道路的机会。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;NO2. 请问贵公司最成功的员工为公司做出了什么样的贡献？&lt;br /&gt;
谁对公司贡献最大, 谁领导之类的, 做了什么? 有那些优秀品质. 了解公司文化.&lt;br /&gt;
面试管, 可能认为你是志在成功公司最优秀的员工之一.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;NO3.如何评估自己在三个月试用期内的工作表现？何种标准算成功？&lt;br /&gt;
该职位遇到的最大的挑战是什么?&lt;br /&gt;
了解公司做事风格, 是否稳重成熟. 排除不靠谱公司, 谁知道半年后他们&lt;br /&gt;
能干出什么? 谨慎对待抛出橄榄枝.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;NO5.目前公司所面对的最大的挑战有哪些？&lt;br /&gt;
这个编程比如说内核在公司的位置, 是否是中心.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;NO6.公司如何来保证人才不流失？&lt;br /&gt;
长期的意愿, 这个问题比较屌.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;NO7.请问您为什么要为这家公司工作呢？&lt;br /&gt;
连面试官自己都不知道为什么要为这家公司工作，你觉得这样的公司会给员工提供多少机会呢？&lt;br /&gt;
去面试工作，是一个相互合作的过程，并不是说哪一方成为主导。你为公司工作，公司给你报酬。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而对所有公司来说它总希望找到那一种类似合作伙伴的员工而不是仅仅是来打工的。&lt;br /&gt;
所以，在面试的时候除了展示你自身特长和文化外，还要表现出一个对公司前景关心和一种参与者的心态来。&lt;br /&gt;
这样能让公司的管理者对你更有好感！这不仅为了进入这个公司也为了以后的发展&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>有一段历史离我们如此近记忆却模糊</title>
      <link>http://firoyang.org/history/china_a_century_of_revolution/</link>
      <pubDate>Wed, 24 Jun 2015 15:46:11 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/history/china_a_century_of_revolution/</guid>
      <description>&lt;p&gt;毛泽东的时代&lt;br /&gt;
&lt;iframe width=&#34;420&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/GMaXSKH2w3c&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;p&gt;建国后出生的新一代&lt;br /&gt;
&lt;iframe width=&#34;420&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/qsmJXJcvG3g&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
