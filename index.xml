<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title> on Firo Notes </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://firoyang.org/</link>
    <language>en-us</language>
    <author>Firo Yang</author>
    
    <updated>Sun, 13 Dec 2015 03:27:16 CST</updated>
    
    <item>
      <title>The common cognition language</title>
      <link>http://firoyang.org/philosophy/ccl/</link>
      <pubDate>Sun, 13 Dec 2015 03:27:16 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/philosophy/ccl/</guid>
      <description>&lt;p&gt;To be continue!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Console and TTY</title>
      <link>http://firoyang.org/kernel/console/</link>
      <pubDate>Sat, 05 Dec 2015 14:06:29 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/kernel/console/</guid>
      <description>

&lt;h1 id=&#34;about-the-design:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;About the design&lt;/h1&gt;

&lt;p&gt;Why dose we use /dev/xxx to represent the &amp;ldquo;tty&amp;rdquo; device?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The whole point with &amp;ldquo;everything is a file&amp;rdquo; is not that you have some random filename (indeed, sockets and pipes show that &amp;ldquo;file&amp;rdquo; and &amp;ldquo;filename&amp;rdquo;&amp;gt; have nothing to do with each other), but the fact that you can use common tools to operate on different things. &amp;ndash; Linus&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So we got the key point!&lt;br /&gt;
In order to use the common tools, file ops and vfs layer, the tty device is &amp;ldquo;abstructed&amp;rdquo; to&lt;br /&gt;
files by us. Addnationaly, we must assurance that is the files is &lt;em&gt;different&lt;/em&gt;. What does&lt;br /&gt;
the word &amp;ldquo;dirrerent&amp;rdquo; means is not that you have some random different filename, but the&lt;br /&gt;
fact that you can access the real device through the different.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Wikipedia:&lt;br /&gt;
In mathematics, injections, surjections and bijections are classes of functions distinguished by the manner in which arguments (input expression&amp;gt; s from the domain) and images (output expressions from the codomain) are related or mapped to each other.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I got an insight that abstruction is a non-injective, right?&lt;br /&gt;
But non-injective may not be a anstruction.&lt;br /&gt;
An asbstruction should come from manipulating different objects.&lt;br /&gt;
Non-injective, 多对一; Multiplex, 一对多.&lt;br /&gt;
So we can use mathematical language to describe the linux subsystem.&lt;br /&gt;
From real life device to a filesystem file.&lt;br /&gt;
* Abstruction: Non-injective, Multiplex(not partial function).&lt;br /&gt;
* Jection num: injective, or non-jective, or multiplex; Jection level: domain set and codoain set!&lt;br /&gt;
Abstruction -&amp;gt; Control abstruction and data abstruction -&amp;gt; Abstruction layer&lt;/p&gt;

&lt;p&gt;软件设计的两个主要目的.&lt;br /&gt;
1. 简化, 易用,易操作, 如computer architecture, tty subsystem. 抽象.&lt;br /&gt;
2. Separation of concerns, modular(abstruciton in layer), 笛卡尔划分的思想&lt;/p&gt;

&lt;h1 id=&#34;tty-struct-disc-data:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;tty_struct-&amp;gt;disc_data&lt;/h1&gt;

&lt;p&gt;tty_init_dev-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    initialize_tty_struct-&amp;gt;tty_ldisc_init&lt;br /&gt;
    tty_ldisc_setup-&amp;gt;tty_ldisc_open-&amp;gt;n_tty_open-&amp;gt; tty-&amp;gt;disc_data = ldata;&lt;br /&gt;
}&lt;br /&gt;
sys_vhangup-&amp;gt;tty_vhangup_self-&amp;gt;__tty_hangup-&amp;gt;tty_ldisc_hangup-&amp;gt;tty_ldisc_reinit&lt;br /&gt;
vfs_write-&amp;gt;redirected_tty_write-&amp;gt;tty_write-&amp;gt;n_tty_write-&amp;gt;process_output&lt;/p&gt;

&lt;h1 id=&#34;early-con:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;early_con&lt;/h1&gt;

&lt;p&gt;EARLYCON_DECLARE(uart8250, early_serial8250_setup); EARLYCON_DECLARE(uart, early_serial8250_setup);&lt;br /&gt;
setup_earlycon-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    parse_options-&amp;gt;&lt;br /&gt;
    {&lt;br /&gt;
        parse earlycon_device-&amp;gt;port-&amp;gt;uartclk and&lt;br /&gt;
        earlycon_device-&amp;gt;baud&lt;br /&gt;
    }&lt;br /&gt;
    setup = early_serial8250_setup-&amp;gt; init_port(device);&lt;br /&gt;
    register_console(early_console_dev.con)&lt;br /&gt;
}&lt;/p&gt;

&lt;h1 id=&#34;earlyprintk:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;earlyprintk&lt;/h1&gt;

&lt;p&gt;early_param(&amp;ldquo;earlyprintk&amp;rdquo;, setup_early_printk)-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    early_serial_init-&amp;gt;&lt;br /&gt;
    {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;}
early_console_register(&amp;amp;early_serial_console, keep);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;h1 id=&#34;cpu-hotplug:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;cpu hotplug&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;onset&lt;br /&gt;
static struct smp_hotplug_thread softirq_threads {&lt;br /&gt;
.thread_fn              = run_ksoftirqd&lt;br /&gt;
};&lt;br /&gt;
early_initcall(spawn_ksoftirqd)-&amp;gt;mpboot_register_percpu_thread(&amp;amp;softirq_threads)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;nucles onset&lt;br /&gt;
suspend_enter-&amp;gt;enable_nonboot_cpus-&amp;gt;_cpu_up-&amp;gt;smpboot_create_threads-&amp;gt;&lt;strong&gt;smpboot_create_thread(&amp;amp;hotplug_threads)-&amp;gt;&lt;br /&gt;
kthread_create_on_cpu(smpboot_thread_fn-&amp;gt; ht-&amp;gt;thread_fn(td-&amp;gt;cpu)= run_ksoftirqd-&amp;gt;&lt;/strong&gt;do_softirq-&amp;gt;h-&amp;gt;action(h) = run_timer_softirq-&amp;gt;&lt;br /&gt;
__run_timers-&amp;gt;call_timer_fn)&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;vt 就是个tty也有tty_driver 叫console_driver.&lt;/p&gt;

&lt;h1 id=&#34;reference:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;Reference&lt;/h1&gt;

&lt;h1 id=&#34;contents:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;Contents&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://superuser.com/questions/144666/what-is-the-difference-between-shell-console-and-terminal&#34;&gt;What is the difference between shell, console, and terminal?&lt;/a&gt;&lt;br /&gt;
What does console do in kernel or u-boot?&lt;br /&gt;
Linux console?&lt;br /&gt;
Computer terminal: keyboard + dispaly&lt;br /&gt;
Terminal emulator:&lt;/p&gt;

&lt;h1 id=&#34;get-a-glance-on-u-boot:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;get a glance on u-boot&lt;/h1&gt;

&lt;p&gt;start.S:board_init_r&lt;br /&gt;
init_sequence_f: -&amp;gt;init_baud_rate; serial_init; console_init_f&lt;br /&gt;
serial_init -&amp;gt;&amp;amp;eserial1_device-&amp;gt;start=eserial##port##_init-&amp;gt;NS16550_init: UART divisor init.&lt;br /&gt;
Firstly, the struct of serial define some input and output funtion.&lt;br /&gt;
It&amp;rsquo;s basic function of serial, put or get!&lt;br /&gt;
console_init_f: just gd-&amp;gt;have_console = 1;&lt;br /&gt;
init_sequence_r: stdio_init_tables,initr_serial, stdio_add_devices, console_init_r,&lt;br /&gt;
initr_serial: just register &amp;amp;eserial1_device to serial_devices&lt;br /&gt;
stdio_add_devices: drv_system_init, serial_stdio_init&lt;br /&gt;
drv_system_init: register default serial dev to devs.list.&lt;br /&gt;
serial_stdio_init: register &amp;amp;eserial1_device to devs.list. Duplicate, but serial dev &amp;ldquo;eserial0&amp;rdquo;  and system &amp;ldquo;serial&amp;rdquo;.&lt;br /&gt;
console_init_r: console_doenv -&amp;gt;console_setfile:stdio_devices[file(0/1/2)] = dev; actually, dev is &amp;ldquo;serial&amp;rdquo;, but they may be KBD!&lt;br /&gt;
看来console的真正作用就是在serial和kbd中选择一个, 可能多选iomux?&lt;br /&gt;
main_loop:cli_loop: getc!&lt;/p&gt;

&lt;h1 id=&#34;what-is-platform-device-or-driver:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;what is platform device or driver?&lt;/h1&gt;

&lt;h1 id=&#34;a-reallife-serial8250:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;A reallife serial8250&lt;/h1&gt;

&lt;p&gt;drivers/tty/serial/8250/8250_boca.c:plat_serial8250_port&lt;br /&gt;
module_init-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    serial8250_init-&amp;gt;serial8250_isa_init_ports-&amp;gt;serial8250_ports[i].port.ops = &amp;amp;serial8250_pops; //insidious&lt;br /&gt;
    boca_init-&amp;gt;platform_device_register(&amp;amp;boca_device); //register platform device and data.&lt;br /&gt;
}&lt;br /&gt;
* uart_port-&amp;gt;tty_port&lt;/p&gt;

&lt;p&gt;serial8250_probe(plat_serial8250_port)-&amp;gt;serial8250_register_8250_port(uart_8250_port)-&amp;gt;&lt;br /&gt;
uart_add_one_port(&amp;amp;serial8250_reg, &amp;amp;uart-&amp;gt;port=uart_port)-&amp;gt;&lt;br /&gt;
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uart_configure_port-&amp;gt;
{
    port-&amp;gt;ops-&amp;gt;config_port(port, flags)=serial8250_config_port
    if post is console and not registered; register!
    we know that uport-&amp;gt;cons = drv-&amp;gt;cons; what is the relation to registering about up-&amp;gt;cons.
    why we register it? where does drv-&amp;gt;cons come from?
    //这个uart_driver drv就是serial8250_reg, 我们也就知道了
    // console是设备的一种天生能力. 能否使用, 只关乎你是否想用, 就是配置相关的config SERIAL8250_CONSOLE
    // con_driver is the backends, vga, dummy/serial?, fb. 
}
tty_port_register_device_attr-&amp;gt;
{
    //tty_driver  tty_port
    tty_port_link_device
    tty_register_device_attr
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;h1 id=&#34;simple-conceptions:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;Simple conceptions&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.linusakesson.net/programming/tty/&#34;&gt;You must read this -&amp;gt; The TTY demystified&lt;/a&gt;&lt;br /&gt;
System consoles are generalized to computer terminals, which are abstracted respectively by virtual consoles and terminal emulators.&lt;br /&gt;
        UART&lt;br /&gt;
        Line displine + TTY(pts, dummy/serial, kbd+vga/fb)&lt;br /&gt;
* System console&lt;br /&gt;
Virtual termial, Terminal emulator/telnet/ssh -&amp;gt; pts ,Physical terminal&lt;br /&gt;
You need at least one virtual terminal device in order to make use of your keyboard and monitor.&lt;br /&gt;
VT combine keyboard and display see con_init&lt;br /&gt;
con_init init a virtual terminal like gnome-terminal but in kernel.&lt;br /&gt;
con_init mainly init display.&lt;br /&gt;
vty_init mainly init kbd&lt;br /&gt;
They all can be system console.(Exception pts??), if you enable it.&lt;br /&gt;
Console is the entry of linux system.&lt;br /&gt;
* Console driver &amp;ndash; banckends of  console&lt;br /&gt;
struct console 指定了console的结构.&lt;br /&gt;
* Console config&lt;br /&gt;
If I disable CONFIG_SERIAL8250_CONSOLE(enable vt console), then no booting log and I can not login system.&lt;br /&gt;
If I disable CONFIG_VT_CONSOLE(enable serail console, /dev/console point to ttyS0 see show_cons_active), no booting log but I can lgin system.&lt;br /&gt;
How to explain this phenomena?&lt;br /&gt;
From show_cons_active, we know /dev/console should come from console_drivers.&lt;br /&gt;
/dev/console is really the pointer.&lt;br /&gt;
Now, let&amp;rsquo;s inspect open /dev/console.&lt;br /&gt;
* Open /dev/console&lt;br /&gt;
Fisrt, it&amp;rsquo;s the very last place of booting kernel.&lt;br /&gt;
start_kernel-&amp;gt;rest_init-&amp;gt;kernel_init-&amp;gt;kernel_init_freeable-&amp;gt;sys_open((const char __user *) &amp;ldquo;/dev/console&amp;rdquo;, O_RDWR, 0)-&amp;gt;&amp;hellip;-&amp;gt;&lt;br /&gt;
console_fops-&amp;gt;tty_open-&amp;gt;&lt;br /&gt;
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Sitiuations: disbale VT CONSOLE byt enable SERIAL8250_CONSOLE.
// This function work only for /dev/tty
// ls -l /dev/tty
// crw-rw-rw- 1 root tty 5, 0 Dec 10 10:24 /dev/tty
tty_open_current_tty-&amp;gt;
{
    /dev/console is 5:1, just return NULL
}
//This index should be Ctrl + Alt + Fn??
// tty_struct is corresponding virtual console, or just console??
// lookup tty_driver. It looks like lookup a inode, right?
tty_lookup_driver-&amp;gt;
{
    // Find a tty_driver by device() in console_drivers.
    // So we know, got a console, then got a tty_driver, right?
    // Where do the components of console_drivers come form?
    // At present, we should have only serial8250_console because 
    // console vt_console_driver is disabled by us! But tty_driver console_driver
    // still do exist!So console and tty is really separated!
    // When we init vt, we get the tty_driver console_driver with con_ops type of tty_operations.
    // tty_drivers have the same major with /dev/tty0!
    // char_dev -&amp;gt; tty_driver int vty_init, not disable.
    // vt console---^
    console_device-&amp;gt;c-&amp;gt;device(c, index)
    // What about serial8250_console?
    // Where is the tty_driver of serial8250_console?
    // console-&amp;gt;data = uart_driver-&amp;gt;tty_driver.
    // We got another scene : uart-&amp;gt;tty
    // serial8250 console-&amp;gt;data-^
    // serial&#39;s tty_driver alloced in serial8250_init with uart_ops.
    // vt&#39;s tty_driver alloced in vty_init.
    // We summarize these:
    // uart_driver serial8250_reg &amp;lt;-&amp;gt;  vc dev or /dev/tty*
    // serial tty driver &amp;lt;-&amp;gt; vt tty driver 
    // fs:vty_init &amp;lt;-&amp;gt; module:serial8250_init
    // tty driver ops con_ops &amp;lt;-&amp;gt; uart_ops
    // vt use major to connect tty and  vc dev
    // serial use major and -&amp;gt; to connect tty and uart_driver
    // It seems that uart and tty has a strong relationship, yet vt.
    // Ok... we got tty driver.
    // If we disable vt console, then here is the serial8250 tty_driver.
}
// Lookup for tty_struct
tty_driver_lookup_tty -&amp;gt;
{
    //tty_struct is alloced in init function alloc_tty_driver.
    // ttys, termios, ports, cdevs.
    // ttys was used by tty_standard_install then tty_driver_install_tty 
    // then tty_init_dev then ok we return to tty open. So this is the start place.

    So we know tty_driver-&amp;gt;ttys[*] must be NULL.
}
tty_init_dev-&amp;gt;
{
    // tty_driver likes a process, ttys like the files, tty_struct like a file!
    // So we know a tty_struct is a tty file.
    // tty_driver much like a inode
    //So tty_struct-&amp;gt;ops = tty_driver-&amp;gt;ops = &amp;amp; uart_ops
    alloc_tty_struct-&amp;gt;tty-&amp;gt;ops = driver-&amp;gt;ops;
    tty_driver_install_tty(driver, tty_struct)-&amp;gt; tty_standard_install-&amp;gt;driver-&amp;gt;ttys[tty-&amp;gt;index] = tty;
}
// Ok... We got a tty_struct.
// Add /dev/console to tty_struct-&amp;gt;tty_files
tty_add_file
// At present, what have we done?
// open(/dev/console)-&amp;gt;console_drivers-&amp;gt;console-&amp;gt;tty_driver-&amp;gt;tty_struct, right?

tty-&amp;gt;ops-&amp;gt;open(tty, filp)-&amp;gt;//ops = &amp;amp;uart_ops
{
    uart_ops-&amp;gt;open = uart_open-&amp;gt;
    {
        uart-&amp;gt; tty struct
        struct uart_driver *drv = (struct uart_driver *)tty-&amp;gt;driver-&amp;gt;driver_state;
        struct uart_state *state = drv-&amp;gt;state + line; //uart_state
        tty-&amp;gt;driver_data = state;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
// At present, we understand the flow of open /dev/console to serial console&lt;/p&gt;

&lt;h1 id=&#34;what-about-opening-dev-console-to-vt-console:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;What about opening /dev/console to vt console&lt;/h1&gt;

&lt;p&gt;sys_open(/dev/console)-&amp;gt; &amp;hellip; tty_open -&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    tty_lookup_driver-&amp;gt; get tty_driver=console_driver,&lt;br /&gt;
    Through the name console_driver, we know, vt tty_driver is the defaut driver of console!&lt;br /&gt;
    // 同时, 我们也应该知道所谓的kernel的system console 是你只要enable了先关的config CONFIG_VT_CONSOLE and CONFIG_SERIAL_8250_CONSOLE.&lt;br /&gt;
    // system console就有了, printk也就有了归处. In other words, you registered, you got printed&lt;br /&gt;
    // In theory, you should be able to input something, like sysrq, I maybe test tomorrow.&lt;br /&gt;
    // 那么在kernel_init中sys_open又是什么鬼呢?&lt;br /&gt;
    // dev/tty 是专门真对进程的, 就是进程之前打开了一个tty就存在singnal里, 这个dev/tty就是取出来的.&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;h1 id=&#34;总结下-打开-dev-console-会从console-drivers-最终到达tty-driver:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;总结下, 打开/dev/console, 会从console_drivers, 最终到达tty_driver.&lt;/h1&gt;

&lt;h1 id=&#34;这和-dev-tty-dev-ttys-从tty-drivers-差不多:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;这和/dev/tty* /dev/ttyS* 从tty_drivers, 差不多.&lt;/h1&gt;

&lt;p&gt;// 这么输出为什么不会打窜了?&lt;br /&gt;
// How ctrl alt Fn work?&lt;br /&gt;
// echo xxx /dev/tty in serial tty_lookup_driver&lt;br /&gt;
// 另一个问题, serial 的terminal?&lt;/p&gt;

&lt;h1 id=&#34;the-perspective:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;The perspective&lt;/h1&gt;

&lt;p&gt;/dev/*&lt;br /&gt;
vfs&lt;br /&gt;
chrdev&lt;br /&gt;
tty_fops&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;gt;tty core&lt;br /&gt;
    ld_ops &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;&amp;gt; tty line discipline(for read, write)&lt;br /&gt;
tty_driver con_ops/uart_ops&amp;mdash;&amp;mdash;&amp;ndash;&amp;gt; tty driver and tty_operations&lt;br /&gt;
HW&lt;br /&gt;
There are three different types of tty drivers: console, serial port, and pty.&lt;br /&gt;
serial8250_default_handle_irq&lt;br /&gt;
UART console&lt;br /&gt;
              |&amp;mdash;- Virtual terminal &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; VT console&lt;br /&gt;
              |                 | &amp;ndash; VT console&lt;br /&gt;
              |&amp;mdash;-&lt;br /&gt;
        Terminal&amp;ndash;|&lt;br /&gt;
              |&amp;mdash;-&lt;/p&gt;

&lt;h1 id=&#34;what-about-console:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;What about console?&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;early_con&lt;br /&gt;
start_kernel or setup_arch(arm)-&amp;gt;parse_early_param-&amp;gt;do_early_param-&amp;gt;p-&amp;gt;setup_func()= setup_early_printk-&amp;gt;register_console&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;vga_con&lt;br /&gt;
start_kerenl-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
// All about vga console&lt;br /&gt;
set_arch-&amp;gt; conswitchp = &amp;amp;vga_con; or conswitchp = &amp;amp;dummy_con;&lt;br /&gt;
console_init-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    con_init-&amp;gt;&lt;br /&gt;
    {&lt;br /&gt;
        // vc-&amp;gt;vc_sw-&amp;gt;con_putcs is DUMMY&lt;br /&gt;
        //内存映射64KB or 32KB的VGA区域. 启动VGA&lt;br /&gt;
        conswitchp-&amp;gt;con_startup = vgacon_startup -&amp;gt;vga_vram_base = VGA_MAP_MEM(vga_vram_base, vga_vram_size);&lt;br /&gt;
        con_driver_map[0~MAX_NR_CONSOLES] = conswitchp; //空间换时间&lt;br /&gt;
        // 核心内容!&lt;br /&gt;
        for (currcons = 0; currcons &amp;lt; MIN_NR_CONSOLES; currcons++) {&lt;br /&gt;
            // 给vc_cons[currcons].d分配内存&lt;br /&gt;
            vc_cons[currcons].d = vc = kzalloc(sizeof(struct vc_data), GFP_NOWAIT);&lt;br /&gt;
            INIT_WORK(&amp;amp;vc_cons[currcons].SAK_work, vc_SAK);&lt;br /&gt;
            //初始化vc_cons[currcons].d&lt;br /&gt;
            tty_port_init(&amp;amp;vc-&amp;gt;port);&lt;br /&gt;
            // 继续初始化, 主要是确定screenbuf size&lt;br /&gt;
            visual_init(vc, currcons, 1);&lt;br /&gt;
            // 给vc_screenbuf分配内存&lt;br /&gt;
            vc-&amp;gt;vc_screenbuf = kzalloc(vc-&amp;gt;vc_screenbuf_size, GFP_NOWAIT);&lt;br /&gt;
            vc_init(vc, vc-&amp;gt;vc_rows, vc-&amp;gt;vc_cols,&lt;br /&gt;
                currcons || !vc-&amp;gt;vc_sw-&amp;gt;con_save_screen);&lt;br /&gt;
        }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    [    0.000000] Console: colour VGA+ 80x25
    register_console(&amp;amp;vt_console_driver);//vt_console can use vgacon writing.
}
serial8250_console_init-&amp;gt;register_console(&amp;amp;serial8250_console) to console_drivers; exclusive_console.
[    0.000000] console [tty0] enabled
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
module_init(serial8250_init);??&lt;br /&gt;
}&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;fbcon&lt;br /&gt;
register_framebuffer-&amp;gt; do_take_over_console -&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
do_register_con_driver-&amp;gt;csw-&amp;gt;con_startup();registered_con_driver&lt;br /&gt;
do_bind_con_driver -&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    [    3.882220] Console: switching to colour dummy device 80x25&lt;br /&gt;
    [    4.720732] Console: switching to colour frame buffer device 170x48&lt;br /&gt;
}&lt;br /&gt;
}&lt;/p&gt;

&lt;h2 id=&#34;vga-text-console-printk-write:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;VGA text console printk &amp;amp; write&lt;/h2&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;kernel space&lt;br /&gt;
printk-&amp;gt; &amp;hellip;-&amp;gt;log_buf&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;userspace for ttyN&lt;br /&gt;
tty_fops-&amp;gt;write=tty_write-&amp;gt; tty_ldisc_N_TTY-&amp;gt;write=n_tty_write-&amp;gt; tty_driver-&amp;gt;ops=con_ops-&amp;gt;write=con_write-&amp;gt;do_con_write&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;agent&lt;br /&gt;
console_drivers-&amp;gt;vt_console_driver-&amp;gt;serial8250_console-&amp;gt;NULL&lt;br /&gt;
console_unlock-&amp;gt;..-&amp;gt;__call_console_drivers-&amp;gt; console_drivers-&amp;gt;write = vt_console_print&lt;br /&gt;
{&lt;br /&gt;
//保存到screen buf, vga_con也什么不做啊.&lt;br /&gt;
scr_writew((vc-&amp;gt;vc_attr &amp;lt;&amp;lt; 8) + c, (unsigned short *)vc-&amp;gt;vc_pos);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;h1 id=&#34;what-about-tty:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;What about tty&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;onset&lt;br /&gt;
console_init-&amp;gt;tty_ldisc_begin-&amp;gt;tty_register_ldisc(N_TTY, &amp;amp;tty_ldisc_N_TTY);&lt;br /&gt;
N_TTY:&lt;a href=&#34;http://www.linux.it/~rubini/docs/serial/serial.html&#34;&gt;Serial Drivers by Alessandro Rubini&lt;/a&gt;&lt;br /&gt;
fs_initcall:chr_dev_init-&amp;gt;drivers/tty/tty_io.c: tty_init-&amp;gt;&lt;br /&gt;
{&lt;/p&gt;

&lt;p&gt;/* /dev/tty0 = /dev/console console_ops &lt;em&gt;/&lt;br /&gt;
/&lt;/em&gt; /dev/tty = the /dev/ttyN whererun echo /dev/tty tty_ops */&lt;/p&gt;

&lt;p&gt;//&amp;ldquo;/dev/tty&amp;rdquo;,&lt;br /&gt;
cdev_init(&amp;amp;tty_cdev, &amp;amp;tty_fops);&lt;br /&gt;
&amp;rdquo;/dev/console&amp;rdquo;&lt;br /&gt;
cdev_init(&amp;amp;console_cdev, &amp;amp;console_fops);&lt;br /&gt;
vty_init-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    //&amp;ldquo;dev/tty0&amp;rdquo;&lt;br /&gt;
    cdev_init(&amp;amp;vc0_cdev, console_fops);&lt;br /&gt;
    //&amp;ldquo;/dev/ttyN&amp;rdquo;&lt;br /&gt;
    tty_register_driver-&amp;gt;&lt;br /&gt;
    {&lt;br /&gt;
        // What does tty_register_driver do ?&lt;br /&gt;
        // Alloc and register chr dev region.&lt;br /&gt;
        // Add cdev with tty_ops and above region.&lt;br /&gt;
        // Register tty device&lt;br /&gt;
        // Why do we register tty devices?&lt;br /&gt;
        // These devices must be used in some place.&lt;br /&gt;
        // After registering itself, the driver registers the devices it controls through the tty_register_device function.&lt;br /&gt;
        // 原来是把major 和minor做成dev_t放到driver-&amp;gt;cdevs[index].dev里面了.&lt;br /&gt;
        // 也就是说driver-&amp;gt;cdevs[index]就是tty driver控制的device啊, 怪不得cdev_init(&amp;amp;driver-&amp;gt;cdevs[index], &amp;amp;tty_fops);&lt;br /&gt;
        // 那么看来用到的时候就是open了, 竟然没有不过有个tty_get_device用了tty_class&lt;br /&gt;
        // tty_register_device_attr-&amp;gt;device_register-&amp;gt;device_add-&amp;gt;klist_add_tail(&amp;amp;dev-&amp;gt;knode_class,&amp;amp;dev-&amp;gt;class-&amp;gt;p-&amp;gt;klist_devices)&lt;br /&gt;
        // 果然是在open tty-&amp;gt;dev = tty_get_device(tty);在alloc_tty_struct&lt;br /&gt;
        // 不知道这个tty-&amp;gt;dev在哪里用, 不管他了.&lt;br /&gt;
        tty_register_device(_attr) -&amp;gt;tty_cdev_add-&amp;gt; cdev_init(&amp;amp;driver-&amp;gt;cdevs[index], &amp;amp;tty_fops);&lt;br /&gt;
    }&lt;br /&gt;
    kbd_init&lt;br /&gt;
}&lt;br /&gt;
}&lt;br /&gt;
device_init:serial8250_init-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
// In this function we decide &amp;ldquo;/dev/ttyS*&amp;rdquo;&lt;br /&gt;
// dmesg |grep Serial&lt;br /&gt;
// [    0.696341] Serial: &lt;sup&gt;8250&lt;/sup&gt;&amp;frasl;&lt;sub&gt;16550&lt;/sub&gt; driver, 32 ports, IRQ sharing enabled&lt;br /&gt;
// serial8250.c -&amp;gt; tty_io.c&lt;br /&gt;
serial8250_reg.nr = UART_NR;&lt;br /&gt;
ret = uart_register_driver(&amp;amp;serial8250_reg);&lt;br /&gt;
tty_driver set to uart_driver by uart_register_driver -&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    drv-&amp;gt;state = kzalloc        //uart_state&lt;br /&gt;
    normal-&amp;gt;driver_state    = drv; //args struct uart_driver *drv = &amp;amp;serial8250_reg&lt;br /&gt;
    tty_set_operations(normal, &amp;amp;uart_ops);&lt;br /&gt;
    struct tty_port &lt;em&gt;port = &amp;amp;state-&amp;gt;port&lt;br /&gt;
    tty_port_init(port);&lt;br /&gt;
    port-&amp;gt;ops = &amp;amp;uart_port_ops; //tty_port&lt;br /&gt;
    // We register &amp;ldquo;/dev/ttyS&lt;/em&gt;&amp;rdquo; files here.&lt;br /&gt;
    static struct uart_driver serial8250_reg = {&lt;br /&gt;
        .owner                  = THIS_MODULE,&lt;br /&gt;
        .driver_name            = &amp;ldquo;serial&amp;rdquo;,&lt;br /&gt;
        .dev_name               = &amp;ldquo;ttyS&amp;rdquo;,&lt;br /&gt;
        .major                  = TTY_MAJOR,&lt;br /&gt;
        .minor                  = 64,&lt;br /&gt;
        .cons                   = SERIAL8250_CONSOLE,&lt;br /&gt;
    };&lt;br /&gt;
    retval = tty_register_driver(normal); -&amp;gt; register_chrdev_region(dev, driver-&amp;gt;num, driver-&amp;gt;name) //32, ttyS?*? should be tty_ops&lt;/p&gt;

&lt;p&gt;}&lt;br /&gt;
serial8250_register_ports(&amp;amp;serial8250_reg, &amp;amp;serial8250_isa_devs-&amp;gt;dev);&lt;br /&gt;
}&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;nucleus&lt;br /&gt;
tty_write-&amp;gt;ld-&amp;gt;ops-&amp;gt;write=n_tty_write-&amp;gt;(tty_struct tty-&amp;gt;ops-&amp;gt;write)=uart_write-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
struct uart_state *state = tty-&amp;gt;driver_data;&lt;br /&gt;
port = state-&amp;gt;uart_port;&lt;br /&gt;
circ = &amp;amp;state-&amp;gt;xmit;&lt;br /&gt;
memcpy(circ-&amp;gt;buf + circ-&amp;gt;head, buf, c);&lt;br /&gt;
uart_start-&amp;gt;__uart_start-&amp;gt;(uart_port-&amp;gt;ops-&amp;gt;start_tx(port)); //&amp;amp;uart_port_ops ?? uart_ops??&lt;br /&gt;
}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;what-about-pseudoterminal:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;What about Pseudoterminal&lt;/h1&gt;

&lt;p&gt;/dev/ptmx is the &amp;ldquo;pseudo-terminal master multiplexer&amp;rdquo;. from wikipedia&lt;br /&gt;
static struct tty_driver *ptm_driver;&lt;br /&gt;
static struct tty_driver *pts_driver;&lt;br /&gt;
module_init(pty_init)-&amp;gt;unix98_pty_init-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    tty_set_operations(ptm_driver, &amp;amp;ptm_unix98_ops);&lt;br /&gt;
    tty_register_driver(ptm_driver)&lt;br /&gt;
    tty_set_operations(pts_driver, &amp;amp;pty_unix98_ops);&lt;br /&gt;
    tty_register_driver(pts_driver)&lt;br /&gt;
    ptmx_fops = tty_fops;&lt;br /&gt;
    ptmx_fops.open = ptmx_open;&lt;br /&gt;
    cdev_init(&amp;amp;ptmx_cdev, &amp;amp;ptmx_fops);&lt;br /&gt;
}&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;How to use ptmx?&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;tty-drivers:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;tty drivers&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;cat /proc/tty/drivers&lt;br /&gt;
/dev/tty             /dev/tty        5       0 system:/dev/tty&lt;br /&gt;
/dev/console         /dev/console    5       1 system:console&lt;br /&gt;
/dev/ptmx            /dev/ptmx       5       2 system&lt;br /&gt;
/dev/vc/0            /dev/vc/0       4       0 system:vtmaster&lt;br /&gt;
usbserial            /dev/ttyUSB   188 0-511 serial&lt;br /&gt;
serial               /dev/ttyS       4 64-95 serial&lt;br /&gt;
pty_slave            /dev/pts      136 0-1048575 pty:slave&lt;br /&gt;
pty_master           /dev/ptm      128 0-1048575 pty:master&lt;br /&gt;
unknown              /dev/tty        4 1-63 console&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;question:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;Question?&lt;/h1&gt;

&lt;p&gt;what is /dev/vcs?&lt;/p&gt;

&lt;h1 id=&#34;backup:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;Backup&lt;/h1&gt;

&lt;p&gt;./drivers//tty/vt/vt.c:3042:        register_chrdev_region(MKDEV(TTY_MAJOR, 0), 1, &amp;ldquo;/dev/vc/0&amp;rdquo;) &amp;lt; 0)&lt;br /&gt;
./drivers//tty/vt/vc_screen.c:644:  if (register_chrdev(VCS_MAJOR, &amp;ldquo;vcs&amp;rdquo;, &amp;amp;vcs_fops))&lt;br /&gt;
./drivers//tty/tty_io.c:3377:       error = register_chrdev_region(dev, driver-&amp;gt;num, driver-&amp;gt;name);&lt;br /&gt;
./drivers//tty/tty_io.c:3414:   unregister_chrdev_region(dev, driver-&amp;gt;num);&lt;br /&gt;
./drivers//tty/tty_io.c:3430:   unregister_chrdev_region(MKDEV(driver-&amp;gt;major, driver-&amp;gt;minor_start),&lt;br /&gt;
./drivers//tty/tty_io.c:3607:       register_chrdev_region(MKDEV(TTYAUX_MAJOR, 0), 1, &amp;ldquo;/dev/tty&amp;rdquo;) &amp;lt; 0)&lt;br /&gt;
./drivers//tty/tty_io.c:3613:       register_chrdev_region(MKDEV(TTYAUX_MAJOR, 1), 1, &amp;ldquo;/dev/console&amp;rdquo;) &amp;lt; 0)&lt;br /&gt;
./drivers//tty/pty.c:841:       register_chrdev_region(MKDEV(TTYAUX_MAJOR, 2), 1, &amp;ldquo;/dev/ptmx&amp;rdquo;) &amp;lt; 0)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>System booting</title>
      <link>http://firoyang.org/cs/boot/</link>
      <pubDate>Thu, 12 Nov 2015 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/boot/</guid>
      <description>

&lt;h1 id=&#34;reference:4ccc61562af88da39fe562fcf76d50be&#34;&gt;Reference&lt;/h1&gt;

&lt;h1 id=&#34;contents:4ccc61562af88da39fe562fcf76d50be&#34;&gt;Contents&lt;/h1&gt;

&lt;p&gt;What basic initializations should be perfomed when power on?&lt;br /&gt;
How do we load the kernel to memory?&lt;br /&gt;
What does kernel do when kernel boot.&lt;br /&gt;
MBR vs BIOS?&lt;br /&gt;
PC vs embedded&lt;br /&gt;
Kernel init&lt;br /&gt;
before start_kernel&lt;br /&gt;
start_kernel&lt;br /&gt;
reset_init &amp;amp; kernel_init&lt;/p&gt;

&lt;h1 id=&#34;p4080-board:4ccc61562af88da39fe562fcf76d50be&#34;&gt;p4080 Board&lt;/h1&gt;

&lt;p&gt;PBL&lt;br /&gt;
1. initialize I2C, SPI, eLBC, eSDHC.&lt;br /&gt;
2. Load RCW and boot init commands from above.&lt;br /&gt;
3. write date to conf register and memory&lt;/p&gt;

&lt;h1 id=&#34;config:4ccc61562af88da39fe562fcf76d50be&#34;&gt;config&lt;/h1&gt;

&lt;p&gt;CCSRBAR -&amp;gt; CCSR&lt;br /&gt;
default is 0x0_FE00_0000&lt;br /&gt;
CCSRBAR is in CCSR memory. odd. stored in 0(CCSRBAR).&lt;br /&gt;
CCSRBAR always points to itself.&lt;br /&gt;
holdoff&lt;/p&gt;

&lt;h1 id=&#34;u-boot:4ccc61562af88da39fe562fcf76d50be&#34;&gt;u-boot&lt;/h1&gt;

&lt;p&gt;ft_fixup_cpu -&amp;gt; determine_mp_bootpg(NULL) &amp;amp; fdt_add_mem_rsv&lt;/p&gt;

&lt;p&gt;main_loop-&amp;gt; &amp;hellip;-&amp;gt;./common/bootm_os.c:410:&amp;hellip; do_bootm_states-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
bootm_find_other-&amp;gt;bootm_find_ramdisk_fdt-&amp;gt;bootm_find_fdt-&amp;gt;boot_get_fdt&amp;amp;set_working_fdt_addr(0x0200000)-&amp;gt;IMAGE_FORMAT_FIT-&amp;gt;&lt;br /&gt;
&amp;amp;&lt;br /&gt;
boot_fn = bootm_os_get_boot_func(images-&amp;gt;os.os)=[IH_OS_LINUX] =&lt;br /&gt;
&amp;amp;&lt;br /&gt;
boot_selected_os-&amp;gt;boot_fn=do_bootm_linux-&amp;gt;boot_body_linux-&amp;gt;image_setup_linux-&amp;gt;image_setup_libfdt-&amp;gt;&lt;br /&gt;
board/freescale/corenet_ds/corenet_ds.c ft_board_setup-&amp;gt; ft_cpu_setup-&amp;gt;&lt;br /&gt;
}&lt;/p&gt;

&lt;h1 id=&#34;ppc-multicore-booting:4ccc61562af88da39fe562fcf76d50be&#34;&gt;PPC multicore booting&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;There are two possibilites to make secondary cores booting failed.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;There is a bug in the code executed by Secondary cores&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;The spin table address, passed to croe0, is not correct, so we did not really kick the secondary cores.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CCSRBAR&lt;br /&gt;
MPC86xx_MCM_OFFSET&lt;br /&gt;
srio_boot_master_release_slave&lt;/p&gt;

&lt;p&gt;uboot-&amp;gt;&lt;br /&gt;
set the cpu-release-addr at funciton ft_fixup_cpu(), I am not sure.&lt;/p&gt;

&lt;p&gt;core0 run, 2nd cores holdoff&lt;br /&gt;
core0 set BPTR and kick(BRR) 2nd cores, 2nd cores spintable loop in uboot function setup_mp&lt;br /&gt;
core0 -&amp;gt; arch/powerpc/cpu/mpc85xx/start.S-&amp;gt;_start_e500&lt;br /&gt;
board_init_r-&amp;gt;cpu_init_r-&amp;gt; setup_mp-&amp;gt; {&lt;br /&gt;
&lt;strong&gt;bootpg_addr = (u32)virt_to_phys(&amp;amp;&lt;/strong&gt;second_half_boot_page); //Assembly code for put core to spin tablea. Used by __secondary_start_page&lt;br /&gt;
__spin_table_addr = (u32)get_spin_phys_addr();// used by __second_half_boot_page&lt;br /&gt;
bootpg = BPTR = __secondary_start_page&lt;br /&gt;
plat_mp_up-&amp;gt;kick BRR &amp;amp; Boot Space Translation&lt;br /&gt;
}&lt;br /&gt;
2nd cores holdoff -&amp;gt; &lt;strong&gt;secondary_start_page&lt;br /&gt;
kernel-&amp;gt;&lt;br /&gt;
core0 boot kernel, core0 kickoff 2nd cores spintable, triger 2nd core&amp;rsquo;s spin table by writing  the spin table field with the desired address&lt;br /&gt;
2nd cores ePAPR-&amp;gt;spintable-&amp;gt;addr_l=&lt;/strong&gt;early_start-&amp;gt;__secondary_start-&amp;gt;smp_ops-&amp;gt;setup_cpu-&amp;gt;cpu_idle&lt;br /&gt;
arch/powerpc/kernel/head_fsl_booke.S&lt;br /&gt;
U-boot logs:&lt;br /&gt;
Reserving MP boot page to 7ffff000^M^M - &amp;ndash;   -   MP spin table&lt;br /&gt;
address.&lt;br /&gt;
SPAG : fdt_fixup_fman_firmware, 567^M^M&lt;br /&gt;
^M^M&lt;br /&gt;
..r.^M^M&lt;br /&gt;
VDBG : ft_cpu_setup, 737, comment fdt_fixup_memory ^M^M&lt;br /&gt;
VDBG: Secondary cores are not held in reset.^M^M&lt;br /&gt;
Kernel Logs:&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 1 to ack^M^M&lt;br /&gt;
smp: failed starting cpu 1 (rc -2)^M^M&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 2 to ack^M^M&lt;br /&gt;
smp: failed starting cpu 2 (rc -2)^M^M&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 3 to ack^M^M&lt;br /&gt;
smp: failed starting cpu 3 (rc -2)^M^M&lt;br /&gt;
Brought up 1 CPUs^M^M&lt;br /&gt;
devtmpfs: initialized^M^M&lt;/p&gt;

&lt;p&gt;Note that u-boot can&amp;rsquo;t detect  memory above 2G and we need to check&lt;br /&gt;
if kernel is accessing at high mem of 2G or 4G.&lt;/p&gt;

&lt;p&gt;Here are the logs..&lt;/p&gt;

&lt;p&gt;I printed pa in %lx since the outout of &lt;strong&gt;pa(&lt;/strong&gt;early_start) is in long unsigned int.&lt;/p&gt;

&lt;p&gt;Firo:cpu nr1 release addr c3fe352c, spin_table c000003f, ioremmappable 0&lt;br /&gt;
Firo: kernel origin spin tbale addr_l a63b2000, pir 57cc802, resv 480000, r3 3ae000, pa 50&lt;br /&gt;
Firo: kernel update spin tbale addr_l 50, pir 1, resv 480000, r3 3ae000&lt;br /&gt;
Firo: kernel timeout spin tbale addr_l 50, pir 1, resv 480000, r3 3ae000&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 1 to ack&lt;br /&gt;
smp: failed starting cpu 1 (rc -2)&lt;br /&gt;
Firo:cpu nr2 release addr c3fe3740, spin_table c000007f, ioremmappable 0&lt;br /&gt;
Firo: kernel origin spin tbale addr_l a654e7af, pir a654e780, resv 387cf99a, r3 3408200, pa 50&lt;br /&gt;
Firo: kernel update spin tbale addr_l 50, pir 2, resv 387cf99a, r3 3408200&lt;br /&gt;
Firo: kernel timeout spin tbale addr_l 50, pir 2, resv 387cf99a, r3 3408200&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 2 to ack&lt;br /&gt;
smp: failed starting cpu 2 (rc -2)&lt;br /&gt;
Firo:cpu nr3 release addr c3fe3954, spin_table c00000bf, ioremmappable 0&lt;br /&gt;
Firo: kernel origin spin tbale addr_l 247cf09a, pir 7cf19b, resv a664e740, r3 3e7cf19a, pa 50&lt;br /&gt;
Firo: kernel update spin tbale addr_l 50, pir 3, resv a664e740, r3 3e7cf19a&lt;br /&gt;
Firo: kernel timeout spin tbale addr_l 50, pir 3, resv a664e740, r3 3e7cf19a&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 3 to ack&lt;br /&gt;
smp: failed starting cpu 3 (rc -2)&lt;br /&gt;
I don’t see the following print in u-boot..&lt;br /&gt;
 69                                 fdt_setprop(blob, off, &amp;ldquo;cpu-release-addr&amp;rdquo;,&lt;br /&gt;
 70                                                 &amp;amp;val, sizeof(val));&lt;br /&gt;
+ printf(&amp;ldquo;Firo u-boot:cpu release addr %p, value %x\n&amp;rdquo;, &amp;amp;val, val);&lt;/p&gt;

&lt;p&gt;Firo:cpu nr1 release addr c3fe352c, spin_table c000003f, ioremmappable 0&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 1 to ack&lt;br /&gt;
smp: failed starting cpu 1 (rc -2)&lt;br /&gt;
Firo:cpu nr2 release addr c3fe3740, spin_table c000007f, ioremmappable 0&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 2 to ack&lt;br /&gt;
smp: failed starting cpu 2 (rc -2)&lt;br /&gt;
Firo:cpu nr3 release addr c3fe3954, spin_table c00000bf, ioremmappable 0&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 3 to ack&lt;br /&gt;
smp: failed starting cpu 3 (rc -2)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Light camera action - compile link load</title>
      <link>http://firoyang.org/cs/build/</link>
      <pubDate>Sun, 25 Oct 2015 01:46:28 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/build/</guid>
      <description>

&lt;h1 id=&#34;reference:aba878e576894cc4457876fdf276811e&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.tenouk.com/ModuleW.html&#34;&gt;compiler, assembler, linker and loader: a brief story&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;contents:aba878e576894cc4457876fdf276811e&#34;&gt;Contents&lt;/h1&gt;

&lt;p&gt;Why complier can manipulate the address of vriables?&lt;br /&gt;
What is the address in lds(??) file?&lt;/p&gt;

&lt;h1 id=&#34;build-automation:aba878e576894cc4457876fdf276811e&#34;&gt;Build automation&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Make&lt;br /&gt;
make cynthia&lt;/p&gt;

&lt;h2 id=&#34;kbuild:aba878e576894cc4457876fdf276811e&#34;&gt;kbuild&lt;/h2&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;if no .config, every config tools make a .config from scrach!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;oldconfig just for new moduels patch merged in trunk. This no any relations to .config.old and /boot/config.x.y.z&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;make localmodconfig will reduce many unused kernel config.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;make bzImage  #kmods will not build that configured with M!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;make modules_install INSTALL_MOD_PATH=/home/firo/kmods&lt;/p&gt;

&lt;h2 id=&#34;yocto:aba878e576894cc4457876fdf276811e&#34;&gt;yocto&lt;/h2&gt;

&lt;p&gt;make ARCH=arm menuconfig&lt;br /&gt;
##build signle kernel module&lt;br /&gt;
make menuconfig&lt;br /&gt;
make oldconfig &amp;amp;&amp;amp; make prepare&lt;br /&gt;
make -C $(pwd) M=/home/firo/linux/fs/ext3 modules V=1&lt;br /&gt;
make ARCH=arm CROSS_COMPILE=/usr/bin/arm-linux-gnu- drivers/pcmcia/sa11xx_base.o&lt;/p&gt;

&lt;h1 id=&#34;compile-construction:aba878e576894cc4457876fdf276811e&#34;&gt;Compile construction&lt;/h1&gt;

&lt;p&gt;Understand pl deeply&lt;br /&gt;
how to translate it into machine code for specific CPU&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;gcc&lt;br /&gt;
-E -S -c&lt;br /&gt;
-I -L -l&lt;br /&gt;
-ansi&lt;br /&gt;
-fsyntax-only&lt;br /&gt;
-Werror&lt;br /&gt;
-save-temps&lt;br /&gt;
-H: show all header used&lt;br /&gt;
-v&lt;br /&gt;
-Wall&lt;br /&gt;
-fPIC: for shared library&lt;br /&gt;
-Q: print function and statisc?&lt;br /&gt;
-Wextra: 用处不大.&lt;br /&gt;
-U: undefine a preprocessor macro.&lt;br /&gt;
-pipe: make compilation faster, replace xx.S with |&lt;br /&gt;
-Wpadded: we can rearrange the fields of structure to make the structure smaller&lt;br /&gt;
-time&lt;br /&gt;
-x c: c language&lt;br /&gt;
-: stdin&lt;br /&gt;
asmlinkage&lt;br /&gt;
However, for C functions invoked from assembly code,&lt;br /&gt;
we should explicitly declare the function&amp;rsquo;s calling convention,&lt;br /&gt;
because the parameter passing code in assembly side has been fixed.&lt;br /&gt;
##&lt;a href=&#34;http://www.stlinux.com/devel/debug/jtag/build?q=node/82&#34;&gt;Generating optimized code&lt;/a&gt;&lt;br /&gt;
##Symbol table&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;System.map less&lt;br /&gt;
When you compile the kernel&lt;br /&gt;
nm vmlinux&lt;br /&gt;
readelf -s&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;/proc/kallsyms&lt;/p&gt;

&lt;h1 id=&#34;link:aba878e576894cc4457876fdf276811e&#34;&gt;Link&lt;/h1&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;GNU ld&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;gold&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>我读过的好书</title>
      <link>http://firoyang.org/review/book_list/</link>
      <pubDate>Wed, 14 Oct 2015 14:09:57 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/review/book_list/</guid>
      <description>

&lt;p&gt;我在大连民族学院学的本科计算机专业,主攻哲学,毕业3年工作2年左右.&lt;br /&gt;
推荐一些我觉得好的书.&lt;/p&gt;

&lt;h1 id=&#34;computer-science:55cb7bf81f2a4f67e449fcf14cb41572&#34;&gt;Computer science&lt;/h1&gt;

&lt;p&gt;Code: The hidden language of computer hardware and software&lt;br /&gt;
Digital Design and Computer Architecture 2nd Edition&lt;/p&gt;

&lt;p&gt;未看口碑好:&lt;br /&gt;
Computer Organization and Design, Fifth Edition&lt;br /&gt;
ARM System-on-Chip Architecture (2nd Edition)&lt;/p&gt;

&lt;h1 id=&#34;philosophy:55cb7bf81f2a4f67e449fcf14cb41572&#34;&gt;Philosophy&lt;/h1&gt;

&lt;p&gt;普通认识论 &amp;ndash; Moritz Schlick&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Computer architecture</title>
      <link>http://firoyang.org/cs/arch/</link>
      <pubDate>Tue, 13 Oct 2015 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/arch/</guid>
      <description>

&lt;p&gt;##Reference&lt;br /&gt;
Legacy 常用寄存器，常见指令 实模式和保护模式 分段和分页机制 TSS和任务管理 中断机制 时钟机制 高速缓存&lt;br /&gt;
《模拟电子技术基础 童诗白 第四版》第一章前半部分&lt;br /&gt;
Structured Computer Organization 6th Edition&lt;br /&gt;
Digital Design and Computer Architecture 2nd Edition&lt;br /&gt;
Computer Organization and Design 5th Edition&lt;br /&gt;
Write Great Code: Volume 1: Understanding the Machine&lt;br /&gt;
See MIPS run&lt;br /&gt;
Intel 64 and IA-32 architectures software developers manual combined volumes 3A, 3B, and 3C: System programming guide&lt;br /&gt;
Microelectronics&lt;/p&gt;

&lt;h1 id=&#34;computer-architecture:db4e8bc0878d0c9c387c4ffab2ea87af&#34;&gt;Computer architecture&lt;/h1&gt;

&lt;p&gt;cpu&lt;br /&gt;
memory&lt;br /&gt;
I/O&lt;/p&gt;

&lt;h1 id=&#34;contents:db4e8bc0878d0c9c387c4ffab2ea87af&#34;&gt;Contents&lt;/h1&gt;

&lt;p&gt;I/O IC&lt;br /&gt;
Assembly language&lt;br /&gt;
Interrupt&lt;br /&gt;
ISA&lt;br /&gt;
Machine language&lt;br /&gt;
Interpreting Machine Language Code&lt;br /&gt;
Microarchitecture&lt;br /&gt;
Digital Logic circuit(Logic gates)&lt;br /&gt;
ALU&lt;br /&gt;
Computer memory&lt;br /&gt;
Register/Flip-flop&lt;br /&gt;
Cache/SRAM&lt;br /&gt;
DRAM/capacitor&lt;br /&gt;
Analog Circuit&lt;br /&gt;
BJT FET Didoe&lt;/p&gt;

&lt;h2 id=&#34;isa:db4e8bc0878d0c9c387c4ffab2ea87af&#34;&gt;ISA&lt;/h2&gt;

&lt;p&gt;model: 1570s, &amp;ldquo;likeness made to scale; architect&amp;rsquo;s set of designs,&amp;rdquo; from Middle French modelle&lt;br /&gt;
Semantics in computer science: In programming language theory, semantics is the field concerned&lt;br /&gt;
with the rigorous mathematical study of the meaning of programming languages.&lt;br /&gt;
Language primitive&lt;br /&gt;
ISA: memory model, registers, data types, instructions, word size(?).&lt;br /&gt;
Memory model: unit of address resolution, word, aligment, address space, addressing mode, memory barrier/memory order primitive&amp;rsquo;s semantics.&lt;br /&gt;
The interface between hardware and software.&lt;br /&gt;
Arm v7&lt;br /&gt;
word = instruction&lt;br /&gt;
vocabulary = instruction set&lt;/p&gt;

&lt;h2 id=&#34;microarchitecture:db4e8bc0878d0c9c387c4ffab2ea87af&#34;&gt;Microarchitecture&lt;/h2&gt;

&lt;p&gt;datapath: memories, registers, ALUs, multiplexers.&lt;br /&gt;
control unit/decoder&lt;br /&gt;
Microcode&lt;br /&gt;
How to gurante that every control signal arrive the destnations before the data that will also pass through the destination?&lt;br /&gt;
What is the pipeline?&lt;br /&gt;
architectural state (the program counter and registers&lt;/p&gt;

&lt;h1 id=&#34;logic-circuit:db4e8bc0878d0c9c387c4ffab2ea87af&#34;&gt;Logic circuit&lt;/h1&gt;

&lt;p&gt;Sequential logic&lt;br /&gt;
Combinational logic&lt;/p&gt;

&lt;h2 id=&#34;computer-memory:db4e8bc0878d0c9c387c4ffab2ea87af&#34;&gt;Computer memory&lt;/h2&gt;

&lt;p&gt;flip-flops &amp;amp; latches, register files(?), memorys&lt;br /&gt;
What is NOR gates?&lt;br /&gt;
What is the implement of gate?&lt;/p&gt;

&lt;p&gt;data type&lt;br /&gt;
instructions: 算术, 控制, 数据传送&lt;br /&gt;
register file&lt;br /&gt;
addressing modes(include memory mode)&lt;br /&gt;
interrupt and exception handling,&lt;br /&gt;
external I/O&lt;/p&gt;

&lt;p&gt;#x86 Interrupt&lt;br /&gt;
If interrupt occured in user mode, then cpu will context swith for potential reschedule.&lt;br /&gt;
The Interrupt Descriptor Table (IDT) is a data structure used by the x86 architecture to implement an interrupt vector table.&lt;br /&gt;
##Hardware interrupts&lt;br /&gt;
are used by devices to communicate that they require attention from the operating system.&lt;br /&gt;
asynchronus&lt;br /&gt;
more details in init_IRQ() or set_irq() in driver.&lt;br /&gt;
##software interrupt&lt;br /&gt;
synchronus&lt;br /&gt;
more details in trap_init().&lt;br /&gt;
* exception or trap&lt;br /&gt;
is caused either by an exceptional condition in the processor itself,&lt;br /&gt;
divide zero painc?&lt;br /&gt;
* special instruction, for example INT 0x80&lt;br /&gt;
or a special instruction in the instruction set which causes an interrupt when it is executed.&lt;/p&gt;

&lt;h2 id=&#34;microarchitecture-1:db4e8bc0878d0c9c387c4ffab2ea87af&#34;&gt;Microarchitecture.&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;pipeline, 为什么流水工作效率高?复用? 一整条流水线对应一种指令:运算指令(算术 控制) or 数据传输指令(load sotre)对于RISC&lt;br /&gt;
IF阶段也可以访问存储器,要和load sotre分开. IF是对指令的读取. load store是对数据, 这是icache和dcache产生的原因, FIXME.&lt;br /&gt;
结构冒险说的就是i/dcache没分开, IF 和MEM冲突了.&lt;br /&gt;
数据冒险, 指令件参数依赖造成的问题.&lt;br /&gt;
控制冒险, 流水越深,危害越大.软件排空流水的方法是加nop, x86硬件排空,分支预测减少危害.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;branch prediction.&lt;br /&gt;
dsp用条件执行替代跳转.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;out-of-order&lt;br /&gt;
乱序执行相对于顺序执行.&lt;br /&gt;
无关指令可以任意执行.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;superscalar&lt;br /&gt;
instruction cycle, 什么是cycle.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;data level parallelism&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;thread level parallelism&lt;br /&gt;
超线程, 同步问题.&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cache&lt;br /&gt;
cache miss&lt;br /&gt;
住要看cache, 乱序, 还有lock对执行的影响.&lt;br /&gt;
temporal locality: for icache&lt;br /&gt;
spatial locality: array&lt;br /&gt;
第一次访问内存里arry[0]很慢, 可被load cacheline 后其他数组成员访问延时就飞了.&lt;br /&gt;
##Cache&lt;br /&gt;
a cache is a component that stores data so future requests for that data can be served faster;&lt;br /&gt;
the data stored in a cache might be the results of an earlier computation,&lt;br /&gt;
or the duplicates of data stored elsewhere.&lt;br /&gt;
###CPU cache&lt;br /&gt;
A CPU cache is a cache used by the central processing unit (CPU) of a computer&lt;br /&gt;
to reduce the average time to access data from the main memory.&lt;/p&gt;

&lt;h4 id=&#34;associativity-cpu-cache-algorithms:db4e8bc0878d0c9c387c4ffab2ea87af&#34;&gt;Associativity - CPU Cache algorithms&lt;/h4&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Two-way set associative cache&lt;/p&gt;

&lt;h4 id=&#34;cache-coherence:db4e8bc0878d0c9c387c4ffab2ea87af&#34;&gt;Cache coherence&lt;/h4&gt;

&lt;p&gt;Cache coherence is the consistency of shared resource data that ends up stored in multiple local caches.&lt;br /&gt;
Cache conerence is mantained by mostly archtecure like cpu&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;MSI&lt;br /&gt;
####Cache type&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Instructin cache&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Data cache&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;TLB - Translation lookaside buffer&lt;br /&gt;
###GPU cache&lt;br /&gt;
###Disk cache&lt;br /&gt;
###Web cache&lt;/p&gt;

&lt;h2 id=&#34;fixme-concepts:db4e8bc0878d0c9c387c4ffab2ea87af&#34;&gt;FIXME concepts&lt;/h2&gt;

&lt;p&gt;code: 手电筒 -&amp;gt;　莫尔斯码&lt;br /&gt;
Numeral system: 手指头　-&amp;gt; 二进制&lt;br /&gt;
logic: 三段论 -&amp;gt; bool -&amp;gt; 电路开关 亚里士多德 布尔 香农&lt;br /&gt;
A Symbolic Analysis of Relay and Switching Circuits&lt;br /&gt;
The Mathematical Theory of Communication&lt;br /&gt;
触发器 英国射电物理学家 William Henry Eccles&lt;br /&gt;
晶体管&lt;/p&gt;

&lt;h1 id=&#34;phy-the-physical-layer:db4e8bc0878d0c9c387c4ffab2ea87af&#34;&gt;PHY &amp;ndash; The physical layer&lt;/h1&gt;

&lt;h2 id=&#34;introductions:db4e8bc0878d0c9c387c4ffab2ea87af&#34;&gt;Introductions&lt;/h2&gt;

&lt;p&gt;Fromwikipedia:&lt;br /&gt;
&amp;gt; In the seven-layer OSI model of computer networking, the physical layer or layer 1 is the first (lowest) layer.[1]&lt;br /&gt;
&amp;gt; The implementation of this layer is often termed PHY.&lt;br /&gt;
&amp;gt; The physical layer consists of the basic networking hardware transmission technologies of a network.&lt;br /&gt;
&lt;a href=&#34;https://www.kernel.org/doc/Documentation/networking/phy.txt&#34;&gt;https://www.kernel.org/doc/Documentation/networking/phy.txt&lt;/a&gt;&lt;br /&gt;
PCS&lt;br /&gt;
PMD&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;i-o-ic:db4e8bc0878d0c9c387c4ffab2ea87af&#34;&gt;I/O IC&lt;/h1&gt;

&lt;p&gt;serial communication: UART(16550) + RS-232&lt;br /&gt;
parallel communication: SCSI, ISA, ATA, PCI, FSB&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux time subsystem</title>
      <link>http://firoyang.org/kernel/time/</link>
      <pubDate>Tue, 22 Sep 2015 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/kernel/time/</guid>
      <description>

&lt;p&gt;我写作的主要目的是理清基本概念与原理, 而非实现,细节这一类.&lt;/p&gt;

&lt;p&gt;时间是人类发明出来的概念, Kant也认为时间是心智概念.&lt;br /&gt;
一百年前的世界和现在有什么不同呢?这个提问揭示生活中时间最重要的用途,&lt;br /&gt;
*标记*某中状态下的世界. 所谓的过去世界不过是世界的一个个连续状态&lt;br /&gt;
那么时空穿越, 就变成了保住项少龙这个肉身不变, 世界的其他部分完全&lt;br /&gt;
转变到过去的某一个状态. 而所谓现在世界就被抹杀了.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The future is already here – it&#39;s just not evenly distributed.
                        — William Gibson
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;人想回到&amp;rdquo;过去&amp;rdquo;多半源于情感因素, 而想去&amp;rdquo;未来&amp;rdquo;则是因为&amp;rdquo;物质&amp;rdquo;的缘故.&lt;br /&gt;
想象下中国的未来50年, 很可能是现在美国or西欧现在的样子.虽然中西虽然处在&lt;br /&gt;
时间概念上相同的现在, 而物质世界确实&amp;rdquo;过去&amp;rdquo;和&amp;rdquo;未来&amp;rdquo;之差.&lt;/p&gt;

&lt;p&gt;比如我们下周而要开会, 那么此时下周二就是有意识的规划未来, 时间依然是标记.&lt;br /&gt;
UTC/GMT&lt;br /&gt;
Based on caesium microwave atomic clock&lt;br /&gt;
Leap second&lt;/p&gt;

&lt;h2 id=&#34;genus-differentia-definition:eefdcd66b28c2b86ef84bba398f2d59a&#34;&gt;Genus-differentia definition&lt;/h2&gt;

&lt;p&gt;interrupt, clock event,  clock source, tick, timer, timekeeping, gettimeofday.&lt;/p&gt;

&lt;h2 id=&#34;功用定义:eefdcd66b28c2b86ef84bba398f2d59a&#34;&gt;功用定义&lt;/h2&gt;

&lt;p&gt;获取时间&lt;br /&gt;
timer&lt;br /&gt;
sleep ?&lt;br /&gt;
update sched info&lt;/p&gt;

&lt;h2 id=&#34;发生定义-设计-etymology-history-operational-definition:eefdcd66b28c2b86ef84bba398f2d59a&#34;&gt;发生定义/设计   etymology, history Operational definition&lt;/h2&gt;

&lt;p&gt;timekeeping/计时:时刻．&lt;br /&gt;
clock source: 时间之源, 表针之力.&lt;br /&gt;
clock event: 闹铃之力, 经过tick展现能力.&lt;br /&gt;
tick: timer的中断事件叫tick, tick device产生tick, 可以说tick决定了clock_event event_handler进而决定了, clock_event行为.&lt;br /&gt;
tickless:&lt;br /&gt;
for timer: use HW timer one shot, set next.&lt;br /&gt;
for update time: in above HW timer, not good&lt;br /&gt;
for sched: for priority distributed in time slice, use timer.&lt;br /&gt;
dynamic tick/no HZ:&lt;br /&gt;
No HZ in idle&lt;br /&gt;
No HZ while only 1 process running for HPC.&lt;br /&gt;
tick devies 就是clock event包了层虎皮.&lt;br /&gt;
tick broadcast framework:  based on tick device&lt;br /&gt;
clock: 可记录时间, 表盘.利用timekeeping&lt;br /&gt;
timer: use clock. what about timer_list?&lt;br /&gt;
timer_list: do in softirq&lt;br /&gt;
* timekeeping aspect&lt;br /&gt;
onset: start_kernel -&amp;gt; timekeeping_init &amp;amp; time_init &amp;amp;(rest_init-&amp;gt; kernel_init-&amp;gt; \&lt;br /&gt;
kernel_init_freeable-&amp;gt;do_basic_setup-&amp;gt;do_initcalls&amp;ndash;device_initcall(init_clocksource_sysfs))&lt;br /&gt;
nucleus:used by clock see init_posix_timers and update_wall_time and sys_time&lt;br /&gt;
coda:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;clock source aspect&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;tick device layer aspect&lt;br /&gt;
per_cpu(tick_cpu_device, cpu)&lt;br /&gt;
onset: time_init-&amp;gt;mach-&amp;gt;init_time-&amp;gt;&amp;hellip;clockevents_register_device-&amp;gt;tick_check_new_device&lt;br /&gt;
nucleus: a38x_timer_interrupt-&amp;gt;a38x_clkevt.event_handler&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;tick broadcast framework&lt;br /&gt;
onset:&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;clock aspect&lt;br /&gt;
k_clock&lt;br /&gt;
onset:init_posix_timers &amp;amp; init_posix_cpu_timers&lt;br /&gt;
nucleus: 用户-&amp;gt; posix_clock-&amp;gt;timepkeeping-&amp;gt;clock_socurce&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;timer aspect&lt;br /&gt;
onset: open_softirq(HRTIMER_SOFTIRQ, run_hrtimer_softirq);&lt;br /&gt;
nucleus: common_timer_set&lt;br /&gt;
hrtimer_interrupt | (tick_handle_periodic-&amp;gt; tick_periodic-&amp;gt; update_process_times-&amp;gt;run_local_timers-&amp;gt;hrtimer_run_queues)-&amp;gt;__run_hrtimer-&amp;gt;timer.function = posix_timer_fn;(set in common_timer_set)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;计算机概念&lt;br /&gt;
system clock CLOCK_REALTIME CLOCK_MONOTONIC&lt;br /&gt;
time.h time_t=tm=timeval=timespec calendar time  clock_t&lt;/p&gt;

&lt;p&gt;clock event -&amp;gt; tick device-&amp;gt; handle function&lt;br /&gt;
clock event 相较于timer更为抽象, timer 是一种用途,timer 通过clock event来实现功能,&lt;br /&gt;
clock event 通过timer来体现自己, timer面向使用者的onset,&lt;br /&gt;
而clock event 则是偏向于nucleus and coda.&lt;br /&gt;
timer: 标记不能立即执行的变化.&lt;br /&gt;
clock source: 用一些整型抽象一个过程, 对于时间来说, 简直是完美的抽象.&lt;br /&gt;
* kernel requirement&lt;br /&gt;
linux的时间子系统要求硬件timer提供下面两种能力：&lt;br /&gt;
一是free running的counter，此外需要能够在指定的counter值上产生中断的能力。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Quantitative congnition - The philosophy on which I live</title>
      <link>http://firoyang.org/philosophy/philosophy/</link>
      <pubDate>Sun, 13 Sep 2015 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/philosophy/philosophy/</guid>
      <description>

&lt;p&gt;我正在常识建立一套量化认知体系. 为什么要做这件事? 无论是之于生命个体还是整个人类社会的演化总是依凭着对世界更深入, 更全面的认知. ? 正如Schlick 在General Theory of Knowledge 所言&amp;hellip; 而这种认知本身是什么呢? 在哲学上, Epistemology专门研究这个问题. 而我继续前人的工作.&lt;/p&gt;

&lt;h1 id=&#34;big-map:007041aa20bf44bd43eba68b5f650c57&#34;&gt;Big map&lt;/h1&gt;

&lt;p&gt;首先, 你要量化目标事物, 确定能量化多少, 还是不能量化.&lt;br /&gt;
对于能力之外的事情, 不能量化, 也无法量化. 需要方向和切入点.&lt;br /&gt;
可以量化的事情, 就可以确定具体的方法.&lt;/p&gt;

&lt;h2 id=&#34;量化对象选取与分析:007041aa20bf44bd43eba68b5f650c57&#34;&gt;量化对象选取与分析&lt;/h2&gt;

&lt;p&gt;定义度, Pragmatism, 视野广度, origin, general度, 重要度, 常用度, foundation, protye.&lt;br /&gt;
对于知识类的思维事物遵从以上原则.对于行为类的事物, 如debug, 生活, 还没有总结原则.&lt;br /&gt;
我们单看认知与解决问题这两种行为中的两个对象.认知的对象通常是一个复杂的整体.&lt;br /&gt;
而解决问题更多的则是在复杂的整体中趟出一条线来.这种理所当然的界定, 尤其适合应用到computer science.&lt;br /&gt;
这条趟出来的线是100%Pragmatism, 逻辑完整性的.而学习认知对象的时通常思维是没有特定的聚焦点的,&lt;br /&gt;
很分散的. 所以在认知的时候用Descartes的划分的方法之外, 还要把他问题化同时确保问题的Pragmatism.&lt;br /&gt;
而保持逻辑的完整和pragmatism, 最好的方法就是自我按步骤推理.&lt;/p&gt;

&lt;h2 id=&#34;量化方法的选取评估-criteria-and-banchmark:007041aa20bf44bd43eba68b5f650c57&#34;&gt;量化方法的选取评估 Criteria and banchmark&lt;/h2&gt;

&lt;p&gt;理性程度, 合理度, 可行度(简单, 易操作, 可长久做下去).&lt;br /&gt;
Completeness, consistency, validity, soundness. &amp;ndash; Logic&lt;br /&gt;
Accept as true only what is indubitable. &amp;ndash; Descartes&lt;br /&gt;
Falsifiability可证伪性 &amp;ndash; Popper&lt;br /&gt;
批判性, 你所学的一切都是暂时性的,任何所学都有改口 驳斥 质疑的余地 &amp;ndash;Aaron Swartz,25:20&lt;br /&gt;
对于学习的知识上, 方法要做到知识之间的联系, 转换关系.&lt;br /&gt;
To attain perfect clearness in our thoughts of an object, then, we need only consider&lt;br /&gt;
what conceivable effects of a practical kind the object may involve what sensations we&lt;br /&gt;
are to expect from it, and what reactions we must prepare. (1907: 29)&lt;br /&gt;
                &amp;ndash; James, Pragmatism: A New Name for an Old way of Thinking&lt;br /&gt;
每一次问题解决后都应积累pattern. &amp;ndash; Firo&lt;br /&gt;
问题的解决方法要能够Self-correcting. 也就是索罗斯的反射原理.&lt;/p&gt;

&lt;h1 id=&#34;adverse-factors-of-congition:007041aa20bf44bd43eba68b5f650c57&#34;&gt;Adverse factors of congition&lt;/h1&gt;

&lt;p&gt;认知的缺陷, imperfect-understand, 彻底可错性. &amp;ndash;Firo Soros Popper&lt;br /&gt;
别人(自己存在)认识的谬误性. &amp;ndash; Firo Soros&lt;br /&gt;
个人 or Government 掩盖篡改历史的真相.&lt;br /&gt;
越是大型的魔术表演，其门道往往就越是简单！人们认定不可能发生这种事的常识，固定观念往往孕育出盲点！&amp;ndash; 唐吉诃德·多弗朗明哥&lt;br /&gt;
正义会胜？那是当然的吧，只有胜者，才是正义啊！&amp;ndash; 唐吉诃德·多弗朗明哥&lt;/p&gt;

&lt;h1 id=&#34;量化的方法步骤:007041aa20bf44bd43eba68b5f650c57&#34;&gt;量化的方法步骤&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;自己思考. 不要上来就读or做, 你要思考这个过程.&amp;ndash; Firo&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;首先要思考的就是找到整个思考认知系统的落脚点, 基石. Cognitive from ground/zero.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;根据具体的定义的问题, 使用具体的现成的方法.&lt;br /&gt;
比如做生活计划的时候, 很多时候是无力的. 可以从缺点不足之处,开始不断弥补. 生活不在别处, 正是当下此地.&lt;br /&gt;
还有英语的学习, 越真实的实践, 越多的实践, 提高越大. 可以不断的听, 听真是的场景. 找到不足修正.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果没有现成的方法, 整体的方向和切入点很重要. 因为你没有足够的能力完成和掌控它.&lt;br /&gt;
很多时候要多种方法一起用.&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;从个人角度, 越靠近真实, 越真实, 不靠近就会远离. 这也是因果律的体现, 越靠近因, 越靠近果.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;切入点的选取也就是量化对象, 必须脚踏实地, 循序渐进一步一个脚印.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;切入点可以是以完整理论为基点的推理过程, 偏向于认知, 没有明确特定的侧重点, 而实际上理解认知本身就是侧重点, 也不过本身在认知完成前具有模糊性, 因为它不予特定的Pragmatism想关联;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;也可以是实际的问题, 偏向于解决问题, 有核心侧重点.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;去看看别人怎么做的, 也可以思考什么书或者人会遇到相似的问题, 有解决的方法.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;可以自己从公理出发构建出一套方法.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;保守点从自己的不足之处开始.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;一些通用的方法, 可以帮助我们解决很多问题.&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;笛卡尔方法&lt;br /&gt;
Divide every question into manageable parts. &amp;ndash; Descartes&lt;br /&gt;
Begin with the simplest issues and ascend to the more complex. &amp;ndash; Descartes&lt;br /&gt;
Review frequently enough to retain the whole argument at once &amp;ndash; Descartes&lt;br /&gt;
Accept as true only what is indubitable. &amp;ndash; Descartes&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;语言分析, 是我认知的重要工具, 甚至是主要工具. &amp;ndash; Firo, Saussure&lt;br /&gt;
抽象明确概念所属的范畴,从而正确的定义理解问题.&lt;br /&gt;
内涵定义: Genus-differentia definition 属加种差定义: 发生定义(设计), 关系定义, 功用定义, 摹状定义&lt;br /&gt;
充要定义, Real and nominal definitions&lt;br /&gt;
Classes of extensional definitions: enumerative definition&lt;br /&gt;
&lt;a href=&#34;http://plato.stanford.edu/entries/definitions/&#34;&gt;Definitions Stanford Encyclopedia of Philosophy&lt;/a&gt;&lt;br /&gt;
语言必须被还原到实际的生活场景  &amp;ndash; 维特根斯坦&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Pragmatism questions:&lt;br /&gt;
Why does it appear? What problem does it solve? What happend if it does not exist?&lt;br /&gt;
How does it solve this problem in generalization and different sesanations level?&lt;br /&gt;
Is it good or bad? What is the feedback?&lt;br /&gt;
Question about what is the important, foundation, most useful, minimal cached? &amp;ndash; Firo&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Autonomous decision and Change-of-state calculus &amp;ndash;Firo-Von Wright’s approach&lt;br /&gt;
胡适日记全集 第三册，1921年7月10一则杜威先生不曾给我们一些关于特别问题的特别主张，&lt;br /&gt;
——如共产主义，无政府主义，自由恋爱之类，——他只给了我们一个哲学方法，使我们用这个方法去解决我们自己的特别问题。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;（1）历史的方法——“祖孙的方法”   the genetic method, why xxx?&lt;br /&gt;
他从来不把一个制度或学说，看做一个孤立的东西，总被他看做一个中段；一头是他所以发生的原因，一头是他自己发生的效果；上头有他的祖父，下头有他的孙子。捉住了这两头，他再也逃不出去了！这个方法的应用，一方面是很忠厚宽恕的，因为他处处指出一个制度或学说所以发生的原因，指出他历史的背景，故能了解他在历史上的地位和价值，故不致有过分的苛责。一方面，这个方法又是很严厉的，最带有革命性质的。因为他处处拿一个学说或制度发生的结果，来评判他本身的价值，故最公平，又最利害。这种方法，是一切带有评判（Critical）精神的运动的一个武器。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;（2）实验的方法　　实验的方法，至少注重三件事：&lt;br /&gt;
（一）从具体的事实与境地下手；&lt;br /&gt;
（二）一切学说理想，一切知识，都只是待证的假设，并非天经地义；&lt;br /&gt;
（三）一切学说与理想，都须用实行来试验过。实验是真理的唯一试金石。&lt;br /&gt;
第一件，——注意具体的境地——使我们免去许多无谓的问题，省去许多无意识的争论。&lt;br /&gt;
第二件，——一切学理都看做假设——可以解放许多“古人的奴隶”。&lt;br /&gt;
第三件，——实验——可以稍稍限制那上天下地的妄想冥想。实验主义只承认那一点一滴做到的进步，步步有智慧的指导，步步有自动的实验——才是真进化。&lt;br /&gt;
所谓实验的方法应该看成实证主义, 而不是更宽泛的实用主义. 维也纳小组, 即是逻辑实证主义.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;模式-结构-关系-原理:007041aa20bf44bd43eba68b5f650c57&#34;&gt;模式 &amp;ndash; 结构 关系 原理&lt;/h1&gt;

&lt;p&gt;逻辑问题定位, 一定要遵从整体到部分, 有前到后, 逻辑一定要completeness. 如wfi问题, 先看下3.2sdk的config, 就done了.&lt;br /&gt;
问题总是复杂的, 解决方法总是简单的.  &amp;ndash;xiaolai.li&lt;br /&gt;
computer first pattern: init onset, running nuclus, exit coda&lt;/p&gt;

&lt;h1 id=&#34;世界的组成-属性:007041aa20bf44bd43eba68b5f650c57&#34;&gt;世界的组成, 属性&lt;/h1&gt;

&lt;p&gt;因果律&lt;br /&gt;
转换,不稳定,不确定性,复杂，&lt;/p&gt;

&lt;h1 id=&#34;mind:007041aa20bf44bd43eba68b5f650c57&#34;&gt;mind&lt;/h1&gt;

&lt;p&gt;认知的unit是概念.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Firo</title>
      <link>http://firoyang.org/firo/firo/</link>
      <pubDate>Tue, 25 Aug 2015 15:46:11 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/firo/firo/</guid>
      <description>&lt;p&gt;一个人应该与外界的应该保持什么样的关系? 每个人都应该有自己的回答, 而且答案不一而终.&lt;br /&gt;
正是这种关系成就了我们的一生.个体如何确定这种关系,或者说如何确定一种合理的生存状态?&lt;br /&gt;
对于人类丰富, 无止尽的欲望而言, 很难给出统一的答案.然而这并不妨碍我们找到理想的状态.&lt;br /&gt;
简单说来, 两点; 那些来自内心的, 原始的, 本能的愿望正是我们生活的方向, 不应被忽视, 反而&lt;br /&gt;
要经常回忆起来, 并视若内心的珍宝一样对待; 另外, 我们应该做的是弥补生活中的不足, 以此来&lt;br /&gt;
向理想中的生活不断的迈进, 而不是沉醉于对理想的执着与等待中. 从实实在在的生活不足开始,&lt;br /&gt;
这才是真实的, 是你的生活.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;生活不在别处, 正是当下此地.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于世界一部分的个体, 充分的认识世界的运作机制, 成为确定自己生活状态的前提. 对于普通人&lt;br /&gt;
而言, 这似乎无从下手. 尤其是对于处在巨大生存压力下的人, 无暇顾及这般如同象牙塔式的问题?&lt;br /&gt;
我想这正是他们生活悲剧的根源之一. 对于了解这个世界, 实际上要简单许多. 我想, 只要你有意识&lt;br /&gt;
地在遇到困惑, 疑问, 艰难, 令人不适的生活的时候, 寻找这些问题背后的原因的时候, 答案便会出现.&lt;br /&gt;
而答案就是一种关系, 因果律. 同时连带得出关系的主客体. 比如, 49年后, 中国人都有一个潜在&lt;br /&gt;
的伟大的身份, 社会主义建造者.这是个体和国家之间的某种答案,在我出生之时, 变自动获得这种身份.&lt;br /&gt;
直到我意识到这种身份的存在时, 我毫不犹豫的放弃了它.因为我并不是一个社会主义者,&lt;br /&gt;
我打心眼里抵触社会主义, 我很难想象他的存在, 同时那样的社会对我来说是一种无声的恐惧,&lt;br /&gt;
因为他偏离人性的核心, 那样的社会下的生活, 我一点也不期待, 我已体验过了.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;显然, 在人与世界的诸多联系中, 有一些是被他人赋予, 而那些强制赋予的很多都成了枷锁.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于确定生命个体的合理生存状态, 可以看成找到你与世界现有的关系以及想要的某种关系.&lt;br /&gt;
首先, 我们要理清那些重要的关系. 可以说我的哲学就是建立在关系之上, 也就是因果律.&lt;br /&gt;
人总生活在关系中, 我认为下面的关系很重要.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;从个人角度, 越靠近真实, 越靠近真实, 不靠近就会远离. 这也是因果律的体现.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;即便你找不到期待中的生活状态，你也活在关系中, 这也是最基本的．&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;人生没有目标, 也要好好活着!&lt;br /&gt;
所有人都是某些东西的奴隶 &amp;ndash; 进击的巨人&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其他的规律：&lt;/p&gt;

&lt;p&gt;＞正反合&lt;br /&gt;
&amp;gt; 完整的逻辑,包含不存在&lt;br /&gt;
&amp;gt; 生活就是同傻逼的战争!&lt;br /&gt;
&amp;gt; 每个人都有自己内心的弱点, 不必害怕他们.&lt;br /&gt;
&amp;gt; 生长需要滋润.&lt;br /&gt;
&amp;gt; 成长开始于注意到缺陷, 疑问&lt;br /&gt;
&amp;gt; 很多时候其实我们的忙碌都是做着自己并不在乎的事情！&lt;br /&gt;
&amp;gt; 生命所不能承受之轻!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>My Career</title>
      <link>http://firoyang.org/firo/career/</link>
      <pubDate>Sun, 26 Jul 2015 15:46:11 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/firo/career/</guid>
      <description>

&lt;p&gt;无论是位高权重的政治家, 富贵显荣的商人, 亦或是蝇营狗苟的市侩之人等等, 所有芸芸众生&lt;br /&gt;
每日莫不是为了谋生而奔走. 长久的活着是一种负担.&lt;br /&gt;
忙碌的生活, 难以审视自己的人生. 今天坐下来, 谈谈这个话题.&lt;/p&gt;

&lt;p&gt;毫无已问, 从小到大, 即便是为曾到达的未来, 工作都占据了我们据大多数时间, 当然X二代&lt;br /&gt;
不在此列. 在这个社会, 即便每日辛劳的工作, 绝大多数人, 依然连自己卑微的梦想都无法实现.&lt;br /&gt;
今天, 我不谈政治层面的原因. 只想从个人角度, 去剖析人与工作之间的关系.&lt;/p&gt;

&lt;p&gt;英文&lt;a href=&#34;https://en.wikipedia.org/wiki/Career&#34;&gt;career&lt;/a&gt;, 在维基给出了基本的解释:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A career is an individual&#39;s journey through learning, work and other aspects of life.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;词源上是由马车引出的人生之路的涵义. 而中文, 生涯出自《庄子·养生主》：“吾生也有涯，而知也无涯。”&lt;br /&gt;
我们今天主要谈两个问题, 人生的马车和人生的&amp;rdquo;涯&amp;rdquo;.&lt;br /&gt;
我的职业生涯始于大学, 童年时期热爱电子游戏, 导致大学选择了计算机科学这个行业. 到今天整整过去了&lt;br /&gt;
7个年头, 不短了. 本人只敢自称勤奋之人, 大学伊始至今, 绝大多数时光都在勤奋治学, 未曾懈怠.&lt;br /&gt;
大学毕业三年, 依然没有实现自己当初的愿望, a remote kernel hacker. 这个目标完全是个人喜好, 性格使然.&lt;br /&gt;
同时也受限于我个人的视野.&lt;br /&gt;
1. 我喜欢自由, 所以不希望自己被束缚在办公室里面, 我期望那种一边旅行一边工作的生活.&lt;br /&gt;
所以纯个人脑力的工作是我的第一选择, programmer, 作家,都在此列, 而且我也很喜欢且擅长这样的工作.&lt;br /&gt;
2. 我喜欢开放的东西, 开源的软件就成了我的选择, kernel, openstack, 都是那时的选择.&lt;br /&gt;
3. 我喜欢有挑战的事情, 11年一起在sina实习的同学, 现在是openstack的remote开发者了,&lt;br /&gt;
当初我们一起去的, 我最后选择了kernel, 源于我认为kernel会更靠近计算机科学.&lt;br /&gt;
我对web相关的技术有偏见,觉得缺乏深度且很多与用户体验相关.&lt;br /&gt;
其实很多&lt;a href=&#34;http://careers.stackoverflow.com/jobs/remote&#34;&gt;职位&lt;/a&gt;都是可以remote的不限于open source的, 而且相对于&lt;br /&gt;
kernel和openstack的remote工作机会更多.&lt;br /&gt;
4. 我认为社会风气不好, 会对计算机这个行业有影响, 我更侧重选择纯技术的方向, 原理web, 具体业务.&lt;br /&gt;
这就是当时的思考, 当初的视野太狭隘了,主观臆断太严重.&lt;br /&gt;
这个时候薪资都不在考虑之列, 以为做喜欢的事就很开心了.&lt;br /&gt;
大学4年都在逃课, 专业知识, 都是仿照MIT和Computer ScienceCurriculum 2008自己设计出来的.&lt;br /&gt;
大学一年级, 看各种游戏的书,&lt;br /&gt;
大学二年级做机器人的比赛还有和艺术学院合作的事情,&lt;br /&gt;
大二下学期开始基础linux,看apue 还有unp这些书, 开始搞搜索引擎&lt;br /&gt;
大三的时候看了csapp, 还有组合数学&lt;br /&gt;
大四上学期基本上没干什么事, 10月份就去sina实习了, 下学期开始看内核.&lt;br /&gt;
虽然一直都很忙, 但是没学到什么东西.&lt;br /&gt;
我放弃了sina的offer, 毕业(12年7月)后整整有一年时间没有工作了.&lt;br /&gt;
一直到次年13年的9月才开始去极路由工作.到今年15年5月离职.&lt;br /&gt;
现在以外包的形式在windriver的ccm team 工作.&lt;br /&gt;
这就是我职业生涯的7年时光, 过得很坎坷.&lt;/p&gt;

&lt;h1 id=&#34;plan:7e6e72851422b97b7259805ca91208dc&#34;&gt;Plan&lt;/h1&gt;

&lt;p&gt;0916, 0515, 8 months&lt;br /&gt;
Go abroad &amp;amp; HB1&lt;br /&gt;
English: 3w&lt;br /&gt;
Work achievement: 6w&lt;br /&gt;
Problem solving/Pattern or estemology: 3w&lt;br /&gt;
Kernel patches 500 commits, 10w&lt;/p&gt;

&lt;h1 id=&#34;interview:7e6e72851422b97b7259805ca91208dc&#34;&gt;Interview&lt;/h1&gt;

&lt;h2 id=&#34;关于薪资问题:7e6e72851422b97b7259805ca91208dc&#34;&gt;关于薪资问题&lt;/h2&gt;

&lt;p&gt;全面回答包括股票期权.&lt;br /&gt;
real background.&lt;br /&gt;
期望的薪资别说太低, 往上也别说的太死, 比预期要高.&lt;br /&gt;
说更关注职业发展.&lt;/p&gt;

&lt;h2 id=&#34;想面试公司提出的问题:7e6e72851422b97b7259805ca91208dc&#34;&gt;想面试公司提出的问题&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;NO1. 我所应聘的这个职位为什么会出现空缺？&lt;br /&gt;
如果空, 空多长时间, 因为什么原因空的.&lt;br /&gt;
如果这个职位是新近才出现的，或许你就拥有了一个理想的、开辟属于自己的道路的机会。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;NO2. 请问贵公司最成功的员工为公司做出了什么样的贡献？&lt;br /&gt;
谁对公司贡献最大, 谁领导之类的, 做了什么? 有那些优秀品质. 了解公司文化.&lt;br /&gt;
面试管, 可能认为你是志在成功公司最优秀的员工之一.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;NO3.如何评估自己在三个月试用期内的工作表现？何种标准算成功？&lt;br /&gt;
该职位遇到的最大的挑战是什么?&lt;br /&gt;
了解公司做事风格, 是否稳重成熟. 排除不靠谱公司, 谁知道半年后他们&lt;br /&gt;
能干出什么? 谨慎对待抛出橄榄枝.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;NO5.目前公司所面对的最大的挑战有哪些？&lt;br /&gt;
这个编程比如说内核在公司的位置, 是否是中心.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;NO6.公司如何来保证人才不流失？&lt;br /&gt;
长期的意愿, 这个问题比较屌.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;NO7.请问您为什么要为这家公司工作呢？&lt;br /&gt;
连面试官自己都不知道为什么要为这家公司工作，你觉得这样的公司会给员工提供多少机会呢？&lt;br /&gt;
去面试工作，是一个相互合作的过程，并不是说哪一方成为主导。你为公司工作，公司给你报酬。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而对所有公司来说它总希望找到那一种类似合作伙伴的员工而不是仅仅是来打工的。&lt;br /&gt;
所以，在面试的时候除了展示你自身特长和文化外，还要表现出一个对公司前景关心和一种参与者的心态来。&lt;br /&gt;
这样能让公司的管理者对你更有好感！这不仅为了进入这个公司也为了以后的发展&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>有一段历史离我们如此近记忆却模糊</title>
      <link>http://firoyang.org/history/china_a_century_of_revolution/</link>
      <pubDate>Wed, 24 Jun 2015 15:46:11 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/history/china_a_century_of_revolution/</guid>
      <description>&lt;p&gt;毛泽东的时代&lt;br /&gt;
&lt;iframe width=&#34;420&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/GMaXSKH2w3c&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;p&gt;建国后出生的新一代&lt;br /&gt;
&lt;iframe width=&#34;420&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/qsmJXJcvG3g&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux virtualization</title>
      <link>http://firoyang.org/kernel/virt/</link>
      <pubDate>Wed, 17 Jun 2015 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/kernel/virt/</guid>
      <description>

&lt;p&gt;本文着重探讨下kvm的实现, 11年在snia的实习的时候, 接触过一点.&lt;br /&gt;
已经过去将近4年了,  当初看到qemu的代码, 被吓到了, 我靠, 这代码量赶上内核了!&lt;br /&gt;
现在kvm核心就1069行当前kernel 4.1 rc7, qemu虽然赶不上kernel但是也不少1144756.&lt;br /&gt;
看过指环王的, 都知道神奇中土大陆是托尔金虚构的魔幻世界,那里活着阿拉贡和&lt;br /&gt;
他的朋友们, 以及他们精彩的历程.人的想象力, 如此神奇, 他能使人超越时间与&lt;br /&gt;
空间去体验到不同生命历程.&lt;br /&gt;
今天, 我们来探索一下&lt;a href=&#34;https://en.wikipedia.org/wiki/Virtualization&#34;&gt;虚拟化&lt;/a&gt;&lt;br /&gt;
如wikipedia所说, 虚拟化始于上个世纪60年代, 这是指的计算机领域内的.&lt;br /&gt;
显然, 我们要把眼光放得更远, 因为我们想洞见一些深层次的内容.&lt;br /&gt;
法国哲学家福柯一生都在从事&amp;rdquo;知识考古学&amp;rdquo;, 而我也喜欢在研究问题时, 从语言学特别是&lt;br /&gt;
词源角度开始. virtual这个词, 最早来自于中世纪拉丁文virtualis, 涵义是&lt;br /&gt;
influencing by physical virtues or capabilities,&lt;br /&gt;
effective with respect to inherent natural qualities&lt;br /&gt;
受某种实在的长处能力影响, 源自本质的效用.&lt;br /&gt;
这里从两种角度理解virtual, 受影响者, 影响者本身.&lt;br /&gt;
所以这里virtual的真实涵义应该是延续某种内在的本质并施加于外物.&lt;br /&gt;
这个英文单词的汉语翻译是很有趣的, 摘自金山词霸:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;virtual 音节划分：vir▪tual
英 [ˈvɜ:tʃuəl] 美 [ˈvɜ:rtʃuəl]
adj.实质上的，事实上的；（计算机）虚拟的；&amp;lt;物&amp;gt;有效的，虚像的；（粒子）实际存在的
虚；虚拟艺术；虚拟的；模拟帐户
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个词汇简直是英语翻译界的笑话, 一会实一会虚, 非常让人困惑!&lt;br /&gt;
话说回来, 这个词的翻译确实有难度.我翻译的话会叫质延.&lt;br /&gt;
很多事情, 在我们出生前就决定了, 我是89年9月出生的.&lt;br /&gt;
我们搞懂了所谓&amp;rdquo;虚拟化&amp;rdquo;的实质, 之后就可以继续探索了.&lt;br /&gt;
如wikipedia, 所说计算机领域的虚拟化更多的是指hardware virtualization.&lt;br /&gt;
没错就是延伸硬件的特质, 准确说是在软件层继续延伸硬件的特质.&lt;br /&gt;
好, 首先, 我们要搞懂硬件都有那些特质? 硬件有很多, 在计算机领域指什么呢?&lt;br /&gt;
没错, CPU, 硬盘, 电路板, 内存, 鼠标键盘等等. 那么他们有什么特质呢?&lt;br /&gt;
所谓的特质就是特别的性质, 一种属性, 哲学上, 称之为事物对外物的作用的一种表现.&lt;br /&gt;
那么CPU的最大特质就是指令处理, 我想这也是虚拟化的核心吧!&lt;br /&gt;
我们硬件虚拟化延伸的终点是让另一个操作系统运行于当前操作系统提供的硬件特质延伸之上.&lt;br /&gt;
终于进入正文了. 现在我们自己来设计一套虚拟化基础架构, 让一个简单的kernel运行在当前的fedora&lt;br /&gt;
之上.&lt;/p&gt;

&lt;h2 id=&#34;fkvm:d29da9244342e72819e84d5dee753d17&#34;&gt;FKVM&lt;/h2&gt;

&lt;p&gt;没错我的虚拟化技术就叫这个FucK VM, 好吧, 其实简写于Firo&amp;rsquo;s KVM!&lt;br /&gt;
首先, 我们必须明确一点, 即便我 or 我们不能最终实现一个虚拟化架构让另一个kernel&lt;br /&gt;
运行起来, 今天在这里做得事情的意义, 依然深远且几乎无可替代!&lt;br /&gt;
因为, 至少你是在想象力,或者更为正式表述是在概念层次上让他运行起来了, 而且跑得飞快!&lt;br /&gt;
你在虚拟化一个虚拟化, 这就是智力劳动的乐趣.&lt;br /&gt;
怎么才能让一个kernel 运行起来呢? 能想到的就是从用户态起一个进程, 之后这个进程fork下去执行&lt;br /&gt;
start_kernel的代码.有点眉目了. 问题也来了, 内核启动的时候会各种初始化, 这会扰乱了现在正在运行的&lt;br /&gt;
cpu, 我能想到的这个新的内核的内存管理不能和之前运行的fedora的冲突, 两个都玩完, 首先要隔离内存.&lt;br /&gt;
也就是要虚拟化一块内存. 怎么解决, 最简单的直接malloc一块空间给他吧. 怎么给? 为了简单.&lt;br /&gt;
在内核初始化的时候, 会用调用bios的中断来获取内存信息.&lt;br /&gt;
也就是说我们要先弄一个虚拟bios出来啊. 先假设bios, 我们弄出来了.&lt;br /&gt;
开机先执行这段bios代码, 把之前申请的内存告诉bios, 之后我们在内核内核初始化的时候, 就用这块.&lt;br /&gt;
现在问题用来了. 内核要访问这块内存就必须为他建页表, 申请的这块内存可能是不连续的而且还可能是&lt;br /&gt;
高端内存, 内核初始化的代码可没考虑这么复杂. 要么该内核, 要么改FKVM, 显然不能改内核啊.&lt;br /&gt;
只能去尝试, 虚拟一个CPU, cpu指令那么复杂, 怎么能搞定. 是否有必要, 搞那么复杂呢?&lt;br /&gt;
我们的一个cpu就是一个进程.这个cpu执行内初始化的代码, 需要想办法, 让内核感知不到底层的变化.&lt;br /&gt;
就好比, 他访问了一块高端内存, 但这个内核, 里面的页表却标明他是低端, 随意访问.&lt;br /&gt;
也就是说, 我们要截获cpu访存的指令, 并且要把他再次重定向到真正的物理内存.&lt;br /&gt;
如何截获?我们不能有太多假设.而且现在的工作, 实际已经被usermode linux 完成了.&lt;br /&gt;
这里需要很多底层的知识. 先看点资料再回来.&lt;br /&gt;
看了下基本实现, 这里我们的思路没有问题, 只不过指令和优先级的问题没有考虑.&lt;br /&gt;
访问特权指令确实是被截获的. intel引入了vt-x来解决这个问题.&lt;br /&gt;
探索这种复杂的系统, 就行探索一座深山一样, 如果不加思索就突入进去, 最终会迷路.&lt;br /&gt;
无论别人说的多么好, 我们必须要有自己的思路.&lt;br /&gt;
总结下所得:&lt;br /&gt;
控制虚拟机对全局资源的访问, 通过截获虚拟的某些指令.&lt;br /&gt;
虚拟化一块内存.&lt;br /&gt;
我们知道想中断啊, IO这些都得良好的处理掉, 否这会影响到我们早已运行的fedora.&lt;br /&gt;
由于缺少太多硬件知识, 在这样思考下去, 就会变成满篇假设了, 这和我们的目的背道而驰了.&lt;br /&gt;
同时乐趣也会减少.&lt;/p&gt;

&lt;h1 id=&#34;kvm-qemu:d29da9244342e72819e84d5dee753d17&#34;&gt;KVM QEMU&lt;/h1&gt;

&lt;p&gt;现在我们来了解KVM, 在经过前面不成熟的思考好, 结果有点令人沮丧. 似乎我们什么都没完成&amp;hellip;&lt;br /&gt;
探索的方式, 依然是以自我思考为主, 通过提问的形式完成思考过程.&lt;br /&gt;
千万不可成了, 靠一点一滴积累别人的思想感悟来成长. 万万不可.对于问题的洞见主力依然&lt;br /&gt;
是我们自己, 别人的知识只是辅助. 那好我们开始.&lt;br /&gt;
首先, 我们是为了了解KVM是如何运作的, 晚上的paper 帖子, 都说比较概括, 而分析的又不太通俗.&lt;br /&gt;
往往初学者, 很容易被绕进去.&lt;br /&gt;
从宏观上看KVM虚拟化, 由KVM和QEMU两个组件完成的, 一个内核模块, 一个用户态程序.&lt;br /&gt;
为什么这么设计? 还有别的虚拟化架构吗? 维基给出了, 硬件虚拟化的几种实现策略.&lt;br /&gt;
Full virtualization,  VMware Workstation 和 QEMU就是这种, 全虚拟化定义上是说, 为虚拟机提供&lt;br /&gt;
全部的硬件特性的延伸支持. 这个技术上个世界70年代就由IBM推行. 在人们看来这门高深的学问在计算机的&lt;br /&gt;
洪荒时代, 便已出现. 那个时代一切都是新的, 人们强烈的渴望伸展四肢, 天不怕地不怕的.&lt;br /&gt;
Partial virtualization, 维基上给出半虚拟化的介绍, 他是全虚拟化的先驱, 现在很少本人提起.&lt;br /&gt;
至少, 现在都是全虚拟化和类虚拟化的天下.文中提及, 虚拟地址空间便是半虚拟化.&lt;br /&gt;
从虚拟化的定义角度来看, 操作系统本身, 便是一种原生且原始的虚拟化, 这无可否认.&lt;br /&gt;
这是一种高度抽象的虚拟化, 就好比进程是cpu的虚拟化, 虚拟地址空间是对内存的一种虚拟化.&lt;br /&gt;
Paravirtualization, para是在什么旁边的意思, 中文翻译成类虚拟化, 也算贴切.&lt;br /&gt;
类虚拟化修改guest 系统, 而不是通过虚拟化硬件.Xen(也支持全虚拟化)和UML是这一类.&lt;br /&gt;
Operating-system-level virtualization&lt;br /&gt;
这种虚拟化,概念上不同于上面三种, 是对操作系统的虚拟化, 虽然追根到底, 还是对硬件的虚拟化.&lt;br /&gt;
但是, 这里强调的是操作系统的资源的虚拟化. 属于操作系统的很多高级抽象, 底层硬件是不具备的.&lt;br /&gt;
比如协议栈这个概念, 他本身是对信息传递的抽象而非硬件, 硬件只是其中一环而已.&lt;br /&gt;
这里若是简单的翻译成系统级虚拟化, 就就比如LXC这个技术而言, 这里面我们并没有虚拟化任何东西.&lt;br /&gt;
比如我们使用socket 发包, 还是这样; 使用malloc分配内存还是这样, 并没有也不需要所谓虚拟化,&lt;br /&gt;
他们都是原生的original.  所以在这里我们就看到了, 不合适的翻译造成的理解差异.&lt;br /&gt;
这里还是直接说容器技术,比较合适, 因为他本来就强调对资源的管理.&lt;br /&gt;
在了解了虚拟化的概念后, 问题又回到了KVM QEMU本身, 此时, 我们依然对他们的实现没有头绪,&lt;br /&gt;
网上也没有找到, 说理清晰的入门文档. 我们还是要搞懂 kvm和qemu的原理.&lt;br /&gt;
我们从小的概念开始, 力求集合小的概念最终, 完成的对kvm 和 qemu的认知.&lt;br /&gt;
首先是qemu是什么? 为什么要有他, 单独一个kvm不行吗?&lt;br /&gt;
官网的解释:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;QEMU is a generic and open source machine emulator and virtualizer.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;qemu可以做emulator, 就像android的开发环境中的那个模拟器差不多.&lt;br /&gt;
qemu可以作为虚拟化的工具和kvm,xen联动, 重点看这个.&lt;br /&gt;
我们在FKVM中已经知道, cpu的虚拟化是同vtx, 截获特殊指令完成的.&lt;br /&gt;
那么内存虚拟化呢, 显然不应是malloc一块空间能解决的.&lt;br /&gt;
毫无疑问, 肯定要有一个机制把host的内存映射到一个guest的物理地址空间, 同时guest的&lt;br /&gt;
虚拟地址解析出来的物理地址在转到宿主机的地址, 最后转成真正的物理地址. 有三次转换.&lt;br /&gt;
据我所指, x86的页表转换是自动的.如何让他这么转来转去的.这个应该就是kvm orvtx干的事情&lt;br /&gt;
补货到访存指令, 之后进行地址转换. 看了下真正的实现, 和我们思路差不多.&lt;br /&gt;
不同点, guest的物理地址是用pfn加数量标志的. 不用想每次访存kvm都要参与, 而且地址转换确实复杂&lt;br /&gt;
肯定有优化空间. 我现在想说, vtx这个截获访存指令确实是个BUG级的存在.&lt;br /&gt;
内存虚拟化就到这里了, 优化去看IBM的讲解帖子吧.&lt;br /&gt;
下面继续看cpu的虚拟化. 这个主要就是, 如何捕获, 那些vm运行比较敏感的指令.&lt;br /&gt;
我们的FKVM支持一个进程跑, 能想到的就是建几个线程来模拟SMP.&lt;/p&gt;

&lt;p&gt;下面是设备的虚拟化, 这个还是看书去吧.&lt;/p&gt;

&lt;h1 id=&#34;代码实现:d29da9244342e72819e84d5dee753d17&#34;&gt;代码实现&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;KVM architecture&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Kernel running flow&lt;br /&gt;
svm.ko -&amp;gt; svm_init(svm.c) -&amp;gt; kvm_init(kvm_main.c) -&amp;gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;File&lt;br /&gt;
svm.c vmx.c kvm_main.c kvm_svm.h&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Function&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Struct&lt;br /&gt;
kvm_x86_ops x86.h&lt;br /&gt;
vcpu_svm    kvm_svm.h&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Algorithms and data structues for kernel hacking</title>
      <link>http://firoyang.org/cs/algorithm/</link>
      <pubDate>Wed, 27 May 2015 12:42:12 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/algorithm/</guid>
      <description>

&lt;h1 id=&#34;reference:0410937a83f6b2d022d3a1c190b257c8&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://cstheory.stackexchange.com/questions/19759/core-algorithms-deployed#&#34;&gt;Core algorithms deployed&lt;/a&gt;&lt;br /&gt;
Algorithms: Design Techniques and Analysis&lt;br /&gt;
kernel/algorithm.md&lt;/p&gt;

&lt;h1 id=&#34;introduction:0410937a83f6b2d022d3a1c190b257c8&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;说实话, 这年头想要做点学问还是需要点定力的.&lt;br /&gt;
就拿内核中的数据结构与算法来说, 也不是说, 别人来了句, 我靠, awesome!&lt;br /&gt;
你也过来瞅两眼, 也能心生感慨, what the fuck! how can this be true?&lt;br /&gt;
我说的定力, 不是两耳闻听窗外事, 一心还读圣贤书!而是思维的能力.&lt;br /&gt;
这是见真章的地方, 不动脑子是玩不转的, 最终浮于表面, 不得所获.&lt;/p&gt;

&lt;p&gt;kfifo 和lock-less list 是kernel中两个基础的数据结构, 用得也不多.&lt;br /&gt;
说实在的这些都不是什么特别难的技术, 但是这种较真的东西使最能考察一个人的能力的.&lt;br /&gt;
什么能力? 写个链表, 队列谁不会? 这里考察的是人的创造力!&lt;br /&gt;
所谓创造力就是一种组合的能力.拆分也是一种组合.&lt;/p&gt;

&lt;p&gt;今天, 我们来聊一聊算法. 数据结构在我看来是算法的一种.&lt;br /&gt;
到底是什么呢? algorithm这个词来自中古拉丁文algorismus音译自一位阿拉伯数学家的名字&lt;br /&gt;
al-Khwarizmi, 这只是一个姓, 类似中文赵钱孙李, al-Khwarizmi这个姓表示&lt;br /&gt;
&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E8%8A%B1%E5%89%8C%E5%AD%90%E6%A8%A1&#34;&gt;花剌子模&lt;/a&gt;地方的人.数学家的全名是Abū ‘Abdallāh Muḥammad ibn Mūsā al-Khwārizmī&lt;br /&gt;
花剌子模有太阳升起之地之意源于这个国家被大量沙漠围住, 气候干燥. 而lowland, 则是因为其海拔很低.&lt;br /&gt;
显然, 这不是我们关心的算法本质. 那么, 为什么欧洲人会把al-Khwarizmi, 作为算法的称谓呢?&lt;br /&gt;
al-Khwarizmi向西方引入了10进制计数法和代数. 同时他的名字慢慢被赋予了现代算法的涵义.&lt;br /&gt;
也就是algorithm的涵义是慢慢衍生出来的.&lt;br /&gt;
那我们能否给算法下一个定义呢:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;An informal definition could be &amp;quot;a set of rules that precisely defines a sequence of operations.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单说, 就是一个执行序列. 这有点太概况了.我们需要一个更精准的定义.&lt;br /&gt;
同时, 我并不把他限制在计算机科学内.&lt;br /&gt;
如果你读过石里克的&lt;a href=&#34;http://book.douban.com/subject/1443472/&#34;&gt;普通认识论&lt;/a&gt;你就会知道, 光的定义也是一波三折.&lt;br /&gt;
所谓的定义, 实际上事物某些属性的集合!&lt;br /&gt;
我们来考察算法的属性.诚如前面的定义算法是一个执行序列.&lt;br /&gt;
那么算法的表现形式呢? 他是抽象的, 根植于人类的思维逻辑当中. 而人的逻辑是通过&lt;br /&gt;
语言表述的.所以算法的重要属性就是他是语言这种形式表现出来的.&lt;br /&gt;
所以我们的定义, 变成一个被执行的语言序列.&lt;br /&gt;
我们还是不满足, 你难道就让我去用这么一句话, 去面对面试时候的各种算法题吗?&lt;br /&gt;
现在我们从算法解决的问题入手? 这是算法的目的. 我的目的是让算法更加的通俗易懂.&lt;br /&gt;
不是让人们说道, 算法就会去向排序, 二叉树. 这跳跃太大了, 在算法的基础定义和实际的算法之间,&lt;br /&gt;
还有一些内容, 值得我们挖掘.我们考察排序和二叉树, 这两种算法:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A sorting algorithm is an algorithm that puts elements of a list in a certain order.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从排序算法的定义中, 我们窥探到了算法的一些本质属性. 使对象具备某种属性.这里面有序就是一种属性.&lt;br /&gt;
再来看二叉树:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a binary tree is a tree data structure in which each node has at most two children, 
which are referred to as the left child and the right child.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;无论是二叉树, 还是排序, 我们都能感受到, 算法在展现一种魔法, 使用元素的建立某种空间结构/关系.&lt;br /&gt;
也就是说, 我们的思维本身就具有某种抽象意义上的空间搬运能力.我门知道空间关系, 在确定了个提之后&lt;br /&gt;
是十分清晰的前后左右上下, 这样, 现在我们能进一步的定义算法:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;算法是使对象具备某种空间关系的而被执行的语言序列
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的对象显然是语言层面的.我们的定义是否恰当能呢? 是否所有的算法都是让对象具备某种空间关系吗?&lt;br /&gt;
在比如找到两个数组中相同的元素, 类似常见的字符串查找, 也是不具有所谓的空间的关系, 而是更为抽象的序关系.&lt;br /&gt;
什么是序关系? c语言的比较操作符 &amp;lt; &amp;gt; = 这些都是序关系, 准确说是二元关系.&lt;br /&gt;
而空间关系, 我们也可以通过坐标抽象, 得到数学上的需关系.显然有些时候空间关系更为生动, 但你知道这可以&lt;br /&gt;
用order theory解释.&lt;br /&gt;
作为最古老的算法gcd, 最大公约数, 不是上面的所谓的序关系结构. 他就是一种纯粹的数学定义.&lt;br /&gt;
这个算法的目的不在是一个多个元素的整体了, 只是单独挑出符合性质的其中的元素. 但是在界gcd问题时&lt;br /&gt;
我们依然可以把他转换为同过序关系得到答案.而欧几里得的方法, 确不是用gcd定义的方法解的而是用求余的&lt;br /&gt;
方法. 求余依然是序的关系, 只不过方法不一样, 一个循环比较一个是通过求余加速了答案的发现.&lt;br /&gt;
我们现在姑且认为, 所有算法的最终结果都是为了得到一种序的关系.&lt;br /&gt;
我们现在来整理下算法的定义:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;算法是使对象具备某种序关系的而被执行的语言序列
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们现在来考察, 算法的对象, 我们能感觉到他可以具有任何形态.&lt;br /&gt;
暂略.&lt;br /&gt;
我们来看算法的核心&amp;ndash; 语言序列, 对象, 执行的目的某种序关系, 三者之间的关系.&lt;br /&gt;
同时为了更好的理解语言序列.&lt;br /&gt;
我们先探索一些重要且常见的思路, 也就是语言序列的patterns.&lt;br /&gt;
我们学过的一些算法, 可以用递归的方式解, 而且很简单. 比如二叉树翻转, 二叉树遍历,&lt;br /&gt;
快排等等, 作为一种解问题的思路也就是, 语言序列的模式. 我们要彻底的搞懂倒地什么才是&lt;/p&gt;

&lt;h2 id=&#34;递归-为什么递归可以很好的解决问题:0410937a83f6b2d022d3a1c190b257c8&#34;&gt;递归? 为什么递归可以很好的解决问题.&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/thumb/6/62/Droste.jpg/220px-Droste.jpg&#34; alt=&#34;递归图&#34; /&gt;&lt;br /&gt;
就是这种感觉, 你总能看到自己的样子, 每个尽头. 可是计算机的递归是有终止条件, 否则程序就跑飞了.&lt;br /&gt;
所以, 无论脑洞多大, 都要想到如何停止递归调用.&lt;br /&gt;
就和我们写个for循环for (i=0; i &amp;lt; 10; i++) 一个道理, 本质都是在重复. 递归定义:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;递归指由一种（或多种）简单的基本情况定义的一类对象或方法，并规定其他所有情况都能被还原为其基本情况。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通俗说函数调用自身, 都是递归.一个合格的递归, 有终止条件和非终止条件.非终止条件必须可以通过递归变成终止条件.&lt;br /&gt;
现在我们来看下两类经典的算法排序和二叉树.先说二叉树, 各种遍历啊翻转都是用递归实现的.&lt;br /&gt;
先不考虑递归的问题, 就比方说我们要把二叉树的所有点都打印出来, 随便打不要管什么深度广度中序啊. 你会怎么办?&lt;br /&gt;
一个for循环把所有最left都打出来了, 其他点呢? 没出来.怎么办?为什么二叉树这么难处理啊?&lt;br /&gt;
我们之前打印数组or链表一个循环就ok了. 二叉树的和他们的区别是一个点有2个后继.&lt;br /&gt;
那么2个后继对我们造成什么影响. for通过单个指针只能得到线性的关系. 那如何得到树式的关系呢?&lt;br /&gt;
我们可以从最简单的开始考察空树, 1,2层的树都好办. 3层呢, 就不好办了? 怎么不好办了.&lt;br /&gt;
如果我们知识在白板上把每个节点, 画个对号, 就算输出的话, 我们很轻松, 就画完了.&lt;br /&gt;
可是在计算机内部, 比如我们现在100层的树我们在left子树上输出, 我们就没有办法知道丛root开始&lt;br /&gt;
的right子树的信息了, 我们一条路走到黑, 回不去了. 我门必要track住所谓的right节点的信息.&lt;br /&gt;
这很明显, 咋么track住呢?还是以3层树为例我们可以轻而易举的输出上面两层.&lt;br /&gt;
如果按层输出, 我们输出当前node把子nodes存到queue里面, 每次都这么干. 我们track住了其他节点的信息了&lt;br /&gt;
而链表这种线性结构则是自身就可以track住后继节点的信息, 这就是差别, 多了一个node我们就要&lt;br /&gt;
多个地方存他, 在我们的场景你都不需要关系存的顺序, 因为我们就是随便输出, 全输出就可以了.&lt;br /&gt;
回过头, 我们来看, 这个解法和递归之间的关系. 只要最终能终止就可以用递归解, 我们这个问题能吗?&lt;br /&gt;
显然可以, 停在最底层节点.&lt;br /&gt;
void bin_recur(node)&lt;br /&gt;
{&lt;br /&gt;
    //这是内核的标准风格&lt;br /&gt;
    if(!node)&lt;br /&gt;
        return&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print(node);
bin_recur(node-&amp;gt;left);
bin_recur(node-&amp;gt;right);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;完了这就是我们的随意树遍历法, 记住我们只要求输出全部节点就ok了. 至于, node之间的关系, 就随他去吧.哈哈.&lt;br /&gt;
无论递归多么简洁, track nrightnode信息一个也不能少, 知识没有眼睛的计算机的眼睛, 就好像盲人的盲文一样.&lt;br /&gt;
这个递归的和我们的for循环的结果不一样.不用queue用stack结果就一直了.&lt;br /&gt;
广度优先不可以用递归形式, 这是我们知道的第一个不能用递归解的问题.&lt;br /&gt;
1. 接下来我们聊3个问题, 什么问题不能用递归解&lt;br /&gt;
2. 递归 和非递归如何转换&lt;br /&gt;
3. 结合二叉树排序算法探讨递归如何可能.&lt;/p&gt;

&lt;h3 id=&#34;先看第三个问题-同时我们也知道gcd也是递归算法实现的:0410937a83f6b2d022d3a1c190b257c8&#34;&gt;先看第三个问题, 同时我们也知道gcd也是递归算法实现的.&lt;/h3&gt;

&lt;p&gt;在这里我们要达成的是递归为什么能解问题. 遇到一个问题时我们我们如何用递归曲解.&lt;br /&gt;
我们要用另外一种思想去解释递归, 且最好是生活化的例子.&lt;br /&gt;
搜了半天也没有即通俗又深刻的讲解.&lt;br /&gt;
我们按着递归的定义来:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;递归指由一种（或多种）简单的基本情况定义的一类对象或方法，并规定其他所有情况都能被还原为其基本情况。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么我们不找一个实际生活场景来解释递归呢? 你给我找一个试试, 正常人谁这么做事啊:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;To Iterate is Human, to Recurse, Divine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;定义中明确说明了基本情况可以不止一种, 意识到这点很重要. 那么下面我们来看一个递归函数都有什么.&lt;br /&gt;
通过定义, 我们知道递归函数只要两部分内容, 基本情况 + 还原到基本情况两部分:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int depth(Tree t){
    if(!t) 
        return 0; 
    int a=depth(t.right); 
    int b=depth(t.left); 
    return (a&amp;gt;b)?(a+1):(b+1); 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;求二叉树深度,这个函数的目标就是返回int值树深度&lt;br /&gt;
我们试图通过这么小的一个递归函数, 完成我们对所有递归的认知!&lt;br /&gt;
基本情况:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return 0 和return (a&amp;gt;b)?(a+1):(b+1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还原到基本情况:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int a=depth(t.right);
int b=depth(t.left);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们要当一回弗兰肯斯坦, 原料都有了, 那我们如何把他组成一个会动且名字叫做递归函数的人呢?&lt;br /&gt;
代码本身就是执行序列, 而这些序列的先后关系非常重要.基本情况和还原基本情况具备哪些关系呢?&lt;br /&gt;
这是我们要完整认知递归, 所必须面对的问题.&lt;br /&gt;
在这个例子当中, 我们可以把基本情况和还原情况分类两类, 从基本情况看:&lt;br /&gt;
不需要依赖还原情况和依赖还原情况的基本情况两类.&lt;br /&gt;
所以我们主要关注, 基本情况就好了, 我们把基本情况排好了还原情况就不是问题了.&lt;br /&gt;
我们总对看不到事物, 不放心,那么还原情况的代码是如何是生效的呢, 怎么就能保证整个程序是我们想要的&lt;br /&gt;
正确结果? 也就是说我们必须证明他!如何证明呢?&lt;br /&gt;
我们只看第一次调用, 显然如果两次depth调用时正确的, 我们最上面这次也是千真万确的!&lt;br /&gt;
也就是说当前的结果正确性依赖于子函数调用的正确性.那么现在问题就变成了, 还原情况是否能&lt;br /&gt;
够真正意义上的收敛到基本情况:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int factorial(int n)
{
    int recurse = factorial(n-1);
    int result = n * recurse;
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数是一个递归函数, 却不能收敛!最后程序直接跑飞了.所以说不是递归就是正确的.&lt;br /&gt;
这严格的依赖于你的实现的语言序列!上面这个例子, 只有去没有回!&lt;br /&gt;
只有保证了去和回的程序才是合理的! 进一步, 我们的基本情况,可以说都是在还原情况的去和回的路径上.&lt;br /&gt;
使用数学归纳法, 我们可以证明递归函数的是否正确!&lt;br /&gt;
现在我们更细致的考察基本情况和去回路径的关系.如果基本情况在去的路径上我们就收他是一种independent&lt;br /&gt;
情况. 反之, 在回来的路径上, 我们就说他是dependent情况. 不用费心, 去想什么那些基本情况是independent哪些&lt;br /&gt;
是dependent这个和具体业务,算法内容相关的.&lt;br /&gt;
下面我们看下排序算法以期更加透彻的理解基本情况!先说快排!&lt;br /&gt;
不知道你还记得吗, 我早都忘了.哈哈.快排的效率是nlogn,why?简单分析下就知道了.&lt;br /&gt;
起始所有的算法都是分治, 只不过分的程度不一样. 快排的思想就是, 又粗到细逐步排序.&lt;br /&gt;
显示选一个特定的元素, 之后把其他元素分列这个元素左右, 之后在分别对左右的元素执行相同的动作.&lt;br /&gt;
用递归怎么实现呢?&lt;br /&gt;
先确定基本情况&lt;br /&gt;
小于2个elements不需要排序&lt;br /&gt;
if ( (first &amp;gt;= last)&lt;br /&gt;
    return;&lt;br /&gt;
这样independent就确定了.&lt;br /&gt;
pivot= array[first]&lt;br /&gt;
while( low &amp;lt;  high){&lt;br /&gt;
    while ( a[high] &amp;gt; pivot  )&lt;br /&gt;
        high&amp;ndash;;&lt;br /&gt;
    a[low]= a[hgih]&lt;br /&gt;
    while ( a[low] &amp;lt; pivot)&lt;br /&gt;
        low++;&lt;br /&gt;
    a[high] = a[low]&lt;br /&gt;
}&lt;br /&gt;
a[low] = pivot&lt;br /&gt;
qs(a, first, low -1)&lt;br /&gt;
qs(a, low + 1, last)&lt;/p&gt;

&lt;p&gt;从这个算法, 我们可以看出全都是independent的基本情况, 都是还原情况依赖基本情况.&lt;br /&gt;
也就是说, 上层的正确性,&lt;br /&gt;
我们在前序二叉树遍历也遇到这种, 全是independent的情况.&lt;br /&gt;
我们来总结下qsort的基本情况:&lt;br /&gt;
他的基本情况是数据的区间.最基本的就是不排序这种&lt;br /&gt;
之后是下面这种通用形式. 瞄准一个区间.基本+通用类似归纳法.&lt;br /&gt;
那我们现在明白了排除最基本的形态作为终止条件. 其他的基本情况和还原情况表明了这个&lt;br /&gt;
算法的核心本质也就是自顶向下top down还是自底向下bottom up的的方法这是最根本的本质.&lt;br /&gt;
要比我们之前说的由粗到细逐步排序, 要准确深刻许多!&lt;br /&gt;
我们再看归并排序.归并是什么思想呢?正好相反, 它依赖底层的排序.&lt;br /&gt;
也就是bottom up的方式, 我们看下msort的代码&lt;br /&gt;
merge sort是基于合并,&lt;br /&gt;
if (len &amp;lt;= 1)&lt;br /&gt;
    return&lt;/p&gt;

&lt;p&gt;ms(a, first, len/2)&lt;br /&gt;
ms(a, len/2 + 1, last)&lt;br /&gt;
merge(a, first, last)&lt;br /&gt;
这次是通用情况在最下面.&lt;br /&gt;
那我们在来看, 二叉树的的遍历. 前序遍历是top down的思想吗?&lt;br /&gt;
先print root, 之后是最左的一排, 从底往上从左往右一次输出left子树&lt;br /&gt;
之后, 类似方法输出right子树.但是为什么不是层序遍历的效果呢?这里是收到了树结构的影响.&lt;br /&gt;
在排序的例子, 我们以数据的宽度大小得出topdown的思路.&lt;br /&gt;
在遍历二叉树, 我们是node的高度和左右作为top的衡量.&lt;br /&gt;
这里就不是topdown的思想而是先处理谁后处理谁的问题, 我们反过来看排序算法, topdown&lt;br /&gt;
bottomup 似乎也只是一种巧合, 那么我们能不能在qsort的时候只处理两个元素, 之后在递归呢&lt;br /&gt;
就好比二叉树中从root到leaf一样之后从leaf到root, 以此往复, 在用递归处理排序是遵从从多到少的去,&lt;br /&gt;
从少到多.&lt;br /&gt;
二叉树: root-&amp;gt;left leaf -&amp;gt;root-&amp;gt;right leaf&lt;br /&gt;
排序:大范围-&amp;gt;个体-&amp;gt;大范围　这也是递归解问题的标准方法逐渐减小问题．&lt;br /&gt;
那么我们能否从最小的地方, 之后逐渐变大, 想当然是可以的.回来路径上的mergesort就是一个.&lt;br /&gt;
其他的呢插入排序的递归版?&lt;br /&gt;
insert sort&lt;br /&gt;
if ( len = 1)&lt;br /&gt;
    return&lt;br /&gt;
isort(a, len -1)&lt;br /&gt;
for(i=0; i&amp;lt; len;i++&lt;br /&gt;
    sort insert alen&lt;br /&gt;
对比非递归版, 我们发现递归给我门提供了两个潜在的for循环.&lt;br /&gt;
如果是从bottom up这种方式接的问题, 递归是放在回来的路径.&lt;br /&gt;
当然递归也是允许你在取得路径上慢慢扩大处理的问题&lt;br /&gt;
插入排序的终止条件编程了len &amp;gt; maxlen.&lt;br /&gt;
qsort和msort 一去一回.&lt;br /&gt;
我们已经考察递归差不多了,总结下&lt;br /&gt;
1. 一去一回, 两个非嵌套循环&lt;br /&gt;
2. 最好遵从, 去的是逐渐减小任务. 回时增大.&lt;br /&gt;
3. 去回可以互相转换.如isort, 当不是所有的都是要稳定性.&lt;/p&gt;

&lt;h3 id=&#34;接下来看递归和非递归的转换:0410937a83f6b2d022d3a1c190b257c8&#34;&gt;接下来看递归和非递归的转换.&lt;/h3&gt;

&lt;p&gt;bubble sort&lt;br /&gt;
if len &amp;lt; 2&lt;br /&gt;
    return&lt;br /&gt;
sort maxer&lt;br /&gt;
bulle sort(len -1)&lt;br /&gt;
冒泡的递归很简单&lt;br /&gt;
那么qsort的非递归版呢&lt;br /&gt;
首先递归给了一个for我们得自己补上&lt;br /&gt;
for&lt;br /&gt;
接下来递归编程压栈就可以了,&lt;br /&gt;
下面的问题答案也是本问题的答案.&lt;/p&gt;

&lt;h3 id=&#34;最后一个问题什么问题不能用递归解:0410937a83f6b2d022d3a1c190b257c8&#34;&gt;最后一个问题什么问题不能用递归解?&lt;/h3&gt;

&lt;p&gt;二叉树层序遍历递归搞不定.&lt;br /&gt;
这个问题实际转换成, 非递归版什么问题搞定什么问题&lt;br /&gt;
我简单的认为&lt;br /&gt;
1. 问题可被还原.&lt;br /&gt;
2. 必要时, 需要stack 信息追踪&lt;br /&gt;
没了. 好关于递归就到这里.&lt;br /&gt;
在考察语言序列的顺序问题.递归的顺序我们很清楚了.但我们似乎还迷茫.&lt;br /&gt;
实际上我们接触的问题都不是用递归解的.&lt;br /&gt;
比如内核的伙伴系统, page cache这些算法. 实际上是这些结构的延伸.&lt;br /&gt;
所有的函数方法都是为了让操作对象, 保持相应结构的性质.&lt;br /&gt;
也就是说这种算法的核心与目的就是结构, 使数据保持这种结构, 算法的目的达到了.&lt;br /&gt;
重点在于维护结构整体, 这点看来和排序算法一样, 一个是侧重空间关系, 一个数值关系.&lt;br /&gt;
可以说都是在保证空间性质的前提, 完成量的性质:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;我们得到两个基本概念, 描述数据个体的量, 与整体的空间结构.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;空间结构是框架, 量则是内容.&lt;br /&gt;
现在我们来看一个实际的算法问题, 如何判断两边是否有环, 这里说的主要是空间结构.&lt;br /&gt;
这个问题主要关注数据的空间结构, 最简单的加个访问标志位.不加呢, 别的方法呢?&lt;br /&gt;
再加一个指针, 也能解决.通过辅助数据结构两个指针解决了这个问题. 现在回想问题.&lt;br /&gt;
我们判断环, 实质上是找到一个等价的条件, 这个条件, 要不然是 ==, 要不然是 !=&lt;br /&gt;
这和具体逻辑有关. 但是我们一定可以确定的就是我们需要right 和left两个operand.&lt;br /&gt;
需要至少两个对比的对象.而这个对象本质就是量. 这里想提供解决问题的通用方式.&lt;br /&gt;
判断问题要有两个量. 而这两个量.&lt;br /&gt;
这里揭示了算法的核心, 就是在完成特定的问题or 结构, 我们需要辅助的结构:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;常见的辅助结构:变量/flag之类, 指针, 队列, stack, 不限制使用数量.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;问题的解决, 变成寻找挑选合适的辅助结构了. 如两个变量比较/flag自身test, 两个指针:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;指针的速度是个很重要的解决问题的因素, 如上面的环问题的两个不同指针.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这也是解决比较问题的, 常见方法.&lt;br /&gt;
选好辅助数据结构就是, 运用了. 运用的主要原则就是找到基本情况. 把具备的互斥特征的&lt;br /&gt;
基本情况找到, 并应用辅助数据结构解决问题.&lt;/p&gt;

&lt;h2 id=&#34;动态规划问题:0410937a83f6b2d022d3a1c190b257c8&#34;&gt;动态规划问题&lt;/h2&gt;

&lt;p&gt;DP通常是以递归化简问题形式出现.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The Journey to RCU</title>
      <link>http://firoyang.org/kernel/rcu/</link>
      <pubDate>Sun, 24 May 2015 09:52:12 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/kernel/rcu/</guid>
      <description>

&lt;h1 id=&#34;reference:ccb822b6795f419b08737308491f6183&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;iframe frameborder=&#34;no&#34; border=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; width=330 height=86 src=&#34;http://music.163.com/outchain/player?type=2&amp;id=444737&amp;auto=1&amp;height=66&#34;&gt;&lt;/iframe&gt;&lt;br /&gt;
&lt;a href=&#34;http://lse.sourceforge.net/locking/rcupdate.html&#34;&gt;官网Read-Copy Update Mutual Exclusion&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://lse.sourceforge.net/locking/rcu/HOWTO/index.html&#34;&gt;Read Copy Update HOWTO&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://lse.sourceforge.net/locking/rcu/rcupdate_doc.html&#34;&gt;Read-Copy Update Mutual-Exclusion in Linux&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://pages.cs.wisc.edu/~thanhdo/qual-notes/sync/sync2-rcu.txt&#34;&gt;Thanh Do&amp;rsquo;s notes Read-copy update. In Ottawa Linux Symposium, July 2001&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;why-do-need-rcu:ccb822b6795f419b08737308491f6183&#34;&gt;Why do need RCU&lt;/h1&gt;

&lt;p&gt;For &lt;a href=&#34;http://en.wikipedia.org/wiki/Scalability&#34;&gt;scalable&lt;/a&gt; mutual exclusion.&lt;br /&gt;
scale有两个词源涵义Proto-Germanic原始日耳曼, 酒杯, 盘子, 称重的盘子, 后来演化成标量的意思.&lt;br /&gt;
scalar在数学上是标量, 在c语言指int float, Scalar processor标量计算机也是来源于此.&lt;br /&gt;
另一个出处是Latin拉丁文scandere, 有攀爬之意, 进而衍生出扩展之意.&lt;br /&gt;
From wikipedia,  A system whose performance improves after adding hardware,&lt;br /&gt;
proportionally to the capacity added, is said to be a scalable system.&lt;br /&gt;
&lt;a href=&#34;https://www.ibm.com/developerworks/cn/linux/l-rcu/&#34;&gt;因为rwlock, brlock在多核性能下降.需要个高性能的锁&lt;/a&gt;&lt;br /&gt;
言下之意, 就是其他的mutual exclusion 机制不能很好的扩展, 需要RCU.&lt;br /&gt;
Read Copy Update HOWTO介绍了当初RCU开发的动机:&lt;br /&gt;
* Increase in cost of conventional locks&lt;br /&gt;
第一个原因也是最重要的, 最根本原因.&lt;br /&gt;
传统的锁the contended lock如spinlock实现上不断访问内存轮询锁当前状态, cpu和内存速度的*越来越*巨大差异;&lt;br /&gt;
一种新的锁机制减少访问内存,就成了强烈的需求.&lt;br /&gt;
* Cache benefits of lock-free reads&lt;br /&gt;
传统锁/tried-and-true 如spinlock一类的实现在多核下, 在出现锁竞争时会导致&lt;a href=&#34;http://www.quora.com/What-is-cache-line-bouncing-How-spinlock-may-trigger-this-frequently&#34;&gt;cache line bouncing&lt;/a&gt;.&lt;br /&gt;
3个cpu, A占有spinlock, 另外两个轮询尝试获取在test and set版本的&lt;br /&gt;
spinlock, 如果Bcpu 修改lock那么C cpu的d cache line 就会强制无效,&lt;br /&gt;
之后c 也修改lock, B的d cache line就无效了.之后B又来了, 就这样.&lt;br /&gt;
在不同cpu之间同步数据, 会耗费很多cpu 指令周期.&lt;br /&gt;
像&lt;a href=&#34;https://www.ibm.com/developerworks/cn/linux/l-cn-spinlock/&#34;&gt;x86的spinlock的实现用lock指令前缀锁住总线&lt;/a&gt;,&lt;br /&gt;
其他cpu or dma就不能访问内存, 降低系统的性能, ibm这篇文章说P6之后的处理器减少这种危害.&lt;br /&gt;
* Avoiding complicated races&lt;br /&gt;
No deadlock, 减少了开发维护.&lt;/p&gt;

&lt;h1 id=&#34;how-to-use-rcu:ccb822b6795f419b08737308491f6183&#34;&gt;How to use RCU&lt;/h1&gt;

&lt;p&gt;list rcu&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/263130/&#34;&gt;What is RCU? Part 2: Usage&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www2.rdrop.com/users/paulmck/techreports/RCUUsage.2013.02.24a.pdf&#34;&gt;RCU Usage In the Linux Kernel: One Decade Later&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;what-is-rcu:ccb822b6795f419b08737308491f6183&#34;&gt;What is RCU&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.rdrop.com/~paulmck/RCU/whatisRCU.html&#34;&gt;What is RCU, Really?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://lwn.net/Articles/262464/&#34;&gt;What is RCU, Fundamentally?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://lwn.net/Articles/264090/&#34;&gt;RCU part 3: the RCU API&lt;/a&gt;&lt;br /&gt;
RCU supports concurrency between a single updater and multiple readers!&lt;/p&gt;

&lt;h2 id=&#34;design-pattern:ccb822b6795f419b08737308491f6183&#34;&gt;Design pattern&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Publish-Subscribe&lt;br /&gt;
For updater before synchnization_rcu(); similar to softirq rcu&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Observer&lt;br /&gt;
For updater to wait For Pre-Existing RCU Readers to Complete&lt;br /&gt;
Maintain Multiple Versions of Recently Updated Objects&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;positivism-implementions:ccb822b6795f419b08737308491f6183&#34;&gt;Positivism Implementions&lt;/h1&gt;

&lt;h2 id=&#34;classic-rcu:ccb822b6795f419b08737308491f6183&#34;&gt;Classic RCU&lt;/h2&gt;

&lt;p&gt;Classic RCU requires that read-side critical sections obey the same rules&lt;br /&gt;
obeyed by the critical sections of pure spinlocks:&lt;br /&gt;
blocking or sleeping of any sort is strictly prohibited.&lt;/p&gt;

&lt;h2 id=&#34;preemtible-rcu:ccb822b6795f419b08737308491f6183&#34;&gt;Preemtible RCU&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://lwn.net/Articles/253651/&#34;&gt;The design of preemptible read-copy-update&lt;/a&gt;&lt;br /&gt;
stage 的切换是由rcu_read_unlock 推动的!&lt;/p&gt;

&lt;h2 id=&#34;tree-rcu:ccb822b6795f419b08737308491f6183&#34;&gt;Tree RCU&lt;/h2&gt;

&lt;p&gt;For hundreds and thounds CPU cores&lt;/p&gt;

&lt;p&gt;#FAQ&lt;br /&gt;
* Difference with primitive and atomic&lt;br /&gt;
* Grace period is synchroinze_rcu or a softirq justment&lt;br /&gt;
* __rcu sparse will warn you if you access that pointer without the services of one of the variants of rcu_dereference().&lt;/p&gt;

&lt;h1 id=&#34;below-is-how-to-use-rcu:ccb822b6795f419b08737308491f6183&#34;&gt;Below is how to use RCU!&lt;/h1&gt;

&lt;h1 id=&#34;reference-1:ccb822b6795f419b08737308491f6183&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www2.rdrop.com/users/paulmck/techreports/RCUUsage.2013.02.24a.pdf&#34;&gt;RCU Usage In the Linux Kernel: One Decade Later&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;introduction:ccb822b6795f419b08737308491f6183&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;本文内容并非我原创, 实际上是翻译加上个人理解Paul E. McKenney的paper.Credit to Paul and others.&lt;br /&gt;
本文不关心RCU的实现.&lt;br /&gt;
本文的核心目标就是了解如何使用RCU.&lt;br /&gt;
所有使用RCU代码, 都可以分为4部分:&lt;br /&gt;
RCU read critical section: 就是rcu_read_lock()和rcu_read_unlock()之间的代码.&lt;br /&gt;
update: 这部分代码在synchronize_rcu/call_rcu之前执行. 比如给pointer = new_data;&lt;br /&gt;
synchronize: 这部分代码是等待调用synchronize/call_rcu时的所有Rcu read critical section 执行完.&lt;br /&gt;
free: 这部分是在上面synchronize/call_rcu确认所有对就数据引用的RCU read critical section都执行完了, 安全释放内存.&lt;br /&gt;
Paul的paper总结了5种用法, 并且附上了代码, 便于理解.&lt;br /&gt;
理解的过程实质上是用RCU的外衣再次理解这个5种方法!&lt;/p&gt;

&lt;h1 id=&#34;wait-for-completion:ccb822b6795f419b08737308491f6183&#34;&gt;Wait for Completion&lt;/h1&gt;

&lt;p&gt;内核中有&lt;a href=&#34;https://lwn.net/Articles/23993/&#34;&gt;完成量completion&lt;/a&gt;的基础设施&lt;br /&gt;
上面的RCU read critical section和synchronize可以构成completion的语义.&lt;br /&gt;
为什么要用RCU而不是内核自身提供的completion函数呢?&lt;br /&gt;
Paul的文中举的例子实在NMI中要作这样的事情, 显然基于waitqueue的completion是毫无用处的.&lt;br /&gt;
所以这里的RCU, 应该叫做Completion RCU-version.&lt;/p&gt;

&lt;h1 id=&#34;reference-counting:ccb822b6795f419b08737308491f6183&#34;&gt;Reference Counting&lt;/h1&gt;

&lt;p&gt;传统的引用计数就是往结构体里面内嵌一个atomic,加加减减.&lt;br /&gt;
但RCU实现的引用计数把实际工作转移到softirq-rcu部分去了.&lt;br /&gt;
Paul给了一个例子, 我认为是及其不合适的.因为他忽略了softirq部分随着smp的核数增多&lt;br /&gt;
同样也会带来性能的损耗,而不是almost zero in his paper.&lt;br /&gt;
引用计数和完成量的区别, 除了语义上的差异, 看起来没有太大的区分.FIXME.&lt;/p&gt;

&lt;h1 id=&#34;type-safe-memory:ccb822b6795f419b08737308491f6183&#34;&gt;Type Safe Memory&lt;/h1&gt;

&lt;h1 id=&#34;publish-subscribe:ccb822b6795f419b08737308491f6183&#34;&gt;Publish-Subscribe&lt;/h1&gt;

&lt;h1 id=&#34;read-write-lock-alternative:ccb822b6795f419b08737308491f6183&#34;&gt;Read-Write Lock Alternative&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>Understanding linux netfilter</title>
      <link>http://firoyang.org/net/netfilter/</link>
      <pubDate>Sun, 10 May 2015 15:46:13 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/net/netfilter/</guid>
      <description>

&lt;h1 id=&#34;reference:e2689587120d0b6ef78b8a3e3eecfbca&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.netfilter.org/documentation/HOWTO//netfilter-hacking-HOWTO.html&#34;&gt;Linux netfilter Hacking HOWTO&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.karlrupp.net/en/computer/nat_tutorial&#34;&gt;NAT - Network Address Translation&lt;/a&gt;&lt;br /&gt;
man iptables and man iptables-extension&lt;/p&gt;

&lt;h1 id=&#34;introduction-to-netfilter:e2689587120d0b6ef78b8a3e3eecfbca&#34;&gt;Introduction to netfilter&lt;/h1&gt;

&lt;p&gt;Netfilter 是Kernel提供在BSD socket API之外进行网络操作的框架.&lt;br /&gt;
Netfilter的本质就是内核协议栈上的Hook的集合.&lt;br /&gt;
对于ipv4 or ipv6分别有5个Hook点.正如Rusty Russell所言&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Firstly, each protocol defines &amp;ldquo;hooks&amp;rdquo; (IPv4 defines 5) which are well-defined points in a packet&amp;rsquo;s traversal of that protocol stack.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;到底什么是well-defined, 我个人理解就是这5个点可以cover住所有协议栈中的packet.&lt;br /&gt;
与Netfilter类似框架, 主要是BSD系的IPFilter, ipfirewall, PF, NPF等.&lt;br /&gt;
Netfilter的历史请查阅wikipedia.&lt;br /&gt;
内核基于netfilter构建了 iptables 和 connection track两套系统.&lt;br /&gt;
从这两个系统, 衍生出了众多的功能, 如防火墙filter, NAT, mangle, kproxy等等.&lt;br /&gt;
netfilter&lt;br /&gt;
ct| |iptables&lt;br /&gt;
nat,filter,mangle,kproxy,smartqos&lt;br /&gt;
当然, 也可能不依赖iptables 和 conntrack, 或者部分依赖.&lt;/p&gt;

&lt;h1 id=&#34;netfilter:e2689587120d0b6ef78b8a3e3eecfbca&#34;&gt;netfilter&lt;/h1&gt;

&lt;h2 id=&#34;source:e2689587120d0b6ef78b8a3e3eecfbca&#34;&gt;source&lt;/h2&gt;

&lt;p&gt;netfilter 公共: net/netfilter&lt;br /&gt;
ipv4协议的netfilter细节在: net/ipv4/netfilter/&lt;/p&gt;

&lt;h2 id=&#34;init:e2689587120d0b6ef78b8a3e3eecfbca&#34;&gt;Init&lt;/h2&gt;

&lt;p&gt;~/linux/net/netfilter/core.c&lt;br /&gt;
netfilter_init()&lt;/p&gt;

&lt;h2 id=&#34;hook-point:e2689587120d0b6ef78b8a3e3eecfbca&#34;&gt;Hook point&lt;/h2&gt;

&lt;p&gt;local_in local_out forward pre_routing post_routing&lt;/p&gt;

&lt;h1 id=&#34;iptables:e2689587120d0b6ef78b8a3e3eecfbca&#34;&gt;Iptables&lt;/h1&gt;

&lt;p&gt;Iptables is a packet selecttion system (包括内核和用户态两部分).&lt;br /&gt;
iptables 的ip是IP(Internet Protocol).&lt;br /&gt;
xtable是内核iptables抽象nat, mangle, filter(防火墙)的得到共有的部分.&lt;br /&gt;
&lt;a href=&#34;http://en.wikipedia.org/wiki/Iptables#Overview&#34;&gt;Overview of xtables in wikipedia&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;details-of-iptables:e2689587120d0b6ef78b8a3e3eecfbca&#34;&gt;Details of iptables&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;iptables command&lt;br /&gt;
直观上iptables命令最重要的组成部分: table, chain, match 参数, -j target&lt;br /&gt;
如:iptables -t filter -I INPUT -p tcp &amp;ndash;dport 22 -j ACCEPT&lt;br /&gt;
特别: 从-p开始到-j 之前这是一个 match!&lt;br /&gt;
更多的match 和 target, please, man iptables-extension&lt;br /&gt;
一个table的内置chain,就是他所在的hook点.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;kernel code&lt;br /&gt;
ipt_do_table() 就是内核处理nat, filter, mangle的公用函数.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;step-of-exution:e2689587120d0b6ef78b8a3e3eecfbca&#34;&gt;Step of exution&lt;/h2&gt;

&lt;h3 id=&#34;init-1:e2689587120d0b6ef78b8a3e3eecfbca&#34;&gt;Init&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;如mangle表的初始化见iptable_mangle_init&lt;br /&gt;
xt_table: ipt_register_table&lt;br /&gt;
    struct xt_table         *iptable_filter;&lt;br /&gt;
    struct xt_table         *iptable_mangle;&lt;br /&gt;
    struct xt_table         *iptable_raw;&lt;br /&gt;
    struct xt_table         *arptable_filter;&lt;br /&gt;
    struct xt_table         *iptable_security;&lt;br /&gt;
    struct xt_table         *nat_table;&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如mark match的初始化 mark_mt_init&lt;br /&gt;
xt_match: xt_register_match&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如MARK target 的初始化 也在 mark_mt_init&lt;br /&gt;
xt_target: xt_register_target&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;the-mangle-journal:e2689587120d0b6ef78b8a3e3eecfbca&#34;&gt;The mangle journal&lt;/h3&gt;

&lt;p&gt;netfilter hook -&amp;gt;  iptable_mangle_hook -&amp;gt; ipt_do_table -&amp;gt;&amp;hellip;&lt;/p&gt;

&lt;h1 id=&#34;connection-tracking:e2689587120d0b6ef78b8a3e3eecfbca&#34;&gt;Connection tracking&lt;/h1&gt;

&lt;p&gt;Conntrack 的实现不依赖iptables, 很独立.&lt;/p&gt;

&lt;h2 id=&#34;init-2:e2689587120d0b6ef78b8a3e3eecfbca&#34;&gt;init&lt;/h2&gt;

&lt;p&gt;nf_conntrack_standalone_init()&lt;br /&gt;
nf_conntrack_l3proto_ipv4_init()&lt;/p&gt;

&lt;h2 id=&#34;conntrack-user-land-tools:e2689587120d0b6ef78b8a3e3eecfbca&#34;&gt;conntrack &amp;ndash; user-land tools&lt;/h2&gt;

&lt;p&gt;obsolete /proc/net/nf_conntrack&lt;/p&gt;

&lt;h2 id=&#34;tuple-link-a-socket-5-arry-tuple:e2689587120d0b6ef78b8a3e3eecfbca&#34;&gt;tuple &amp;ndash; link a socket 5-arry tuple&lt;/h2&gt;

&lt;p&gt;Each Netfilter connection is uniquely identified by a&lt;br /&gt;
(layer-3 protocol, source address, destination address, layer-4 protocol, layer-4 key) tuple&lt;br /&gt;
nf_conntrack_tuple nf_conn&lt;/p&gt;

&lt;h2 id=&#34;connection-tracking-helper:e2689587120d0b6ef78b8a3e3eecfbca&#34;&gt;Connection tracking helper&lt;/h2&gt;

&lt;p&gt;connection tracking can be given knowledge of application-layer protocols&lt;br /&gt;
ALG&lt;/p&gt;

&lt;h2 id=&#34;template:e2689587120d0b6ef78b8a3e3eecfbca&#34;&gt;template&lt;/h2&gt;

&lt;p&gt;netfilter: nf_conntrack: support conntrack templates&lt;/p&gt;

&lt;h2 id=&#34;details:e2689587120d0b6ef78b8a3e3eecfbca&#34;&gt;Details&lt;/h2&gt;

&lt;p&gt;以上的工作事实上都很简单，基本思路是：&lt;br /&gt;
一个包来了，转换其tuple，看其在连接跟踪表中没有，有的话，更新其状态，以其做一些与协议相关的工作，如果没有，则分配一个新的连接表项，并与skb_buff关连，但是问题是，这个表项，还没有被加入连接表当中来。其实这样做的理由很简单，因为这个时候，这个包是否有机会活命还是个未知数，例如被其它模块给Drop了……所以，要等到一切安全了，再来将这个表项插入至连接跟踪表。&lt;br /&gt;
这个“一切安全”当然是Netfilter所有的模块处理完了，最完全了。&lt;br /&gt;
徐琛,也这么说!&lt;/p&gt;

&lt;p&gt;#NAT&lt;br /&gt;
&lt;a href=&#34;https://www.ietf.org/rfc/rfc3489.txt&#34;&gt;https://www.ietf.org/rfc/rfc3489.txt&lt;/a&gt;&lt;br /&gt;
symmetric nat, 端口不复用, 访问同一个服务器.&lt;br /&gt;
linux 内核的NAT是基于iptables 和 conntrack实现的.&lt;/p&gt;

&lt;p&gt;##init&lt;br /&gt;
iptable_nat_init&lt;/p&gt;

&lt;h2 id=&#34;nat-helper:e2689587120d0b6ef78b8a3e3eecfbca&#34;&gt;NAT helper&lt;/h2&gt;

&lt;p&gt;Similar to connection tracking helpers, NAT helpers will do a packet inspection&lt;br /&gt;
and substitute original addresses by reply addresses in the payload.&lt;/p&gt;

&lt;h2 id=&#34;drop-icmp-redict-in-nat:e2689587120d0b6ef78b8a3e3eecfbca&#34;&gt;Drop ICMP redict in NAT&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.netfilter.org/documentation/HOWTO/NAT-HOWTO-10.html&#34;&gt;http://www.netfilter.org/documentation/HOWTO/NAT-HOWTO-10.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;snat:e2689587120d0b6ef78b8a3e3eecfbca&#34;&gt;SNAT&lt;/h2&gt;

&lt;p&gt;nf_nat_ipv4_out -&amp;gt; nf_nat_ipv4_fn -&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
nf_nat_rule_find -&amp;gt; ipt_do_table -&amp;gt; xt_snat_target_v1 -&amp;gt; nf_nat_setup_info&lt;br /&gt;
    {&lt;br /&gt;
        无论是SNAT, 还是DNAT,改的都是ct的reply. 所以这里先把 orig_rely的对应的orig_original形式弄出来.&lt;br /&gt;
        但是,必须要保证改skb的真实值要保证source 唯一, orig_original -&amp;gt; new_original找到后再revert,成new_reply在改到ct里面去.&lt;br /&gt;
        orig_orignal-&amp;gt;skb&lt;br /&gt;
        nf_ct_invert_tuplepr(inverse, orig_relply)&lt;br /&gt;
        {&lt;br /&gt;
            ipv4_invert_tuple&lt;br /&gt;
            tcp_invert_tuple&lt;br /&gt;
            For example, orig tuple:&lt;br /&gt;
            original: 192.168.199.132 -&amp;gt; google.com&lt;br /&gt;
            reply: google.com -&amp;gt; 192.168.199.132 //this is orig_relpy&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        inverse tuple:
        original(inverse-&amp;gt;dst.dir = !orig-&amp;gt;dst.dir;):
        192.168.199.132 -&amp;gt; google.com (!!!reverse orig_reply in ipv4_inver_tuple())
         这个函数的用途可能是担心, orig被人改了, 不能用了.
        except for prior manipulations
    }       

    get_unique_tuple
    {
        1. 如果snat, 且前后可以一致就直接new=orig, 合理.
        2. find_appropriate_src 费点力... 貌似找到已经用到的, 复用
        3. find_best_ips_proto, 找一个 the least-used IP/proto combination in the given range
        4. nf_nat_used_tuple 保证唯一
    }       

    bysoruce 里面存的应该是new_original, hash -&amp;gt; &amp;amp;net-&amp;gt;ct.nat_bysource[srchash]


}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//上面ct改完了该改skb了.&lt;br /&gt;
    nf_nat_packet -&amp;gt; nf_nat_ipv4_manip_pkt,&lt;br /&gt;
}&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SNAT nftables&lt;br /&gt;
nf_nat_prerouting &amp;hellip;-&amp;gt; nft_do_chain&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;One kind of NAT, just set one flag bit in ct-&amp;gt;status (SRC_NAT or DST_NAT), but set both SRC/DST_DONE!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;De-NAT&lt;br /&gt;
最简单的路由器 在postrouting 做了snat（masquade）那么回来的报文怎么unsnat呢？&lt;br /&gt;
我看了九贱的帖子，一笔带过了。 我不太懂的地方是在nat_packet这个函数里面在发现是rely的报文，要判断ct→status &amp;amp; IPS_DST_NAT 为真 才修改skb里的IP port，我不清楚reply的报文何时给ct→status打的DST_NAT的标记位，看代码好象是prerouting的ip_nat_setup_info这个函数，可是我看到必须改了ct的tuple才能给ct→status打标记位，反复的修改ct，我觉得自己想的不对。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;*答案3.17的代码和原来没多大变化就是函数名字变了&lt;br /&gt;
发包-POSTROUTING -&amp;gt;SNAT -&amp;gt;修改ct: nf_nat_setup_info-&amp;gt;　ct-&amp;gt;status |= IPS_SRC_NAT;-&amp;gt;修改skb:nf_nat_packet&lt;/p&gt;

&lt;p&gt;收报-PREOUTING-&amp;gt; DNAT-&amp;gt;修改skb:nf_nat_packet&lt;br /&gt;
{&lt;br /&gt;
    enum nf_nat_manip_type mtype = HOOK2MANIP(hooknum);&lt;br /&gt;
    //因为是在PREROUTING, 所以是DNAT, 我以前一直以为, de-snat在postrouting中做的.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (mtype == NF_NAT_MANIP_SRC)          
    statusbit = IPS_SRC_NAT;             
else                                      
    statusbit = IPS_DST_NAT;        //到这里

/* Invert if this is reply dir. */            
if (dir == IP_CT_DIR_REPLY) 
    statusbit ^= IPS_NAT_MASK;        //翻转一下变成SNAT 
/* Non-atomic: these bits don&#39;t change. */                                                                                                    
if (ct-&amp;gt;status &amp;amp; statusbit) {                 
//正好和发包是的   ct-&amp;gt;status |= IPS_SRC_NAT;匹配了, 开始de-snat.                    
    struct nf_conntrack_tuple target;
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;#ipset&lt;br /&gt;
salist for iptables&lt;/p&gt;

&lt;p&gt;#SYN proxy&lt;br /&gt;
SYNPROXY target makes handling of large SYN floods possible without&lt;br /&gt;
the large performance penalties imposed by the connection tracking in such cases.&lt;br /&gt;
On 3 November 2013, SYN proxy functionality was merged into the Netfilter,&lt;br /&gt;
with the release of version 3.12 of the Linux kernel mainline&lt;/p&gt;

&lt;p&gt;#nftables&lt;/p&gt;

&lt;p&gt;#FAQ&lt;br /&gt;
* 如何查看某个table 具体在那几个hook点.&lt;br /&gt;
去看内核代码 or iptables -L -t &amp;ldquo;table 名&amp;rdquo;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
