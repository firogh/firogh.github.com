<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title> on f(x) </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://firoyang.org/</link>
    <language>en-us</language>
    <author>Firo Yang</author>
    
    <updated>Sun, 12 Jun 2016 20:23:11 CST</updated>
    
    <item>
      <title>荒野中的人</title>
      <link>http://firoyang.org/philosophy/the_wilds/</link>
      <pubDate>Sun, 12 Jun 2016 20:23:11 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/philosophy/the_wilds/</guid>
      <description>&lt;p&gt;国家是所有怪物中最为冷酷的, 冷酷的谎言从头的嘴里爬出来:&amp;ldquo;我, 这个国家, 就是全体人民.&lt;br /&gt;
                                ———— 尼采 《新的偶像》&lt;/p&gt;

&lt;p&gt;一个人在降生之前, 他的同类, 就以国家这个怪物的名义瓜分了这个他所赖以生存世界,&lt;br /&gt;
没有选择的余地. 是的, 无论你是否愿意, 你都将成为国家的一部分. 同时, 这也是&lt;br /&gt;
个人乃至整个人类族群的悲剧的起源!&lt;/p&gt;

&lt;p&gt;人们不可避免的成为了社会的一个螺丝钉, 你要生存就必须参与进来.&lt;br /&gt;
生活在所谓社会中的个体, 又是怎样的? 普遍特征就是放弃思考!&lt;br /&gt;
在面对历经数千年历史形成的庞大社会体系, 对于个人来说, 了解适应&lt;br /&gt;
这个社会占据了他的一生. 只要少数人不断常识改变, 革新人们所处的生活&lt;br /&gt;
牢笼, 如卢梭, 孟德斯鸠, 尼采, 马克思等等.&lt;/p&gt;

&lt;p&gt;我发现, 所处社会中绝大多数人, 都觉得他的being, 以及围绕他的一切都是理所当然.&lt;br /&gt;
所有的人, 都在顺从着社会的意志, 成为社会的奴隶. 而社会中的绝大多数人成为了一小部分&lt;br /&gt;
人的奴隶.&lt;/p&gt;

&lt;p&gt;To be continue.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>杂记于蓝星花园</title>
      <link>http://firoyang.org/firo/z1/</link>
      <pubDate>Sat, 27 Feb 2016 22:12:11 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/firo/z1/</guid>
      <description>&lt;p&gt;我知道有很多事我的去做, 但是又不知如何开始, 这就是现在的我.&lt;br /&gt;
我之所以这样, 很可能因为, 之前走过太多弯路, 现在害怕在走上那样的路.&lt;/p&gt;

&lt;p&gt;如何开始着手呢? 算法用不用看? kernel 用不用看?&lt;br /&gt;
如何衡量某个内容是否值得花时间呢?&lt;br /&gt;
至少要分出主次来.&lt;br /&gt;
首先要推理出所有知识的关系图, 这是第一步, 也就是先确定所谓的框架.&lt;br /&gt;
之后, 在这个框架上, 挑选重要的, 可行的学习.&lt;br /&gt;
这么看来和学习英语很像. 正所谓万变不离其宗.&lt;/p&gt;

&lt;p&gt;May 1 2015&lt;br /&gt;
我今天建立了关于Computer science 知识的Architecture.&lt;br /&gt;
我需要抽空写一篇文章完整的阐述这个Architecture.我也总算是对计算机科学有个&lt;br /&gt;
交代了.虽然框架是有了, 但我还是不知道怎么来填充它, 以及在填充的过程中如何&lt;br /&gt;
和实际的实践联系上.&lt;/p&gt;

&lt;p&gt;实际上, 只要沿着architecture的逻辑链条逐次递归的需找sub-architecture就可以了.&lt;br /&gt;
虽然, 依然不能很好的把握和实际实践联系. 但至少可以明确, 寻找sub-architecture,&lt;br /&gt;
这件事也是在日程上的需要去做.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The Architecture of Knowledge</title>
      <link>http://firoyang.org/philosophy/knowledge/</link>
      <pubDate>Wed, 17 Feb 2016 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/philosophy/knowledge/</guid>
      <description>

&lt;h1 id=&#34;世界本源-the-origin-of-the-world-l-origine-du-monde&#34;&gt;世界本源, the origin of the world, L&amp;rsquo;Origine du monde&lt;/h1&gt;

&lt;p&gt;being(4), abyss(0)&lt;br /&gt;
material(1) change, quality, quantity, relation, inference&lt;br /&gt;
process(2)(5), tansfer, truth, signifier(3), bijection, Causality&lt;br /&gt;
simaotics, time-sharing&lt;/p&gt;

&lt;p&gt;以数学进制系统为例.貌似越为简约的计数系统, 只能越复杂,反之操作越为简单,原始.&lt;br /&gt;
或者说除一进制职位的计数系统, 其他都需要更为复杂?&lt;br /&gt;
 一进制对应双射! 其他是一对多.&lt;br /&gt;
本隐藏的识别系统.&lt;br /&gt;
我所理解人类思维行事习惯, 是建立在模式识别的基础上的. 很自然想到同理去制作computer.&lt;br /&gt;
这也是Turing machine所依靠的潜在前提.&lt;br /&gt;
而PC是建立在Bool Shannon的电子代数逻辑上的.&lt;br /&gt;
Arithmetic, 基础的 quantity change 规律.&lt;br /&gt;
algebra 求解未知process.&lt;br /&gt;
36 Turing machine.&lt;br /&gt;
我们如何评价computer中arithmetic用boolean algebra实现?&lt;br /&gt;
quantity -&amp;gt; quality, 这都是具体语义层面的概念.&lt;br /&gt;
首先, 要明确对于computer的adder来说,他在做得是elementary algebra不是简单的arithmetic,&lt;br /&gt;
而同时用于实现adder的是boolean algebra.&lt;br /&gt;
是什么是boolean algebra构建adder成为可能?&lt;br /&gt;
一个是qunatity, 一个是quality, 但采用相同的符号表达概念, 二者都是form system,&lt;br /&gt;
确是不同substance.只有0,1 的quantity和truth quality,在形式上等价,&lt;br /&gt;
我们先放下为什么computer不是从量这个角度构建.&lt;br /&gt;
那么logic的基本运算and, or, not又是什么呢?人为认知的quality的process or relation.&lt;br /&gt;
首先从一进制转换成二进制就已经违反人类的直观了.&lt;br /&gt;
一进制每个signifier(都相同)都有一个signified, bijection, one-to-one correspondence;抽象后lack of material.&lt;br /&gt;
二进制呢?signifier出现差异, 有两种0,1; 一进制可看成全是0,0&amp;hellip;&amp;hellip;;&lt;br /&gt;
{,x, oo, ddd, ffff, &amp;hellip;}&lt;br /&gt;
一进制{, 0, 00, 000, 0000, &amp;hellip;}&lt;br /&gt;
二进制{0, 1, 10, 11, 100, 101, &amp;hellip;}&lt;br /&gt;
很显然, 一进制更符合我们对量的理解. 而二进制,就不那么直观了, 但是依然符合量的表述, 不过,&lt;br /&gt;
signifier的数量成2的指数所见. 同理16进制就更慢了.&lt;br /&gt;
检视adder的logic实现, 以1bit二进制数加和为例.&lt;br /&gt;
从量的视角, 一进制{,0,00}只有这三种可能.&lt;br /&gt;
二进制{0,1,10}, 我们人类如何计算二进制1 + 1呢?是一种模式匹配.&lt;br /&gt;
a + b &amp;lt; base , result = a + b; 如何a + b &amp;gt; base, result a + b - base;&lt;br /&gt;
如果我们使用电路但不是基于逻辑上的而是基于本质的运算规则. 我们规定相应的input的值和output值的关系.&lt;br /&gt;
0,0 -&amp;gt; 0&lt;br /&gt;
0,1 -&amp;gt; 1&lt;br /&gt;
1,0 -&amp;gt; 1&lt;br /&gt;
1,1 -&amp;gt; 0, 1carry&lt;br /&gt;
电路怎么画呢?电路结构本身就是一种判断!&lt;br /&gt;
画完图, 我就明白了, 不是我们选择使用boolean algebra作为实现运算的手段, 而是我们别无选择, 或者说这种思维&lt;br /&gt;
过程, 正好被明明为了boolean 代数.&lt;br /&gt;
怎么实现一进制呢? a 有10中连接到reslt同b控制.&lt;br /&gt;
为什么进位制是有效的呢?反证法?&lt;br /&gt;
那这种进制计数法本质又是什么呢?一进制是纯粹的quantity语义, 而其他进制form system加入了顺序, 通过顺序表示quantity.&lt;br /&gt;
这也就是符号系统的表意能力, 又好比英语的word order. 顺序(排列)和元素种类是符号系统的signifier表意的重要关键.&lt;br /&gt;
留心到顺序与元素差异多少, 是唇亡齿寒的关系!&lt;br /&gt;
多进制系统已经不是纯粹量化关系了, 还涉及到了符号系统的表意层面, 也就是说要做判断(匹配).&lt;br /&gt;
二进制是扩大符号系统表意数量的, 而logic电路开关是构成符号系统表达能力的基本元素!&lt;br /&gt;
符号系统是有表达极限的!&lt;/p&gt;

&lt;p&gt;x代表0 or 1; x + x的数字电路logic实现:&lt;/p&gt;

&lt;p&gt;0 不被理解-&amp;ldquo;冰冷安静&amp;rdquo;的世界。&lt;br /&gt;
1 An object is abstract (if and) only if it is causally inefficacious.&lt;br /&gt;
2 过程本身是有记忆的.&lt;br /&gt;
3 f(3)=4, 3是signifier, process or relation是f(x)=x+1 or f(x)=2x-2;&lt;br /&gt;
4 语言符号概念切割知识/being. 造成碎片成为理解的阻碍.人类的独特是能够感受的being.&lt;br /&gt;
5 由算法分析感知, 搞清变化与原因原因要比记住过程要vital. 过程的结果(不是最终结果,是每步的阶段)是他的因! 很美妙.&lt;br /&gt;
人对世界理解是建立在人对世界理解产生的概念之上, 这事把双刃剑. 被割裂的世界成为认知的&lt;br /&gt;
障碍. 成一种约束, 束缚.这个世界只要是能认知的,都被人类提上了标签. 恰恰因为这些标签,&lt;br /&gt;
割裂了二进制和boolean logic.知识本身成为了,知识自身发展的壁垒!人们建立沟壑, 同时又在&lt;br /&gt;
弥合这些沟壑. 也就是学到的知识本身,成为不可完全信任的存在了! sense experience成为重要认知手段.&lt;br /&gt;
在被割裂的前提下, 形式form成为了弥合沟壑的重要手段.&lt;br /&gt;
还有一点, Turing machine是建立在人为判断的基础上的. 而二进制的数字电路的这种判断能力是人为设计的.&lt;br /&gt;
我们可以称此二种判断为过程, 一个是通过光学转换成脑信号的过程, 一个是通过电流传到的过程.&lt;br /&gt;
那么为什么这两个复杂度天差地别的判断过程, 会形成相同的结果(在这里是完成计算二进制的1+1之类)呢?&lt;br /&gt;
虽然二进制数字电路无法完成, 眼睛光学信号到脑电流的附在转换过程.但是他们在能力上是完全等价的之于&lt;br /&gt;
computation 1+1, 这件事他们完成的是传递transfer这个世界本源.只要把相应符号送到相应process就可以了.&lt;br /&gt;
光学, 我们直接把1+1, 送到了1+1=0,1 carry.而二进制,我们是把1+1送到了a^b, a and b这两个过程中了.&lt;br /&gt;
判断本质是transfer.所以, 眼睛和电路完成了相同的功能&amp;ndash;transfer. 这里就是明显的概念割裂了知识,沟壑&lt;br /&gt;
使人难以预约, 最终通过形式form的一致(transfer)填补了沟壑.&lt;/p&gt;

&lt;p&gt;接下来是各种各样的&lt;br /&gt;
Computer science: learn how to formalize intuition about process, how to do things,&lt;br /&gt;
starting to develop a way to talk precisely about how-to knowledge, as opposed to&lt;br /&gt;
geometry talks about what is true.&lt;br /&gt;
Imperative knowledge: How to. guess is the 1st method. That&amp;rsquo;s a process as like a&lt;br /&gt;
magical spirit that sort of lives in the computer and does something.&lt;br /&gt;
Procedure directs a process is a pattern of rules. spells.&lt;br /&gt;
process is magical spirit.&lt;/p&gt;

&lt;p&gt;process包含algorithms和更为基础的computation and else;&lt;br /&gt;
programming(design pattern) through language 是把这个process实例化.&lt;br /&gt;
os, architecture是作为process的辅助.&lt;br /&gt;
我觉得这里computation就类似语言的顺序和曲折变化这些最基本的elements.&lt;br /&gt;
并不是我们发现了hardware的计算能力, 而是hardware能完成我们的计算需求.&lt;/p&gt;

&lt;p&gt;Mathematics: Declartive knowledge, what is true. doesn&amp;rsquo;t really say anything about how&lt;br /&gt;
you might go out and find one.&lt;/p&gt;

&lt;h1 id=&#34;根据依赖关系组织-展示的知识&#34;&gt;根据依赖关系组织, 展示的知识&lt;/h1&gt;

&lt;p&gt;知识之间都是相互依赖的.&lt;br /&gt;
Logic&lt;br /&gt;
Language&lt;br /&gt;
Mathematics&lt;br /&gt;
Programming&lt;/p&gt;

&lt;p&gt;English&lt;br /&gt;
Hibert提出23个问题. turing machine 是为了解决数学可判定性问题.&lt;br /&gt;
由此导致CS的蓬勃发展.&lt;/p&gt;

&lt;p&gt;Class of knowledge&lt;br /&gt;
Raw knowledge, which exists in live, is real, leisure, scattered, low chance to learn.&lt;br /&gt;
Raw knowledge need lots of time to learn.&lt;br /&gt;
Artificial knowledge&lt;br /&gt;
linear enumerate knowledge: only for searching.&lt;/p&gt;

&lt;p&gt;Phased objectives of learning knowledge&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The common cognition language</title>
      <link>http://firoyang.org/linguistics/ccl/</link>
      <pubDate>Sun, 13 Dec 2015 03:27:16 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/linguistics/ccl/</guid>
      <description>&lt;p&gt;What&amp;rsquo;s the orgnaiszations of knowledge?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Console and TTY</title>
      <link>http://firoyang.org/cs/console/</link>
      <pubDate>Sat, 05 Dec 2015 14:06:29 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/console/</guid>
      <description>

&lt;p&gt;343 line&lt;br /&gt;
1. /dev/console 指向正在运行的tty 和tty0 一样ttyN not pts, console 佬变.&lt;br /&gt;
2. /dev/tty 一直指向所在的那个不变.&lt;/p&gt;

&lt;h1 id=&#34;about-the-design&#34;&gt;About the design&lt;/h1&gt;

&lt;p&gt;Why dose we use /dev/xxx to represent the &amp;ldquo;tty&amp;rdquo; device?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The whole point with &amp;ldquo;everything is a file&amp;rdquo; is not that you have some random filename (indeed, sockets and pipes show that &amp;ldquo;file&amp;rdquo; and &amp;ldquo;filename&amp;rdquo;&amp;gt; have nothing to do with each other), but the fact that you can use common tools to operate on different things. &amp;ndash; Linus&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So we got the key point!&lt;br /&gt;
In order to use the common tools, file ops and vfs layer, the tty device is &amp;ldquo;abstructed&amp;rdquo; to&lt;br /&gt;
files by us. Addnationaly, we must assurance that is the files is &lt;em&gt;different&lt;/em&gt;. What does&lt;br /&gt;
the word &amp;ldquo;dirrerent&amp;rdquo; means is not that you have some random different filename, but the&lt;br /&gt;
fact that you can access the real device through the different.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Wikipedia:&lt;br /&gt;
In mathematics, injections, surjections and bijections are classes of functions distinguished by the manner in which arguments (input expression&amp;gt; s from the domain) and images (output expressions from the codomain) are related or mapped to each other.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I got an insight that abstruction is a non-injective, right?&lt;br /&gt;
But non-injective may not be a anstruction.&lt;br /&gt;
An asbstruction should come from manipulating different objects.&lt;br /&gt;
Non-injective, 多对一; Multiplex, 一对多.&lt;br /&gt;
So we can use mathematical language to describe the linux subsystem.&lt;br /&gt;
From real life device to a filesystem file.&lt;br /&gt;
* Abstruction: Non-injective, Multiplex(not partial function).&lt;br /&gt;
* Jection num: injective, or non-jective, or multiplex; Jection level: domain set and codoain set!&lt;br /&gt;
Abstruction -&amp;gt; Control abstruction and data abstruction -&amp;gt; Abstruction layer&lt;/p&gt;

&lt;p&gt;软件设计的两个主要目的.&lt;br /&gt;
1. 简化, 易用,易操作, 如computer architecture, tty subsystem. 抽象.&lt;br /&gt;
2. Separation of concerns, modular(abstruciton in layer), 笛卡尔划分的思想&lt;/p&gt;

&lt;h1 id=&#34;tty-struct-disc-data&#34;&gt;tty_struct-&amp;gt;disc_data&lt;/h1&gt;

&lt;p&gt;tty_init_dev-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    initialize_tty_struct-&amp;gt;tty_ldisc_init&lt;br /&gt;
    tty_ldisc_setup-&amp;gt;tty_ldisc_open-&amp;gt;n_tty_open-&amp;gt; tty-&amp;gt;disc_data = ldata;&lt;br /&gt;
}&lt;br /&gt;
sys_vhangup-&amp;gt;tty_vhangup_self-&amp;gt;__tty_hangup-&amp;gt;tty_ldisc_hangup-&amp;gt;tty_ldisc_reinit&lt;br /&gt;
vfs_write-&amp;gt;redirected_tty_write-&amp;gt;tty_write-&amp;gt;n_tty_write-&amp;gt;process_output&lt;/p&gt;

&lt;h1 id=&#34;early-con&#34;&gt;early_con&lt;/h1&gt;

&lt;p&gt;EARLYCON_DECLARE(uart8250, early_serial8250_setup); EARLYCON_DECLARE(uart, early_serial8250_setup);&lt;br /&gt;
setup_earlycon-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    parse_options-&amp;gt;&lt;br /&gt;
    {&lt;br /&gt;
        parse earlycon_device-&amp;gt;port-&amp;gt;uartclk and&lt;br /&gt;
        earlycon_device-&amp;gt;baud&lt;br /&gt;
    }&lt;br /&gt;
    setup = early_serial8250_setup-&amp;gt; init_port(device);&lt;br /&gt;
    register_console(early_console_dev.con)&lt;br /&gt;
}&lt;/p&gt;

&lt;h1 id=&#34;earlyprintk&#34;&gt;earlyprintk&lt;/h1&gt;

&lt;p&gt;early_param(&amp;ldquo;earlyprintk&amp;rdquo;, setup_early_printk)-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    early_serial_init-&amp;gt;&lt;br /&gt;
    {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;}
early_console_register(&amp;amp;early_serial_console, keep);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;h1 id=&#34;cpu-hotplug&#34;&gt;cpu hotplug&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;onset&lt;br /&gt;
static struct smp_hotplug_thread softirq_threads {&lt;br /&gt;
.thread_fn              = run_ksoftirqd&lt;br /&gt;
};&lt;br /&gt;
early_initcall(spawn_ksoftirqd)-&amp;gt;mpboot_register_percpu_thread(&amp;amp;softirq_threads)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;nucles onset&lt;br /&gt;
suspend_enter-&amp;gt;enable_nonboot_cpus-&amp;gt;_cpu_up-&amp;gt;smpboot_create_threads-&amp;gt;&lt;strong&gt;smpboot_create_thread(&amp;amp;hotplug_threads)-&amp;gt;&lt;br /&gt;
kthread_create_on_cpu(smpboot_thread_fn-&amp;gt; ht-&amp;gt;thread_fn(td-&amp;gt;cpu)= run_ksoftirqd-&amp;gt;&lt;/strong&gt;do_softirq-&amp;gt;h-&amp;gt;action(h) = run_timer_softirq-&amp;gt;&lt;br /&gt;
__run_timers-&amp;gt;call_timer_fn)&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;vt 就是个tty也有tty_driver 叫console_driver.&lt;/p&gt;

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;h1 id=&#34;contents&#34;&gt;Contents&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://superuser.com/questions/144666/what-is-the-difference-between-shell-console-and-terminal&#34;&gt;What is the difference between shell, console, and terminal?&lt;/a&gt;&lt;br /&gt;
What does console do in kernel or u-boot?&lt;br /&gt;
Linux console?&lt;br /&gt;
Computer terminal: keyboard + dispaly&lt;br /&gt;
Terminal emulator:&lt;/p&gt;

&lt;h1 id=&#34;get-a-glance-on-u-boot&#34;&gt;get a glance on u-boot&lt;/h1&gt;

&lt;p&gt;start.S:board_init_r&lt;br /&gt;
init_sequence_f: -&amp;gt;init_baud_rate; serial_init; console_init_f&lt;br /&gt;
serial_init -&amp;gt;&amp;amp;eserial1_device-&amp;gt;start=eserial##port##_init-&amp;gt;NS16550_init: UART divisor init.&lt;br /&gt;
Firstly, the struct of serial define some input and output funtion.&lt;br /&gt;
It&amp;rsquo;s basic function of serial, put or get!&lt;br /&gt;
console_init_f: just gd-&amp;gt;have_console = 1;&lt;br /&gt;
init_sequence_r: stdio_init_tables,initr_serial, stdio_add_devices, console_init_r,&lt;br /&gt;
initr_serial: just register &amp;amp;eserial1_device to serial_devices&lt;br /&gt;
stdio_add_devices: drv_system_init, serial_stdio_init&lt;br /&gt;
drv_system_init: register default serial dev to devs.list.&lt;br /&gt;
serial_stdio_init: register &amp;amp;eserial1_device to devs.list. Duplicate, but serial dev &amp;ldquo;eserial0&amp;rdquo;  and system &amp;ldquo;serial&amp;rdquo;.&lt;br /&gt;
console_init_r: console_doenv -&amp;gt;console_setfile:stdio_devices[file(0/1/2)] = dev; actually, dev is &amp;ldquo;serial&amp;rdquo;, but they may be KBD!&lt;br /&gt;
看来console的真正作用就是在serial和kbd中选择一个, 可能多选iomux?&lt;br /&gt;
main_loop:cli_loop: getc!&lt;/p&gt;

&lt;h1 id=&#34;what-is-platform-device-or-driver&#34;&gt;what is platform device or driver?&lt;/h1&gt;

&lt;h1 id=&#34;a-reallife-serial8250&#34;&gt;A reallife serial8250&lt;/h1&gt;

&lt;p&gt;drivers/tty/serial/8250/8250_boca.c:plat_serial8250_port&lt;br /&gt;
module_init-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    serial8250_init-&amp;gt;serial8250_isa_init_ports-&amp;gt;serial8250_ports[i].port.ops = &amp;amp;serial8250_pops; //insidious&lt;br /&gt;
    boca_init-&amp;gt;platform_device_register(&amp;amp;boca_device); //register platform device and data.&lt;br /&gt;
}&lt;br /&gt;
* uart_port-&amp;gt;tty_port&lt;/p&gt;

&lt;p&gt;serial8250_probe(plat_serial8250_port)-&amp;gt;serial8250_register_8250_port(uart_8250_port)-&amp;gt;&lt;br /&gt;
uart_add_one_port(&amp;amp;serial8250_reg, &amp;amp;uart-&amp;gt;port=uart_port)-&amp;gt;&lt;br /&gt;
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uart_configure_port-&amp;gt;
{
    port-&amp;gt;ops-&amp;gt;config_port(port, flags)=serial8250_config_port
    if post is console and not registered; register!
    we know that uport-&amp;gt;cons = drv-&amp;gt;cons; what is the relation to registering about up-&amp;gt;cons.
    why we register it? where does drv-&amp;gt;cons come from?
    //这个uart_driver drv就是serial8250_reg, 我们也就知道了
    // console是设备的一种天生能力. 能否使用, 只关乎你是否想用, 就是配置相关的config SERIAL8250_CONSOLE
    // con_driver is the backends, vga, dummy/serial?, fb. 
}
tty_port_register_device_attr-&amp;gt;
{
    //tty_driver  tty_port
    tty_port_link_device
    tty_register_device_attr
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;h1 id=&#34;simple-conceptions&#34;&gt;Simple conceptions&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.linusakesson.net/programming/tty/&#34;&gt;You must read this -&amp;gt; The TTY demystified&lt;/a&gt;&lt;br /&gt;
System consoles are generalized to computer terminals, which are abstracted respectively by virtual consoles and terminal emulators.&lt;br /&gt;
        UART&lt;br /&gt;
        Line displine + TTY(pts, dummy/serial, kbd+vga/fb)&lt;br /&gt;
* System console&lt;br /&gt;
Virtual termial, Terminal emulator/telnet/ssh -&amp;gt; pts ,Physical terminal&lt;br /&gt;
You need at least one virtual terminal device in order to make use of your keyboard and monitor.&lt;br /&gt;
VT combine keyboard and display see con_init&lt;br /&gt;
con_init init a virtual terminal like gnome-terminal but in kernel.&lt;br /&gt;
con_init mainly init display.&lt;br /&gt;
vty_init mainly init kbd&lt;br /&gt;
They all can be system console.(Exception pts??), if you enable it.&lt;br /&gt;
Console is the entry of linux system.&lt;br /&gt;
* Console driver &amp;ndash; banckends of  console&lt;br /&gt;
struct console 指定了console的结构.&lt;br /&gt;
* Console config&lt;br /&gt;
If I disable CONFIG_SERIAL8250_CONSOLE(enable vt console), then no booting log and I can not login system.&lt;br /&gt;
If I disable CONFIG_VT_CONSOLE(enable serail console, /dev/console point to ttyS0 see show_cons_active), no booting log but I can lgin system.&lt;br /&gt;
How to explain this phenomena?&lt;br /&gt;
From show_cons_active, we know /dev/console should come from console_drivers.&lt;br /&gt;
/dev/console is really the pointer.&lt;br /&gt;
Now, let&amp;rsquo;s inspect open /dev/console.&lt;br /&gt;
* Open /dev/console&lt;br /&gt;
Fisrt, it&amp;rsquo;s the very last place of booting kernel.&lt;br /&gt;
start_kernel-&amp;gt;rest_init-&amp;gt;kernel_init-&amp;gt;kernel_init_freeable-&amp;gt;sys_open((const char __user *) &amp;ldquo;/dev/console&amp;rdquo;, O_RDWR, 0)-&amp;gt;&amp;hellip;-&amp;gt;&lt;br /&gt;
console_fops-&amp;gt;tty_open-&amp;gt;&lt;br /&gt;
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Sitiuations: disbale VT CONSOLE byt enable SERIAL8250_CONSOLE.
// This function work only for /dev/tty
// ls -l /dev/tty
// crw-rw-rw- 1 root tty 5, 0 Dec 10 10:24 /dev/tty
tty_open_current_tty-&amp;gt;
{
    /dev/console is 5:1, just return NULL
}
//This index should be Ctrl + Alt + Fn??
// tty_struct is corresponding virtual console, or just console??
// lookup tty_driver. It looks like lookup a inode, right?
tty_lookup_driver-&amp;gt;
{
    // Find a tty_driver by device() in console_drivers.
    // So we know, got a console, then got a tty_driver, right?
    // Where do the components of console_drivers come form?
    // At present, we should have only serial8250_console because 
    // console vt_console_driver is disabled by us! But tty_driver console_driver
    // still do exist!So console and tty is really separated!
    // When we init vt, we get the tty_driver console_driver with con_ops type of tty_operations.
    // tty_drivers have the same major with /dev/tty0!
    // char_dev -&amp;gt; tty_driver int vty_init, not disable.
    // vt console---^
    console_device-&amp;gt;c-&amp;gt;device(c, index)
    // What about serial8250_console?
    // Where is the tty_driver of serial8250_console?
    // console-&amp;gt;data = uart_driver-&amp;gt;tty_driver.
    // We got another scene : uart-&amp;gt;tty
    // serial8250 console-&amp;gt;data-^
    // serial&#39;s tty_driver alloced in serial8250_init with uart_ops.
    // vt&#39;s tty_driver alloced in vty_init.
    // We summarize these:
    // uart_driver serial8250_reg &amp;lt;-&amp;gt;  vc dev or /dev/tty*
    // serial tty driver &amp;lt;-&amp;gt; vt tty driver 
    // fs:vty_init &amp;lt;-&amp;gt; module:serial8250_init
    // tty driver ops con_ops &amp;lt;-&amp;gt; uart_ops
    // vt use major to connect tty and  vc dev
    // serial use major and -&amp;gt; to connect tty and uart_driver
    // It seems that uart and tty has a strong relationship, yet vt.
    // Ok... we got tty driver.
    // If we disable vt console, then here is the serial8250 tty_driver.
}
// Lookup for tty_struct
tty_driver_lookup_tty -&amp;gt;
{
    //tty_struct is alloced in init function alloc_tty_driver.
    // ttys, termios, ports, cdevs.
    // ttys was used by tty_standard_install then tty_driver_install_tty 
    // then tty_init_dev then ok we return to tty open. So this is the start place.

    So we know tty_driver-&amp;gt;ttys[*] must be NULL.
}
tty_init_dev-&amp;gt;
{
    // tty_driver likes a process, ttys like the files, tty_struct like a file!
    // So we know a tty_struct is a tty file.
    // tty_driver much like a inode
    //So tty_struct-&amp;gt;ops = tty_driver-&amp;gt;ops = &amp;amp; uart_ops
    alloc_tty_struct-&amp;gt;tty-&amp;gt;ops = driver-&amp;gt;ops;
    tty_driver_install_tty(driver, tty_struct)-&amp;gt; tty_standard_install-&amp;gt;driver-&amp;gt;ttys[tty-&amp;gt;index] = tty;
}
// Ok... We got a tty_struct.
// Add /dev/console to tty_struct-&amp;gt;tty_files
tty_add_file
// At present, what have we done?
// open(/dev/console)-&amp;gt;console_drivers-&amp;gt;console-&amp;gt;tty_driver-&amp;gt;tty_struct, right?

tty-&amp;gt;ops-&amp;gt;open(tty, filp)-&amp;gt;//ops = &amp;amp;uart_ops
{
    uart_ops-&amp;gt;open = uart_open-&amp;gt;
    {
        uart-&amp;gt; tty struct
        struct uart_driver *drv = (struct uart_driver *)tty-&amp;gt;driver-&amp;gt;driver_state;
        struct uart_state *state = drv-&amp;gt;state + line; //uart_state
        tty-&amp;gt;driver_data = state;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
// At present, we understand the flow of open /dev/console to serial console&lt;/p&gt;

&lt;h1 id=&#34;what-about-opening-dev-console-to-vt-console&#34;&gt;What about opening /dev/console to vt console&lt;/h1&gt;

&lt;p&gt;sys_open(/dev/console)-&amp;gt; &amp;hellip; tty_open -&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    tty_lookup_driver-&amp;gt; get tty_driver=console_driver,&lt;br /&gt;
    Through the name console_driver, we know, vt tty_driver is the defaut driver of console!&lt;br /&gt;
    // 同时, 我们也应该知道所谓的kernel的system console 是你只要enable了先关的config CONFIG_VT_CONSOLE and CONFIG_SERIAL_8250_CONSOLE.&lt;br /&gt;
    // system console就有了, printk也就有了归处. In other words, you registered, you got printed&lt;br /&gt;
    // In theory, you should be able to input something, like sysrq, I maybe test tomorrow.&lt;br /&gt;
    // 那么在kernel_init中sys_open又是什么鬼呢?&lt;br /&gt;
    // dev/tty 是专门真对进程的, 就是进程之前打开了一个tty就存在singnal里, 这个dev/tty就是取出来的.&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;h1 id=&#34;总结下-打开-dev-console-会从console-drivers-最终到达tty-driver&#34;&gt;总结下, 打开/dev/console, 会从console_drivers, 最终到达tty_driver.&lt;/h1&gt;

&lt;h1 id=&#34;这和-dev-tty-dev-ttys-从tty-drivers-差不多&#34;&gt;这和/dev/tty* /dev/ttyS* 从tty_drivers, 差不多.&lt;/h1&gt;

&lt;p&gt;// 这么输出为什么不会打窜了?&lt;br /&gt;
// How ctrl alt Fn work?&lt;br /&gt;
// echo xxx /dev/tty in serial tty_lookup_driver&lt;br /&gt;
// 另一个问题, serial 的terminal?&lt;/p&gt;

&lt;h1 id=&#34;the-perspective&#34;&gt;The perspective&lt;/h1&gt;

&lt;p&gt;/dev/*&lt;br /&gt;
vfs&lt;br /&gt;
chrdev&lt;br /&gt;
tty_fops&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;gt;tty core&lt;br /&gt;
    ld_ops &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;&amp;gt; tty line discipline(for read, write)&lt;br /&gt;
tty_driver con_ops/uart_ops&amp;mdash;&amp;mdash;&amp;ndash;&amp;gt; tty driver and tty_operations&lt;br /&gt;
HW&lt;br /&gt;
There are three different types of tty drivers: console, serial port, and pty.&lt;br /&gt;
serial8250_default_handle_irq&lt;br /&gt;
UART console&lt;br /&gt;
              |&amp;mdash;- Virtual terminal &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; VT console&lt;br /&gt;
              |                 | &amp;ndash; VT console&lt;br /&gt;
              |&amp;mdash;-&lt;br /&gt;
        Terminal&amp;ndash;|&lt;br /&gt;
              |&amp;mdash;-&lt;/p&gt;

&lt;h1 id=&#34;what-about-console&#34;&gt;What about console?&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;early_con&lt;br /&gt;
start_kernel or setup_arch(arm)-&amp;gt;parse_early_param-&amp;gt;do_early_param-&amp;gt;p-&amp;gt;setup_func()= setup_early_printk-&amp;gt;register_console&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;vga_con&lt;br /&gt;
start_kerenl-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
// All about vga console&lt;br /&gt;
set_arch-&amp;gt; conswitchp = &amp;amp;vga_con; or conswitchp = &amp;amp;dummy_con;&lt;br /&gt;
console_init-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
        tty_ldisc_begin-&amp;gt;tty_register_ldisc(N_TTY, &amp;amp;tty_ldisc_N_TTY);&lt;br /&gt;
    console_initcall(con_init);&lt;br /&gt;
console_initcall(serial8250_console_init)&lt;br /&gt;
    con_init-&amp;gt;&lt;br /&gt;
    {&lt;br /&gt;
        // vc-&amp;gt;vc_sw-&amp;gt;con_putcs is DUMMY&lt;br /&gt;
        //内存映射64KB or 32KB的VGA区域. 启动VGA&lt;br /&gt;
        conswitchp-&amp;gt;con_startup = vgacon_startup -&amp;gt;vga_vram_base = VGA_MAP_MEM(vga_vram_base, vga_vram_size);&lt;br /&gt;
        con_driver_map[0~MAX_NR_CONSOLES] = conswitchp; //空间换时间&lt;br /&gt;
        // 核心内容!&lt;br /&gt;
        for (currcons = 0; currcons &amp;lt; MIN_NR_CONSOLES; currcons++) {&lt;br /&gt;
            // 给vc_cons[currcons].d分配内存&lt;br /&gt;
            vc_cons[currcons].d = vc = kzalloc(sizeof(struct vc_data), GFP_NOWAIT);&lt;br /&gt;
            INIT_WORK(&amp;amp;vc_cons[currcons].SAK_work, vc_SAK);&lt;br /&gt;
            //初始化vc_cons[currcons].d&lt;br /&gt;
            tty_port_init(&amp;amp;vc-&amp;gt;port);&lt;br /&gt;
            // 继续初始化, 主要是确定screenbuf size&lt;br /&gt;
            visual_init(vc, currcons, 1);&lt;br /&gt;
            // 给vc_screenbuf分配内存&lt;br /&gt;
            vc-&amp;gt;vc_screenbuf = kzalloc(vc-&amp;gt;vc_screenbuf_size, GFP_NOWAIT);&lt;br /&gt;
            vc_init(vc, vc-&amp;gt;vc_rows, vc-&amp;gt;vc_cols,&lt;br /&gt;
                currcons || !vc-&amp;gt;vc_sw-&amp;gt;con_save_screen);&lt;br /&gt;
        }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    [    0.000000] Console: colour VGA+ 80x25
    register_console(&amp;amp;vt_console_driver);//vt_console can use vgacon writing.
}
serial8250_console_init-&amp;gt;register_console(&amp;amp;serial8250_console) to console_drivers; exclusive_console.
[    0.000000] console [tty0] enabled
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
module_init(serial8250_init);??&lt;br /&gt;
}&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;fbcon&lt;br /&gt;
register_framebuffer-&amp;gt; do_take_over_console -&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
do_register_con_driver-&amp;gt;csw-&amp;gt;con_startup();registered_con_driver&lt;br /&gt;
do_bind_con_driver -&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    [    3.882220] Console: switching to colour dummy device 80x25&lt;br /&gt;
    [    4.720732] Console: switching to colour frame buffer device 170x48&lt;br /&gt;
}&lt;br /&gt;
}&lt;/p&gt;

&lt;h2 id=&#34;vga-text-console-printk-write&#34;&gt;VGA text console printk &amp;amp; write&lt;/h2&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;kernel space&lt;br /&gt;
printk-&amp;gt; &amp;hellip;-&amp;gt;log_buf&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;userspace for ttyN&lt;br /&gt;
tty_fops-&amp;gt;write=tty_write-&amp;gt; tty_ldisc_N_TTY-&amp;gt;write=n_tty_write-&amp;gt; tty_driver-&amp;gt;ops=con_ops-&amp;gt;write=con_write-&amp;gt;do_con_write&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;agent&lt;br /&gt;
console_drivers-&amp;gt;vt_console_driver-&amp;gt;serial8250_console-&amp;gt;NULL&lt;br /&gt;
console_unlock-&amp;gt;..-&amp;gt;__call_console_drivers-&amp;gt; console_drivers-&amp;gt;write = vt_console_print&lt;br /&gt;
{&lt;br /&gt;
//保存到screen buf, vga_con也什么不做啊.&lt;br /&gt;
scr_writew((vc-&amp;gt;vc_attr &amp;lt;&amp;lt; 8) + c, (unsigned short *)vc-&amp;gt;vc_pos);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;h1 id=&#34;what-about-tty&#34;&gt;What about tty&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;onset&lt;br /&gt;
console_init-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
tty_ldisc_begin-&amp;gt;tty_register_ldisc(N_TTY, &amp;amp;tty_ldisc_N_TTY);&lt;br /&gt;
console_initcall(con_init);&lt;br /&gt;
console_initcall(serial8250_console_init)&lt;br /&gt;
}&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;N_TTY:&lt;a href=&#34;http://www.linux.it/~rubini/docs/serial/serial.html&#34;&gt;Serial Drivers by Alessandro Rubini&lt;/a&gt;&lt;br /&gt;
fs_initcall:chr_dev_init-&amp;gt;drivers/tty/tty_io.c: tty_init-&amp;gt;&lt;br /&gt;
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* /dev/tty0 = /dev/console console_ops */
/* /dev/tty = the /dev/ttyN whererun echo /dev/tty tty_ops */

//&amp;quot;/dev/tty&amp;quot;,
cdev_init(&amp;amp;tty_cdev, &amp;amp;tty_fops);
&amp;quot;/dev/console&amp;quot;
cdev_init(&amp;amp;console_cdev, &amp;amp;console_fops);
vty_init-&amp;gt;
{
    //&amp;quot;dev/tty0&amp;quot;    
    cdev_init(&amp;amp;vc0_cdev, console_fops); 
    //&amp;quot;/dev/ttyN&amp;quot;
    tty_register_driver-&amp;gt;
    {
        // What does tty_register_driver do ?
        // Alloc and register chr dev region.
        // Add cdev with tty_ops and above region.
        // Register tty device
        // Why do we register tty devices?
        // These devices must be used in some place.
        // After registering itself, the driver registers the devices it controls through the tty_register_device function. 
        // 原来是把major 和minor做成dev_t放到driver-&amp;gt;cdevs[index].dev里面了.
        // 也就是说driver-&amp;gt;cdevs[index]就是tty driver控制的device啊, 怪不得cdev_init(&amp;amp;driver-&amp;gt;cdevs[index], &amp;amp;tty_fops);
        // 那么看来用到的时候就是open了, 竟然没有不过有个tty_get_device用了tty_class
        // tty_register_device_attr-&amp;gt;device_register-&amp;gt;device_add-&amp;gt;klist_add_tail(&amp;amp;dev-&amp;gt;knode_class,&amp;amp;dev-&amp;gt;class-&amp;gt;p-&amp;gt;klist_devices)
        // 果然是在open tty-&amp;gt;dev = tty_get_device(tty);在alloc_tty_struct
        // 不知道这个tty-&amp;gt;dev在哪里用, 不管他了.
        tty_register_device(_attr) -&amp;gt;tty_cdev_add-&amp;gt; cdev_init(&amp;amp;driver-&amp;gt;cdevs[index], &amp;amp;tty_fops);
    }
    kbd_init
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
device_init:serial8250_init-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    // In this function we decide &amp;ldquo;/dev/ttyS*&amp;rdquo;&lt;br /&gt;
    // dmesg |grep Serial&lt;br /&gt;
    // [    0.696341] Serial: &lt;sup&gt;8250&lt;/sup&gt;&amp;frasl;&lt;sub&gt;16550&lt;/sub&gt; driver, 32 ports, IRQ sharing enabled&lt;br /&gt;
    // serial8250.c -&amp;gt; tty_io.c&lt;br /&gt;
    serial8250_reg.nr = UART_NR;&lt;br /&gt;
    ret = uart_register_driver(&amp;amp;serial8250_reg);&lt;br /&gt;
    tty_driver set to uart_driver by uart_register_driver -&amp;gt;&lt;br /&gt;
    {&lt;br /&gt;
        drv-&amp;gt;state = kzalloc        //uart_state&lt;br /&gt;
        normal-&amp;gt;driver_state    = drv; //args struct uart_driver *drv = &amp;amp;serial8250_reg&lt;br /&gt;
        tty_set_operations(normal, &amp;amp;uart_ops);&lt;br /&gt;
        struct tty_port &lt;em&gt;port = &amp;amp;state-&amp;gt;port&lt;br /&gt;
        tty_port_init(port);&lt;br /&gt;
        port-&amp;gt;ops = &amp;amp;uart_port_ops; //tty_port&lt;br /&gt;
        // We register &amp;ldquo;/dev/ttyS&lt;/em&gt;&amp;rdquo; files here.&lt;br /&gt;
        static struct uart_driver serial8250_reg = {&lt;br /&gt;
            .owner                  = THIS_MODULE,&lt;br /&gt;
            .driver_name            = &amp;ldquo;serial&amp;rdquo;,&lt;br /&gt;
            .dev_name               = &amp;ldquo;ttyS&amp;rdquo;,&lt;br /&gt;
            .major                  = TTY_MAJOR,&lt;br /&gt;
            .minor                  = 64,&lt;br /&gt;
            .cons                   = SERIAL8250_CONSOLE,&lt;br /&gt;
        };&lt;br /&gt;
        retval = tty_register_driver(normal); -&amp;gt; register_chrdev_region(dev, driver-&amp;gt;num, driver-&amp;gt;name) //32, ttyS?*? should be tty_ops&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;}
serial8250_register_ports(&amp;amp;serial8250_reg, &amp;amp;serial8250_isa_devs-&amp;gt;dev);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
* nucleus&lt;br /&gt;
tty_write-&amp;gt;ld-&amp;gt;ops-&amp;gt;write=n_tty_write-&amp;gt;(tty_struct tty-&amp;gt;ops-&amp;gt;write)=uart_write-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    struct uart_state *state = tty-&amp;gt;driver_data;&lt;br /&gt;
    port = state-&amp;gt;uart_port;&lt;br /&gt;
    circ = &amp;amp;state-&amp;gt;xmit;&lt;br /&gt;
    memcpy(circ-&amp;gt;buf + circ-&amp;gt;head, buf, c);&lt;br /&gt;
    uart_start-&amp;gt;__uart_start-&amp;gt;(uart_port-&amp;gt;ops-&amp;gt;start_tx(port)); //&amp;amp;uart_port_ops ?? uart_ops??&lt;br /&gt;
}&lt;/p&gt;

&lt;h1 id=&#34;what-about-pseudoterminal&#34;&gt;What about Pseudoterminal&lt;/h1&gt;

&lt;p&gt;/dev/ptmx is the &amp;ldquo;pseudo-terminal master multiplexer&amp;rdquo;. from wikipedia&lt;br /&gt;
static struct tty_driver *ptm_driver;&lt;br /&gt;
static struct tty_driver *pts_driver;&lt;br /&gt;
module_init(pty_init)-&amp;gt;unix98_pty_init-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    tty_set_operations(ptm_driver, &amp;amp;ptm_unix98_ops);&lt;br /&gt;
    tty_register_driver(ptm_driver)&lt;br /&gt;
    tty_set_operations(pts_driver, &amp;amp;pty_unix98_ops);&lt;br /&gt;
    tty_register_driver(pts_driver)&lt;br /&gt;
    ptmx_fops = tty_fops;&lt;br /&gt;
    ptmx_fops.open = ptmx_open;&lt;br /&gt;
    cdev_init(&amp;amp;ptmx_cdev, &amp;amp;ptmx_fops);&lt;br /&gt;
}&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;How to use ptmx?&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;tty-drivers&#34;&gt;tty drivers&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;cat /proc/tty/drivers&lt;br /&gt;
/dev/tty             /dev/tty        5       0 system:/dev/tty&lt;br /&gt;
/dev/console         /dev/console    5       1 system:console&lt;br /&gt;
/dev/ptmx            /dev/ptmx       5       2 system&lt;br /&gt;
/dev/vc/0            /dev/vc/0       4       0 system:vtmaster&lt;br /&gt;
usbserial            /dev/ttyUSB   188 0-511 serial&lt;br /&gt;
serial               /dev/ttyS       4 64-95 serial&lt;br /&gt;
pty_slave            /dev/pts      136 0-1048575 pty:slave&lt;br /&gt;
pty_master           /dev/ptm      128 0-1048575 pty:master&lt;br /&gt;
unknown              /dev/tty        4 1-63 console&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;question&#34;&gt;Question?&lt;/h1&gt;

&lt;p&gt;what is /dev/vcs?&lt;/p&gt;

&lt;h1 id=&#34;backup&#34;&gt;Backup&lt;/h1&gt;

&lt;p&gt;./drivers//tty/vt/vt.c:3042:        register_chrdev_region(MKDEV(TTY_MAJOR, 0), 1, &amp;ldquo;/dev/vc/0&amp;rdquo;) &amp;lt; 0)&lt;br /&gt;
./drivers//tty/vt/vc_screen.c:644:  if (register_chrdev(VCS_MAJOR, &amp;ldquo;vcs&amp;rdquo;, &amp;amp;vcs_fops))&lt;br /&gt;
./drivers//tty/tty_io.c:3377:       error = register_chrdev_region(dev, driver-&amp;gt;num, driver-&amp;gt;name);&lt;br /&gt;
./drivers//tty/tty_io.c:3414:   unregister_chrdev_region(dev, driver-&amp;gt;num);&lt;br /&gt;
./drivers//tty/tty_io.c:3430:   unregister_chrdev_region(MKDEV(driver-&amp;gt;major, driver-&amp;gt;minor_start),&lt;br /&gt;
./drivers//tty/tty_io.c:3607:       register_chrdev_region(MKDEV(TTYAUX_MAJOR, 0), 1, &amp;ldquo;/dev/tty&amp;rdquo;) &amp;lt; 0)&lt;br /&gt;
./drivers//tty/tty_io.c:3613:       register_chrdev_region(MKDEV(TTYAUX_MAJOR, 1), 1, &amp;ldquo;/dev/console&amp;rdquo;) &amp;lt; 0)&lt;br /&gt;
./drivers//tty/pty.c:841:       register_chrdev_region(MKDEV(TTYAUX_MAJOR, 2), 1, &amp;ldquo;/dev/ptmx&amp;rdquo;) &amp;lt; 0)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>System booting</title>
      <link>http://firoyang.org/cs/boot/</link>
      <pubDate>Thu, 12 Nov 2015 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/boot/</guid>
      <description>

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;h1 id=&#34;contents&#34;&gt;Contents&lt;/h1&gt;

&lt;p&gt;What basic initializations should be perfomed when power on?&lt;br /&gt;
How do we load the kernel to memory?&lt;br /&gt;
What does kernel do when kernel boot.&lt;br /&gt;
MBR vs BIOS?&lt;br /&gt;
PC vs embedded&lt;br /&gt;
Kernel init&lt;br /&gt;
before start_kernel&lt;br /&gt;
start_kernel&lt;br /&gt;
reset_init &amp;amp; kernel_init&lt;/p&gt;

&lt;h1 id=&#34;p4080-board&#34;&gt;p4080 Board&lt;/h1&gt;

&lt;p&gt;PBL&lt;br /&gt;
1. initialize I2C, SPI, eLBC, eSDHC.&lt;br /&gt;
2. Load RCW and boot init commands from above.&lt;br /&gt;
3. write date to conf register and memory&lt;/p&gt;

&lt;h1 id=&#34;config&#34;&gt;config&lt;/h1&gt;

&lt;p&gt;CCSRBAR -&amp;gt; CCSR&lt;br /&gt;
default is 0x0_FE00_0000&lt;br /&gt;
CCSRBAR is in CCSR memory. odd. stored in 0(CCSRBAR).&lt;br /&gt;
CCSRBAR always points to itself.&lt;br /&gt;
holdoff&lt;/p&gt;

&lt;h1 id=&#34;u-boot&#34;&gt;u-boot&lt;/h1&gt;

&lt;p&gt;ft_fixup_cpu -&amp;gt; determine_mp_bootpg(NULL) &amp;amp; fdt_add_mem_rsv&lt;/p&gt;

&lt;p&gt;main_loop-&amp;gt; &amp;hellip;-&amp;gt;./common/bootm_os.c:410:&amp;hellip; do_bootm_states-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
bootm_find_other-&amp;gt;bootm_find_ramdisk_fdt-&amp;gt;bootm_find_fdt-&amp;gt;boot_get_fdt&amp;amp;set_working_fdt_addr(0x0200000)-&amp;gt;IMAGE_FORMAT_FIT-&amp;gt;&lt;br /&gt;
&amp;amp;&lt;br /&gt;
boot_fn = bootm_os_get_boot_func(images-&amp;gt;os.os)=[IH_OS_LINUX] =&lt;br /&gt;
&amp;amp;&lt;br /&gt;
boot_selected_os-&amp;gt;boot_fn=do_bootm_linux-&amp;gt;boot_body_linux-&amp;gt;image_setup_linux-&amp;gt;image_setup_libfdt-&amp;gt;&lt;br /&gt;
board/freescale/corenet_ds/corenet_ds.c ft_board_setup-&amp;gt; ft_cpu_setup-&amp;gt;&lt;br /&gt;
}&lt;/p&gt;

&lt;h1 id=&#34;ppc-multicore-booting&#34;&gt;PPC multicore booting&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;There are two possibilites to make secondary cores booting failed.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;There is a bug in the code executed by Secondary cores&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;The spin table address, passed to croe0, is not correct, so we did not really kick the secondary cores.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CCSRBAR&lt;br /&gt;
MPC86xx_MCM_OFFSET&lt;br /&gt;
srio_boot_master_release_slave&lt;/p&gt;

&lt;p&gt;uboot-&amp;gt;&lt;br /&gt;
set the cpu-release-addr at funciton ft_fixup_cpu(), I am not sure.&lt;/p&gt;

&lt;p&gt;core0 run, 2nd cores holdoff&lt;br /&gt;
core0 set BPTR and kick(BRR) 2nd cores, 2nd cores spintable loop in uboot function setup_mp&lt;br /&gt;
core0 -&amp;gt; arch/powerpc/cpu/mpc85xx/start.S-&amp;gt;_start_e500&lt;br /&gt;
board_init_r-&amp;gt;cpu_init_r-&amp;gt; setup_mp-&amp;gt; {&lt;br /&gt;
&lt;strong&gt;bootpg_addr = (u32)virt_to_phys(&amp;amp;&lt;/strong&gt;second_half_boot_page); //Assembly code for put core to spin tablea. Used by __secondary_start_page&lt;br /&gt;
__spin_table_addr = (u32)get_spin_phys_addr();// used by __second_half_boot_page&lt;br /&gt;
bootpg = BPTR = __secondary_start_page&lt;br /&gt;
plat_mp_up-&amp;gt;kick BRR &amp;amp; Boot Space Translation&lt;br /&gt;
}&lt;br /&gt;
2nd cores holdoff -&amp;gt; &lt;strong&gt;secondary_start_page&lt;br /&gt;
kernel-&amp;gt;&lt;br /&gt;
core0 boot kernel, core0 kickoff 2nd cores spintable, triger 2nd core&amp;rsquo;s spin table by writing  the spin table field with the desired address&lt;br /&gt;
2nd cores ePAPR-&amp;gt;spintable-&amp;gt;addr_l=&lt;/strong&gt;early_start-&amp;gt;__secondary_start-&amp;gt;smp_ops-&amp;gt;setup_cpu-&amp;gt;cpu_idle&lt;br /&gt;
arch/powerpc/kernel/head_fsl_booke.S&lt;br /&gt;
U-boot logs:&lt;br /&gt;
Reserving MP boot page to 7ffff000^M^M - &amp;ndash;   -   MP spin table&lt;br /&gt;
address.&lt;br /&gt;
SPAG : fdt_fixup_fman_firmware, 567^M^M&lt;br /&gt;
^M^M&lt;br /&gt;
..r.^M^M&lt;br /&gt;
VDBG : ft_cpu_setup, 737, comment fdt_fixup_memory ^M^M&lt;br /&gt;
VDBG: Secondary cores are not held in reset.^M^M&lt;br /&gt;
Kernel Logs:&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 1 to ack^M^M&lt;br /&gt;
smp: failed starting cpu 1 (rc -2)^M^M&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 2 to ack^M^M&lt;br /&gt;
smp: failed starting cpu 2 (rc -2)^M^M&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 3 to ack^M^M&lt;br /&gt;
smp: failed starting cpu 3 (rc -2)^M^M&lt;br /&gt;
Brought up 1 CPUs^M^M&lt;br /&gt;
devtmpfs: initialized^M^M&lt;/p&gt;

&lt;p&gt;Note that u-boot can&amp;rsquo;t detect  memory above 2G and we need to check&lt;br /&gt;
if kernel is accessing at high mem of 2G or 4G.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Light camera action - compile link load</title>
      <link>http://firoyang.org/cs/cll/</link>
      <pubDate>Sun, 25 Oct 2015 01:46:28 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/cll/</guid>
      <description>

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.tenouk.com/ModuleW.html&#34;&gt;compiler, assembler, linker and loader: a brief story&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://a3f.at/lists/linkers&#34;&gt;Linkers 20 parts by Gold author Ian Lance Taylor&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://rickgray.me/2015/08/07/use-gdb-to-study-got-and-plt.html&#34;&gt;通过 GDB 调试理解 GOT/PLT&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html&#34;&gt;PLT and GOT - the key to code sharing and dynamic libraries&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;elf&#34;&gt;ELF&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.sco.com/developers/gabi/latest/contents.html&#34;&gt;System V Application Binary Interface ELF&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://www.sco.com/developers/devspecs/&#34;&gt;SCO Developer Specifications&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;function-call&#34;&gt;Function call&lt;/h1&gt;

&lt;p&gt;x86: stack and caller but kernel maybe regpara(3)&lt;/p&gt;

&lt;p&gt;create_elf_tables&lt;br /&gt;
sysdeps/x86_64/dl-machine.h: -&amp;gt; _start -&amp;gt;_dl_start-&amp;gt;/elf/dl-sysdep.c:83:_dl_sysdep_start-&amp;gt;dl_main&lt;br /&gt;
Relocation&lt;br /&gt;
PIC&lt;/p&gt;

&lt;h1 id=&#34;contents&#34;&gt;Contents&lt;/h1&gt;

&lt;p&gt;Why complier can manipulate the address of vriables?&lt;br /&gt;
What is the address in lds(??) file?&lt;/p&gt;

&lt;h2 id=&#34;kbuild&#34;&gt;kbuild&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;if no .config, every config tools make a .config from scrach!&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;oldconfig just for new moduels patch merged in trunk. This no any relations to .config.old and /boot/config.x.y.z&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;make localmodconfig will reduce many unused kernel config.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;make bzImage  #kmods will not build that configured with M!&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;make modules_install INSTALL_MOD_PATH=/home/firo/kmods&lt;br /&gt;
##build signle kernel module&lt;br /&gt;
make menuconfig&lt;br /&gt;
make oldconfig &amp;amp;&amp;amp; make prepare&lt;br /&gt;
make -C $(pwd) M=/home/firo/linux/fs/ext3 modules V=1&lt;br /&gt;
make ARCH=arm CROSS_COMPILE=/usr/bin/arm-linux-gnu- drivers/pcmcia/sa11xx_base.o&lt;/p&gt;

&lt;h1 id=&#34;compile-construction&#34;&gt;Compile construction&lt;/h1&gt;

&lt;p&gt;##&lt;a href=&#34;http://www.stlinux.com/devel/debug/jtag/build?q=node/82&#34;&gt;Generating optimized code&lt;/a&gt;&lt;br /&gt;
##Symbol table&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;System.map less&lt;br /&gt;
When you compile the kernel&lt;br /&gt;
nm vmlinux&lt;br /&gt;
readelf -s&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;/proc/kallsyms&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>My reading list of computer science</title>
      <link>http://firoyang.org/review/reading_list/</link>
      <pubDate>Wed, 14 Oct 2015 14:09:57 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/review/reading_list/</guid>
      <description>

&lt;p&gt;I think you should check my The Organization of Knowledgs&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Programming:&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&#34;http://sarabander.github.io/sicp/&#34;&gt;SICP&lt;/a&gt;&lt;br /&gt;
The science of programming&lt;/p&gt;

&lt;h1 id=&#34;computer-science&#34;&gt;Computer science&lt;/h1&gt;

&lt;p&gt;Code: The hidden language of computer hardware and software&lt;br /&gt;
Digital Design and Computer Architecture 2nd Edition&lt;/p&gt;

&lt;p&gt;未看口碑好:&lt;br /&gt;
Computer Organization and Design, Fifth Edition&lt;br /&gt;
ARM System-on-Chip Architecture (2nd Edition)&lt;/p&gt;

&lt;h1 id=&#34;philosophy&#34;&gt;Philosophy&lt;/h1&gt;

&lt;p&gt;普通认识论 &amp;ndash; Moritz Schlick&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Computer architecture</title>
      <link>http://firoyang.org/cs/arch/</link>
      <pubDate>Tue, 13 Oct 2015 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/arch/</guid>
      <description>

&lt;p&gt;##Reference&lt;br /&gt;
&lt;a href=&#34;https://youtu.be/cNN_tTXABUA&#34;&gt;How a CPU Works&lt;/a&gt;&lt;br /&gt;
Legacy 常用寄存器，常见指令 实模式和保护模式 分段和分页机制 TSS和任务管理 中断机制 时钟机制 高速缓存&lt;br /&gt;
《模拟电子技术基础 童诗白 第四版》第一章前半部分&lt;br /&gt;
Structured Computer Organization 6th Edition&lt;br /&gt;
Digital Design and Computer Architecture 2nd Edition&lt;br /&gt;
Computer Organization and Design 5th Edition&lt;br /&gt;
Write Great Code: Volume 1: Understanding the Machine&lt;br /&gt;
See MIPS run&lt;br /&gt;
Intel 64 and IA-32 architectures software developers manual combined volumes 3A, 3B, and 3C: System programming guide&lt;br /&gt;
Microelectronics&lt;/p&gt;

&lt;h2 id=&#34;isa&#34;&gt;ISA&lt;/h2&gt;

&lt;p&gt;model: 1570s, &amp;ldquo;likeness made to scale; architect&amp;rsquo;s set of designs,&amp;rdquo; from Middle French modelle&lt;br /&gt;
Semantics in computer science: In programming language theory, semantics is the field concerned&lt;br /&gt;
with the rigorous mathematical study of the meaning of programming languages.&lt;br /&gt;
Language primitive&lt;br /&gt;
ISA: memory model, registers, data types, instructions, word size(?).&lt;br /&gt;
Memory model: unit of address resolution, word, aligment, address space, addressing mode, memory barrier/memory order primitive&amp;rsquo;s semantics.&lt;br /&gt;
#x86 Interrupt&lt;br /&gt;
If interrupt occured in user mode, then cpu will context swith for potential reschedule.&lt;br /&gt;
The Interrupt Descriptor Table (IDT) is a data structure used by the x86 architecture to implement an interrupt vector table.&lt;br /&gt;
##Hardware interrupts&lt;br /&gt;
are used by devices to communicate that they require attention from the operating system.&lt;br /&gt;
asynchronus&lt;br /&gt;
more details in init_IRQ() or set_irq() in driver.&lt;br /&gt;
##software interrupt&lt;br /&gt;
synchronus&lt;br /&gt;
more details in trap_init().&lt;br /&gt;
* exception or trap&lt;br /&gt;
is caused either by an exceptional condition in the processor itself,&lt;br /&gt;
divide zero painc?&lt;br /&gt;
* special instruction, for example INT 0x80&lt;br /&gt;
or a special instruction in the instruction set which causes an interrupt when it is executed.&lt;/p&gt;

&lt;h1 id=&#34;i-o-ic&#34;&gt;I/O IC&lt;/h1&gt;

&lt;p&gt;serial communication: UART(16550) + RS-232&lt;br /&gt;
parallel communication: SCSI, ISA, ATA, PCI, FSB&lt;/p&gt;

&lt;h1 id=&#34;data-struct-aligment&#34;&gt;Data struct aligment&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.catb.org/esr/structure-packing/&#34;&gt;The Lost Art of C Structure Packing&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://en.wikipedia.org/wiki/Data_structure_alignment#Typical_alignment_of_C_structs_on_x86&#34;&gt;Typical alignment of C structs on x86&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;为什么需要结构体对齐&#34;&gt;为什么需要结构体对齐?&lt;/h2&gt;

&lt;p&gt;struct foo {&lt;br /&gt;
char c;&lt;br /&gt;
int i;};&lt;br /&gt;
如果是32位, cpu 一次取4byte a word 数据.&lt;br /&gt;
如果我们把i的前3byte和c存到一起, 剩下1byte of i自己单独存.&lt;br /&gt;
那么我们访问i这个数据就要读两个4byte a word. 对cpu来说性能损耗.&lt;br /&gt;
如果我们把i单独放到4byte 对齐的地址, 那么我们只需要一次cpu读取.fast!&lt;/p&gt;

&lt;h2 id=&#34;产生非对齐访问的场景&#34;&gt;产生非对齐访问的场景&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Casting variables to types of different lengths, 比如char * 到int *&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Pointer arithmetic followed by access to at least 2 bytes of data , 不太理解.&lt;/p&gt;

&lt;h2 id=&#34;我们做什么&#34;&gt;我们做什么?&lt;/h2&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;什么也不干, 按默认对齐来Natural alignment&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为了不影响性能, 同时减少内存使用, 编程时最好显示reorder.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;get/put_unaligned  to avoid analigned access.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通过attribute aligned指定对齐要求.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;数据要在不同体系, 32/64之间使用, 比如网络,写到disk, 我们必须要attribute packed&lt;br /&gt;
也就是说不对齐, 不同平台对齐可能不同, 我们不能让数据corruption.&lt;/p&gt;

&lt;h2 id=&#34;如果数据不对齐有什么-cpu怎么办&#34;&gt;如果数据不对齐有什么, cpu怎么办?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kernel.org/doc/Documentation/unaligned-memory-access.txt&#34;&gt;必读UNALIGNED MEMORY ACCESSES&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果用了packed, 编译器会生成extra代码阻止非对齐访问, performance loss.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cpu呢? 可能正确处理raise a exception to fix it with performance loss.&lt;/p&gt;

&lt;h2 id=&#34;calculate-the-sizeof-of-aligned-c-struct&#34;&gt;Calculate the sizeof of aligned c struct&lt;/h2&gt;

&lt;p&gt;Data alignment means putting the data at a memory address equal to some multiple of the word size,&lt;br /&gt;
which increases the system&amp;rsquo;s performance due to the way the CPU handles memory.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;find the widest scalar member and attribute( aligned(x)) to determin alignment.&lt;br /&gt;
找到结构体内scalar和attribute最大的对齐要求.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;fill the member to alignement without wrap&lt;br /&gt;
把结构的成员一次填满对齐宽度, 不够的填到下个对齐宽度, 空出来留着padding&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Pading to alignment&lt;br /&gt;
填上所有空.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;endianess&#34;&gt;Endianess&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.yolinux.com/TUTORIALS/Endian-Byte-Order.html&#34;&gt;Endianness: Big and Little Endian Byte Order&lt;/a&gt;&lt;br /&gt;
应该说bit endianess 实际存储只有MSB &amp;hellip; LSB这一种二进制表达形式! 在上面的文章的representtion, 辅证这一点.&lt;br /&gt;
这篇文章&lt;a href=&#34;http://tonybai.com/2013/05/21/talk-about-bitfield-in-c-again/&#34;&gt;再谈C语言位域&lt;/a&gt;,&lt;br /&gt;
之所以输出逆序, 是因为错误里理解了, bit 序. bit 序是cpu 读取的方式, 不是存储的方式!&lt;br /&gt;
* &lt;a href=&#34;https://en.wikipedia.org/wiki/Bit_numbering&#34;&gt;bit endianness&lt;/a&gt;&lt;br /&gt;
这样就可以更好的理解iphdr:&lt;br /&gt;
#if defined(__LITTLE_ENDIAN_BITFIELD)&lt;br /&gt;
    &lt;strong&gt;u8    ihl:4,&lt;br /&gt;
        version:4;&lt;br /&gt;
#elif defined (&lt;/strong&gt;BIG_ENDIAN_BITFIELD)&lt;br /&gt;
    __u8    version:4,&lt;br /&gt;
        ihl:4;&lt;br /&gt;
#else&lt;br /&gt;
#error  &amp;ldquo;Please fix &lt;asm/byteorder.h&gt;&amp;ldquo;&lt;br /&gt;
#endif&lt;br /&gt;
ipv4 header的拓扑&lt;br /&gt;
version ihl&lt;br /&gt;
0100 0101&lt;br /&gt;
因为le的cpu是 lsb first, 也就是从最左面的1开始读, 所以第一个是ihl&lt;br /&gt;
而be的cpu是 msb first, 从最右开始所以version开头.&lt;br /&gt;
而使用unsigned char ver_ihl&lt;br /&gt;
(ver_ihl &amp;amp; 0xf0)&amp;gt;&amp;gt; 4 = version&lt;br /&gt;
ver_ihl &amp;amp; 0x0f = ihl&lt;br /&gt;
是无关cpu读取顺序的.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux time subsystem</title>
      <link>http://firoyang.org/cs/time/</link>
      <pubDate>Tue, 22 Sep 2015 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/time/</guid>
      <description>

&lt;p&gt;我写作的主要目的是理清基本概念与原理, 而非实现,细节这一类.&lt;/p&gt;

&lt;p&gt;时间是人类发明出来的概念, Kant也认为时间是心智概念.&lt;br /&gt;
一百年前的世界和现在有什么不同呢?这个提问揭示生活中时间最重要的用途,&lt;br /&gt;
*标记*某中状态下的世界. 所谓的过去世界不过是世界的一个个连续状态&lt;br /&gt;
那么时空穿越, 就变成了保住项少龙这个肉身不变, 世界的其他部分完全&lt;br /&gt;
转变到过去的某一个状态. 而所谓现在世界就被抹杀了.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The future is already here – it&#39;s just not evenly distributed.
                        — William Gibson
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;人想回到&amp;rdquo;过去&amp;rdquo;多半源于情感因素, 而想去&amp;rdquo;未来&amp;rdquo;则是因为&amp;rdquo;物质&amp;rdquo;的缘故.&lt;br /&gt;
想象下中国的未来50年, 很可能是现在美国or西欧现在的样子.虽然中西虽然处在&lt;br /&gt;
时间概念上相同的现在, 而物质世界确实&amp;rdquo;过去&amp;rdquo;和&amp;rdquo;未来&amp;rdquo;之差.&lt;/p&gt;

&lt;p&gt;比如我们下周而要开会, 那么此时下周二就是有意识的规划未来, 时间依然是标记.&lt;br /&gt;
UTC/GMT&lt;br /&gt;
Based on caesium microwave atomic clock&lt;br /&gt;
Leap second&lt;/p&gt;

&lt;h2 id=&#34;genus-differentia-definition&#34;&gt;Genus-differentia definition&lt;/h2&gt;

&lt;p&gt;interrupt, clock event,  clock source, tick, timer, timekeeping, gettimeofday.&lt;/p&gt;

&lt;h2 id=&#34;功用定义&#34;&gt;功用定义&lt;/h2&gt;

&lt;p&gt;获取时间&lt;br /&gt;
timer&lt;br /&gt;
sleep ?&lt;br /&gt;
update sched info&lt;/p&gt;

&lt;h2 id=&#34;发生定义-设计-etymology-history-operational-definition&#34;&gt;发生定义/设计   etymology, history Operational definition&lt;/h2&gt;

&lt;p&gt;timekeeping/计时:时刻．&lt;br /&gt;
clock source: 时间之源, 表针之力.&lt;br /&gt;
clock event: 闹铃之力, 经过tick展现能力.&lt;br /&gt;
tick: timer的中断事件叫tick, tick device产生tick, 可以说tick决定了clock_event event_handler进而决定了, clock_event行为.&lt;br /&gt;
tickless:&lt;br /&gt;
for timer: use HW timer one shot, set next.&lt;br /&gt;
for update time: in above HW timer, not good&lt;br /&gt;
for sched: for priority distributed in time slice, use timer.&lt;br /&gt;
dynamic tick/no HZ:&lt;br /&gt;
No HZ in idle&lt;br /&gt;
No HZ while only 1 process running for HPC.&lt;br /&gt;
tick devies 就是clock event包了层虎皮.&lt;br /&gt;
tick broadcast framework:  based on tick device&lt;br /&gt;
clock: 可记录时间, 表盘.利用timekeeping&lt;br /&gt;
timer: use clock. what about timer_list?&lt;br /&gt;
timer_list: do in softirq&lt;br /&gt;
* timekeeping aspect&lt;br /&gt;
onset: start_kernel -&amp;gt; timekeeping_init &amp;amp; time_init &amp;amp;(rest_init-&amp;gt; kernel_init-&amp;gt; &lt;br /&gt;
kernel_init_freeable-&amp;gt;do_basic_setup-&amp;gt;do_initcalls&amp;ndash;device_initcall(init_clocksource_sysfs))&lt;br /&gt;
nucleus:used by clock see init_posix_timers and update_wall_time and sys_time&lt;br /&gt;
coda:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;clock source aspect&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;tick device layer aspect&lt;br /&gt;
per_cpu(tick_cpu_device, cpu)&lt;br /&gt;
onset: time_init-&amp;gt;mach-&amp;gt;init_time-&amp;gt;&amp;hellip;clockevents_register_device-&amp;gt;tick_check_new_device&lt;br /&gt;
nucleus: a38x_timer_interrupt-&amp;gt;a38x_clkevt.event_handler&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;tick broadcast framework&lt;br /&gt;
onset:&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;clock aspect&lt;br /&gt;
k_clock&lt;br /&gt;
onset:init_posix_timers &amp;amp; init_posix_cpu_timers&lt;br /&gt;
nucleus: 用户-&amp;gt; posix_clock-&amp;gt;timepkeeping-&amp;gt;clock_socurce&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;timer aspect&lt;br /&gt;
onset: open_softirq(HRTIMER_SOFTIRQ, run_hrtimer_softirq);&lt;br /&gt;
nucleus: common_timer_set&lt;br /&gt;
hrtimer_interrupt | (tick_handle_periodic-&amp;gt; tick_periodic-&amp;gt; update_process_times-&amp;gt;run_local_timers-&amp;gt;hrtimer_run_queues)-&amp;gt;__run_hrtimer-&amp;gt;timer.function = posix_timer_fn;(set in common_timer_set)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;计算机概念&lt;br /&gt;
system clock CLOCK_REALTIME CLOCK_MONOTONIC&lt;br /&gt;
time.h time_t=tm=timeval=timespec calendar time  clock_t&lt;/p&gt;

&lt;p&gt;clock event -&amp;gt; tick device-&amp;gt; handle function&lt;br /&gt;
clock event 相较于timer更为抽象, timer 是一种用途,timer 通过clock event来实现功能,&lt;br /&gt;
clock event 通过timer来体现自己, timer面向使用者的onset,&lt;br /&gt;
而clock event 则是偏向于nucleus and coda.&lt;br /&gt;
timer: 标记不能立即执行的变化.&lt;br /&gt;
clock source: 用一些整型抽象一个过程, 对于时间来说, 简直是完美的抽象.&lt;br /&gt;
* kernel requirement&lt;br /&gt;
linux的时间子系统要求硬件timer提供下面两种能力：&lt;br /&gt;
一是free running的counter，此外需要能够在指定的counter值上产生中断的能力。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Quantitative congnition - The philosophy on which I live</title>
      <link>http://firoyang.org/philosophy/philosophy/</link>
      <pubDate>Sun, 13 Sep 2015 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/philosophy/philosophy/</guid>
      <description>

&lt;p&gt;我正在常识建立一套量化认知体系. 为什么要做这件事? 无论是之于生命个体还是整个人类社会的演化总是依凭着对世界更深入,&lt;br /&gt;
更全面的认知. ? 正如Schlick 在General Theory of Knowledge 所言&amp;hellip; 而这种认知本身是什么呢? 在哲学上,&lt;br /&gt;
Epistemology专门研究这个问题. 而我继续前人的工作.&lt;br /&gt;
在过往的不断尝试中, 我体验与感悟到了, 这个世界很复杂, 不能有一些简单的规则来理解透.&lt;br /&gt;
多种不同的角度, 往往是理解事物最合宜的方法.&lt;/p&gt;

&lt;h1 id=&#34;framework-architecture-oracle-machine-万物皆备于我&#34;&gt;Framework architecture: oracle-machine, 万物皆备于我&lt;/h1&gt;

&lt;p&gt;Sentific method&lt;br /&gt;
oracle: book, website, papper.&lt;br /&gt;
学习知识的重点, 不是知识现在是什么样, 也不是知识为什么这么样, 而是要是, 如果是你的话会是什么样的!&lt;br /&gt;
如果是我, 去创造回事什么样? 推倒现有的存在, 自己去创造.并且所有知识体系都建立在这个根基之上.&lt;br /&gt;
比如说计算机的知识,语法的知识,如果我造一个语法会是什么样呢?很自然就会理出为什么要这么干了.&lt;br /&gt;
房子的架构是靠重力,钢筋,水泥,联系到一起的.而为的architecture是靠logic联系到一起的。&lt;br /&gt;
小河之光.&lt;br /&gt;
奥卡姆的剃刀.&lt;br /&gt;
知识进来时是肤浅的,暂时的理解, 能否出去, 只有能出去的知识,才算吸收, 否则通常都是肤浅的记忆, 你以为你懂了, 但没懂.&lt;br /&gt;
阶段性啊, 骨肉框架内容.&lt;br /&gt;
根据不同的状态, 框架内容啊, 定义问题(往往多个问题)&lt;br /&gt;
选取总结找到解决问题的模式过程(往往多种方法)&lt;br /&gt;
建立一个真实的实践环境, 在其中不断实践,体验.成长的主要步骤.&lt;br /&gt;
认识缺陷, 发现反馈不足, 尝试收集资料, 分析, 找寻方法, 实践,修正缺陷, 解决问题.成长.&lt;/p&gt;

&lt;h1 id=&#34;原则&#34;&gt;原则&lt;/h1&gt;

&lt;p&gt;世界之源, 费曼技巧, semantic tree hung point &amp;ndash;Firo, 费曼, Musk&lt;br /&gt;
注意到quantaties很重要, 一个复杂的东西. 要看出来他是有简单的form通过量化后形成的.&lt;br /&gt;
form transformation cognition form analysis algorithm by change process to quantity(有些时候1个量不能描述清楚). &amp;ndash; Firo&lt;br /&gt;
我们只能包相似一类的过程量化, 不相似的过程量化需要更高阶, 更抽象的思维,起始没意义. 比如基数排序和霍夫曼编码. &amp;ndash;Firo&lt;br /&gt;
即便是结构本身一样不可以描述一定要找到某个点, 之后分析相似衍生才有意义, 如树结构,试问霍夫曼和searching的关联+ linked list. &amp;ndash;Firo&lt;br /&gt;
量要和过程匹配, 同步动态变化. 如二叉树的height就不是一个process 量.quantities有很多 &amp;ndash;Firo&lt;br /&gt;
Reflexivity &amp;ndash; Soros&lt;br /&gt;
直达最可能的地方, 答案, 要事第一.&lt;br /&gt;
一切的发源的动机.知识是有生命力的, 一点点生长的.&lt;br /&gt;
从实际问题触发, 实际的topic, 实际的问题应该是完整的, 不要孤立化, 也就是具体到具体行为, 业务场景, 不要把说和听分开.&lt;br /&gt;
实际的东西也能抽象化而且保留实际的内容要点, 语言可以抽象成理解和表述两方面, 都是抽象的但同时保留具体的含义.&lt;br /&gt;
学习的原则, 广(框架建立, 涉及的方面多), 效果好又快(学最重要的,排除无用的知识), 时间短(短时间内完成一两个周)&lt;br /&gt;
Top down: architecture, bottom up: feedback. 算是一种横向上的成果.&lt;br /&gt;
框架通过具体肉, 受肉, 联系(统治, 延伸)到现实,实际, 框架本来就来自实际.整体不等于部分之和.&lt;br /&gt;
为什么框架能够指导, 统治现实呢? 因为框架就是实际, 同时超越实际.&lt;br /&gt;
搞清楚architecture的一种可能的方法是, 指出ostensive涉及到的内容, 并从时间, 因果角度加以分析.&lt;br /&gt;
被列出来的事物, 因为不同, 显得独立模块化. 比如UTM和architecture. 正因为替换成DNA之类才显示出UTM的独立.&lt;br /&gt;
From architecture to another architecture&lt;br /&gt;
有机的知识.  算是一种横向上的成果.&lt;br /&gt;
不要把目标看成一个孤立的节点, 它和现在千丝万缕的联系.&lt;br /&gt;
有的问题, 虽然看上去无法理解清楚也不知道怎么解决.只要去做就行了doing.&lt;br /&gt;
将语言还原为日常生活及其形式.&amp;ndash; 维特根斯坦&lt;br /&gt;
Zeroness, 自己思考. 不要上来就读or做, 你要思考这个过程.&amp;ndash; Firo&lt;br /&gt;
方法简单容易, 方便证明是否有效&lt;br /&gt;
世界总是转换,不稳定,不确定.&lt;br /&gt;
Completeness, consistency, validity, soundness. &amp;ndash; Logic&lt;br /&gt;
Falsifiability可证伪性 &amp;ndash; Popper&lt;br /&gt;
批判性, 你所学的一切都是暂时性的,任何所学都有改口 驳斥 质疑的余地 &amp;ndash;Aaron Swartz,25:20&lt;br /&gt;
对于学习的知识上, 方法要做到知识之间的联系, 转换关系.&lt;br /&gt;
认知的缺陷, imperfect-understand, 彻底可错性. &amp;ndash;Firo Soros Popper&lt;br /&gt;
When you can not think any further of somthing, you must be awarenees of lack of causilities.&lt;/p&gt;

&lt;h1 id=&#34;收集&#34;&gt;收集&lt;/h1&gt;

&lt;h1 id=&#34;分析&#34;&gt;分析&lt;/h1&gt;

&lt;p&gt;Autonomous Change-of-state calculus &amp;ndash;Firo-Von Wright’s approach&lt;/p&gt;

&lt;p&gt;骨架和肉分析法 &amp;ndash; Firo&lt;/p&gt;

&lt;p&gt;祖孙的方法”   the genetic method &amp;ndash; 胡适,杜威&lt;br /&gt;
Why? How? What? Good and bad?&lt;/p&gt;

&lt;p&gt;从结构角度, 往往并不是所有简单元素都可以组合成复杂元素. 这也整个结构的缩影.&lt;br /&gt;
特别是简单元素和由简单元素合成的复杂元素却是平级的, 复合元素也成为了&amp;rdquo;简单元素&amp;rdquo;, 独立, 完整, 不可或缺的元素.&lt;br /&gt;
对于但从简单元素角度看, 有点哥德尔不完备定理的感觉.&lt;br /&gt;
比如英语的Collocation, 并不是掌握了基础就掌握了一切.&lt;/p&gt;

&lt;p&gt;从时间角度&lt;/p&gt;

&lt;p&gt;最重要的是什么呢?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;analysis computer program&lt;br /&gt;
init onset, running nuclus, exit coda&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;阶段目标与问题定义&#34;&gt;阶段目标与问题定义&lt;/h1&gt;

&lt;p&gt;The phrased objectives&lt;br /&gt;
What is the important, foundation, most useful, minimal cached? &amp;ndash; Firo&lt;/p&gt;

&lt;p&gt;内涵定义: Genus-differentia definition 属加种差定义: 发生定义(设计), 关系定义, 功用定义, 摹状定义&lt;br /&gt;
充要定义, Real and nominal definitions&lt;br /&gt;
Classes of extensional definitions: enumerative definition&lt;br /&gt;
&lt;a href=&#34;http://plato.stanford.edu/entries/definitions/&#34;&gt;Definitions Stanford Encyclopedia of Philosophy&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;模式过程&#34;&gt;模式过程&lt;/h1&gt;

&lt;p&gt;反射理论作为开始, 有机知识作为结果, feedback update 作为机制.&lt;br /&gt;
工作生活中的决断都现实的真实反馈而做出的.&lt;br /&gt;
费曼技巧可以部分地用来生成有机知识.&lt;br /&gt;
缺陷反馈更新, 可以以假设-验证的方式进行.假设自己全会了, 去想象那种感觉, 之后去实践验证.从而得出缺陷. 修补缺陷.&lt;br /&gt;
Experiential Learning, 两个难点, 实践的范围强度和谕示机.&lt;/p&gt;

&lt;p&gt;去看看别人怎么做的, 什么应该做, 什么不应该做.&lt;/p&gt;

&lt;p&gt;Divide every question into manageable parts. &amp;ndash; Descartes&lt;br /&gt;
Begin with the simplest issues and ascend to the more complex. &amp;ndash; Descartes&lt;br /&gt;
Review frequently enough to retain the whole argument at once &amp;ndash; Descartes&lt;br /&gt;
Accept as true only what is indubitable. &amp;ndash; Descartes&lt;/p&gt;

&lt;h1 id=&#34;实践&#34;&gt;实践&lt;/h1&gt;

&lt;p&gt;建立一个全面的wilds环境, 在这个环境下生存!&lt;br /&gt;
活下去!&lt;/p&gt;

&lt;h1 id=&#34;反馈缺陷&#34;&gt;反馈缺陷&lt;/h1&gt;

&lt;h1 id=&#34;本体系自身的反馈&#34;&gt;本体系自身的反馈&lt;/h1&gt;

&lt;p&gt;成长来自实践, 以及认识缺陷并加以改正.&lt;br /&gt;
不断的实践和改正缺陷才是提高能力的核心!&lt;br /&gt;
很多时候, 依靠现在的经验学识不能找到完整的方法, 需要不断的调整.&lt;br /&gt;
学会认识自己的无力.&lt;br /&gt;
问题总是复杂的, 解决方法总是简单的.  &amp;ndash;xiaolai.li&lt;br /&gt;
反射理论, 反射的对象不是其他, 正是现实!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2016年4月第一周</title>
      <link>http://firoyang.org/lyubishchev/day-2016-04-07/</link>
      <pubDate>Tue, 25 Aug 2015 15:46:11 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/lyubishchev/day-2016-04-07/</guid>
      <description>&lt;p&gt;The man who staring at the abyss.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Firo</title>
      <link>http://firoyang.org/firo/firo/</link>
      <pubDate>Tue, 25 Aug 2015 15:46:11 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/firo/firo/</guid>
      <description>&lt;p&gt;一个人应该与外界的应该保持什么样的关系? 每个人都应该有自己的回答, 而且答案不一而终.&lt;br /&gt;
正是这种关系成就了我们的一生.个体如何确定这种关系,或者说如何确定一种合理的生存状态?&lt;br /&gt;
对于人类丰富, 无止尽的欲望而言, 很难给出统一的答案.然而这并不妨碍我们找到理想的状态.&lt;br /&gt;
简单说来, 两点; 那些来自内心的, 原始的, 本能的愿望正是我们生活的方向, 不应被忽视, 反而&lt;br /&gt;
要经常回忆起来, 并视若内心的珍宝一样对待; 另外, 我们应该做的是弥补生活中的不足, 以此来&lt;br /&gt;
向理想中的生活不断的迈进, 而不是沉醉于对理想的执着与等待中. 从实实在在的生活不足开始,&lt;br /&gt;
这才是真实的, 是你的生活.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;生活不在别处, 正是当下此地.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于世界一部分的个体, 充分的认识世界的运作机制, 成为确定自己生活状态的前提. 对于普通人&lt;br /&gt;
而言, 这似乎无从下手. 尤其是对于处在巨大生存压力下的人, 无暇顾及这般如同象牙塔式的问题?&lt;br /&gt;
我想这正是他们生活悲剧的根源之一. 对于了解这个世界, 实际上要简单许多. 我想, 只要你有意识&lt;br /&gt;
地在遇到困惑, 疑问, 艰难, 令人不适的生活的时候, 寻找这些问题背后的原因的时候, 答案便会出现.&lt;br /&gt;
而答案就是一种关系, 因果律. 同时连带得出关系的主客体. 比如, 49年后, 中国人都有一个潜在&lt;br /&gt;
的伟大的身份, 社会主义建造者.这是个体和国家之间的某种答案,在我出生之时, 变自动获得这种身份.&lt;br /&gt;
直到我意识到这种身份的存在时, 我毫不犹豫的放弃了它.因为我并不是一个社会主义者,&lt;br /&gt;
我打心眼里抵触社会主义, 我很难想象他的存在, 同时那样的社会对我来说是一种无声的恐惧,&lt;br /&gt;
因为他偏离人性的核心, 那样的社会下的生活, 我一点也不期待, 我已体验过了.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;显然, 在人与世界的诸多联系中, 有一些是被他人赋予, 而那些强制赋予的很多都成了枷锁.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于确定生命个体的合理生存状态, 可以看成找到你与世界现有的关系以及想要的某种关系.&lt;br /&gt;
首先, 我们要理清那些重要的关系. 可以说我的哲学就是建立在关系之上, 也就是因果律.&lt;br /&gt;
人总生活在关系中, 我认为下面的关系很重要.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;从个人角度, 越靠近真实, 越靠近真实, 不靠近就会远离. 这也是因果律的体现.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;即便你找不到期待中的生活状态，你也活在关系中, 这也是最基本的．&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;人生没有目标, 也要好好活着!&lt;br /&gt;
所有人都是某些东西的奴隶 &amp;ndash; 进击的巨人&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其他的规律：&lt;/p&gt;

&lt;p&gt;＞正反合&lt;br /&gt;
&amp;gt; 完整的逻辑,包含不存在&lt;br /&gt;
&amp;gt; 生活就是同傻逼的战争!&lt;br /&gt;
&amp;gt; 每个人都有自己内心的弱点, 不必害怕他们.&lt;br /&gt;
&amp;gt; 生长需要滋润.&lt;br /&gt;
&amp;gt; 成长开始于注意到缺陷, 疑问&lt;br /&gt;
&amp;gt; 很多时候其实我们的忙碌都是做着自己并不在乎的事情！&lt;br /&gt;
&amp;gt; 生命所不能承受之轻!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>My Career</title>
      <link>http://firoyang.org/firo/career/</link>
      <pubDate>Sun, 26 Jul 2015 15:46:11 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/firo/career/</guid>
      <description>

&lt;p&gt;无论是位高权重的政治家, 富贵显荣的商人, 亦或是蝇营狗苟的市侩之人等等, 所有芸芸众生&lt;br /&gt;
每日莫不是为了谋生而奔走. 长久的活着是一种负担.&lt;br /&gt;
忙碌的生活, 难以审视自己的人生. 今天坐下来, 谈谈这个话题.&lt;/p&gt;

&lt;p&gt;毫无已问, 从小到大, 即便是为曾到达的未来, 工作都占据了我们据大多数时间, 当然X二代&lt;br /&gt;
不在此列. 在这个社会, 即便每日辛劳的工作, 绝大多数人, 依然连自己卑微的梦想都无法实现.&lt;br /&gt;
今天, 我不谈政治层面的原因. 只想从个人角度, 去剖析人与工作之间的关系.&lt;/p&gt;

&lt;p&gt;英文&lt;a href=&#34;https://en.wikipedia.org/wiki/Career&#34;&gt;career&lt;/a&gt;, 在维基给出了基本的解释:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A career is an individual&#39;s journey through learning, work and other aspects of life.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;词源上是由马车引出的人生之路的涵义. 而中文, 生涯出自《庄子·养生主》：“吾生也有涯，而知也无涯。”&lt;br /&gt;
我们今天主要谈两个问题, 人生的马车和人生的&amp;rdquo;涯&amp;rdquo;.&lt;br /&gt;
我的职业生涯始于大学, 童年时期热爱电子游戏, 导致大学选择了计算机科学这个行业. 到今天整整过去了&lt;br /&gt;
7个年头, 不短了. 本人只敢自称勤奋之人, 大学伊始至今, 绝大多数时光都在勤奋治学, 未曾懈怠.&lt;br /&gt;
大学毕业三年, 依然没有实现自己当初的愿望, a remote kernel hacker. 这个目标完全是个人喜好, 性格使然.&lt;br /&gt;
同时也受限于我个人的视野.&lt;/p&gt;

&lt;h1 id=&#34;interview&#34;&gt;Interview&lt;/h1&gt;

&lt;h2 id=&#34;关于薪资问题&#34;&gt;关于薪资问题&lt;/h2&gt;

&lt;p&gt;全面回答包括股票期权.&lt;br /&gt;
real background.&lt;br /&gt;
期望的薪资别说太低, 往上也别说的太死, 比预期要高.&lt;br /&gt;
说更关注职业发展.&lt;/p&gt;

&lt;h2 id=&#34;想面试公司提出的问题&#34;&gt;想面试公司提出的问题&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;NO1. 我所应聘的这个职位为什么会出现空缺？&lt;br /&gt;
如果空, 空多长时间, 因为什么原因空的.&lt;br /&gt;
如果这个职位是新近才出现的，或许你就拥有了一个理想的、开辟属于自己的道路的机会。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;NO2. 请问贵公司最成功的员工为公司做出了什么样的贡献？&lt;br /&gt;
谁对公司贡献最大, 谁领导之类的, 做了什么? 有那些优秀品质. 了解公司文化.&lt;br /&gt;
面试管, 可能认为你是志在成功公司最优秀的员工之一.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;NO3.如何评估自己在三个月试用期内的工作表现？何种标准算成功？&lt;br /&gt;
该职位遇到的最大的挑战是什么?&lt;br /&gt;
了解公司做事风格, 是否稳重成熟. 排除不靠谱公司, 谁知道半年后他们&lt;br /&gt;
能干出什么? 谨慎对待抛出橄榄枝.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;NO5.目前公司所面对的最大的挑战有哪些？&lt;br /&gt;
这个编程比如说内核在公司的位置, 是否是中心.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;NO6.公司如何来保证人才不流失？&lt;br /&gt;
长期的意愿, 这个问题比较屌.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;NO7.请问您为什么要为这家公司工作呢？&lt;br /&gt;
连面试官自己都不知道为什么要为这家公司工作，你觉得这样的公司会给员工提供多少机会呢？&lt;br /&gt;
去面试工作，是一个相互合作的过程，并不是说哪一方成为主导。你为公司工作，公司给你报酬。&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而对所有公司来说它总希望找到那一种类似合作伙伴的员工而不是仅仅是来打工的。&lt;br /&gt;
所以，在面试的时候除了展示你自身特长和文化外，还要表现出一个对公司前景关心和一种参与者的心态来。&lt;br /&gt;
这样能让公司的管理者对你更有好感！这不仅为了进入这个公司也为了以后的发展.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>有一段历史离我们如此近记忆却模糊</title>
      <link>http://firoyang.org/history/china_a_century_of_revolution/</link>
      <pubDate>Wed, 24 Jun 2015 15:46:11 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/history/china_a_century_of_revolution/</guid>
      <description>&lt;p&gt;毛泽东的时代&lt;br /&gt;
&lt;iframe width=&#34;420&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/GMaXSKH2w3c&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;p&gt;建国后出生的新一代&lt;br /&gt;
&lt;iframe width=&#34;420&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/qsmJXJcvG3g&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
