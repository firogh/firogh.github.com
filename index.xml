<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title> on Firo Notes </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://firoyang.org/</link>
    <language>en-us</language>
    <author>Firo Yang</author>
    
    <updated>Sat, 27 Feb 2016 22:12:11 CST</updated>
    
    <item>
      <title>杂记于蓝星花园</title>
      <link>http://firoyang.org/firo/n1/</link>
      <pubDate>Sat, 27 Feb 2016 22:12:11 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/firo/n1/</guid>
      <description>&lt;p&gt;我和这个国家的矛盾最终演变成不可调和的地步. 我已无法在北京生存了, 国内其他的城市对我来说也一样.&lt;br /&gt;
于是, 我已走头无路, 只剩出国这一条路了.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The map of Knowledges</title>
      <link>http://firoyang.org/philosophy/knowledge_map/</link>
      <pubDate>Wed, 17 Feb 2016 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/philosophy/knowledge_map/</guid>
      <description>

&lt;h1 id=&#34;根据依赖关系组织-展示的知识:260b1b4cb8a9fd578dd92738bfffb93b&#34;&gt;根据依赖关系组织, 展示的知识&lt;/h1&gt;

&lt;p&gt;知识之间都是相互依赖的.&lt;br /&gt;
Logic&lt;br /&gt;
Language&lt;br /&gt;
Mathematics&lt;br /&gt;
Programming&lt;/p&gt;

&lt;p&gt;English&lt;br /&gt;
Hibert提出23个问题. turing machine 是为了解决数学可判定性问题.&lt;br /&gt;
由此导致CS的蓬勃发展.&lt;/p&gt;

&lt;p&gt;Class of knowledge&lt;br /&gt;
Raw knowledge, which exists in live, is real, leisure, scattered, low chance to learn.&lt;br /&gt;
Raw knowledge need lots of time to learn.&lt;br /&gt;
Artificial knowledge&lt;br /&gt;
linear enumerate knowledge: only for searching.&lt;/p&gt;

&lt;p&gt;Phased objectives of learning knowledge&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>奔腾年代</title>
      <link>http://firoyang.org/cs/golden_age_of_cs/</link>
      <pubDate>Tue, 05 Jan 2016 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/golden_age_of_cs/</guid>
      <description>&lt;p&gt;计算机的奔腾年代&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The common cognition language</title>
      <link>http://firoyang.org/philosophy/ccl/</link>
      <pubDate>Sun, 13 Dec 2015 03:27:16 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/philosophy/ccl/</guid>
      <description>&lt;p&gt;What&amp;rsquo;s the orgnaiszations of knowledge?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Console and TTY</title>
      <link>http://firoyang.org/kernel/console/</link>
      <pubDate>Sat, 05 Dec 2015 14:06:29 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/kernel/console/</guid>
      <description>

&lt;p&gt;343 line&lt;br /&gt;
1. /dev/console 指向正在运行的tty 和tty0 一样ttyN not pts, console 佬变.&lt;br /&gt;
2. /dev/tty 一直指向所在的那个不变.&lt;/p&gt;

&lt;h1 id=&#34;about-the-design:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;About the design&lt;/h1&gt;

&lt;p&gt;Why dose we use /dev/xxx to represent the &amp;ldquo;tty&amp;rdquo; device?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The whole point with &amp;ldquo;everything is a file&amp;rdquo; is not that you have some random filename (indeed, sockets and pipes show that &amp;ldquo;file&amp;rdquo; and &amp;ldquo;filename&amp;rdquo;&amp;gt; have nothing to do with each other), but the fact that you can use common tools to operate on different things. &amp;ndash; Linus&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So we got the key point!&lt;br /&gt;
In order to use the common tools, file ops and vfs layer, the tty device is &amp;ldquo;abstructed&amp;rdquo; to&lt;br /&gt;
files by us. Addnationaly, we must assurance that is the files is &lt;em&gt;different&lt;/em&gt;. What does&lt;br /&gt;
the word &amp;ldquo;dirrerent&amp;rdquo; means is not that you have some random different filename, but the&lt;br /&gt;
fact that you can access the real device through the different.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Wikipedia:&lt;br /&gt;
In mathematics, injections, surjections and bijections are classes of functions distinguished by the manner in which arguments (input expression&amp;gt; s from the domain) and images (output expressions from the codomain) are related or mapped to each other.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I got an insight that abstruction is a non-injective, right?&lt;br /&gt;
But non-injective may not be a anstruction.&lt;br /&gt;
An asbstruction should come from manipulating different objects.&lt;br /&gt;
Non-injective, 多对一; Multiplex, 一对多.&lt;br /&gt;
So we can use mathematical language to describe the linux subsystem.&lt;br /&gt;
From real life device to a filesystem file.&lt;br /&gt;
* Abstruction: Non-injective, Multiplex(not partial function).&lt;br /&gt;
* Jection num: injective, or non-jective, or multiplex; Jection level: domain set and codoain set!&lt;br /&gt;
Abstruction -&amp;gt; Control abstruction and data abstruction -&amp;gt; Abstruction layer&lt;/p&gt;

&lt;p&gt;软件设计的两个主要目的.&lt;br /&gt;
1. 简化, 易用,易操作, 如computer architecture, tty subsystem. 抽象.&lt;br /&gt;
2. Separation of concerns, modular(abstruciton in layer), 笛卡尔划分的思想&lt;/p&gt;

&lt;h1 id=&#34;tty-struct-disc-data:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;tty_struct-&amp;gt;disc_data&lt;/h1&gt;

&lt;p&gt;tty_init_dev-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    initialize_tty_struct-&amp;gt;tty_ldisc_init&lt;br /&gt;
    tty_ldisc_setup-&amp;gt;tty_ldisc_open-&amp;gt;n_tty_open-&amp;gt; tty-&amp;gt;disc_data = ldata;&lt;br /&gt;
}&lt;br /&gt;
sys_vhangup-&amp;gt;tty_vhangup_self-&amp;gt;__tty_hangup-&amp;gt;tty_ldisc_hangup-&amp;gt;tty_ldisc_reinit&lt;br /&gt;
vfs_write-&amp;gt;redirected_tty_write-&amp;gt;tty_write-&amp;gt;n_tty_write-&amp;gt;process_output&lt;/p&gt;

&lt;h1 id=&#34;early-con:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;early_con&lt;/h1&gt;

&lt;p&gt;EARLYCON_DECLARE(uart8250, early_serial8250_setup); EARLYCON_DECLARE(uart, early_serial8250_setup);&lt;br /&gt;
setup_earlycon-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    parse_options-&amp;gt;&lt;br /&gt;
    {&lt;br /&gt;
        parse earlycon_device-&amp;gt;port-&amp;gt;uartclk and&lt;br /&gt;
        earlycon_device-&amp;gt;baud&lt;br /&gt;
    }&lt;br /&gt;
    setup = early_serial8250_setup-&amp;gt; init_port(device);&lt;br /&gt;
    register_console(early_console_dev.con)&lt;br /&gt;
}&lt;/p&gt;

&lt;h1 id=&#34;earlyprintk:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;earlyprintk&lt;/h1&gt;

&lt;p&gt;early_param(&amp;ldquo;earlyprintk&amp;rdquo;, setup_early_printk)-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    early_serial_init-&amp;gt;&lt;br /&gt;
    {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;}
early_console_register(&amp;amp;early_serial_console, keep);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;h1 id=&#34;cpu-hotplug:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;cpu hotplug&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;onset&lt;br /&gt;
static struct smp_hotplug_thread softirq_threads {&lt;br /&gt;
.thread_fn              = run_ksoftirqd&lt;br /&gt;
};&lt;br /&gt;
early_initcall(spawn_ksoftirqd)-&amp;gt;mpboot_register_percpu_thread(&amp;amp;softirq_threads)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;nucles onset&lt;br /&gt;
suspend_enter-&amp;gt;enable_nonboot_cpus-&amp;gt;_cpu_up-&amp;gt;smpboot_create_threads-&amp;gt;&lt;strong&gt;smpboot_create_thread(&amp;amp;hotplug_threads)-&amp;gt;&lt;br /&gt;
kthread_create_on_cpu(smpboot_thread_fn-&amp;gt; ht-&amp;gt;thread_fn(td-&amp;gt;cpu)= run_ksoftirqd-&amp;gt;&lt;/strong&gt;do_softirq-&amp;gt;h-&amp;gt;action(h) = run_timer_softirq-&amp;gt;&lt;br /&gt;
__run_timers-&amp;gt;call_timer_fn)&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;vt 就是个tty也有tty_driver 叫console_driver.&lt;/p&gt;

&lt;h1 id=&#34;reference:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;Reference&lt;/h1&gt;

&lt;h1 id=&#34;contents:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;Contents&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://superuser.com/questions/144666/what-is-the-difference-between-shell-console-and-terminal&#34;&gt;What is the difference between shell, console, and terminal?&lt;/a&gt;&lt;br /&gt;
What does console do in kernel or u-boot?&lt;br /&gt;
Linux console?&lt;br /&gt;
Computer terminal: keyboard + dispaly&lt;br /&gt;
Terminal emulator:&lt;/p&gt;

&lt;h1 id=&#34;get-a-glance-on-u-boot:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;get a glance on u-boot&lt;/h1&gt;

&lt;p&gt;start.S:board_init_r&lt;br /&gt;
init_sequence_f: -&amp;gt;init_baud_rate; serial_init; console_init_f&lt;br /&gt;
serial_init -&amp;gt;&amp;amp;eserial1_device-&amp;gt;start=eserial##port##_init-&amp;gt;NS16550_init: UART divisor init.&lt;br /&gt;
Firstly, the struct of serial define some input and output funtion.&lt;br /&gt;
It&amp;rsquo;s basic function of serial, put or get!&lt;br /&gt;
console_init_f: just gd-&amp;gt;have_console = 1;&lt;br /&gt;
init_sequence_r: stdio_init_tables,initr_serial, stdio_add_devices, console_init_r,&lt;br /&gt;
initr_serial: just register &amp;amp;eserial1_device to serial_devices&lt;br /&gt;
stdio_add_devices: drv_system_init, serial_stdio_init&lt;br /&gt;
drv_system_init: register default serial dev to devs.list.&lt;br /&gt;
serial_stdio_init: register &amp;amp;eserial1_device to devs.list. Duplicate, but serial dev &amp;ldquo;eserial0&amp;rdquo;  and system &amp;ldquo;serial&amp;rdquo;.&lt;br /&gt;
console_init_r: console_doenv -&amp;gt;console_setfile:stdio_devices[file(0/1/2)] = dev; actually, dev is &amp;ldquo;serial&amp;rdquo;, but they may be KBD!&lt;br /&gt;
看来console的真正作用就是在serial和kbd中选择一个, 可能多选iomux?&lt;br /&gt;
main_loop:cli_loop: getc!&lt;/p&gt;

&lt;h1 id=&#34;what-is-platform-device-or-driver:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;what is platform device or driver?&lt;/h1&gt;

&lt;h1 id=&#34;a-reallife-serial8250:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;A reallife serial8250&lt;/h1&gt;

&lt;p&gt;drivers/tty/serial/8250/8250_boca.c:plat_serial8250_port&lt;br /&gt;
module_init-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    serial8250_init-&amp;gt;serial8250_isa_init_ports-&amp;gt;serial8250_ports[i].port.ops = &amp;amp;serial8250_pops; //insidious&lt;br /&gt;
    boca_init-&amp;gt;platform_device_register(&amp;amp;boca_device); //register platform device and data.&lt;br /&gt;
}&lt;br /&gt;
* uart_port-&amp;gt;tty_port&lt;/p&gt;

&lt;p&gt;serial8250_probe(plat_serial8250_port)-&amp;gt;serial8250_register_8250_port(uart_8250_port)-&amp;gt;&lt;br /&gt;
uart_add_one_port(&amp;amp;serial8250_reg, &amp;amp;uart-&amp;gt;port=uart_port)-&amp;gt;&lt;br /&gt;
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uart_configure_port-&amp;gt;
{
    port-&amp;gt;ops-&amp;gt;config_port(port, flags)=serial8250_config_port
    if post is console and not registered; register!
    we know that uport-&amp;gt;cons = drv-&amp;gt;cons; what is the relation to registering about up-&amp;gt;cons.
    why we register it? where does drv-&amp;gt;cons come from?
    //这个uart_driver drv就是serial8250_reg, 我们也就知道了
    // console是设备的一种天生能力. 能否使用, 只关乎你是否想用, 就是配置相关的config SERIAL8250_CONSOLE
    // con_driver is the backends, vga, dummy/serial?, fb. 
}
tty_port_register_device_attr-&amp;gt;
{
    //tty_driver  tty_port
    tty_port_link_device
    tty_register_device_attr
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;h1 id=&#34;simple-conceptions:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;Simple conceptions&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.linusakesson.net/programming/tty/&#34;&gt;You must read this -&amp;gt; The TTY demystified&lt;/a&gt;&lt;br /&gt;
System consoles are generalized to computer terminals, which are abstracted respectively by virtual consoles and terminal emulators.&lt;br /&gt;
        UART&lt;br /&gt;
        Line displine + TTY(pts, dummy/serial, kbd+vga/fb)&lt;br /&gt;
* System console&lt;br /&gt;
Virtual termial, Terminal emulator/telnet/ssh -&amp;gt; pts ,Physical terminal&lt;br /&gt;
You need at least one virtual terminal device in order to make use of your keyboard and monitor.&lt;br /&gt;
VT combine keyboard and display see con_init&lt;br /&gt;
con_init init a virtual terminal like gnome-terminal but in kernel.&lt;br /&gt;
con_init mainly init display.&lt;br /&gt;
vty_init mainly init kbd&lt;br /&gt;
They all can be system console.(Exception pts??), if you enable it.&lt;br /&gt;
Console is the entry of linux system.&lt;br /&gt;
* Console driver &amp;ndash; banckends of  console&lt;br /&gt;
struct console 指定了console的结构.&lt;br /&gt;
* Console config&lt;br /&gt;
If I disable CONFIG_SERIAL8250_CONSOLE(enable vt console), then no booting log and I can not login system.&lt;br /&gt;
If I disable CONFIG_VT_CONSOLE(enable serail console, /dev/console point to ttyS0 see show_cons_active), no booting log but I can lgin system.&lt;br /&gt;
How to explain this phenomena?&lt;br /&gt;
From show_cons_active, we know /dev/console should come from console_drivers.&lt;br /&gt;
/dev/console is really the pointer.&lt;br /&gt;
Now, let&amp;rsquo;s inspect open /dev/console.&lt;br /&gt;
* Open /dev/console&lt;br /&gt;
Fisrt, it&amp;rsquo;s the very last place of booting kernel.&lt;br /&gt;
start_kernel-&amp;gt;rest_init-&amp;gt;kernel_init-&amp;gt;kernel_init_freeable-&amp;gt;sys_open((const char __user *) &amp;ldquo;/dev/console&amp;rdquo;, O_RDWR, 0)-&amp;gt;&amp;hellip;-&amp;gt;&lt;br /&gt;
console_fops-&amp;gt;tty_open-&amp;gt;&lt;br /&gt;
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Sitiuations: disbale VT CONSOLE byt enable SERIAL8250_CONSOLE.
// This function work only for /dev/tty
// ls -l /dev/tty
// crw-rw-rw- 1 root tty 5, 0 Dec 10 10:24 /dev/tty
tty_open_current_tty-&amp;gt;
{
    /dev/console is 5:1, just return NULL
}
//This index should be Ctrl + Alt + Fn??
// tty_struct is corresponding virtual console, or just console??
// lookup tty_driver. It looks like lookup a inode, right?
tty_lookup_driver-&amp;gt;
{
    // Find a tty_driver by device() in console_drivers.
    // So we know, got a console, then got a tty_driver, right?
    // Where do the components of console_drivers come form?
    // At present, we should have only serial8250_console because 
    // console vt_console_driver is disabled by us! But tty_driver console_driver
    // still do exist!So console and tty is really separated!
    // When we init vt, we get the tty_driver console_driver with con_ops type of tty_operations.
    // tty_drivers have the same major with /dev/tty0!
    // char_dev -&amp;gt; tty_driver int vty_init, not disable.
    // vt console---^
    console_device-&amp;gt;c-&amp;gt;device(c, index)
    // What about serial8250_console?
    // Where is the tty_driver of serial8250_console?
    // console-&amp;gt;data = uart_driver-&amp;gt;tty_driver.
    // We got another scene : uart-&amp;gt;tty
    // serial8250 console-&amp;gt;data-^
    // serial&#39;s tty_driver alloced in serial8250_init with uart_ops.
    // vt&#39;s tty_driver alloced in vty_init.
    // We summarize these:
    // uart_driver serial8250_reg &amp;lt;-&amp;gt;  vc dev or /dev/tty*
    // serial tty driver &amp;lt;-&amp;gt; vt tty driver 
    // fs:vty_init &amp;lt;-&amp;gt; module:serial8250_init
    // tty driver ops con_ops &amp;lt;-&amp;gt; uart_ops
    // vt use major to connect tty and  vc dev
    // serial use major and -&amp;gt; to connect tty and uart_driver
    // It seems that uart and tty has a strong relationship, yet vt.
    // Ok... we got tty driver.
    // If we disable vt console, then here is the serial8250 tty_driver.
}
// Lookup for tty_struct
tty_driver_lookup_tty -&amp;gt;
{
    //tty_struct is alloced in init function alloc_tty_driver.
    // ttys, termios, ports, cdevs.
    // ttys was used by tty_standard_install then tty_driver_install_tty 
    // then tty_init_dev then ok we return to tty open. So this is the start place.

    So we know tty_driver-&amp;gt;ttys[*] must be NULL.
}
tty_init_dev-&amp;gt;
{
    // tty_driver likes a process, ttys like the files, tty_struct like a file!
    // So we know a tty_struct is a tty file.
    // tty_driver much like a inode
    //So tty_struct-&amp;gt;ops = tty_driver-&amp;gt;ops = &amp;amp; uart_ops
    alloc_tty_struct-&amp;gt;tty-&amp;gt;ops = driver-&amp;gt;ops;
    tty_driver_install_tty(driver, tty_struct)-&amp;gt; tty_standard_install-&amp;gt;driver-&amp;gt;ttys[tty-&amp;gt;index] = tty;
}
// Ok... We got a tty_struct.
// Add /dev/console to tty_struct-&amp;gt;tty_files
tty_add_file
// At present, what have we done?
// open(/dev/console)-&amp;gt;console_drivers-&amp;gt;console-&amp;gt;tty_driver-&amp;gt;tty_struct, right?

tty-&amp;gt;ops-&amp;gt;open(tty, filp)-&amp;gt;//ops = &amp;amp;uart_ops
{
    uart_ops-&amp;gt;open = uart_open-&amp;gt;
    {
        uart-&amp;gt; tty struct
        struct uart_driver *drv = (struct uart_driver *)tty-&amp;gt;driver-&amp;gt;driver_state;
        struct uart_state *state = drv-&amp;gt;state + line; //uart_state
        tty-&amp;gt;driver_data = state;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
// At present, we understand the flow of open /dev/console to serial console&lt;/p&gt;

&lt;h1 id=&#34;what-about-opening-dev-console-to-vt-console:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;What about opening /dev/console to vt console&lt;/h1&gt;

&lt;p&gt;sys_open(/dev/console)-&amp;gt; &amp;hellip; tty_open -&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    tty_lookup_driver-&amp;gt; get tty_driver=console_driver,&lt;br /&gt;
    Through the name console_driver, we know, vt tty_driver is the defaut driver of console!&lt;br /&gt;
    // 同时, 我们也应该知道所谓的kernel的system console 是你只要enable了先关的config CONFIG_VT_CONSOLE and CONFIG_SERIAL_8250_CONSOLE.&lt;br /&gt;
    // system console就有了, printk也就有了归处. In other words, you registered, you got printed&lt;br /&gt;
    // In theory, you should be able to input something, like sysrq, I maybe test tomorrow.&lt;br /&gt;
    // 那么在kernel_init中sys_open又是什么鬼呢?&lt;br /&gt;
    // dev/tty 是专门真对进程的, 就是进程之前打开了一个tty就存在singnal里, 这个dev/tty就是取出来的.&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;h1 id=&#34;总结下-打开-dev-console-会从console-drivers-最终到达tty-driver:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;总结下, 打开/dev/console, 会从console_drivers, 最终到达tty_driver.&lt;/h1&gt;

&lt;h1 id=&#34;这和-dev-tty-dev-ttys-从tty-drivers-差不多:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;这和/dev/tty* /dev/ttyS* 从tty_drivers, 差不多.&lt;/h1&gt;

&lt;p&gt;// 这么输出为什么不会打窜了?&lt;br /&gt;
// How ctrl alt Fn work?&lt;br /&gt;
// echo xxx /dev/tty in serial tty_lookup_driver&lt;br /&gt;
// 另一个问题, serial 的terminal?&lt;/p&gt;

&lt;h1 id=&#34;the-perspective:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;The perspective&lt;/h1&gt;

&lt;p&gt;/dev/*&lt;br /&gt;
vfs&lt;br /&gt;
chrdev&lt;br /&gt;
tty_fops&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;gt;tty core&lt;br /&gt;
    ld_ops &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;&amp;gt; tty line discipline(for read, write)&lt;br /&gt;
tty_driver con_ops/uart_ops&amp;mdash;&amp;mdash;&amp;ndash;&amp;gt; tty driver and tty_operations&lt;br /&gt;
HW&lt;br /&gt;
There are three different types of tty drivers: console, serial port, and pty.&lt;br /&gt;
serial8250_default_handle_irq&lt;br /&gt;
UART console&lt;br /&gt;
              |&amp;mdash;- Virtual terminal &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; VT console&lt;br /&gt;
              |                 | &amp;ndash; VT console&lt;br /&gt;
              |&amp;mdash;-&lt;br /&gt;
        Terminal&amp;ndash;|&lt;br /&gt;
              |&amp;mdash;-&lt;/p&gt;

&lt;h1 id=&#34;what-about-console:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;What about console?&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;early_con&lt;br /&gt;
start_kernel or setup_arch(arm)-&amp;gt;parse_early_param-&amp;gt;do_early_param-&amp;gt;p-&amp;gt;setup_func()= setup_early_printk-&amp;gt;register_console&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;vga_con&lt;br /&gt;
start_kerenl-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
// All about vga console&lt;br /&gt;
set_arch-&amp;gt; conswitchp = &amp;amp;vga_con; or conswitchp = &amp;amp;dummy_con;&lt;br /&gt;
console_init-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
        tty_ldisc_begin-&amp;gt;tty_register_ldisc(N_TTY, &amp;amp;tty_ldisc_N_TTY);&lt;br /&gt;
    console_initcall(con_init);&lt;br /&gt;
console_initcall(serial8250_console_init)&lt;br /&gt;
    con_init-&amp;gt;&lt;br /&gt;
    {&lt;br /&gt;
        // vc-&amp;gt;vc_sw-&amp;gt;con_putcs is DUMMY&lt;br /&gt;
        //内存映射64KB or 32KB的VGA区域. 启动VGA&lt;br /&gt;
        conswitchp-&amp;gt;con_startup = vgacon_startup -&amp;gt;vga_vram_base = VGA_MAP_MEM(vga_vram_base, vga_vram_size);&lt;br /&gt;
        con_driver_map[0~MAX_NR_CONSOLES] = conswitchp; //空间换时间&lt;br /&gt;
        // 核心内容!&lt;br /&gt;
        for (currcons = 0; currcons &amp;lt; MIN_NR_CONSOLES; currcons++) {&lt;br /&gt;
            // 给vc_cons[currcons].d分配内存&lt;br /&gt;
            vc_cons[currcons].d = vc = kzalloc(sizeof(struct vc_data), GFP_NOWAIT);&lt;br /&gt;
            INIT_WORK(&amp;amp;vc_cons[currcons].SAK_work, vc_SAK);&lt;br /&gt;
            //初始化vc_cons[currcons].d&lt;br /&gt;
            tty_port_init(&amp;amp;vc-&amp;gt;port);&lt;br /&gt;
            // 继续初始化, 主要是确定screenbuf size&lt;br /&gt;
            visual_init(vc, currcons, 1);&lt;br /&gt;
            // 给vc_screenbuf分配内存&lt;br /&gt;
            vc-&amp;gt;vc_screenbuf = kzalloc(vc-&amp;gt;vc_screenbuf_size, GFP_NOWAIT);&lt;br /&gt;
            vc_init(vc, vc-&amp;gt;vc_rows, vc-&amp;gt;vc_cols,&lt;br /&gt;
                currcons || !vc-&amp;gt;vc_sw-&amp;gt;con_save_screen);&lt;br /&gt;
        }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    [    0.000000] Console: colour VGA+ 80x25
    register_console(&amp;amp;vt_console_driver);//vt_console can use vgacon writing.
}
serial8250_console_init-&amp;gt;register_console(&amp;amp;serial8250_console) to console_drivers; exclusive_console.
[    0.000000] console [tty0] enabled
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
module_init(serial8250_init);??&lt;br /&gt;
}&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;fbcon&lt;br /&gt;
register_framebuffer-&amp;gt; do_take_over_console -&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
do_register_con_driver-&amp;gt;csw-&amp;gt;con_startup();registered_con_driver&lt;br /&gt;
do_bind_con_driver -&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    [    3.882220] Console: switching to colour dummy device 80x25&lt;br /&gt;
    [    4.720732] Console: switching to colour frame buffer device 170x48&lt;br /&gt;
}&lt;br /&gt;
}&lt;/p&gt;

&lt;h2 id=&#34;vga-text-console-printk-write:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;VGA text console printk &amp;amp; write&lt;/h2&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;kernel space&lt;br /&gt;
printk-&amp;gt; &amp;hellip;-&amp;gt;log_buf&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;userspace for ttyN&lt;br /&gt;
tty_fops-&amp;gt;write=tty_write-&amp;gt; tty_ldisc_N_TTY-&amp;gt;write=n_tty_write-&amp;gt; tty_driver-&amp;gt;ops=con_ops-&amp;gt;write=con_write-&amp;gt;do_con_write&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;agent&lt;br /&gt;
console_drivers-&amp;gt;vt_console_driver-&amp;gt;serial8250_console-&amp;gt;NULL&lt;br /&gt;
console_unlock-&amp;gt;..-&amp;gt;__call_console_drivers-&amp;gt; console_drivers-&amp;gt;write = vt_console_print&lt;br /&gt;
{&lt;br /&gt;
//保存到screen buf, vga_con也什么不做啊.&lt;br /&gt;
scr_writew((vc-&amp;gt;vc_attr &amp;lt;&amp;lt; 8) + c, (unsigned short *)vc-&amp;gt;vc_pos);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;h1 id=&#34;what-about-tty:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;What about tty&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;onset&lt;br /&gt;
console_init-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
tty_ldisc_begin-&amp;gt;tty_register_ldisc(N_TTY, &amp;amp;tty_ldisc_N_TTY);&lt;br /&gt;
console_initcall(con_init);&lt;br /&gt;
console_initcall(serial8250_console_init)&lt;br /&gt;
}&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;N_TTY:&lt;a href=&#34;http://www.linux.it/~rubini/docs/serial/serial.html&#34;&gt;Serial Drivers by Alessandro Rubini&lt;/a&gt;&lt;br /&gt;
fs_initcall:chr_dev_init-&amp;gt;drivers/tty/tty_io.c: tty_init-&amp;gt;&lt;br /&gt;
{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* /dev/tty0 = /dev/console console_ops */
/* /dev/tty = the /dev/ttyN whererun echo /dev/tty tty_ops */

//&amp;quot;/dev/tty&amp;quot;,
cdev_init(&amp;amp;tty_cdev, &amp;amp;tty_fops);
&amp;quot;/dev/console&amp;quot;
cdev_init(&amp;amp;console_cdev, &amp;amp;console_fops);
vty_init-&amp;gt;
{
    //&amp;quot;dev/tty0&amp;quot;    
    cdev_init(&amp;amp;vc0_cdev, console_fops); 
    //&amp;quot;/dev/ttyN&amp;quot;
    tty_register_driver-&amp;gt;
    {
        // What does tty_register_driver do ?
        // Alloc and register chr dev region.
        // Add cdev with tty_ops and above region.
        // Register tty device
        // Why do we register tty devices?
        // These devices must be used in some place.
        // After registering itself, the driver registers the devices it controls through the tty_register_device function. 
        // 原来是把major 和minor做成dev_t放到driver-&amp;gt;cdevs[index].dev里面了.
        // 也就是说driver-&amp;gt;cdevs[index]就是tty driver控制的device啊, 怪不得cdev_init(&amp;amp;driver-&amp;gt;cdevs[index], &amp;amp;tty_fops);
        // 那么看来用到的时候就是open了, 竟然没有不过有个tty_get_device用了tty_class
        // tty_register_device_attr-&amp;gt;device_register-&amp;gt;device_add-&amp;gt;klist_add_tail(&amp;amp;dev-&amp;gt;knode_class,&amp;amp;dev-&amp;gt;class-&amp;gt;p-&amp;gt;klist_devices)
        // 果然是在open tty-&amp;gt;dev = tty_get_device(tty);在alloc_tty_struct
        // 不知道这个tty-&amp;gt;dev在哪里用, 不管他了.
        tty_register_device(_attr) -&amp;gt;tty_cdev_add-&amp;gt; cdev_init(&amp;amp;driver-&amp;gt;cdevs[index], &amp;amp;tty_fops);
    }
    kbd_init
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
device_init:serial8250_init-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    // In this function we decide &amp;ldquo;/dev/ttyS*&amp;rdquo;&lt;br /&gt;
    // dmesg |grep Serial&lt;br /&gt;
    // [    0.696341] Serial: &lt;sup&gt;8250&lt;/sup&gt;&amp;frasl;&lt;sub&gt;16550&lt;/sub&gt; driver, 32 ports, IRQ sharing enabled&lt;br /&gt;
    // serial8250.c -&amp;gt; tty_io.c&lt;br /&gt;
    serial8250_reg.nr = UART_NR;&lt;br /&gt;
    ret = uart_register_driver(&amp;amp;serial8250_reg);&lt;br /&gt;
    tty_driver set to uart_driver by uart_register_driver -&amp;gt;&lt;br /&gt;
    {&lt;br /&gt;
        drv-&amp;gt;state = kzalloc        //uart_state&lt;br /&gt;
        normal-&amp;gt;driver_state    = drv; //args struct uart_driver *drv = &amp;amp;serial8250_reg&lt;br /&gt;
        tty_set_operations(normal, &amp;amp;uart_ops);&lt;br /&gt;
        struct tty_port &lt;em&gt;port = &amp;amp;state-&amp;gt;port&lt;br /&gt;
        tty_port_init(port);&lt;br /&gt;
        port-&amp;gt;ops = &amp;amp;uart_port_ops; //tty_port&lt;br /&gt;
        // We register &amp;ldquo;/dev/ttyS&lt;/em&gt;&amp;rdquo; files here.&lt;br /&gt;
        static struct uart_driver serial8250_reg = {&lt;br /&gt;
            .owner                  = THIS_MODULE,&lt;br /&gt;
            .driver_name            = &amp;ldquo;serial&amp;rdquo;,&lt;br /&gt;
            .dev_name               = &amp;ldquo;ttyS&amp;rdquo;,&lt;br /&gt;
            .major                  = TTY_MAJOR,&lt;br /&gt;
            .minor                  = 64,&lt;br /&gt;
            .cons                   = SERIAL8250_CONSOLE,&lt;br /&gt;
        };&lt;br /&gt;
        retval = tty_register_driver(normal); -&amp;gt; register_chrdev_region(dev, driver-&amp;gt;num, driver-&amp;gt;name) //32, ttyS?*? should be tty_ops&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;}
serial8250_register_ports(&amp;amp;serial8250_reg, &amp;amp;serial8250_isa_devs-&amp;gt;dev);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br /&gt;
* nucleus&lt;br /&gt;
tty_write-&amp;gt;ld-&amp;gt;ops-&amp;gt;write=n_tty_write-&amp;gt;(tty_struct tty-&amp;gt;ops-&amp;gt;write)=uart_write-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    struct uart_state *state = tty-&amp;gt;driver_data;&lt;br /&gt;
    port = state-&amp;gt;uart_port;&lt;br /&gt;
    circ = &amp;amp;state-&amp;gt;xmit;&lt;br /&gt;
    memcpy(circ-&amp;gt;buf + circ-&amp;gt;head, buf, c);&lt;br /&gt;
    uart_start-&amp;gt;__uart_start-&amp;gt;(uart_port-&amp;gt;ops-&amp;gt;start_tx(port)); //&amp;amp;uart_port_ops ?? uart_ops??&lt;br /&gt;
}&lt;/p&gt;

&lt;h1 id=&#34;what-about-pseudoterminal:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;What about Pseudoterminal&lt;/h1&gt;

&lt;p&gt;/dev/ptmx is the &amp;ldquo;pseudo-terminal master multiplexer&amp;rdquo;. from wikipedia&lt;br /&gt;
static struct tty_driver *ptm_driver;&lt;br /&gt;
static struct tty_driver *pts_driver;&lt;br /&gt;
module_init(pty_init)-&amp;gt;unix98_pty_init-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
    tty_set_operations(ptm_driver, &amp;amp;ptm_unix98_ops);&lt;br /&gt;
    tty_register_driver(ptm_driver)&lt;br /&gt;
    tty_set_operations(pts_driver, &amp;amp;pty_unix98_ops);&lt;br /&gt;
    tty_register_driver(pts_driver)&lt;br /&gt;
    ptmx_fops = tty_fops;&lt;br /&gt;
    ptmx_fops.open = ptmx_open;&lt;br /&gt;
    cdev_init(&amp;amp;ptmx_cdev, &amp;amp;ptmx_fops);&lt;br /&gt;
}&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;How to use ptmx?&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;tty-drivers:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;tty drivers&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;cat /proc/tty/drivers&lt;br /&gt;
/dev/tty             /dev/tty        5       0 system:/dev/tty&lt;br /&gt;
/dev/console         /dev/console    5       1 system:console&lt;br /&gt;
/dev/ptmx            /dev/ptmx       5       2 system&lt;br /&gt;
/dev/vc/0            /dev/vc/0       4       0 system:vtmaster&lt;br /&gt;
usbserial            /dev/ttyUSB   188 0-511 serial&lt;br /&gt;
serial               /dev/ttyS       4 64-95 serial&lt;br /&gt;
pty_slave            /dev/pts      136 0-1048575 pty:slave&lt;br /&gt;
pty_master           /dev/ptm      128 0-1048575 pty:master&lt;br /&gt;
unknown              /dev/tty        4 1-63 console&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;question:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;Question?&lt;/h1&gt;

&lt;p&gt;what is /dev/vcs?&lt;/p&gt;

&lt;h1 id=&#34;backup:49ed33abd1f8adafccaa91748bb495b5&#34;&gt;Backup&lt;/h1&gt;

&lt;p&gt;./drivers//tty/vt/vt.c:3042:        register_chrdev_region(MKDEV(TTY_MAJOR, 0), 1, &amp;ldquo;/dev/vc/0&amp;rdquo;) &amp;lt; 0)&lt;br /&gt;
./drivers//tty/vt/vc_screen.c:644:  if (register_chrdev(VCS_MAJOR, &amp;ldquo;vcs&amp;rdquo;, &amp;amp;vcs_fops))&lt;br /&gt;
./drivers//tty/tty_io.c:3377:       error = register_chrdev_region(dev, driver-&amp;gt;num, driver-&amp;gt;name);&lt;br /&gt;
./drivers//tty/tty_io.c:3414:   unregister_chrdev_region(dev, driver-&amp;gt;num);&lt;br /&gt;
./drivers//tty/tty_io.c:3430:   unregister_chrdev_region(MKDEV(driver-&amp;gt;major, driver-&amp;gt;minor_start),&lt;br /&gt;
./drivers//tty/tty_io.c:3607:       register_chrdev_region(MKDEV(TTYAUX_MAJOR, 0), 1, &amp;ldquo;/dev/tty&amp;rdquo;) &amp;lt; 0)&lt;br /&gt;
./drivers//tty/tty_io.c:3613:       register_chrdev_region(MKDEV(TTYAUX_MAJOR, 1), 1, &amp;ldquo;/dev/console&amp;rdquo;) &amp;lt; 0)&lt;br /&gt;
./drivers//tty/pty.c:841:       register_chrdev_region(MKDEV(TTYAUX_MAJOR, 2), 1, &amp;ldquo;/dev/ptmx&amp;rdquo;) &amp;lt; 0)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>System booting</title>
      <link>http://firoyang.org/cs/boot/</link>
      <pubDate>Thu, 12 Nov 2015 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/boot/</guid>
      <description>

&lt;h1 id=&#34;reference:4ccc61562af88da39fe562fcf76d50be&#34;&gt;Reference&lt;/h1&gt;

&lt;h1 id=&#34;contents:4ccc61562af88da39fe562fcf76d50be&#34;&gt;Contents&lt;/h1&gt;

&lt;p&gt;What basic initializations should be perfomed when power on?&lt;br /&gt;
How do we load the kernel to memory?&lt;br /&gt;
What does kernel do when kernel boot.&lt;br /&gt;
MBR vs BIOS?&lt;br /&gt;
PC vs embedded&lt;br /&gt;
Kernel init&lt;br /&gt;
before start_kernel&lt;br /&gt;
start_kernel&lt;br /&gt;
reset_init &amp;amp; kernel_init&lt;/p&gt;

&lt;h1 id=&#34;p4080-board:4ccc61562af88da39fe562fcf76d50be&#34;&gt;p4080 Board&lt;/h1&gt;

&lt;p&gt;PBL&lt;br /&gt;
1. initialize I2C, SPI, eLBC, eSDHC.&lt;br /&gt;
2. Load RCW and boot init commands from above.&lt;br /&gt;
3. write date to conf register and memory&lt;/p&gt;

&lt;h1 id=&#34;config:4ccc61562af88da39fe562fcf76d50be&#34;&gt;config&lt;/h1&gt;

&lt;p&gt;CCSRBAR -&amp;gt; CCSR&lt;br /&gt;
default is 0x0_FE00_0000&lt;br /&gt;
CCSRBAR is in CCSR memory. odd. stored in 0(CCSRBAR).&lt;br /&gt;
CCSRBAR always points to itself.&lt;br /&gt;
holdoff&lt;/p&gt;

&lt;h1 id=&#34;u-boot:4ccc61562af88da39fe562fcf76d50be&#34;&gt;u-boot&lt;/h1&gt;

&lt;p&gt;ft_fixup_cpu -&amp;gt; determine_mp_bootpg(NULL) &amp;amp; fdt_add_mem_rsv&lt;/p&gt;

&lt;p&gt;main_loop-&amp;gt; &amp;hellip;-&amp;gt;./common/bootm_os.c:410:&amp;hellip; do_bootm_states-&amp;gt;&lt;br /&gt;
{&lt;br /&gt;
bootm_find_other-&amp;gt;bootm_find_ramdisk_fdt-&amp;gt;bootm_find_fdt-&amp;gt;boot_get_fdt&amp;amp;set_working_fdt_addr(0x0200000)-&amp;gt;IMAGE_FORMAT_FIT-&amp;gt;&lt;br /&gt;
&amp;amp;&lt;br /&gt;
boot_fn = bootm_os_get_boot_func(images-&amp;gt;os.os)=[IH_OS_LINUX] =&lt;br /&gt;
&amp;amp;&lt;br /&gt;
boot_selected_os-&amp;gt;boot_fn=do_bootm_linux-&amp;gt;boot_body_linux-&amp;gt;image_setup_linux-&amp;gt;image_setup_libfdt-&amp;gt;&lt;br /&gt;
board/freescale/corenet_ds/corenet_ds.c ft_board_setup-&amp;gt; ft_cpu_setup-&amp;gt;&lt;br /&gt;
}&lt;/p&gt;

&lt;h1 id=&#34;ppc-multicore-booting:4ccc61562af88da39fe562fcf76d50be&#34;&gt;PPC multicore booting&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;There are two possibilites to make secondary cores booting failed.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;There is a bug in the code executed by Secondary cores&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;The spin table address, passed to croe0, is not correct, so we did not really kick the secondary cores.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CCSRBAR&lt;br /&gt;
MPC86xx_MCM_OFFSET&lt;br /&gt;
srio_boot_master_release_slave&lt;/p&gt;

&lt;p&gt;uboot-&amp;gt;&lt;br /&gt;
set the cpu-release-addr at funciton ft_fixup_cpu(), I am not sure.&lt;/p&gt;

&lt;p&gt;core0 run, 2nd cores holdoff&lt;br /&gt;
core0 set BPTR and kick(BRR) 2nd cores, 2nd cores spintable loop in uboot function setup_mp&lt;br /&gt;
core0 -&amp;gt; arch/powerpc/cpu/mpc85xx/start.S-&amp;gt;_start_e500&lt;br /&gt;
board_init_r-&amp;gt;cpu_init_r-&amp;gt; setup_mp-&amp;gt; {&lt;br /&gt;
&lt;strong&gt;bootpg_addr = (u32)virt_to_phys(&amp;amp;&lt;/strong&gt;second_half_boot_page); //Assembly code for put core to spin tablea. Used by __secondary_start_page&lt;br /&gt;
__spin_table_addr = (u32)get_spin_phys_addr();// used by __second_half_boot_page&lt;br /&gt;
bootpg = BPTR = __secondary_start_page&lt;br /&gt;
plat_mp_up-&amp;gt;kick BRR &amp;amp; Boot Space Translation&lt;br /&gt;
}&lt;br /&gt;
2nd cores holdoff -&amp;gt; &lt;strong&gt;secondary_start_page&lt;br /&gt;
kernel-&amp;gt;&lt;br /&gt;
core0 boot kernel, core0 kickoff 2nd cores spintable, triger 2nd core&amp;rsquo;s spin table by writing  the spin table field with the desired address&lt;br /&gt;
2nd cores ePAPR-&amp;gt;spintable-&amp;gt;addr_l=&lt;/strong&gt;early_start-&amp;gt;__secondary_start-&amp;gt;smp_ops-&amp;gt;setup_cpu-&amp;gt;cpu_idle&lt;br /&gt;
arch/powerpc/kernel/head_fsl_booke.S&lt;br /&gt;
U-boot logs:&lt;br /&gt;
Reserving MP boot page to 7ffff000^M^M - &amp;ndash;   -   MP spin table&lt;br /&gt;
address.&lt;br /&gt;
SPAG : fdt_fixup_fman_firmware, 567^M^M&lt;br /&gt;
^M^M&lt;br /&gt;
..r.^M^M&lt;br /&gt;
VDBG : ft_cpu_setup, 737, comment fdt_fixup_memory ^M^M&lt;br /&gt;
VDBG: Secondary cores are not held in reset.^M^M&lt;br /&gt;
Kernel Logs:&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 1 to ack^M^M&lt;br /&gt;
smp: failed starting cpu 1 (rc -2)^M^M&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 2 to ack^M^M&lt;br /&gt;
smp: failed starting cpu 2 (rc -2)^M^M&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 3 to ack^M^M&lt;br /&gt;
smp: failed starting cpu 3 (rc -2)^M^M&lt;br /&gt;
Brought up 1 CPUs^M^M&lt;br /&gt;
devtmpfs: initialized^M^M&lt;/p&gt;

&lt;p&gt;Note that u-boot can&amp;rsquo;t detect  memory above 2G and we need to check&lt;br /&gt;
if kernel is accessing at high mem of 2G or 4G.&lt;/p&gt;

&lt;p&gt;Here are the logs..&lt;/p&gt;

&lt;p&gt;I printed pa in %lx since the outout of &lt;strong&gt;pa(&lt;/strong&gt;early_start) is in long unsigned int.&lt;/p&gt;

&lt;p&gt;Firo:cpu nr1 release addr c3fe352c, spin_table c000003f, ioremmappable 0&lt;br /&gt;
Firo: kernel origin spin tbale addr_l a63b2000, pir 57cc802, resv 480000, r3 3ae000, pa 50&lt;br /&gt;
Firo: kernel update spin tbale addr_l 50, pir 1, resv 480000, r3 3ae000&lt;br /&gt;
Firo: kernel timeout spin tbale addr_l 50, pir 1, resv 480000, r3 3ae000&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 1 to ack&lt;br /&gt;
smp: failed starting cpu 1 (rc -2)&lt;br /&gt;
Firo:cpu nr2 release addr c3fe3740, spin_table c000007f, ioremmappable 0&lt;br /&gt;
Firo: kernel origin spin tbale addr_l a654e7af, pir a654e780, resv 387cf99a, r3 3408200, pa 50&lt;br /&gt;
Firo: kernel update spin tbale addr_l 50, pir 2, resv 387cf99a, r3 3408200&lt;br /&gt;
Firo: kernel timeout spin tbale addr_l 50, pir 2, resv 387cf99a, r3 3408200&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 2 to ack&lt;br /&gt;
smp: failed starting cpu 2 (rc -2)&lt;br /&gt;
Firo:cpu nr3 release addr c3fe3954, spin_table c00000bf, ioremmappable 0&lt;br /&gt;
Firo: kernel origin spin tbale addr_l 247cf09a, pir 7cf19b, resv a664e740, r3 3e7cf19a, pa 50&lt;br /&gt;
Firo: kernel update spin tbale addr_l 50, pir 3, resv a664e740, r3 3e7cf19a&lt;br /&gt;
Firo: kernel timeout spin tbale addr_l 50, pir 3, resv a664e740, r3 3e7cf19a&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 3 to ack&lt;br /&gt;
smp: failed starting cpu 3 (rc -2)&lt;br /&gt;
I don’t see the following print in u-boot..&lt;br /&gt;
 69                                 fdt_setprop(blob, off, &amp;ldquo;cpu-release-addr&amp;rdquo;,&lt;br /&gt;
 70                                                 &amp;amp;val, sizeof(val));&lt;br /&gt;
+ printf(&amp;ldquo;Firo u-boot:cpu release addr %p, value %x\n&amp;rdquo;, &amp;amp;val, val);&lt;/p&gt;

&lt;p&gt;Firo:cpu nr1 release addr c3fe352c, spin_table c000003f, ioremmappable 0&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 1 to ack&lt;br /&gt;
smp: failed starting cpu 1 (rc -2)&lt;br /&gt;
Firo:cpu nr2 release addr c3fe3740, spin_table c000007f, ioremmappable 0&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 2 to ack&lt;br /&gt;
smp: failed starting cpu 2 (rc -2)&lt;br /&gt;
Firo:cpu nr3 release addr c3fe3954, spin_table c00000bf, ioremmappable 0&lt;br /&gt;
smp_85xx_kick_cpu: timeout waiting for core 3 to ack&lt;br /&gt;
smp: failed starting cpu 3 (rc -2)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Light camera action - compile link load</title>
      <link>http://firoyang.org/cs/build/</link>
      <pubDate>Sun, 25 Oct 2015 01:46:28 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/build/</guid>
      <description>

&lt;h1 id=&#34;reference:aba878e576894cc4457876fdf276811e&#34;&gt;Reference&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.tenouk.com/ModuleW.html&#34;&gt;compiler, assembler, linker and loader: a brief story&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;contents:aba878e576894cc4457876fdf276811e&#34;&gt;Contents&lt;/h1&gt;

&lt;p&gt;Why complier can manipulate the address of vriables?&lt;br /&gt;
What is the address in lds(??) file?&lt;/p&gt;

&lt;h1 id=&#34;build-automation:aba878e576894cc4457876fdf276811e&#34;&gt;Build automation&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Make&lt;br /&gt;
make cynthia&lt;/p&gt;

&lt;h2 id=&#34;kbuild:aba878e576894cc4457876fdf276811e&#34;&gt;kbuild&lt;/h2&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;if no .config, every config tools make a .config from scrach!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;oldconfig just for new moduels patch merged in trunk. This no any relations to .config.old and /boot/config.x.y.z&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;make localmodconfig will reduce many unused kernel config.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;make bzImage  #kmods will not build that configured with M!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;make modules_install INSTALL_MOD_PATH=/home/firo/kmods&lt;/p&gt;

&lt;h2 id=&#34;yocto:aba878e576894cc4457876fdf276811e&#34;&gt;yocto&lt;/h2&gt;

&lt;p&gt;make ARCH=arm menuconfig&lt;br /&gt;
##build signle kernel module&lt;br /&gt;
make menuconfig&lt;br /&gt;
make oldconfig &amp;amp;&amp;amp; make prepare&lt;br /&gt;
make -C $(pwd) M=/home/firo/linux/fs/ext3 modules V=1&lt;br /&gt;
make ARCH=arm CROSS_COMPILE=/usr/bin/arm-linux-gnu- drivers/pcmcia/sa11xx_base.o&lt;/p&gt;

&lt;h1 id=&#34;compile-construction:aba878e576894cc4457876fdf276811e&#34;&gt;Compile construction&lt;/h1&gt;

&lt;p&gt;Understand pl deeply&lt;br /&gt;
how to translate it into machine code for specific CPU&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;gcc&lt;br /&gt;
-E -S -c&lt;br /&gt;
-I -L -l&lt;br /&gt;
-ansi&lt;br /&gt;
-fsyntax-only&lt;br /&gt;
-Werror&lt;br /&gt;
-save-temps&lt;br /&gt;
-H: show all header used&lt;br /&gt;
-v&lt;br /&gt;
-Wall&lt;br /&gt;
-fPIC: for shared library&lt;br /&gt;
-Q: print function and statisc?&lt;br /&gt;
-Wextra: 用处不大.&lt;br /&gt;
-U: undefine a preprocessor macro.&lt;br /&gt;
-pipe: make compilation faster, replace xx.S with |&lt;br /&gt;
-Wpadded: we can rearrange the fields of structure to make the structure smaller&lt;br /&gt;
-time&lt;br /&gt;
-x c: c language&lt;br /&gt;
-: stdin&lt;br /&gt;
asmlinkage&lt;br /&gt;
However, for C functions invoked from assembly code,&lt;br /&gt;
we should explicitly declare the function&amp;rsquo;s calling convention,&lt;br /&gt;
because the parameter passing code in assembly side has been fixed.&lt;br /&gt;
Show all predefined macros for your compiler&lt;br /&gt;
gcc -dM -E -x c /dev/null&lt;br /&gt;
##&lt;a href=&#34;http://www.stlinux.com/devel/debug/jtag/build?q=node/82&#34;&gt;Generating optimized code&lt;/a&gt;&lt;br /&gt;
##Symbol table&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;System.map less&lt;br /&gt;
When you compile the kernel&lt;br /&gt;
nm vmlinux&lt;br /&gt;
readelf -s&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;/proc/kallsyms&lt;/p&gt;

&lt;h1 id=&#34;link:aba878e576894cc4457876fdf276811e&#34;&gt;Link&lt;/h1&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;GNU ld&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;gold&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>My reading list of computer science</title>
      <link>http://firoyang.org/review/reading_list/</link>
      <pubDate>Wed, 14 Oct 2015 14:09:57 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/review/reading_list/</guid>
      <description>

&lt;p&gt;I think you should check my The Organization of Knowledgs&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Programming:&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&#34;http://sarabander.github.io/sicp/&#34;&gt;SICP&lt;/a&gt;&lt;br /&gt;
The science of programming&lt;/p&gt;

&lt;h1 id=&#34;computer-science:0d6d2ff91b088c0d630e79146323ef87&#34;&gt;Computer science&lt;/h1&gt;

&lt;p&gt;Code: The hidden language of computer hardware and software&lt;br /&gt;
Digital Design and Computer Architecture 2nd Edition&lt;/p&gt;

&lt;p&gt;未看口碑好:&lt;br /&gt;
Computer Organization and Design, Fifth Edition&lt;br /&gt;
ARM System-on-Chip Architecture (2nd Edition)&lt;/p&gt;

&lt;h1 id=&#34;philosophy:0d6d2ff91b088c0d630e79146323ef87&#34;&gt;Philosophy&lt;/h1&gt;

&lt;p&gt;普通认识论 &amp;ndash; Moritz Schlick&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Computer architecture</title>
      <link>http://firoyang.org/cs/arch/</link>
      <pubDate>Tue, 13 Oct 2015 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/cs/arch/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Linux time subsystem</title>
      <link>http://firoyang.org/kernel/time/</link>
      <pubDate>Tue, 22 Sep 2015 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/kernel/time/</guid>
      <description>

&lt;p&gt;我写作的主要目的是理清基本概念与原理, 而非实现,细节这一类.&lt;/p&gt;

&lt;p&gt;时间是人类发明出来的概念, Kant也认为时间是心智概念.&lt;br /&gt;
一百年前的世界和现在有什么不同呢?这个提问揭示生活中时间最重要的用途,&lt;br /&gt;
*标记*某中状态下的世界. 所谓的过去世界不过是世界的一个个连续状态&lt;br /&gt;
那么时空穿越, 就变成了保住项少龙这个肉身不变, 世界的其他部分完全&lt;br /&gt;
转变到过去的某一个状态. 而所谓现在世界就被抹杀了.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The future is already here – it&#39;s just not evenly distributed.
                        — William Gibson
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;人想回到&amp;rdquo;过去&amp;rdquo;多半源于情感因素, 而想去&amp;rdquo;未来&amp;rdquo;则是因为&amp;rdquo;物质&amp;rdquo;的缘故.&lt;br /&gt;
想象下中国的未来50年, 很可能是现在美国or西欧现在的样子.虽然中西虽然处在&lt;br /&gt;
时间概念上相同的现在, 而物质世界确实&amp;rdquo;过去&amp;rdquo;和&amp;rdquo;未来&amp;rdquo;之差.&lt;/p&gt;

&lt;p&gt;比如我们下周而要开会, 那么此时下周二就是有意识的规划未来, 时间依然是标记.&lt;br /&gt;
UTC/GMT&lt;br /&gt;
Based on caesium microwave atomic clock&lt;br /&gt;
Leap second&lt;/p&gt;

&lt;h2 id=&#34;genus-differentia-definition:eefdcd66b28c2b86ef84bba398f2d59a&#34;&gt;Genus-differentia definition&lt;/h2&gt;

&lt;p&gt;interrupt, clock event,  clock source, tick, timer, timekeeping, gettimeofday.&lt;/p&gt;

&lt;h2 id=&#34;功用定义:eefdcd66b28c2b86ef84bba398f2d59a&#34;&gt;功用定义&lt;/h2&gt;

&lt;p&gt;获取时间&lt;br /&gt;
timer&lt;br /&gt;
sleep ?&lt;br /&gt;
update sched info&lt;/p&gt;

&lt;h2 id=&#34;发生定义-设计-etymology-history-operational-definition:eefdcd66b28c2b86ef84bba398f2d59a&#34;&gt;发生定义/设计   etymology, history Operational definition&lt;/h2&gt;

&lt;p&gt;timekeeping/计时:时刻．&lt;br /&gt;
clock source: 时间之源, 表针之力.&lt;br /&gt;
clock event: 闹铃之力, 经过tick展现能力.&lt;br /&gt;
tick: timer的中断事件叫tick, tick device产生tick, 可以说tick决定了clock_event event_handler进而决定了, clock_event行为.&lt;br /&gt;
tickless:&lt;br /&gt;
for timer: use HW timer one shot, set next.&lt;br /&gt;
for update time: in above HW timer, not good&lt;br /&gt;
for sched: for priority distributed in time slice, use timer.&lt;br /&gt;
dynamic tick/no HZ:&lt;br /&gt;
No HZ in idle&lt;br /&gt;
No HZ while only 1 process running for HPC.&lt;br /&gt;
tick devies 就是clock event包了层虎皮.&lt;br /&gt;
tick broadcast framework:  based on tick device&lt;br /&gt;
clock: 可记录时间, 表盘.利用timekeeping&lt;br /&gt;
timer: use clock. what about timer_list?&lt;br /&gt;
timer_list: do in softirq&lt;br /&gt;
* timekeeping aspect&lt;br /&gt;
onset: start_kernel -&amp;gt; timekeeping_init &amp;amp; time_init &amp;amp;(rest_init-&amp;gt; kernel_init-&amp;gt; \&lt;br /&gt;
kernel_init_freeable-&amp;gt;do_basic_setup-&amp;gt;do_initcalls&amp;ndash;device_initcall(init_clocksource_sysfs))&lt;br /&gt;
nucleus:used by clock see init_posix_timers and update_wall_time and sys_time&lt;br /&gt;
coda:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;clock source aspect&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;tick device layer aspect&lt;br /&gt;
per_cpu(tick_cpu_device, cpu)&lt;br /&gt;
onset: time_init-&amp;gt;mach-&amp;gt;init_time-&amp;gt;&amp;hellip;clockevents_register_device-&amp;gt;tick_check_new_device&lt;br /&gt;
nucleus: a38x_timer_interrupt-&amp;gt;a38x_clkevt.event_handler&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;tick broadcast framework&lt;br /&gt;
onset:&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;clock aspect&lt;br /&gt;
k_clock&lt;br /&gt;
onset:init_posix_timers &amp;amp; init_posix_cpu_timers&lt;br /&gt;
nucleus: 用户-&amp;gt; posix_clock-&amp;gt;timepkeeping-&amp;gt;clock_socurce&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;timer aspect&lt;br /&gt;
onset: open_softirq(HRTIMER_SOFTIRQ, run_hrtimer_softirq);&lt;br /&gt;
nucleus: common_timer_set&lt;br /&gt;
hrtimer_interrupt | (tick_handle_periodic-&amp;gt; tick_periodic-&amp;gt; update_process_times-&amp;gt;run_local_timers-&amp;gt;hrtimer_run_queues)-&amp;gt;__run_hrtimer-&amp;gt;timer.function = posix_timer_fn;(set in common_timer_set)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;计算机概念&lt;br /&gt;
system clock CLOCK_REALTIME CLOCK_MONOTONIC&lt;br /&gt;
time.h time_t=tm=timeval=timespec calendar time  clock_t&lt;/p&gt;

&lt;p&gt;clock event -&amp;gt; tick device-&amp;gt; handle function&lt;br /&gt;
clock event 相较于timer更为抽象, timer 是一种用途,timer 通过clock event来实现功能,&lt;br /&gt;
clock event 通过timer来体现自己, timer面向使用者的onset,&lt;br /&gt;
而clock event 则是偏向于nucleus and coda.&lt;br /&gt;
timer: 标记不能立即执行的变化.&lt;br /&gt;
clock source: 用一些整型抽象一个过程, 对于时间来说, 简直是完美的抽象.&lt;br /&gt;
* kernel requirement&lt;br /&gt;
linux的时间子系统要求硬件timer提供下面两种能力：&lt;br /&gt;
一是free running的counter，此外需要能够在指定的counter值上产生中断的能力。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Quantitative congnition - The philosophy on which I live</title>
      <link>http://firoyang.org/philosophy/philosophy/</link>
      <pubDate>Sun, 13 Sep 2015 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/philosophy/philosophy/</guid>
      <description>

&lt;p&gt;我正在常识建立一套量化认知体系. 为什么要做这件事? 无论是之于生命个体还是整个人类社会的演化总是依凭着对世界更深入,&lt;br /&gt;
更全面的认知. ? 正如Schlick 在General Theory of Knowledge 所言&amp;hellip; 而这种认知本身是什么呢? 在哲学上,&lt;br /&gt;
Epistemology专门研究这个问题. 而我继续前人的工作.&lt;br /&gt;
在过往的不断尝试中, 我体验与感悟到了, 这个世界很复杂, 不能有一些简单的规则来理解透.&lt;br /&gt;
多种不同的角度, 往往是理解事物最合宜的方法.&lt;/p&gt;

&lt;h1 id=&#34;framework-architecture-oracle-machine-万物皆备于我:007041aa20bf44bd43eba68b5f650c57&#34;&gt;Framework architecture: oracle-machine, 万物皆备于我&lt;/h1&gt;

&lt;p&gt;收集全面, 专业, 多样的书籍,论文等资料, 当然, 还会不断的学习实践过程中收集.&lt;br /&gt;
基于收集到的信息进行,分析.建立阶段性的理性状态和可接受的状态.&lt;br /&gt;
根据不同的状态, 定义问题(往往多个问题)&lt;br /&gt;
选取总结找到解决问题的模式过程(往往多种方法)&lt;br /&gt;
建立一个真实的实践环境, 在其中不断实践,体验.成长的主要步骤.&lt;br /&gt;
认识缺陷, 发现反馈不足, 尝试收集资料, 分析, 找寻方法, 实践,修正缺陷, 解决问题.成长.&lt;/p&gt;

&lt;h1 id=&#34;原则:007041aa20bf44bd43eba68b5f650c57&#34;&gt;原则&lt;/h1&gt;

&lt;p&gt;从实际问题触发, 实际的topic.&lt;br /&gt;
语言必须被还原到实际的生活场景  &amp;ndash; 维特根斯坦&lt;br /&gt;
Zeroness, 自己思考. 不要上来就读or做, 你要思考这个过程.&amp;ndash; Firo&lt;br /&gt;
方法简单容易, 方便证明是否有效&lt;br /&gt;
世界总是转换,不稳定,不确定.&lt;br /&gt;
Completeness, consistency, validity, soundness. &amp;ndash; Logic&lt;br /&gt;
Falsifiability可证伪性 &amp;ndash; Popper&lt;br /&gt;
批判性, 你所学的一切都是暂时性的,任何所学都有改口 驳斥 质疑的余地 &amp;ndash;Aaron Swartz,25:20&lt;br /&gt;
对于学习的知识上, 方法要做到知识之间的联系, 转换关系.&lt;br /&gt;
认知的缺陷, imperfect-understand, 彻底可错性. &amp;ndash;Firo Soros Popper&lt;/p&gt;

&lt;h1 id=&#34;收集:007041aa20bf44bd43eba68b5f650c57&#34;&gt;收集&lt;/h1&gt;

&lt;h1 id=&#34;分析:007041aa20bf44bd43eba68b5f650c57&#34;&gt;分析&lt;/h1&gt;

&lt;p&gt;Autonomous Change-of-state calculus &amp;ndash;Firo-Von Wright’s approach&lt;/p&gt;

&lt;p&gt;祖孙的方法”   the genetic method &amp;ndash; 胡适,杜威&lt;br /&gt;
Why? How? What? Good and bad?&lt;/p&gt;

&lt;p&gt;从时间角度&lt;/p&gt;

&lt;p&gt;最重要的是什么呢?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;analysis computer program&lt;br /&gt;
init onset, running nuclus, exit coda&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;阶段目标与问题定义:007041aa20bf44bd43eba68b5f650c57&#34;&gt;阶段目标与问题定义&lt;/h1&gt;

&lt;p&gt;The phrased objectives&lt;br /&gt;
What is the important, foundation, most useful, minimal cached? &amp;ndash; Firo&lt;/p&gt;

&lt;p&gt;内涵定义: Genus-differentia definition 属加种差定义: 发生定义(设计), 关系定义, 功用定义, 摹状定义&lt;br /&gt;
充要定义, Real and nominal definitions&lt;br /&gt;
Classes of extensional definitions: enumerative definition&lt;br /&gt;
&lt;a href=&#34;http://plato.stanford.edu/entries/definitions/&#34;&gt;Definitions Stanford Encyclopedia of Philosophy&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;模式过程:007041aa20bf44bd43eba68b5f650c57&#34;&gt;模式过程&lt;/h1&gt;

&lt;p&gt;去看看别人怎么做的, 也可以思考人会遇到相似的问题, 有解决的方法.&lt;/p&gt;

&lt;p&gt;Divide every question into manageable parts. &amp;ndash; Descartes&lt;br /&gt;
Begin with the simplest issues and ascend to the more complex. &amp;ndash; Descartes&lt;br /&gt;
Review frequently enough to retain the whole argument at once &amp;ndash; Descartes&lt;br /&gt;
Accept as true only what is indubitable. &amp;ndash; Descartes&lt;/p&gt;

&lt;h1 id=&#34;实践:007041aa20bf44bd43eba68b5f650c57&#34;&gt;实践&lt;/h1&gt;

&lt;p&gt;建立一个全面的wilds环境, 在这个环境下生存!&lt;br /&gt;
活下去!&lt;/p&gt;

&lt;h1 id=&#34;反馈缺陷:007041aa20bf44bd43eba68b5f650c57&#34;&gt;反馈缺陷&lt;/h1&gt;

&lt;h1 id=&#34;本体系自身的反馈:007041aa20bf44bd43eba68b5f650c57&#34;&gt;本体系自身的反馈&lt;/h1&gt;

&lt;p&gt;成长来自实践, 以及认识缺陷并加以改正.&lt;br /&gt;
不断的实践和改正缺陷才是提高能力的核心!&lt;br /&gt;
很多时候, 依靠现在的经验学识不能找到完整的方法, 需要不断的调整.&lt;br /&gt;
学会认识自己的无力.&lt;br /&gt;
问题总是复杂的, 解决方法总是简单的.  &amp;ndash;xiaolai.li&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Firo</title>
      <link>http://firoyang.org/firo/firo/</link>
      <pubDate>Tue, 25 Aug 2015 15:46:11 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/firo/firo/</guid>
      <description>&lt;p&gt;一个人应该与外界的应该保持什么样的关系? 每个人都应该有自己的回答, 而且答案不一而终.&lt;br /&gt;
正是这种关系成就了我们的一生.个体如何确定这种关系,或者说如何确定一种合理的生存状态?&lt;br /&gt;
对于人类丰富, 无止尽的欲望而言, 很难给出统一的答案.然而这并不妨碍我们找到理想的状态.&lt;br /&gt;
简单说来, 两点; 那些来自内心的, 原始的, 本能的愿望正是我们生活的方向, 不应被忽视, 反而&lt;br /&gt;
要经常回忆起来, 并视若内心的珍宝一样对待; 另外, 我们应该做的是弥补生活中的不足, 以此来&lt;br /&gt;
向理想中的生活不断的迈进, 而不是沉醉于对理想的执着与等待中. 从实实在在的生活不足开始,&lt;br /&gt;
这才是真实的, 是你的生活.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;生活不在别处, 正是当下此地.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于世界一部分的个体, 充分的认识世界的运作机制, 成为确定自己生活状态的前提. 对于普通人&lt;br /&gt;
而言, 这似乎无从下手. 尤其是对于处在巨大生存压力下的人, 无暇顾及这般如同象牙塔式的问题?&lt;br /&gt;
我想这正是他们生活悲剧的根源之一. 对于了解这个世界, 实际上要简单许多. 我想, 只要你有意识&lt;br /&gt;
地在遇到困惑, 疑问, 艰难, 令人不适的生活的时候, 寻找这些问题背后的原因的时候, 答案便会出现.&lt;br /&gt;
而答案就是一种关系, 因果律. 同时连带得出关系的主客体. 比如, 49年后, 中国人都有一个潜在&lt;br /&gt;
的伟大的身份, 社会主义建造者.这是个体和国家之间的某种答案,在我出生之时, 变自动获得这种身份.&lt;br /&gt;
直到我意识到这种身份的存在时, 我毫不犹豫的放弃了它.因为我并不是一个社会主义者,&lt;br /&gt;
我打心眼里抵触社会主义, 我很难想象他的存在, 同时那样的社会对我来说是一种无声的恐惧,&lt;br /&gt;
因为他偏离人性的核心, 那样的社会下的生活, 我一点也不期待, 我已体验过了.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;显然, 在人与世界的诸多联系中, 有一些是被他人赋予, 而那些强制赋予的很多都成了枷锁.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于确定生命个体的合理生存状态, 可以看成找到你与世界现有的关系以及想要的某种关系.&lt;br /&gt;
首先, 我们要理清那些重要的关系. 可以说我的哲学就是建立在关系之上, 也就是因果律.&lt;br /&gt;
人总生活在关系中, 我认为下面的关系很重要.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;从个人角度, 越靠近真实, 越靠近真实, 不靠近就会远离. 这也是因果律的体现.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;即便你找不到期待中的生活状态，你也活在关系中, 这也是最基本的．&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;人生没有目标, 也要好好活着!&lt;br /&gt;
所有人都是某些东西的奴隶 &amp;ndash; 进击的巨人&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其他的规律：&lt;/p&gt;

&lt;p&gt;＞正反合&lt;br /&gt;
&amp;gt; 完整的逻辑,包含不存在&lt;br /&gt;
&amp;gt; 生活就是同傻逼的战争!&lt;br /&gt;
&amp;gt; 每个人都有自己内心的弱点, 不必害怕他们.&lt;br /&gt;
&amp;gt; 生长需要滋润.&lt;br /&gt;
&amp;gt; 成长开始于注意到缺陷, 疑问&lt;br /&gt;
&amp;gt; 很多时候其实我们的忙碌都是做着自己并不在乎的事情！&lt;br /&gt;
&amp;gt; 生命所不能承受之轻!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>My Career</title>
      <link>http://firoyang.org/firo/career/</link>
      <pubDate>Sun, 26 Jul 2015 15:46:11 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/firo/career/</guid>
      <description>

&lt;p&gt;无论是位高权重的政治家, 富贵显荣的商人, 亦或是蝇营狗苟的市侩之人等等, 所有芸芸众生&lt;br /&gt;
每日莫不是为了谋生而奔走. 长久的活着是一种负担.&lt;br /&gt;
忙碌的生活, 难以审视自己的人生. 今天坐下来, 谈谈这个话题.&lt;/p&gt;

&lt;p&gt;毫无已问, 从小到大, 即便是为曾到达的未来, 工作都占据了我们据大多数时间, 当然X二代&lt;br /&gt;
不在此列. 在这个社会, 即便每日辛劳的工作, 绝大多数人, 依然连自己卑微的梦想都无法实现.&lt;br /&gt;
今天, 我不谈政治层面的原因. 只想从个人角度, 去剖析人与工作之间的关系.&lt;/p&gt;

&lt;p&gt;英文&lt;a href=&#34;https://en.wikipedia.org/wiki/Career&#34;&gt;career&lt;/a&gt;, 在维基给出了基本的解释:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A career is an individual&#39;s journey through learning, work and other aspects of life.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;词源上是由马车引出的人生之路的涵义. 而中文, 生涯出自《庄子·养生主》：“吾生也有涯，而知也无涯。”&lt;br /&gt;
我们今天主要谈两个问题, 人生的马车和人生的&amp;rdquo;涯&amp;rdquo;.&lt;br /&gt;
我的职业生涯始于大学, 童年时期热爱电子游戏, 导致大学选择了计算机科学这个行业. 到今天整整过去了&lt;br /&gt;
7个年头, 不短了. 本人只敢自称勤奋之人, 大学伊始至今, 绝大多数时光都在勤奋治学, 未曾懈怠.&lt;br /&gt;
大学毕业三年, 依然没有实现自己当初的愿望, a remote kernel hacker. 这个目标完全是个人喜好, 性格使然.&lt;br /&gt;
同时也受限于我个人的视野.&lt;br /&gt;
1. 我喜欢自由, 所以不希望自己被束缚在办公室里面, 我期望那种一边旅行一边工作的生活.&lt;br /&gt;
所以纯个人脑力的工作是我的第一选择, programmer, 作家,都在此列, 而且我也很喜欢且擅长这样的工作.&lt;br /&gt;
2. 我喜欢开放的东西, 开源的软件就成了我的选择, kernel, openstack, 都是那时的选择.&lt;br /&gt;
3. 我喜欢有挑战的事情, 11年一起在sina实习的同学, 现在是openstack的remote开发者了,&lt;br /&gt;
当初我们一起去的, 我最后选择了kernel, 源于我认为kernel会更靠近计算机科学.&lt;br /&gt;
我对web相关的技术有偏见,觉得缺乏深度且很多与用户体验相关.&lt;br /&gt;
其实很多&lt;a href=&#34;http://careers.stackoverflow.com/jobs/remote&#34;&gt;职位&lt;/a&gt;都是可以remote的不限于open source的, 而且相对于&lt;br /&gt;
kernel和openstack的remote工作机会更多.&lt;br /&gt;
4. 我认为社会风气不好, 会对计算机这个行业有影响, 我更侧重选择纯技术的方向, 原理web, 具体业务.&lt;br /&gt;
这就是当时的思考, 当初的视野太狭隘了,主观臆断太严重.&lt;br /&gt;
这个时候薪资都不在考虑之列, 以为做喜欢的事就很开心了.&lt;br /&gt;
大学4年都在逃课, 专业知识, 都是仿照MIT和Computer ScienceCurriculum 2008自己设计出来的.&lt;br /&gt;
大学一年级, 看各种游戏的书,&lt;br /&gt;
大学二年级做机器人的比赛还有和艺术学院合作的事情,&lt;br /&gt;
大二下学期开始基础linux,看apue 还有unp这些书, 开始搞搜索引擎&lt;br /&gt;
大三的时候看了csapp, 还有组合数学&lt;br /&gt;
大四上学期基本上没干什么事, 10月份就去sina实习了, 下学期开始看内核.&lt;br /&gt;
虽然一直都很忙, 但是没学到什么东西.&lt;br /&gt;
我放弃了sina的offer, 毕业(12年7月)后整整有一年时间没有工作了.&lt;br /&gt;
一直到次年13年的9月才开始去极路由工作.到今年15年5月离职.&lt;br /&gt;
现在以外包的形式在windriver的ccm team 工作.&lt;br /&gt;
这就是我职业生涯的7年时光, 过得很坎坷.&lt;/p&gt;

&lt;h1 id=&#34;work-style:7e6e72851422b97b7259805ca91208dc&#34;&gt;Work style&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Plan the day.&lt;br /&gt;
What need to do.&lt;br /&gt;
Prioritization.&lt;br /&gt;
Focus on.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;yet-another-plan:7e6e72851422b97b7259805ca91208dc&#34;&gt;Yet another plan&lt;/h1&gt;

&lt;p&gt;English&lt;br /&gt;
Kernel patches 500 commits&lt;br /&gt;
Work achievement&lt;br /&gt;
Problem solving/pattern&lt;br /&gt;
FIXME in knowledge_map.md&lt;br /&gt;
Passport H1B Offer&lt;/p&gt;

&lt;h1 id=&#34;interview:7e6e72851422b97b7259805ca91208dc&#34;&gt;Interview&lt;/h1&gt;

&lt;h2 id=&#34;关于薪资问题:7e6e72851422b97b7259805ca91208dc&#34;&gt;关于薪资问题&lt;/h2&gt;

&lt;p&gt;全面回答包括股票期权.&lt;br /&gt;
real background.&lt;br /&gt;
期望的薪资别说太低, 往上也别说的太死, 比预期要高.&lt;br /&gt;
说更关注职业发展.&lt;/p&gt;

&lt;h2 id=&#34;想面试公司提出的问题:7e6e72851422b97b7259805ca91208dc&#34;&gt;想面试公司提出的问题&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;NO1. 我所应聘的这个职位为什么会出现空缺？&lt;br /&gt;
如果空, 空多长时间, 因为什么原因空的.&lt;br /&gt;
如果这个职位是新近才出现的，或许你就拥有了一个理想的、开辟属于自己的道路的机会。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;NO2. 请问贵公司最成功的员工为公司做出了什么样的贡献？&lt;br /&gt;
谁对公司贡献最大, 谁领导之类的, 做了什么? 有那些优秀品质. 了解公司文化.&lt;br /&gt;
面试管, 可能认为你是志在成功公司最优秀的员工之一.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;NO3.如何评估自己在三个月试用期内的工作表现？何种标准算成功？&lt;br /&gt;
该职位遇到的最大的挑战是什么?&lt;br /&gt;
了解公司做事风格, 是否稳重成熟. 排除不靠谱公司, 谁知道半年后他们&lt;br /&gt;
能干出什么? 谨慎对待抛出橄榄枝.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;NO5.目前公司所面对的最大的挑战有哪些？&lt;br /&gt;
这个编程比如说内核在公司的位置, 是否是中心.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;NO6.公司如何来保证人才不流失？&lt;br /&gt;
长期的意愿, 这个问题比较屌.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;NO7.请问您为什么要为这家公司工作呢？&lt;br /&gt;
连面试官自己都不知道为什么要为这家公司工作，你觉得这样的公司会给员工提供多少机会呢？&lt;br /&gt;
去面试工作，是一个相互合作的过程，并不是说哪一方成为主导。你为公司工作，公司给你报酬。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而对所有公司来说它总希望找到那一种类似合作伙伴的员工而不是仅仅是来打工的。&lt;br /&gt;
所以，在面试的时候除了展示你自身特长和文化外，还要表现出一个对公司前景关心和一种参与者的心态来。&lt;br /&gt;
这样能让公司的管理者对你更有好感！这不仅为了进入这个公司也为了以后的发展&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>有一段历史离我们如此近记忆却模糊</title>
      <link>http://firoyang.org/history/china_a_century_of_revolution/</link>
      <pubDate>Wed, 24 Jun 2015 15:46:11 CST</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/history/china_a_century_of_revolution/</guid>
      <description>&lt;p&gt;毛泽东的时代&lt;br /&gt;
&lt;iframe width=&#34;420&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/GMaXSKH2w3c&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;p&gt;建国后出生的新一代&lt;br /&gt;
&lt;iframe width=&#34;420&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/qsmJXJcvG3g&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux virtualization</title>
      <link>http://firoyang.org/kernel/virt/</link>
      <pubDate>Wed, 17 Jun 2015 00:00:00 UTC</pubDate>
      <author>Firo Yang</author>
      <guid>http://firoyang.org/kernel/virt/</guid>
      <description>

&lt;p&gt;本文着重探讨下kvm的实现, 11年在snia的实习的时候, 接触过一点.&lt;br /&gt;
已经过去将近4年了,  当初看到qemu的代码, 被吓到了, 我靠, 这代码量赶上内核了!&lt;br /&gt;
现在kvm核心就1069行当前kernel 4.1 rc7, qemu虽然赶不上kernel但是也不少1144756.&lt;br /&gt;
看过指环王的, 都知道神奇中土大陆是托尔金虚构的魔幻世界,那里活着阿拉贡和&lt;br /&gt;
他的朋友们, 以及他们精彩的历程.人的想象力, 如此神奇, 他能使人超越时间与&lt;br /&gt;
空间去体验到不同生命历程.&lt;br /&gt;
今天, 我们来探索一下&lt;a href=&#34;https://en.wikipedia.org/wiki/Virtualization&#34;&gt;虚拟化&lt;/a&gt;&lt;br /&gt;
如wikipedia所说, 虚拟化始于上个世纪60年代, 这是指的计算机领域内的.&lt;br /&gt;
显然, 我们要把眼光放得更远, 因为我们想洞见一些深层次的内容.&lt;br /&gt;
法国哲学家福柯一生都在从事&amp;rdquo;知识考古学&amp;rdquo;, 而我也喜欢在研究问题时, 从语言学特别是&lt;br /&gt;
词源角度开始. virtual这个词, 最早来自于中世纪拉丁文virtualis, 涵义是&lt;br /&gt;
influencing by physical virtues or capabilities,&lt;br /&gt;
effective with respect to inherent natural qualities&lt;br /&gt;
受某种实在的长处能力影响, 源自本质的效用.&lt;br /&gt;
这里从两种角度理解virtual, 受影响者, 影响者本身.&lt;br /&gt;
所以这里virtual的真实涵义应该是延续某种内在的本质并施加于外物.&lt;br /&gt;
这个英文单词的汉语翻译是很有趣的, 摘自金山词霸:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;virtual 音节划分：vir▪tual
英 [ˈvɜ:tʃuəl] 美 [ˈvɜ:rtʃuəl]
adj.实质上的，事实上的；（计算机）虚拟的；&amp;lt;物&amp;gt;有效的，虚像的；（粒子）实际存在的
虚；虚拟艺术；虚拟的；模拟帐户
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个词汇简直是英语翻译界的笑话, 一会实一会虚, 非常让人困惑!&lt;br /&gt;
话说回来, 这个词的翻译确实有难度.我翻译的话会叫质延.&lt;br /&gt;
很多事情, 在我们出生前就决定了, 我是89年9月出生的.&lt;br /&gt;
我们搞懂了所谓&amp;rdquo;虚拟化&amp;rdquo;的实质, 之后就可以继续探索了.&lt;br /&gt;
如wikipedia, 所说计算机领域的虚拟化更多的是指hardware virtualization.&lt;br /&gt;
没错就是延伸硬件的特质, 准确说是在软件层继续延伸硬件的特质.&lt;br /&gt;
好, 首先, 我们要搞懂硬件都有那些特质? 硬件有很多, 在计算机领域指什么呢?&lt;br /&gt;
没错, CPU, 硬盘, 电路板, 内存, 鼠标键盘等等. 那么他们有什么特质呢?&lt;br /&gt;
所谓的特质就是特别的性质, 一种属性, 哲学上, 称之为事物对外物的作用的一种表现.&lt;br /&gt;
那么CPU的最大特质就是指令处理, 我想这也是虚拟化的核心吧!&lt;br /&gt;
我们硬件虚拟化延伸的终点是让另一个操作系统运行于当前操作系统提供的硬件特质延伸之上.&lt;br /&gt;
终于进入正文了. 现在我们自己来设计一套虚拟化基础架构, 让一个简单的kernel运行在当前的fedora&lt;br /&gt;
之上.&lt;/p&gt;

&lt;h2 id=&#34;fkvm:d29da9244342e72819e84d5dee753d17&#34;&gt;FKVM&lt;/h2&gt;

&lt;p&gt;没错我的虚拟化技术就叫这个FucK VM, 好吧, 其实简写于Firo&amp;rsquo;s KVM!&lt;br /&gt;
首先, 我们必须明确一点, 即便我 or 我们不能最终实现一个虚拟化架构让另一个kernel&lt;br /&gt;
运行起来, 今天在这里做得事情的意义, 依然深远且几乎无可替代!&lt;br /&gt;
因为, 至少你是在想象力,或者更为正式表述是在概念层次上让他运行起来了, 而且跑得飞快!&lt;br /&gt;
你在虚拟化一个虚拟化, 这就是智力劳动的乐趣.&lt;br /&gt;
怎么才能让一个kernel 运行起来呢? 能想到的就是从用户态起一个进程, 之后这个进程fork下去执行&lt;br /&gt;
start_kernel的代码.有点眉目了. 问题也来了, 内核启动的时候会各种初始化, 这会扰乱了现在正在运行的&lt;br /&gt;
cpu, 我能想到的这个新的内核的内存管理不能和之前运行的fedora的冲突, 两个都玩完, 首先要隔离内存.&lt;br /&gt;
也就是要虚拟化一块内存. 怎么解决, 最简单的直接malloc一块空间给他吧. 怎么给? 为了简单.&lt;br /&gt;
在内核初始化的时候, 会用调用bios的中断来获取内存信息.&lt;br /&gt;
也就是说我们要先弄一个虚拟bios出来啊. 先假设bios, 我们弄出来了.&lt;br /&gt;
开机先执行这段bios代码, 把之前申请的内存告诉bios, 之后我们在内核内核初始化的时候, 就用这块.&lt;br /&gt;
现在问题用来了. 内核要访问这块内存就必须为他建页表, 申请的这块内存可能是不连续的而且还可能是&lt;br /&gt;
高端内存, 内核初始化的代码可没考虑这么复杂. 要么该内核, 要么改FKVM, 显然不能改内核啊.&lt;br /&gt;
只能去尝试, 虚拟一个CPU, cpu指令那么复杂, 怎么能搞定. 是否有必要, 搞那么复杂呢?&lt;br /&gt;
我们的一个cpu就是一个进程.这个cpu执行内初始化的代码, 需要想办法, 让内核感知不到底层的变化.&lt;br /&gt;
就好比, 他访问了一块高端内存, 但这个内核, 里面的页表却标明他是低端, 随意访问.&lt;br /&gt;
也就是说, 我们要截获cpu访存的指令, 并且要把他再次重定向到真正的物理内存.&lt;br /&gt;
如何截获?我们不能有太多假设.而且现在的工作, 实际已经被usermode linux 完成了.&lt;br /&gt;
这里需要很多底层的知识. 先看点资料再回来.&lt;br /&gt;
看了下基本实现, 这里我们的思路没有问题, 只不过指令和优先级的问题没有考虑.&lt;br /&gt;
访问特权指令确实是被截获的. intel引入了vt-x来解决这个问题.&lt;br /&gt;
探索这种复杂的系统, 就行探索一座深山一样, 如果不加思索就突入进去, 最终会迷路.&lt;br /&gt;
无论别人说的多么好, 我们必须要有自己的思路.&lt;br /&gt;
总结下所得:&lt;br /&gt;
控制虚拟机对全局资源的访问, 通过截获虚拟的某些指令.&lt;br /&gt;
虚拟化一块内存.&lt;br /&gt;
我们知道想中断啊, IO这些都得良好的处理掉, 否这会影响到我们早已运行的fedora.&lt;br /&gt;
由于缺少太多硬件知识, 在这样思考下去, 就会变成满篇假设了, 这和我们的目的背道而驰了.&lt;br /&gt;
同时乐趣也会减少.&lt;/p&gt;

&lt;h1 id=&#34;kvm-qemu:d29da9244342e72819e84d5dee753d17&#34;&gt;KVM QEMU&lt;/h1&gt;

&lt;p&gt;现在我们来了解KVM, 在经过前面不成熟的思考好, 结果有点令人沮丧. 似乎我们什么都没完成&amp;hellip;&lt;br /&gt;
探索的方式, 依然是以自我思考为主, 通过提问的形式完成思考过程.&lt;br /&gt;
千万不可成了, 靠一点一滴积累别人的思想感悟来成长. 万万不可.对于问题的洞见主力依然&lt;br /&gt;
是我们自己, 别人的知识只是辅助. 那好我们开始.&lt;br /&gt;
首先, 我们是为了了解KVM是如何运作的, 晚上的paper 帖子, 都说比较概括, 而分析的又不太通俗.&lt;br /&gt;
往往初学者, 很容易被绕进去.&lt;br /&gt;
从宏观上看KVM虚拟化, 由KVM和QEMU两个组件完成的, 一个内核模块, 一个用户态程序.&lt;br /&gt;
为什么这么设计? 还有别的虚拟化架构吗? 维基给出了, 硬件虚拟化的几种实现策略.&lt;br /&gt;
Full virtualization,  VMware Workstation 和 QEMU就是这种, 全虚拟化定义上是说, 为虚拟机提供&lt;br /&gt;
全部的硬件特性的延伸支持. 这个技术上个世界70年代就由IBM推行. 在人们看来这门高深的学问在计算机的&lt;br /&gt;
洪荒时代, 便已出现. 那个时代一切都是新的, 人们强烈的渴望伸展四肢, 天不怕地不怕的.&lt;br /&gt;
Partial virtualization, 维基上给出半虚拟化的介绍, 他是全虚拟化的先驱, 现在很少本人提起.&lt;br /&gt;
至少, 现在都是全虚拟化和类虚拟化的天下.文中提及, 虚拟地址空间便是半虚拟化.&lt;br /&gt;
从虚拟化的定义角度来看, 操作系统本身, 便是一种原生且原始的虚拟化, 这无可否认.&lt;br /&gt;
这是一种高度抽象的虚拟化, 就好比进程是cpu的虚拟化, 虚拟地址空间是对内存的一种虚拟化.&lt;br /&gt;
Paravirtualization, para是在什么旁边的意思, 中文翻译成类虚拟化, 也算贴切.&lt;br /&gt;
类虚拟化修改guest 系统, 而不是通过虚拟化硬件.Xen(也支持全虚拟化)和UML是这一类.&lt;br /&gt;
Operating-system-level virtualization&lt;br /&gt;
这种虚拟化,概念上不同于上面三种, 是对操作系统的虚拟化, 虽然追根到底, 还是对硬件的虚拟化.&lt;br /&gt;
但是, 这里强调的是操作系统的资源的虚拟化. 属于操作系统的很多高级抽象, 底层硬件是不具备的.&lt;br /&gt;
比如协议栈这个概念, 他本身是对信息传递的抽象而非硬件, 硬件只是其中一环而已.&lt;br /&gt;
这里若是简单的翻译成系统级虚拟化, 就就比如LXC这个技术而言, 这里面我们并没有虚拟化任何东西.&lt;br /&gt;
比如我们使用socket 发包, 还是这样; 使用malloc分配内存还是这样, 并没有也不需要所谓虚拟化,&lt;br /&gt;
他们都是原生的original.  所以在这里我们就看到了, 不合适的翻译造成的理解差异.&lt;br /&gt;
这里还是直接说容器技术,比较合适, 因为他本来就强调对资源的管理.&lt;br /&gt;
在了解了虚拟化的概念后, 问题又回到了KVM QEMU本身, 此时, 我们依然对他们的实现没有头绪,&lt;br /&gt;
网上也没有找到, 说理清晰的入门文档. 我们还是要搞懂 kvm和qemu的原理.&lt;br /&gt;
我们从小的概念开始, 力求集合小的概念最终, 完成的对kvm 和 qemu的认知.&lt;br /&gt;
首先是qemu是什么? 为什么要有他, 单独一个kvm不行吗?&lt;br /&gt;
官网的解释:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;QEMU is a generic and open source machine emulator and virtualizer.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;qemu可以做emulator, 就像android的开发环境中的那个模拟器差不多.&lt;br /&gt;
qemu可以作为虚拟化的工具和kvm,xen联动, 重点看这个.&lt;br /&gt;
我们在FKVM中已经知道, cpu的虚拟化是同vtx, 截获特殊指令完成的.&lt;br /&gt;
那么内存虚拟化呢, 显然不应是malloc一块空间能解决的.&lt;br /&gt;
毫无疑问, 肯定要有一个机制把host的内存映射到一个guest的物理地址空间, 同时guest的&lt;br /&gt;
虚拟地址解析出来的物理地址在转到宿主机的地址, 最后转成真正的物理地址. 有三次转换.&lt;br /&gt;
据我所指, x86的页表转换是自动的.如何让他这么转来转去的.这个应该就是kvm orvtx干的事情&lt;br /&gt;
补货到访存指令, 之后进行地址转换. 看了下真正的实现, 和我们思路差不多.&lt;br /&gt;
不同点, guest的物理地址是用pfn加数量标志的. 不用想每次访存kvm都要参与, 而且地址转换确实复杂&lt;br /&gt;
肯定有优化空间. 我现在想说, vtx这个截获访存指令确实是个BUG级的存在.&lt;br /&gt;
内存虚拟化就到这里了, 优化去看IBM的讲解帖子吧.&lt;br /&gt;
下面继续看cpu的虚拟化. 这个主要就是, 如何捕获, 那些vm运行比较敏感的指令.&lt;br /&gt;
我们的FKVM支持一个进程跑, 能想到的就是建几个线程来模拟SMP.&lt;/p&gt;

&lt;p&gt;下面是设备的虚拟化, 这个还是看书去吧.&lt;/p&gt;

&lt;h1 id=&#34;代码实现:d29da9244342e72819e84d5dee753d17&#34;&gt;代码实现&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;KVM architecture&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Kernel running flow&lt;br /&gt;
svm.ko -&amp;gt; svm_init(svm.c) -&amp;gt; kvm_init(kvm_main.c) -&amp;gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;File&lt;br /&gt;
svm.c vmx.c kvm_main.c kvm_svm.h&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Function&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Struct&lt;br /&gt;
kvm_x86_ops x86.h&lt;br /&gt;
vcpu_svm    kvm_svm.h&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
